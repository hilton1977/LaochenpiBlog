{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/Exchanges-direct.jpg","path":"images/Exchanges-direct.jpg","modified":0,"renderable":0},{"_id":"source/images/Exchanges-fanout.jpg","path":"images/Exchanges-fanout.jpg","modified":0,"renderable":0},{"_id":"source/images/Exchanges-topic.jpg","path":"images/Exchanges-topic.jpg","modified":0,"renderable":0},{"_id":"source/images/HandlerMapping.png","path":"images/HandlerMapping.png","modified":0,"renderable":0},{"_id":"source/images/MemorySplit.png","path":"images/MemorySplit.png","modified":0,"renderable":0},{"_id":"source/images/MySQL.jpg","path":"images/MySQL.jpg","modified":0,"renderable":0},{"_id":"source/images/MySqlReplication.jpg","path":"images/MySqlReplication.jpg","modified":0,"renderable":0},{"_id":"source/images/RabbitMQ.jpg","path":"images/RabbitMQ.jpg","modified":0,"renderable":0},{"_id":"source/images/RabbitMq-Channel.png","path":"images/RabbitMq-Channel.png","modified":0,"renderable":0},{"_id":"source/images/SkyWalking.jpg","path":"images/SkyWalking.jpg","modified":0,"renderable":0},{"_id":"source/images/SpringCloud.jpg","path":"images/SpringCloud.jpg","modified":0,"renderable":0},{"_id":"source/images/String++.jpg","path":"images/String++.jpg","modified":0,"renderable":0},{"_id":"source/images/String==.jpg","path":"images/String==.jpg","modified":0,"renderable":0},{"_id":"source/images/arthas-web-console.png","path":"images/arthas-web-console.png","modified":0,"renderable":0},{"_id":"source/images/arthas.png","path":"images/arthas.png","modified":0,"renderable":0},{"_id":"source/images/chrome-extension.png","path":"images/chrome-extension.png","modified":0,"renderable":0},{"_id":"source/images/color-scope.png","path":"images/color-scope.png","modified":0,"renderable":0},{"_id":"source/images/color-setting.png","path":"images/color-setting.png","modified":0,"renderable":0},{"_id":"source/images/consul.png","path":"images/consul.png","modified":0,"renderable":0},{"_id":"source/images/docker-images.png","path":"images/docker-images.png","modified":0,"renderable":0},{"_id":"source/images/error.jpg","path":"images/error.jpg","modified":0,"renderable":0},{"_id":"source/images/es.jpg","path":"images/es.jpg","modified":0,"renderable":0},{"_id":"source/images/hexo.jpg","path":"images/hexo.jpg","modified":0,"renderable":0},{"_id":"source/images/http.jpg","path":"images/http.jpg","modified":0,"renderable":0},{"_id":"source/images/java-stream.png","path":"images/java-stream.png","modified":0,"renderable":0},{"_id":"source/images/java.jpg","path":"images/java.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm-ObjectCreate.jpg","path":"images/jvm-ObjectCreate.jpg","modified":0,"renderable":0},{"_id":"source/images/left-pivot.jpg","path":"images/left-pivot.jpg","modified":0,"renderable":0},{"_id":"source/images/linux-1.jpg","path":"images/linux-1.jpg","modified":0,"renderable":0},{"_id":"source/images/masterStatus.png","path":"images/masterStatus.png","modified":0,"renderable":0},{"_id":"source/images/maven.jpg","path":"images/maven.jpg","modified":0,"renderable":0},{"_id":"source/images/nginx.png","path":"images/nginx.png","modified":0,"renderable":0},{"_id":"source/images/nginxconf.png","path":"images/nginxconf.png","modified":0,"renderable":0},{"_id":"source/images/oralce_jdbc.png","path":"images/oralce_jdbc.png","modified":0,"renderable":0},{"_id":"source/images/passwd.png","path":"images/passwd.png","modified":0,"renderable":0},{"_id":"source/images/red-black-tree.png","path":"images/red-black-tree.png","modified":0,"renderable":0},{"_id":"source/images/redis-caching-avalanche-solution.png","path":"images/redis-caching-avalanche-solution.png","modified":0,"renderable":0},{"_id":"source/images/redis-caching-avalanche.png","path":"images/redis-caching-avalanche.png","modified":0,"renderable":0},{"_id":"source/images/redis-caching-penetration.png","path":"images/redis-caching-penetration.png","modified":0,"renderable":0},{"_id":"source/images/redis-master-slave-replication.png","path":"images/redis-master-slave-replication.png","modified":0,"renderable":0},{"_id":"source/images/redis-master-slave.png","path":"images/redis-master-slave.png","modified":0,"renderable":0},{"_id":"source/images/redis.jpg","path":"images/redis.jpg","modified":0,"renderable":0},{"_id":"source/images/right-povit.jpg","path":"images/right-povit.jpg","modified":0,"renderable":0},{"_id":"source/images/sentinel-info.png","path":"images/sentinel-info.png","modified":0,"renderable":0},{"_id":"source/images/simpleApplicationEventMulticaster.png","path":"images/simpleApplicationEventMulticaster.png","modified":0,"renderable":0},{"_id":"source/images/skywalking-ui.png","path":"images/skywalking-ui.png","modified":0,"renderable":0},{"_id":"source/images/skywalkingFile.png","path":"images/skywalkingFile.png","modified":0,"renderable":0},{"_id":"source/images/sort-algorithms.png","path":"images/sort-algorithms.png","modified":0,"renderable":0},{"_id":"source/images/spring.jpg","path":"images/spring.jpg","modified":0,"renderable":0},{"_id":"source/images/ssh-key.jpg","path":"images/ssh-key.jpg","modified":0,"renderable":0},{"_id":"source/images/thundering-herd.png","path":"images/thundering-herd.png","modified":0,"renderable":0},{"_id":"source/images/translationCrx.png","path":"images/translationCrx.png","modified":0,"renderable":0},{"_id":"source/images/vmess-windows-client.jpg","path":"images/vmess-windows-client.jpg","modified":0,"renderable":0},{"_id":"source/images/vue.jpg","path":"images/vue.jpg","modified":0,"renderable":0},{"_id":"source/images/winsw.png","path":"images/winsw.png","modified":0,"renderable":0},{"_id":"source/images/ConstantPoolTable.jpg","path":"images/ConstantPoolTable.jpg","modified":0,"renderable":0},{"_id":"source/images/JVM-1.8-after.png","path":"images/JVM-1.8-after.png","modified":0,"renderable":0},{"_id":"source/images/JVM-1.8-before.png","path":"images/JVM-1.8-before.png","modified":0,"renderable":0},{"_id":"source/images/RabbitMQ-Admin.png","path":"images/RabbitMQ-Admin.png","modified":0,"renderable":0},{"_id":"source/images/ThreadPoolExcutor.jpg","path":"images/ThreadPoolExcutor.jpg","modified":0,"renderable":0},{"_id":"source/images/collection.png","path":"images/collection.png","modified":0,"renderable":0},{"_id":"source/images/docker-search.png","path":"images/docker-search.png","modified":0,"renderable":0},{"_id":"source/images/eureka.png","path":"images/eureka.png","modified":0,"renderable":0},{"_id":"source/images/info_replication.png","path":"images/info_replication.png","modified":0,"renderable":0},{"_id":"source/images/redis-sentinel.png","path":"images/redis-sentinel.png","modified":0,"renderable":0},{"_id":"source/images/sharding-jdbc.png","path":"images/sharding-jdbc.png","modified":0,"renderable":0},{"_id":"source/images/springmvc.jpg","path":"images/springmvc.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/clipboard-use.js","path":"js/clipboard-use.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"source/images/sortTable.png","path":"images/sortTable.png","modified":0,"renderable":0},{"_id":"themes/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/images/2020/05/17/97ae0d90-980b-11ea-8fab-19b1e8901849.png","path":"images/2020/05/17/97ae0d90-980b-11ea-8fab-19b1e8901849.png","modified":0,"renderable":0},{"_id":"source/images/2020/05/19/beb83e10-99b4-11ea-bc19-85fa9aca2a18.png","path":"images/2020/05/19/beb83e10-99b4-11ea-bc19-85fa9aca2a18.png","modified":0,"renderable":0},{"_id":"source/images/2020/05/18/c8ff2030-98e4-11ea-baff-f5d93153beb4.png","path":"images/2020/05/18/c8ff2030-98e4-11ea-baff-f5d93153beb4.png","modified":0,"renderable":0},{"_id":"source/images/insert-sort.gif","path":"images/insert-sort.gif","modified":0,"renderable":0},{"_id":"source/images/2020/05/18/c3928180-98e6-11ea-ba5c-993f9fbc0aef.png","path":"images/2020/05/18/c3928180-98e6-11ea-ba5c-993f9fbc0aef.png","modified":0,"renderable":0},{"_id":"source/images/2020/05/18/d3568690-98e4-11ea-baff-f5d93153beb4.png","path":"images/2020/05/18/d3568690-98e4-11ea-baff-f5d93153beb4.png","modified":0,"renderable":0},{"_id":"source/images/header.jpg","path":"images/header.jpg","modified":0,"renderable":0},{"_id":"source/images/2020/05/15/c490d980-9687-11ea-baff-f5d93153beb4.png","path":"images/2020/05/15/c490d980-9687-11ea-baff-f5d93153beb4.png","modified":0,"renderable":0},{"_id":"source/images/bubble-sort.gif","path":"images/bubble-sort.gif","modified":0,"renderable":0},{"_id":"themes/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"source/images/2020/05/25/72d56dc0-9e9f-11ea-81d3-796c7949b71a.png","path":"images/2020/05/25/72d56dc0-9e9f-11ea-81d3-796c7949b71a.png","modified":0,"renderable":0},{"_id":"source/images/selection-sort.gif","path":"images/selection-sort.gif","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"74161b596d943086f214656cb45bb1807aacfa99","modified":1597024124715},{"_id":"themes/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/README.md","hash":"046950dfee8bb3934baed67678e60a002cb20c3c","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/README_en.md","hash":"1c4c47d45746c6741167ba5e8153e235e73f7172","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/_config.yml","hash":"aacd1a2907b6bd376c382b209b9ca4bceabbae21","modified":1605674420885},{"_id":"themes/hexo-theme-fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/package.json","hash":"e2772a7e62badea6d404887d8c2723f0fb7af07d","modified":1602940783000},{"_id":"source/_posts/ArrayList源码阅读.md","hash":"d31408110b7536f56fba6a51999b6bf66dff7fb6","modified":1605669658098},{"_id":"source/_posts/CentOs-Firewalld-脚本.md","hash":"2663fa4952b78f95670cbbccd184e15b03278e25","modified":1597024124718},{"_id":"source/_posts/Docker环境搭建.md","hash":"59537fd18db976ddd59faf7a2c2e63a16cee6d38","modified":1605751760535},{"_id":"source/_posts/Chrome-Extension-开发笔记.md","hash":"f8fc5f1018bac06e5cd4f9af6bc1a781b5291dfb","modified":1605669672851},{"_id":"source/_posts/EasyExcel-简单的Excel-处理工具.md","hash":"20a6b201453ef26c941079804f945ff602bf570b","modified":1598414155263},{"_id":"source/_posts/Hexo部署到VPS自动发布.md","hash":"defed67e493b6d8d310a498e2b545ddb25033c98","modified":1597024124720},{"_id":"source/_posts/Http 知识.md","hash":"b8dc84af094d345f585e4ac35c9516ea9f5e3b58","modified":1597024124721},{"_id":"source/_posts/IDEA-快捷键备份.md","hash":"6c5294f5177a2add6ee69c6afb37f576f53dd5a4","modified":1597024124722},{"_id":"source/_posts/JVM 内存区域.md","hash":"a8937f39e1c5561a6057aeb4655cdb1c60cef9af","modified":1597024124722},{"_id":"source/_posts/JVM 对象创建.md","hash":"c5e3190fa3e10bd3b1ecc6170de44c91867e5b1f","modified":1597024124723},{"_id":"source/_posts/JVM 类加载.md","hash":"5bf97c4481717c63279c0154ec038886dc1b8b36","modified":1597024124723},{"_id":"source/_posts/Java-引用类型.md","hash":"d70583554b9ac6194f94d34173932e09400e295d","modified":1600071397403},{"_id":"source/_posts/Java-排序方法总结.md","hash":"9ffe8669b45b9f1df7e020a8a3a61b5fe7c9f7e0","modified":1597024124724},{"_id":"source/_posts/Java-集合总结.md","hash":"283e0f3ea46b31ed2241f146d60909b04820afc4","modified":1597024124725},{"_id":"source/_posts/Linux-中判断条件.md","hash":"3c47f169460d894ab2c4749964e4360c0075fe93","modified":1597024124725},{"_id":"source/_posts/Linux-关机重启命令.md","hash":"13dd9c21376a3301e5bccac3b26c31b2d8968dd9","modified":1597024124726},{"_id":"source/_posts/Linux-字体背景颜色设置.md","hash":"08ff5cb4fabd2200da51859792359196154ed9b0","modified":1597024124727},{"_id":"source/_posts/Linux-文件权限管理.md","hash":"7a85fa07a0f84637dbc102cba517b9cd07d8036e","modified":1597024124728},{"_id":"source/_posts/Linxu搭建SS.md","hash":"a93ae97559f97abd16022894eec4c21db6106617","modified":1597024124729},{"_id":"source/_posts/Log4j-学习笔记.md","hash":"745d646b4a14288b8eea7dc18c3a8526e67c1fdf","modified":1597024124729},{"_id":"source/_posts/Logstah同步Es.md","hash":"e25fa8aa94af2033e310ad404fd31bc279384641","modified":1597024124730},{"_id":"source/_posts/Maven 属性.md","hash":"d76b5575a87aa650bbbb37d8cfdc07e06956a207","modified":1597024124731},{"_id":"source/_posts/MySQL千行命令.md","hash":"233f63ffeff235fffce15838ddf8ebedb8162bfb","modified":1597024124732},{"_id":"source/_posts/MySql数据库索引知识.md","hash":"ed2a124f38acc233460834d85ce2833c325168d4","modified":1597024124732},{"_id":"source/_posts/Mysql 主从配置.md","hash":"7697598a613e251fb6fba6d5d18a9becf0b6d2f3","modified":1597024124733},{"_id":"source/_posts/Nginx-配置详解.md","hash":"e88039e3caa92b22c3170d282b1c384c5e50e9e9","modified":1605749003151},{"_id":"source/_posts/Oracle数据库驱动.md","hash":"ed6feb2278c0fe0f3dcf94a3f453517470307dc9","modified":1597024124735},{"_id":"source/_posts/Python 第三方库 PIL.md","hash":"082227f78a74ade7ad2d49017ae2179f3db9890a","modified":1597024124736},{"_id":"source/_posts/RabbitMq 消息队列中间件.md","hash":"8d89365d1829f48f6d6a9cbc5ef593e88f69cc04","modified":1597024124737},{"_id":"source/_posts/Redis-集群搭建记录.md","hash":"0c7e1a8e8886dec9629a5b81bd2e0f8a0e7a126c","modified":1597024124738},{"_id":"source/_posts/Redis主从配置.md","hash":"d64509ebcc5c5e14970a3388c0ac790567f7be38","modified":1597024124739},{"_id":"source/_posts/Redis持久化.md","hash":"774f9743a2dc79ed2ea5f373861e3464d5f957d5","modified":1597024124739},{"_id":"source/_posts/Redis数据类型及应用场景.md","hash":"e0e665fb4c5f483227905e64dfc8b0792ea0b521","modified":1597024124740},{"_id":"source/_posts/Redis的淘汰机制LRU算法.md","hash":"fabb63ac70d3c3be16b15f38255afc6a461414e4","modified":1605669681823},{"_id":"source/_posts/Redis缓存场景.md","hash":"afa02e7fe317d34573a2ef0dad1402765a133552","modified":1597024124741},{"_id":"source/_posts/Sharding-jdbc-数据库中间件集成.md","hash":"b8622d799ca4e9cacdb660c80104f40598bf9a41","modified":1597024124741},{"_id":"source/_posts/SkyWalking搭建记录.md","hash":"2a4a49d756617801cfc3008d15c05ba4d0419331","modified":1597309889368},{"_id":"source/_posts/SpringBoot-启动过程（四）.md","hash":"9a7fa41690bb8ac34f5d943d458b4389588e9f57","modified":1597024124743},{"_id":"source/_posts/SpringMVC 工作原理.md","hash":"977431e92e123c4cdef19ce385fda7e57b4b3d94","modified":1597024124743},{"_id":"source/_posts/Springboot 启动过程（一）.md","hash":"7d8dc7dc61373c5d04f3ea934b18b1a28e9d7802","modified":1605685557315},{"_id":"source/_posts/Springboot 启动过程（三）.md","hash":"0b1beb4cced1c2a85d00a4d2d16500deb99662ab","modified":1597024124745},{"_id":"source/_posts/Springboot 启动过程（二）.md","hash":"8604cece6d95c236bf8adcf68f19154f089b0ba4","modified":1597024124746},{"_id":"source/_posts/SprintCloud微服务-Eureka.md","hash":"2625cc74215eedb35a58497f68935bdcbf7d2a6e","modified":1597024124747},{"_id":"source/_posts/Stream流操作.md","hash":"202561f91e2d14a9657e3c015269cce5e8a958bb","modified":1597024124748},{"_id":"source/_posts/String类和常量池.md","hash":"2286892ae306345b5ab034d6403b1ecf58defd0a","modified":1597024124749},{"_id":"source/_posts/ThreadPoolExecutor-线程池.md","hash":"ff3bf59ce4b2dc35f71eedc4c3710955ec8ebab9","modified":1597286064974},{"_id":"source/_posts/V2Ray搭建记录.md","hash":"a2b070c0d0c7c1b35a4d266761c4aad77258772b","modified":1597024124750},{"_id":"source/_posts/VPS-一键搭建脚本.md","hash":"cca19e11ed85911f637c3512043e0aabe25de195","modified":1597024124751},{"_id":"source/_posts/Vue复杂的table表单代码块.md","hash":"abb0f34f4d32ea435c19f1bf88fb39da7c4268c8","modified":1597024124752},{"_id":"source/_posts/Winsw把java项目做成服务.md","hash":"9058a0d33cb759244407e71b57d30f092b087e5f","modified":1597024124753},{"_id":"source/_posts/fast-fail和fast-safe的区别.md","hash":"bdc5bf720a2884c7d44718673b8103343ed9c0ca","modified":1597024124754},{"_id":"source/_posts/hexo.md","hash":"0eade8f55400911f2bca8b2fd02170bc38cf3a23","modified":1597024124755},{"_id":"source/_posts/一致性哈希算法.md","hash":"4b032751d1e398497cfbfa8a84b010e844101063","modified":1597024124756},{"_id":"source/_posts/事务传播性.md","hash":"d617d7a3de14899c555a1055326fb5054da06e3d","modified":1597024124756},{"_id":"source/_posts/事务隔离性.md","hash":"b51920ec633d2affd1184918163e5fe61c5c97c5","modified":1597024124757},{"_id":"source/_posts/大数据-Json-压缩.md","hash":"de9482d4d3e9cc785bc7f2225fef14e89cde2c21","modified":1600324433228},{"_id":"source/_posts/学习-CompletableFuture.md","hash":"ecf45a316417171effe967f26caa300cf1cfd8b4","modified":1597024124758},{"_id":"source/_posts/学习-CurrentHashMap.md","hash":"dbcf699ad4c74c4776807d12b1a17826ba74b02f","modified":1597024124759},{"_id":"source/_posts/学习红黑树.md","hash":"7b2541140cf79ab20bc6a103634b07a48b1a87b4","modified":1597024124760},{"_id":"source/_posts/抢卷并发代码Redis应用.md","hash":"2a0cd4cd98f5654d684ce130ec83fa2d29d2abd5","modified":1605685281548},{"_id":"source/_posts/阿里巴巴诊断器.md","hash":"dde311b8332a81bcd5c616cce3292cfb93f5825f","modified":1597024124760},{"_id":"source/images/Exchanges-direct.jpg","hash":"1f8f1eac93d313cc4961d3587fc4df5e8a857b3e","modified":1597024124778},{"_id":"source/images/Exchanges-fanout.jpg","hash":"7555fb39b4185e7e7cc64eb3aec10572aee955c6","modified":1597024124778},{"_id":"source/images/Exchanges-topic.jpg","hash":"a0b62d532d027c2b264249ee7dd020f0e63c5854","modified":1597024124779},{"_id":"source/images/HandlerMapping.png","hash":"5d492a0ac5f4ad4c0363fca57972db31521ced40","modified":1597024124780},{"_id":"source/images/MemorySplit.png","hash":"4c217d7770502e559ee8bf0aade7b24e82e62a90","modified":1597024124784},{"_id":"source/images/MySQL.jpg","hash":"fff50281e60b58530d67ed29ff6696ee752f1b55","modified":1597024124785},{"_id":"source/images/MySqlReplication.jpg","hash":"ce0b3b602474c849aa64b530c6dd1668aa677cb8","modified":1597024124786},{"_id":"source/images/RabbitMQ.jpg","hash":"fb3d3d2b56e5487e70edd8df28eac779f20dd4ce","modified":1597024124788},{"_id":"source/images/RabbitMq-Channel.png","hash":"fa55531db2b9ce581a7c771a8934042ef4e3a5fd","modified":1597024124789},{"_id":"source/images/SkyWalking.jpg","hash":"baa82a66677fef925f805681d8c0a16132a30aac","modified":1597024124789},{"_id":"source/images/SpringCloud.jpg","hash":"9dc17f37ec633e3924450ce87b16f7003bbe2204","modified":1597024124790},{"_id":"source/images/String++.jpg","hash":"f600547a96d37b0b2d699f6a77d3bb4e3f1d7e25","modified":1597024124791},{"_id":"source/images/String==.jpg","hash":"0cb2f55b8f7352599126bdf46d18282122dc0270","modified":1597024124791},{"_id":"source/images/arthas-web-console.png","hash":"b5f2b5da623df9675253412fe3be95aaed2bf331","modified":1597024124793},{"_id":"source/images/arthas.png","hash":"5afc285d4312f0d9620c835cbc50087252b75cbc","modified":1597024124793},{"_id":"source/images/chrome-extension.png","hash":"8bc3929a741c97862c9248d1efb356513332b998","modified":1597024124799},{"_id":"source/images/color-scope.png","hash":"45ba25c745e430d7aed4580278eb2d1d11c19054","modified":1597024124801},{"_id":"source/images/color-setting.png","hash":"8a162d1ed6d4cffec5119db6a3bb1399e33b0c4e","modified":1597024124802},{"_id":"source/images/consul.png","hash":"fe605415a3e4dcf90f03c1f8b9e5da911aa709b9","modified":1597024124803},{"_id":"source/images/docker-images.png","hash":"23732ca93c0eec031226216062e3a72b1cc0c07d","modified":1597024124804},{"_id":"source/images/error.jpg","hash":"a423ac4b5065916bf22d6e6761503f0ff7167f5a","modified":1597024124806},{"_id":"source/images/es.jpg","hash":"ec173dd17b92482a3add21848631a577eac4cb6b","modified":1597024124807},{"_id":"source/images/hexo.jpg","hash":"53d70fa809156ad0bbbd593005dc9b0e11ffb05b","modified":1597024124814},{"_id":"source/images/http.jpg","hash":"3384f762ccc425ac26ecce016e1fe150daf69708","modified":1597024124815},{"_id":"source/images/java-stream.png","hash":"5b3ab7d172580608399e8f6d10f78fe32077ee3d","modified":1597024124822},{"_id":"source/images/java.jpg","hash":"70bd9b442b72a0b42e3544e48ae9eff56141c7bc","modified":1597024124822},{"_id":"source/images/jvm-ObjectCreate.jpg","hash":"448701ff02b96b4130a144c9e04fe6ee985f06bd","modified":1597024124823},{"_id":"source/images/left-pivot.jpg","hash":"49d85050b3bfce71707346bb7724840fb0b38c1b","modified":1597024124824},{"_id":"source/images/linux-1.jpg","hash":"8fba9c79726876b502d7a2544bd75d77bdab4b66","modified":1597024124825},{"_id":"source/images/masterStatus.png","hash":"616e89d8ee88413c67246a6cfc37f0adf06fda6a","modified":1597024124826},{"_id":"source/images/maven.jpg","hash":"eaf03e3dfcecb4a29dd8047b4a81d58b6b65709a","modified":1597024124827},{"_id":"source/images/nginx.png","hash":"e34f6e159e47ca3f2230ea8b4f71af80492ecdf2","modified":1597024124827},{"_id":"source/images/nginxconf.png","hash":"2a450283aee696dae989315e33fd61b01f3af526","modified":1597024124828},{"_id":"source/images/oralce_jdbc.png","hash":"228bf010dc51c47c7092fa52ab19c3f3f115d48e","modified":1597024124829},{"_id":"source/images/passwd.png","hash":"5bee0ab4f8077522994224981dd289ff169d1d55","modified":1597024124830},{"_id":"source/images/red-black-tree.png","hash":"a3540c19413961c930ba6c95d27b36b28979cddf","modified":1597024124831},{"_id":"source/images/redis-caching-avalanche-solution.png","hash":"40a7dcfdd8f032d3063b54ddb98c68d921d21eaf","modified":1597024124831},{"_id":"source/images/redis-caching-avalanche.png","hash":"3104a3ade8b0a852a0122ac18f89a4dd0aa42156","modified":1597024124832},{"_id":"source/images/redis-caching-penetration.png","hash":"84d3860ce4ce59e842ac00f7d3a3741e4fdcd2ac","modified":1597024124833},{"_id":"source/images/redis-master-slave-replication.png","hash":"a99355e06d206c7e113e13ab14536991d2279219","modified":1597024124834},{"_id":"source/images/redis-master-slave.png","hash":"8411c6c19514e77f81efd1ba6ebf4a90345a508c","modified":1597024124834},{"_id":"source/images/redis.jpg","hash":"7fe35e8d18a533e09fc9eed85940a21d684c39c6","modified":1597024124838},{"_id":"source/images/right-povit.jpg","hash":"1ccac37948f03661a96695479bb5bb463f3692f0","modified":1597024124840},{"_id":"source/images/sentinel-info.png","hash":"b35b75e04e9e97b88c82893a803ac90f703e2bb6","modified":1597024124847},{"_id":"source/images/simpleApplicationEventMulticaster.png","hash":"900235ac704f673d0576fe8c7b0d510b7945e729","modified":1597024124850},{"_id":"source/images/skywalking-ui.png","hash":"a37ed62729c560c241df8538087d0f79211d8f10","modified":1597024124851},{"_id":"source/images/skywalkingFile.png","hash":"05bf19044fb568d7c322facd02043fbcf79ebfe4","modified":1597024124852},{"_id":"source/images/sort-algorithms.png","hash":"a86de9b2515f5678b8ed0ae36823b64926f459c0","modified":1597024124853},{"_id":"source/images/spring.jpg","hash":"4cba6d4467fb3a9aec0043c6668be6a1f8990f29","modified":1597024124857},{"_id":"source/images/ssh-key.jpg","hash":"dbab22e4d3a5d2bc8d4dcb04a061a9e3c6688078","modified":1597024124859},{"_id":"source/images/thundering-herd.png","hash":"ad2ef0ed13fe5153ac73951c7649ce9c39fa2bb9","modified":1597024124860},{"_id":"source/images/translationCrx.png","hash":"6e2224e324fda824391f801890a0e67753fe9b74","modified":1597024124861},{"_id":"source/images/vmess-windows-client.jpg","hash":"550559f3fcf4b164a41c86e6e9f847e1b29b3f4f","modified":1597024124862},{"_id":"source/images/vue.jpg","hash":"0afe537027d90070ff5cb0525dd05d19880446be","modified":1597024124863},{"_id":"source/images/winsw.png","hash":"73f25204b528210daca1d1dcbcb281d2fde1b161","modified":1597024124863},{"_id":"themes/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/about.ejs","hash":"e967e102bab2b35b9083165c2b8e037db8e0a32d","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/archive.ejs","hash":"094357be1c2c6b477269a3f4b725d3c5dd24ef8c","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/categories.ejs","hash":"6c4ab9fcdf5f7b58238bf06276b027075872c424","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/category.ejs","hash":"1cfe94f46f1492a411d431b02a8d09c99cab77d5","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/index.ejs","hash":"58e994d28fd72d585d2e4c63d0c0fd3e61dd14b8","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/layout.ejs","hash":"92474673da8f6016be9f4c0184b746ec21954a4d","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/links.ejs","hash":"6abd180ff4dd1d5d22e4c70328e3c7f83d174d9c","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/post.ejs","hash":"8cbfe4dee760631df26d23c49edaab18b8340526","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/tag.ejs","hash":"fd72ec9e6629facf63ce8122f0fa8d492669fa6a","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1602940783000},{"_id":"source/images/ConstantPoolTable.jpg","hash":"0d19415218c7c203ce15f076e032f2e6763eaedc","modified":1597024124777},{"_id":"source/images/JVM-1.8-after.png","hash":"dda2bfe438c8055100d16d9d7a132b43706e605d","modified":1597024124782},{"_id":"source/images/JVM-1.8-before.png","hash":"ad04409d1de7cdbb01b3fc6a8b7368ef80f5d80b","modified":1597024124783},{"_id":"source/images/RabbitMQ-Admin.png","hash":"83de51e7b0ff0dd4217360229f97684206965052","modified":1597024124787},{"_id":"source/images/ThreadPoolExcutor.jpg","hash":"291c87ad303901ede284a4716a104db2138d308f","modified":1597286018651},{"_id":"source/images/collection.png","hash":"17f679b63fcbbec16fff90c65156907e19cf8998","modified":1597024124800},{"_id":"source/images/docker-search.png","hash":"23d7971b5359c1280605d587b8b1ee7d4a46c8bb","modified":1597024124805},{"_id":"source/images/eureka.png","hash":"546dd33c3b546e35b5bc519950f8395cfcc59517","modified":1597024124808},{"_id":"source/images/info_replication.png","hash":"98478a0ce289ff6e3d7d213c21803a2ee532cf4d","modified":1597024124816},{"_id":"source/images/redis-sentinel.png","hash":"ffe02679a7074644c0d94e55cd35f61e2e4f65bd","modified":1597024124836},{"_id":"source/images/sharding-jdbc.png","hash":"06e329ad427e5c937441a5e6f8a01098c090466b","modified":1597024124849},{"_id":"source/images/springmvc.jpg","hash":"5c6d6836534bb5a91dd7cc626a9988c26b59dad7","modified":1597024124858},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"8f20dca8a03aefd495d0550544f25d8c6e44333e","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"5c5a5565bb13928bc92332d9b99b968673ea7dfb","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"bccd7961fa146dd5f0d70f77e7ab94e9f58d5bd3","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/css.ejs","hash":"a44f0abeb75039804f33771c9c3bdeb78ed2cd7a","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"382bd3ee27bc6d90776fc9171a487ff208bc4caa","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/head.ejs","hash":"55f62c4766f5d505e8307e667f83ea459b84dfb6","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"70490c67b7313ae305d39331238232fe62f094f1","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"7c40672443ba61b62b68a9aa6685ea944dbbb061","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"450918516e50065774e64cae293d39161f0ea137","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/events/index.js","hash":"a6ab2c6d9f9ba58cd1fabb85c2817874246fd525","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/generators/pages.js","hash":"01439b3d7abdeb5e51f810d784181c1d420be55d","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/js/color-schema.js","hash":"8a70f2016d9df68d29800b3bceb8f4c021158248","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1602940783000},{"_id":"source/images/sortTable.png","hash":"fafaf79b7a12d59ad3f1c69160cc66431ee001c4","modified":1597024124856},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"eeb3462cbedd195156aa671fb522bebee0274b5e","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"13c0b62854668fd83287dff3792997baeeb3a2c7","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"f1e5d89cc98e2f6e067e5cd3db728127ccff0105","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"096fef408349db4ebbec84cf20a373dd46c8f4ff","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"3c254c1b7bc5a4c6bd5b724514d463608408018b","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"2b9a49594e9aea4dc8fdd606a63c8c5b9189e325","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"37941b3c6f66f1f22aeff734802373657dfdfb99","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/tocjs.ejs","hash":"2d35295dba2bb912d6ce2ec7747af06bfdc82edb","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"96d56372cad997b09c26dbd29a19f917140c6ab0","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"2264bec80ba051a19ba80396618f3d0c22948f0b","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/preset-configs.js","hash":"202459c9444b1ba967396db3625af261b0b19820","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/version.js","hash":"0250fb16c7c798afd1f7fc816163ea0728765568","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_variables/base.styl","hash":"fe96204aa2e7ee4f7f404c9e90752a8ff822d779","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602940783000},{"_id":"source/images/2020/05/17/97ae0d90-980b-11ea-8fab-19b1e8901849.png","hash":"1798a42efa682d666cdc4bc2579b9db3f772e1cb","modified":1597024124765},{"_id":"source/images/2020/05/19/beb83e10-99b4-11ea-bc19-85fa9aca2a18.png","hash":"437f1bc6babcb20fb2f049be089c3bfdb160c194","modified":1597024124773},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"aa2528e71c290dc43b69dfbdcf4d8d6c258015a4","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"f7004d597163e0af7b9107b0be1df12f4c0a7bc0","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"fab8441a0b8d8f9db6c8370013659c035345ae79","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4f939807936632f2ff2504f139648033aa351957","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"4304bab8ad087911cbf5025a41014fbb67f20b5a","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"1e7e4290a7653f748e0a46c81cc6aed4564f8bf4","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"cbb49a17fcc030029f0c2fbe1e056613109d1ecc","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1602940783000},{"_id":"source/images/2020/05/18/c8ff2030-98e4-11ea-baff-f5d93153beb4.png","hash":"54af3ca819ed147c82fdf9cbc889f9a2f218e20d","modified":1597024124769},{"_id":"source/images/insert-sort.gif","hash":"ca62c4dc80eac486ff5ab2807f76e825228b6951","modified":1597024124820},{"_id":"source/images/2020/05/18/c3928180-98e6-11ea-ba5c-993f9fbc0aef.png","hash":"391d79b4bdb5b063c55e5b8aeff64818f8d1b0d2","modified":1597024124767},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"ec4e9678d2f4df03b1ad773adf57acc83a947687","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"2c9e05a354d4be820646a1c99f814740f299ed37","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"40a198e741805fdd51117bcb0d373660ab7dfdf9","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"7c8170d0e2de47570fe8ed523f10ee1c33138a9f","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1602940783000},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4ad804ab26bdbf5b55abbc5548b6db395cfed04","modified":1602940783000},{"_id":"source/images/2020/05/18/d3568690-98e4-11ea-baff-f5d93153beb4.png","hash":"3d34bd98976597f84d4b3cf395e04cc74d1a0404","modified":1597024124772},{"_id":"source/images/header.jpg","hash":"02cb10f0890d5a9b88f3dc724ee151ad355f61db","modified":1597024124813},{"_id":"source/images/2020/05/15/c490d980-9687-11ea-baff-f5d93153beb4.png","hash":"d97761854c1ba0e4080e6f626a0a0d5aa027b8db","modified":1597024124764},{"_id":"source/images/bubble-sort.gif","hash":"fd6590aecff7c33327ce82b348004d88d56c6a84","modified":1597024124798},{"_id":"themes/hexo-theme-fluid/source/img/default.png","hash":"f1ea58761b91eec9f2b6cd1284185a2c089848e3","modified":1603789942404},{"_id":"source/images/2020/05/25/72d56dc0-9e9f-11ea-81d3-796c7949b71a.png","hash":"f50509eac8738ed0dde1aac334f2489f617e3a27","modified":1597024124776},{"_id":"source/images/selection-sort.gif","hash":"a52157c0615c58066467795c4cd29b6b55a367dc","modified":1597024124846},{"_id":"public/content.json","hash":"4021db87114602a30ee472a74d87ab2094fdc960","modified":1605676518534},{"_id":"public/local-search.xml","hash":"de5676687a840b6b64d1e07abd5622827bfa5d70","modified":1605676518535},{"_id":"public/2020/09/17/大数据-Json-压缩/index.html","hash":"0749786e45ffac5623e386da7c8a91b4d44ed550","modified":1605676520056},{"_id":"public/2020/08/26/Java-引用类型/index.html","hash":"9a86ac91c67803778a73df35ece2445cad28ff60","modified":1605676520056},{"_id":"public/2020/05/27/MySql数据库索引知识/index.html","hash":"1732c43a5e2afed117a42a9f8ed23bdcce498782","modified":1605676520056},{"_id":"public/2020/05/22/事务隔离性/index.html","hash":"4f948a05981f9ed37cc36eb34bf0114d18e2fc77","modified":1605676520056},{"_id":"public/2020/05/18/一致性哈希算法/index.html","hash":"c89428a5f20e5613d8158c8c5d952a4ca7f2a85b","modified":1605676520056},{"_id":"public/2019/10/17/Oracle数据库驱动/index.html","hash":"914b8440367e050b96abe8c3f30632da062f261c","modified":1605676520056},{"_id":"public/2019/08/14/IDEA-快捷键备份/index.html","hash":"97694f2d8f366228d5a06be74b1c2456d1957be4","modified":1605676520056},{"_id":"public/2019/08/08/Linux-字体背景颜色设置/index.html","hash":"10d0ff63758df332ce3eaa7568c5789d80897252","modified":1605676520056},{"_id":"public/2019/08/08/Linux-中判断条件/index.html","hash":"23d663ce173c6873a8738907fe3a609530628291","modified":1605676520056},{"_id":"public/2019/08/07/VPS-一键搭建脚本/index.html","hash":"b0bd710a8624827054f7c9d94a3ad17431d8e83c","modified":1605676520056},{"_id":"public/2019/07/25/学习红黑树/index.html","hash":"1474859017358e5df14209910f4662dad6b17c37","modified":1605676520057},{"_id":"public/2019/07/24/fast-fail和fast-safe的区别/index.html","hash":"a0c107a3b95937cae791415a76cbd6189bb78205","modified":1605676520057},{"_id":"public/2019/07/22/Java-集合总结/index.html","hash":"5e0d1ad3dbf9945f411282cd0990293a4b5794f0","modified":1605676520057},{"_id":"public/2019/07/18/Maven 属性/index.html","hash":"39477ddaec2b905255652cb291683076f599eae4","modified":1605676520057},{"_id":"public/2019/04/17/JVM 对象创建/index.html","hash":"a6f44176142f5dd4ae43e250364a89ea525cc2bd","modified":1605676520057},{"_id":"public/2019/03/29/Stream流操作/index.html","hash":"f0488e4a2347373c6b8b3b76934b432573400203","modified":1605676520057},{"_id":"public/2019/03/21/JVM 类加载/index.html","hash":"46a7dd3df69b1a93f974637178ef0762f8a5edb7","modified":1605676520057},{"_id":"public/2019/02/22/Redis持久化/index.html","hash":"4d627236cbbb706331c473b5b4348a42181b0adc","modified":1605676520057},{"_id":"public/2019/02/22/Redis缓存场景/index.html","hash":"e0485923dde658ce02ae0695253ecbc9de5360c9","modified":1605676520057},{"_id":"public/2018/07/25/Linux-关机重启命令/index.html","hash":"b73f974ca8a2684712a6216b2ce19eb25f4755ad","modified":1605676520057},{"_id":"public/2018/05/25/Logstah同步Es/index.html","hash":"cb5589cd7dfb8c61df4099035277cbb668a93c3a","modified":1605676520057},{"_id":"public/2018/05/25/Python 第三方库 PIL/index.html","hash":"ce41adf0a58effcbd76bcf0a2d21c44b2f0773d5","modified":1605676520057},{"_id":"public/archives/index.html","hash":"7412ed61c4af435126b32b1b49a2d8dd920f0e79","modified":1605676520057},{"_id":"public/archives/page/2/index.html","hash":"b276e8a9c85a5260abb0e45927a839de650b5e7d","modified":1605676520058},{"_id":"public/archives/page/3/index.html","hash":"8b18e406e0b5b5b84e92c0ee50510e888835b244","modified":1605676520058},{"_id":"public/archives/page/4/index.html","hash":"58087d8c327496f4351ac000e48fcd7104a59096","modified":1605676520058},{"_id":"public/archives/page/5/index.html","hash":"9253575bd19b337f0dcb9435c5e4c9e2ec5c918c","modified":1605676520058},{"_id":"public/archives/page/6/index.html","hash":"af3cd24524f6a072eca6d28ca2fc02d981927ef0","modified":1605676520058},{"_id":"public/archives/page/7/index.html","hash":"276f9cc00f72bdc05c660fd7044ccc56b7c5252b","modified":1605676520058},{"_id":"public/archives/2018/index.html","hash":"e06555dcedb0ef8063c39582c61260ae84fec2db","modified":1605676520058},{"_id":"public/archives/2018/page/2/index.html","hash":"46ad767653d59a6d6fb8f33381c99bd0f517d4a3","modified":1605676520058},{"_id":"public/archives/2018/05/index.html","hash":"970cb133f4c58112bd4a9af7ec74390d849e5145","modified":1605676520059},{"_id":"public/archives/2018/07/index.html","hash":"6d7b0c3e74b3d5a0317de92f94619906c41ff502","modified":1605676520059},{"_id":"public/archives/2018/08/index.html","hash":"b664c534ed278a301f20945e33732caf79a30b8b","modified":1605676520059},{"_id":"public/archives/2019/index.html","hash":"42c410789d5bb1af94c9f98d28cb5b3cb56ecf22","modified":1605676520059},{"_id":"public/archives/2019/page/2/index.html","hash":"0b52820593b79655864a9d259156f34c07f0046f","modified":1605676520059},{"_id":"public/archives/2019/page/3/index.html","hash":"8e866d638eb0a5bde7304d771c14191c39a80c3a","modified":1605676520059},{"_id":"public/archives/2019/page/4/index.html","hash":"441491e400469f497169b7e3740d98ad2805e1c2","modified":1605676520059},{"_id":"public/archives/2019/02/index.html","hash":"f9f6ce9bb2b6813cd0bc5e5c777ba0aa147dfa58","modified":1605676520059},{"_id":"public/archives/2019/03/index.html","hash":"b0dcb6d5a855d67075acc24ba563d422c2c58c14","modified":1605676520059},{"_id":"public/archives/2019/04/index.html","hash":"d55f7ae1bf806047538f5159beeaf7e48da008dc","modified":1605676520059},{"_id":"public/archives/2019/07/index.html","hash":"2ab5c4f03a011139a1fe97b9bbf2f15785c1792b","modified":1605676520059},{"_id":"public/archives/2019/08/index.html","hash":"d2154ff5ab516d45cd021ecee39be55d83f936a6","modified":1605676520059},{"_id":"public/archives/2019/09/index.html","hash":"af549643c1856dd2a31ebf63f86551de97e97cd7","modified":1605676520060},{"_id":"public/archives/2019/10/index.html","hash":"1e02ea18137515a87656b38f52311e7380885f2a","modified":1605676520060},{"_id":"public/archives/2019/11/index.html","hash":"2fb5f5142c1db1664debdd898a25d4affc5e8f41","modified":1605676520060},{"_id":"public/archives/2020/index.html","hash":"2cf7fc9eea0beff25304b30fde856cde7a8aae35","modified":1605676520060},{"_id":"public/archives/2020/page/2/index.html","hash":"26faca533d55f049d1b0088ae43849603d7da68a","modified":1605676520060},{"_id":"public/archives/2020/01/index.html","hash":"a6251fdbdf50928ce68d3d56082427b8c16fe755","modified":1605676520060},{"_id":"public/archives/2020/04/index.html","hash":"3c4ddb89e240680992286771dce0ebb08fd2e14a","modified":1605676520060},{"_id":"public/archives/2020/05/index.html","hash":"0777cd295ed08b34ecd29e1c7f088437184bef93","modified":1605676520060},{"_id":"public/archives/2020/08/index.html","hash":"f58a9fdc7628ff6bbfce49245bfd200a7340270f","modified":1605676520060},{"_id":"public/archives/2020/09/index.html","hash":"f2e38579208305a6f8cfb71f641ce68ead3e4e74","modified":1605676520060},{"_id":"public/categories/Java/index.html","hash":"1272484283dd6fab0dbb4bc089070582f20a8806","modified":1605676520060},{"_id":"public/categories/Java/page/2/index.html","hash":"52bfc98ebc42a821d6ab011919efd24481352ef6","modified":1605676520060},{"_id":"public/categories/Java/page/3/index.html","hash":"cf59e668f2f82a4331754201d51434da50eefddb","modified":1605676520060},{"_id":"public/categories/Linux/index.html","hash":"8ae166afc0e388c6cc6495183bf7c92ad9932c2c","modified":1605676520060},{"_id":"public/categories/技术/index.html","hash":"3d355fdb759ecba9933d500dc7878b69e49c6290","modified":1605676520061},{"_id":"public/categories/技术/page/2/index.html","hash":"6bee2a0617e657b1620eed81bc959b4503ce3553","modified":1605676520061},{"_id":"public/categories/java/index.html","hash":"4576ed6242ccfa0375d9ca9e3c4c32e1e944c90f","modified":1605676520061},{"_id":"public/categories/Spring/index.html","hash":"10dd9c5ee8103455497c05d68e841fea06ded8f6","modified":1605676520061},{"_id":"public/categories/数据库/index.html","hash":"045a3370c6ace01787e36d7f908e4c7aecddbb23","modified":1605676520061},{"_id":"public/categories/Python/index.html","hash":"e83fef7ba4d8d568e6cb43813fb58ad10dded1d0","modified":1605676520061},{"_id":"public/categories/redis/index.html","hash":"00e9060d099f2dc924a3e669021e2c2266b4d0d2","modified":1605676520061},{"_id":"public/categories/代码块/index.html","hash":"9f210ac643d6af0221ef3cf4a9cc337bbea4923c","modified":1605676520061},{"_id":"public/page/6/index.html","hash":"307bc0b25d2bdcfca0b744f14249fcc1a6a6d863","modified":1605676520061},{"_id":"public/tags/Java/index.html","hash":"45febeb5b0fdb93609c2233226e7d58a873ef3e9","modified":1605676520061},{"_id":"public/tags/Java/page/2/index.html","hash":"59b0143df06fb8ed8eadff8a487fdb2e4f6289f4","modified":1605676520061},{"_id":"public/tags/Linux/index.html","hash":"f6263f703eb3929fa18c804a17d1bc0779000d32","modified":1605676520061},{"_id":"public/tags/前端/index.html","hash":"7229411bc7f7930675a05cb24954b21bedc7124c","modified":1605676520061},{"_id":"public/tags/复习/index.html","hash":"a0113afa57d22304a35c3c98765b844c900d1702","modified":1605676520061},{"_id":"public/tags/Jvm/index.html","hash":"54552b8bf1161f8383bb3447cf477712f0fe2cca","modified":1605676520061},{"_id":"public/tags/技术/index.html","hash":"ecf45acb90a34ea46608da77e221beb7c7af63d4","modified":1605676520062},{"_id":"public/tags/Maven/index.html","hash":"4eea0273b62bb71b5c2ef469ad177faf8c57333f","modified":1605676520062},{"_id":"public/tags/数据库/index.html","hash":"39b97e1c519097239eef78395575ecb8c648f325","modified":1605676520062},{"_id":"public/tags/文档/index.html","hash":"8f3f412ad742db583e20a615cbece479e15ce727","modified":1605676520062},{"_id":"public/tags/Python/index.html","hash":"8762d49f994e916b8ed48cc05cf4ccdad7609c50","modified":1605676520062},{"_id":"public/tags/中间件/index.html","hash":"59beaf68a58e0a5693871c60ff69b6a04d708cff","modified":1605676520062},{"_id":"public/tags/Redis/index.html","hash":"68b63a6c3ae1a02d2d929bf8308b372931c6a0a5","modified":1605676520062},{"_id":"public/tags/Spring/index.html","hash":"1287c90ca3487fd860a2c04aed4ebf2765e95f11","modified":1605676520062},{"_id":"public/tags/心得/index.html","hash":"f34d28c7e4d0746eee621277f77f0d7d103cb138","modified":1605676520062},{"_id":"public/tags/多线程/index.html","hash":"cae4b0c1ab34e761fc777e4a26872862fc7ea335","modified":1605676520062},{"_id":"public/404.html","hash":"83a25d8a89da4ec48aad90023da453b87bf4cba1","modified":1605676520062},{"_id":"public/tags/index.html","hash":"77930636b8b1abc15e601dba0c1e7643fe205306","modified":1605676520062},{"_id":"public/links/index.html","hash":"5b1a0e0bff6159d0bae5fc114689d64776a73d53","modified":1605676520062},{"_id":"public/2020/09/28/抢卷并发代码Redis应用/index.html","hash":"b85b7fcf864e37730d5f9a4b3c91fea7abecea63","modified":1605676520062},{"_id":"public/2020/09/14/Redis的淘汰机制LRU算法/index.html","hash":"ddc1422deae9592a730ca229b7b2c53bf6f4ad53","modified":1605676520062},{"_id":"public/2020/08/14/EasyExcel-简单的Excel-处理工具/index.html","hash":"9210a064a3a39515435965274e9a47d36ed6142b","modified":1605676520062},{"_id":"public/2020/05/26/事务传播性/index.html","hash":"aa0c1b4f765680db3d49a7c1e0eef33070b3895d","modified":1605676520062},{"_id":"public/2020/05/25/学习-CurrentHashMap/index.html","hash":"db2e94a48d208a1063d5d621058f31c7b541e540","modified":1605676520062},{"_id":"public/2020/05/20/SpringBoot-启动过程（四）/index.html","hash":"52807a0e2b703b52fcabf365799c62917a5032c4","modified":1605676520063},{"_id":"public/2020/05/17/Redis-集群搭建记录/index.html","hash":"b0509673d589e507214c26eaab5c7eb2c7588e92","modified":1605676520063},{"_id":"public/2020/05/11/Springboot 启动过程（二）/index.html","hash":"e7809c92ada19eff5e8745785695f3b788b0214b","modified":1605676520063},{"_id":"public/2020/05/09/Springboot 启动过程（三）/index.html","hash":"f12a2b77c8afb4ceb43914265718b292191f4131","modified":1605676520063},{"_id":"public/2020/04/14/Springboot 启动过程（一）/index.html","hash":"97a622776727e92b0897bd68a5a35414e8561727","modified":1605676520063},{"_id":"public/2020/01/17/Chrome-Extension-开发笔记/index.html","hash":"490497bf9cd2b9b6d96af7b59e979ea4ffcf08a2","modified":1605676520063},{"_id":"public/2019/11/26/ThreadPoolExecutor-线程池/index.html","hash":"e49194ee7489866fbb935de636552868d2d9be2f","modified":1605676520063},{"_id":"public/2019/11/12/Redis主从配置/index.html","hash":"f18056128e1e1157777e5d3bca84139057b9af0f","modified":1605676520063},{"_id":"public/2019/10/17/Sharding-jdbc-数据库中间件集成/index.html","hash":"4a4a39dce8e1c4da78924505549a4fdf66430514","modified":1605676520063},{"_id":"public/2019/09/17/学习-CompletableFuture/index.html","hash":"64f27bf41f34098f2a07f5b59e80fa0ccbc30969","modified":1605676520063},{"_id":"public/2019/08/09/Nginx-配置详解/index.html","hash":"7ccbfea96f6177747183f235040226ed8d9cf741","modified":1605676520063},{"_id":"public/2019/07/25/Java-排序方法总结/index.html","hash":"8499f176273d156692d5583bca2bf0a90c08b1d2","modified":1605676520063},{"_id":"public/2019/07/17/V2Ray搭建记录/index.html","hash":"ff1beb6dfbfcad90ada68fc805f0c2d0cb17fffa","modified":1605676520063},{"_id":"public/2019/07/17/Vue复杂的table表单代码块/index.html","hash":"d5f9a3dec24e59050b337013eceb6089c050ce77","modified":1605676520063},{"_id":"public/2019/04/28/阿里巴巴诊断器/index.html","hash":"3c6db06bbab71f9bd2e4baf552070b7337db109b","modified":1605676520064},{"_id":"public/2019/04/24/Http 知识/index.html","hash":"6a85e56238a9a39f8fbd2c79172d6af3847c5ee4","modified":1605676520064},{"_id":"public/2019/04/22/SpringMVC 工作原理/index.html","hash":"5279400bf4c19e080ba046b8c7163f2557e31b60","modified":1605676520064},{"_id":"public/2019/04/10/Redis数据类型及应用场景/index.html","hash":"63a0f38bb96a715a6e066fa1036cd334dccb21ee","modified":1605676520064},{"_id":"public/2019/04/02/SkyWalking搭建记录/index.html","hash":"c5e33eb00a243097f840a4491dfa4f41e903d658","modified":1605676520064},{"_id":"public/2019/04/01/MySQL千行命令/index.html","hash":"df47d06e2dba24494c829da385498ed8d5caf330","modified":1605676520064},{"_id":"public/2019/03/28/String类和常量池/index.html","hash":"9128279baff01c6d38e9e2f5ee8ae7d45d486c2a","modified":1605676520064},{"_id":"public/2019/03/25/Mysql 主从配置/index.html","hash":"bd6bf038647df91ec4ebe500c3e57ca1f2be9e63","modified":1605676520064},{"_id":"public/2019/03/21/JVM 内存区域/index.html","hash":"b8f93de9968cb6e67c0c86097905b570a45a5a66","modified":1605676520064},{"_id":"public/2019/03/20/RabbitMq 消息队列中间件/index.html","hash":"1eae9d26debc787d7f2543b0436b9264ca97c59d","modified":1605676520064},{"_id":"public/2019/03/18/ArrayList源码阅读/index.html","hash":"80558400743bd2f22d9bc0287069aa16a07cc624","modified":1605676520064},{"_id":"public/2018/08/20/Docker环境搭建/index.html","hash":"2b3305c3ae8d6ba0ad39cfcd2820057db78bea8d","modified":1605676520064},{"_id":"public/2018/08/16/Winsw把java项目做成服务/index.html","hash":"be5830770f25fe85f1a610ee1c230a3051544187","modified":1605676520064},{"_id":"public/2018/08/01/SprintCloud微服务-Eureka/index.html","hash":"bb718e090f3bba040cf0411161bfaa159fcc5f24","modified":1605676520064},{"_id":"public/2018/07/26/Hexo部署到VPS自动发布/index.html","hash":"7f37d2f1d22d612f651fa11d708f355f337f1e03","modified":1605676520064},{"_id":"public/2018/07/25/Linux-文件权限管理/index.html","hash":"e5be3a401c5e6b0b9a5be2cf1bee26ab130fbda1","modified":1605676520065},{"_id":"public/2018/07/20/Log4j-学习笔记/index.html","hash":"6a0ad3c5e1400fc15def7813518babee136a26f7","modified":1605676520065},{"_id":"public/2018/07/19/CentOs-Firewalld-脚本/index.html","hash":"808e367605b93d57f408811e0d7b1f1b25c41c70","modified":1605676520065},{"_id":"public/2018/07/13/Linxu搭建SS/index.html","hash":"94044b79831953011a435973a0e156d870f8b64c","modified":1605676520065},{"_id":"public/2018/05/24/hexo/index.html","hash":"dc057e842452a8cc7b17f576f4a4cb5227567004","modified":1605676520065},{"_id":"public/index.html","hash":"1db7b818a870b71a6e2073445974c4c0a2835a02","modified":1605676520065},{"_id":"public/page/2/index.html","hash":"f186360b6cc6b30382ddcc83f92724d1d032eca2","modified":1605676520065},{"_id":"public/page/3/index.html","hash":"7f4f7270b8701f992cb86b88b8fb08054ab52dcc","modified":1605676520065},{"_id":"public/page/4/index.html","hash":"3021440dc45355d4f2a91bc68deed26b41c318ab","modified":1605676520065},{"_id":"public/page/5/index.html","hash":"6944e05d6547bb2e13dce1b1b83510194c1a2852","modified":1605676520065},{"_id":"public/categories/index.html","hash":"c4158f354b0bced2f610e82399fa6fad459dff09","modified":1605676520065},{"_id":"public/CNAME","hash":"74161b596d943086f214656cb45bb1807aacfa99","modified":1605676520127},{"_id":"public/images/Exchanges-direct.jpg","hash":"1f8f1eac93d313cc4961d3587fc4df5e8a857b3e","modified":1605676520127},{"_id":"public/images/Exchanges-fanout.jpg","hash":"7555fb39b4185e7e7cc64eb3aec10572aee955c6","modified":1605676520127},{"_id":"public/images/Exchanges-topic.jpg","hash":"a0b62d532d027c2b264249ee7dd020f0e63c5854","modified":1605676520127},{"_id":"public/images/HandlerMapping.png","hash":"5d492a0ac5f4ad4c0363fca57972db31521ced40","modified":1605676520127},{"_id":"public/images/MemorySplit.png","hash":"4c217d7770502e559ee8bf0aade7b24e82e62a90","modified":1605676520127},{"_id":"public/images/MySQL.jpg","hash":"fff50281e60b58530d67ed29ff6696ee752f1b55","modified":1605676520127},{"_id":"public/images/MySqlReplication.jpg","hash":"ce0b3b602474c849aa64b530c6dd1668aa677cb8","modified":1605676520127},{"_id":"public/images/RabbitMQ.jpg","hash":"fb3d3d2b56e5487e70edd8df28eac779f20dd4ce","modified":1605676520127},{"_id":"public/images/RabbitMq-Channel.png","hash":"fa55531db2b9ce581a7c771a8934042ef4e3a5fd","modified":1605676520127},{"_id":"public/images/SkyWalking.jpg","hash":"baa82a66677fef925f805681d8c0a16132a30aac","modified":1605676520127},{"_id":"public/images/SpringCloud.jpg","hash":"9dc17f37ec633e3924450ce87b16f7003bbe2204","modified":1605676520128},{"_id":"public/images/String++.jpg","hash":"f600547a96d37b0b2d699f6a77d3bb4e3f1d7e25","modified":1605676520128},{"_id":"public/images/String==.jpg","hash":"0cb2f55b8f7352599126bdf46d18282122dc0270","modified":1605676520128},{"_id":"public/images/arthas-web-console.png","hash":"b5f2b5da623df9675253412fe3be95aaed2bf331","modified":1605676520128},{"_id":"public/images/arthas.png","hash":"5afc285d4312f0d9620c835cbc50087252b75cbc","modified":1605676520128},{"_id":"public/images/color-scope.png","hash":"45ba25c745e430d7aed4580278eb2d1d11c19054","modified":1605676520128},{"_id":"public/images/color-setting.png","hash":"8a162d1ed6d4cffec5119db6a3bb1399e33b0c4e","modified":1605676520128},{"_id":"public/images/consul.png","hash":"fe605415a3e4dcf90f03c1f8b9e5da911aa709b9","modified":1605676520128},{"_id":"public/images/docker-images.png","hash":"23732ca93c0eec031226216062e3a72b1cc0c07d","modified":1605676520128},{"_id":"public/images/error.jpg","hash":"a423ac4b5065916bf22d6e6761503f0ff7167f5a","modified":1605676520128},{"_id":"public/images/es.jpg","hash":"ec173dd17b92482a3add21848631a577eac4cb6b","modified":1605676520128},{"_id":"public/images/hexo.jpg","hash":"53d70fa809156ad0bbbd593005dc9b0e11ffb05b","modified":1605676520128},{"_id":"public/images/http.jpg","hash":"3384f762ccc425ac26ecce016e1fe150daf69708","modified":1605676520128},{"_id":"public/images/java.jpg","hash":"70bd9b442b72a0b42e3544e48ae9eff56141c7bc","modified":1605676520129},{"_id":"public/images/jvm-ObjectCreate.jpg","hash":"448701ff02b96b4130a144c9e04fe6ee985f06bd","modified":1605676520129},{"_id":"public/images/left-pivot.jpg","hash":"49d85050b3bfce71707346bb7724840fb0b38c1b","modified":1605676520129},{"_id":"public/images/masterStatus.png","hash":"616e89d8ee88413c67246a6cfc37f0adf06fda6a","modified":1605676520129},{"_id":"public/images/linux-1.jpg","hash":"8fba9c79726876b502d7a2544bd75d77bdab4b66","modified":1605676520129},{"_id":"public/images/nginx.png","hash":"e34f6e159e47ca3f2230ea8b4f71af80492ecdf2","modified":1605676520129},{"_id":"public/images/maven.jpg","hash":"eaf03e3dfcecb4a29dd8047b4a81d58b6b65709a","modified":1605676520129},{"_id":"public/images/nginxconf.png","hash":"2a450283aee696dae989315e33fd61b01f3af526","modified":1605676520129},{"_id":"public/images/oralce_jdbc.png","hash":"228bf010dc51c47c7092fa52ab19c3f3f115d48e","modified":1605676520129},{"_id":"public/images/passwd.png","hash":"5bee0ab4f8077522994224981dd289ff169d1d55","modified":1605676520129},{"_id":"public/images/red-black-tree.png","hash":"a3540c19413961c930ba6c95d27b36b28979cddf","modified":1605676520129},{"_id":"public/images/redis-caching-avalanche-solution.png","hash":"40a7dcfdd8f032d3063b54ddb98c68d921d21eaf","modified":1605676520129},{"_id":"public/images/redis-caching-avalanche.png","hash":"3104a3ade8b0a852a0122ac18f89a4dd0aa42156","modified":1605676520129},{"_id":"public/images/redis-caching-penetration.png","hash":"84d3860ce4ce59e842ac00f7d3a3741e4fdcd2ac","modified":1605676520130},{"_id":"public/images/redis-master-slave-replication.png","hash":"a99355e06d206c7e113e13ab14536991d2279219","modified":1605676520130},{"_id":"public/images/redis-master-slave.png","hash":"8411c6c19514e77f81efd1ba6ebf4a90345a508c","modified":1605676520130},{"_id":"public/images/redis.jpg","hash":"7fe35e8d18a533e09fc9eed85940a21d684c39c6","modified":1605676520130},{"_id":"public/images/right-povit.jpg","hash":"1ccac37948f03661a96695479bb5bb463f3692f0","modified":1605676520130},{"_id":"public/images/sentinel-info.png","hash":"b35b75e04e9e97b88c82893a803ac90f703e2bb6","modified":1605676520130},{"_id":"public/images/simpleApplicationEventMulticaster.png","hash":"900235ac704f673d0576fe8c7b0d510b7945e729","modified":1605676520130},{"_id":"public/images/skywalking-ui.png","hash":"a37ed62729c560c241df8538087d0f79211d8f10","modified":1605676520130},{"_id":"public/images/skywalkingFile.png","hash":"05bf19044fb568d7c322facd02043fbcf79ebfe4","modified":1605676520130},{"_id":"public/images/sort-algorithms.png","hash":"a86de9b2515f5678b8ed0ae36823b64926f459c0","modified":1605676520130},{"_id":"public/images/spring.jpg","hash":"4cba6d4467fb3a9aec0043c6668be6a1f8990f29","modified":1605676520130},{"_id":"public/images/ssh-key.jpg","hash":"dbab22e4d3a5d2bc8d4dcb04a061a9e3c6688078","modified":1605676520130},{"_id":"public/images/thundering-herd.png","hash":"ad2ef0ed13fe5153ac73951c7649ce9c39fa2bb9","modified":1605676520130},{"_id":"public/images/vmess-windows-client.jpg","hash":"550559f3fcf4b164a41c86e6e9f847e1b29b3f4f","modified":1605676520131},{"_id":"public/images/translationCrx.png","hash":"6e2224e324fda824391f801890a0e67753fe9b74","modified":1605676520131},{"_id":"public/images/vue.jpg","hash":"0afe537027d90070ff5cb0525dd05d19880446be","modified":1605676520131},{"_id":"public/images/winsw.png","hash":"73f25204b528210daca1d1dcbcb281d2fde1b161","modified":1605676520131},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1605676520131},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1605676520131},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1605676520131},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1605676520131},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1605676520131},{"_id":"public/images/2020/05/19/beb83e10-99b4-11ea-bc19-85fa9aca2a18.png","hash":"437f1bc6babcb20fb2f049be089c3bfdb160c194","modified":1605676520131},{"_id":"public/images/2020/05/17/97ae0d90-980b-11ea-8fab-19b1e8901849.png","hash":"1798a42efa682d666cdc4bc2579b9db3f772e1cb","modified":1605676520131},{"_id":"public/images/chrome-extension.png","hash":"8bc3929a741c97862c9248d1efb356513332b998","modified":1605676520823},{"_id":"public/images/java-stream.png","hash":"5b3ab7d172580608399e8f6d10f78fe32077ee3d","modified":1605676520823},{"_id":"public/images/JVM-1.8-after.png","hash":"dda2bfe438c8055100d16d9d7a132b43706e605d","modified":1605676520825},{"_id":"public/images/ConstantPoolTable.jpg","hash":"0d19415218c7c203ce15f076e032f2e6763eaedc","modified":1605676520825},{"_id":"public/images/JVM-1.8-before.png","hash":"ad04409d1de7cdbb01b3fc6a8b7368ef80f5d80b","modified":1605676520825},{"_id":"public/images/RabbitMQ-Admin.png","hash":"83de51e7b0ff0dd4217360229f97684206965052","modified":1605676520825},{"_id":"public/images/ThreadPoolExcutor.jpg","hash":"291c87ad303901ede284a4716a104db2138d308f","modified":1605676520825},{"_id":"public/images/collection.png","hash":"17f679b63fcbbec16fff90c65156907e19cf8998","modified":1605676520825},{"_id":"public/images/docker-search.png","hash":"23d7971b5359c1280605d587b8b1ee7d4a46c8bb","modified":1605676520825},{"_id":"public/images/eureka.png","hash":"546dd33c3b546e35b5bc519950f8395cfcc59517","modified":1605676520826},{"_id":"public/images/info_replication.png","hash":"98478a0ce289ff6e3d7d213c21803a2ee532cf4d","modified":1605676520826},{"_id":"public/images/redis-sentinel.png","hash":"ffe02679a7074644c0d94e55cd35f61e2e4f65bd","modified":1605676520826},{"_id":"public/images/sharding-jdbc.png","hash":"06e329ad427e5c937441a5e6f8a01098c090466b","modified":1605676520826},{"_id":"public/images/springmvc.jpg","hash":"5c6d6836534bb5a91dd7cc626a9988c26b59dad7","modified":1605676520826},{"_id":"public/images/2020/05/18/c8ff2030-98e4-11ea-baff-f5d93153beb4.png","hash":"54af3ca819ed147c82fdf9cbc889f9a2f218e20d","modified":1605676520826},{"_id":"public/images/2020/05/18/c3928180-98e6-11ea-ba5c-993f9fbc0aef.png","hash":"391d79b4bdb5b063c55e5b8aeff64818f8d1b0d2","modified":1605676520826},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1605676520842},{"_id":"public/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1605676520842},{"_id":"public/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1605676520842},{"_id":"public/js/color-schema.js","hash":"8a70f2016d9df68d29800b3bceb8f4c021158248","modified":1605676520842},{"_id":"public/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1605676520842},{"_id":"public/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1605676520842},{"_id":"public/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1605676520842},{"_id":"public/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1605676520842},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1605676520843},{"_id":"public/css/main.css","hash":"4c092bcb04cb3793cac7f62efc49bed5b4fa4d76","modified":1605676520843},{"_id":"public/images/sortTable.png","hash":"fafaf79b7a12d59ad3f1c69160cc66431ee001c4","modified":1605676520843},{"_id":"public/images/2020/05/18/d3568690-98e4-11ea-baff-f5d93153beb4.png","hash":"3d34bd98976597f84d4b3cf395e04cc74d1a0404","modified":1605676520843},{"_id":"public/images/2020/05/25/72d56dc0-9e9f-11ea-81d3-796c7949b71a.png","hash":"f50509eac8738ed0dde1aac334f2489f617e3a27","modified":1605676520843},{"_id":"public/images/2020/05/15/c490d980-9687-11ea-baff-f5d93153beb4.png","hash":"d97761854c1ba0e4080e6f626a0a0d5aa027b8db","modified":1605676520861},{"_id":"public/img/default.png","hash":"f1ea58761b91eec9f2b6cd1284185a2c089848e3","modified":1605676520976},{"_id":"public/images/insert-sort.gif","hash":"ca62c4dc80eac486ff5ab2807f76e825228b6951","modified":1605676520995},{"_id":"public/images/header.jpg","hash":"02cb10f0890d5a9b88f3dc724ee151ad355f61db","modified":1605676521035},{"_id":"public/images/bubble-sort.gif","hash":"fd6590aecff7c33327ce82b348004d88d56c6a84","modified":1605676521035},{"_id":"public/images/selection-sort.gif","hash":"a52157c0615c58066467795c4cd29b6b55a367dc","modified":1605676521062},{"_id":"source/_posts/Spring中-Import-注解的使用.md","hash":"1c67afe40eff12cf83fd62d2645fbef0fd82efe4","modified":1605691657225},{"_id":"source/_posts/Spring-Security-集成-Jwt.md","hash":"db698c437a2a0931a5638ce7b3c237813d61665f","modified":1614648267302},{"_id":"source/_posts/Spring动态注入Bean.md","hash":"058f0dc7c41e3d8114eabead777543389ed952e9","modified":1605748823549}],"Category":[{"name":"Java","_id":"ckhmyc96h0002jsud6uub1okk"},{"name":"Linux","_id":"ckhmyc96q0007jsudxte5mb48"},{"name":"技术","_id":"ckhmyc96y000ejsudfyxzr8if"},{"name":"java","_id":"ckhmyc97i000yjsud4m9vweyt"},{"name":"Spring","_id":"ckhmyc986001ujsud9y4b300d"},{"name":"数据库","_id":"ckhmyc98b0024jsudtsra6ip9"},{"name":"Python","_id":"ckhmyc98m002ljsudj8vc39xu"},{"name":"redis","_id":"ckhmyc9960036jsud0mn41ta1"},{"name":"代码块","_id":"ckhmyc9aq0057jsuduw3zw772"}],"Data":[],"Page":[],"Post":[{"title":"ArrayList源码阅读","date":"2019-03-18T13:01:48.000Z","_content":"![Java](/images/java.jpg)\n\n> 记录学习回顾Java基础学习源码思想ArrayList，平时光顾着写业务代码基础细节都没有进行积累导致出去面试被人家一顿虐，只注重外功不注重内功是不行的。\n\n## ArrayList\n平时最常用的集合，特点有序查找效率高`线程不安全`底层是数组实现了动态数组的功能，实现了`RandomAccess`(快速随机访问)、`Cloneable`(克隆接口)、`Serializabele`(序列化)等接口。\n\n### 源码解析\n``` java\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * 默认的初始化容量 10\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 共享的静态空Object数组用于空实例\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 共享的静态空数组实例 用于最常用的new ArrayList() 无参实例使用\n     */\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 用于存放加入的数据数组 transient 关键字用于标记不需要序列化的字段\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * \n     * 整个数组的长度 size 即size()返回值\n     * @serial\n     */\n    private int size;\n\n    /**\n     * 有参数的构造函数 initialCapacity 用于给集合初始化容量\n     */\n    public ArrayList(int  initialCapacity) {\n    \t//初始化一个大小为 initialCapacity 的Object数组\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n        \t//如果初始容量为0使用静态 EMPTY_ELEMENTDATA 默认的空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     * 最常用的初始化方法\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * Collection 传入一个集合元素列表 E为泛型 指定传入的集合类型\n     */\n    public ArrayList(Collection<? extends E> c) {\n    \t//集合转化为数组 并初始化elementData\n        elementData = c.toArray();\n        //初始化size的值\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            // 由于传入的集合真实类型不一样所以需要调用 Arrays.copyOf 复制到一个新的Object[]数组中，以便可以存放任意类型\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     *修改当前容器值为实际元素的个数\n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n\n    /**\n     * 自行控制扩容大小 \n     * 如果扩容值大于默认值10 则按传入值进行扩容处理判断\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n    /**\n     * 计算最小容量\n     */\n    private static int calculateCapacity(Object[] elementData, int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            return Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        return minCapacity;\n    }\n\n    /**\n     * 根据minCapacity进行扩容\n     */\n    private void ensureCapacityInternal(int minCapacity) {\n        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    }\n\n    /**\n     * 判断是否需要进行扩容操作 如果扩容值大于实际的数组长度则进行扩容\n     */\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n\n    /**\n     * 能分配的最大的数组大小 Integer数值最大值(2^31-1)-8\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * 扩容的核心代码\n     * 每次扩容的大小为 当前数组长度+(数组长度/2)\n     * 如果扩容新容量小于需要扩容量值则覆盖新容量值\n     * 如果扩容新容量大于MAX_ARRAY_SIZE则直接使用Interger.MAX_VALUE否则使用MAX_ARRAY_SIZE\n     */\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n    /**\n     *当需要扩容大于MAX_ARRAY_SIEZ或小于0 返回合适值\n     */\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n}\n\n```","source":"_posts/ArrayList源码阅读.md","raw":"---\ntitle: ArrayList源码阅读\ndate: 2019-03-18 21:01:48\ncategories: [Java]\ntags:\n    - Java\n---\n![Java](/images/java.jpg)\n\n> 记录学习回顾Java基础学习源码思想ArrayList，平时光顾着写业务代码基础细节都没有进行积累导致出去面试被人家一顿虐，只注重外功不注重内功是不行的。\n\n## ArrayList\n平时最常用的集合，特点有序查找效率高`线程不安全`底层是数组实现了动态数组的功能，实现了`RandomAccess`(快速随机访问)、`Cloneable`(克隆接口)、`Serializabele`(序列化)等接口。\n\n### 源码解析\n``` java\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * 默认的初始化容量 10\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 共享的静态空Object数组用于空实例\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 共享的静态空数组实例 用于最常用的new ArrayList() 无参实例使用\n     */\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 用于存放加入的数据数组 transient 关键字用于标记不需要序列化的字段\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * \n     * 整个数组的长度 size 即size()返回值\n     * @serial\n     */\n    private int size;\n\n    /**\n     * 有参数的构造函数 initialCapacity 用于给集合初始化容量\n     */\n    public ArrayList(int  initialCapacity) {\n    \t//初始化一个大小为 initialCapacity 的Object数组\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n        \t//如果初始容量为0使用静态 EMPTY_ELEMENTDATA 默认的空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     * 最常用的初始化方法\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * Collection 传入一个集合元素列表 E为泛型 指定传入的集合类型\n     */\n    public ArrayList(Collection<? extends E> c) {\n    \t//集合转化为数组 并初始化elementData\n        elementData = c.toArray();\n        //初始化size的值\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            // 由于传入的集合真实类型不一样所以需要调用 Arrays.copyOf 复制到一个新的Object[]数组中，以便可以存放任意类型\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     *修改当前容器值为实际元素的个数\n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n\n    /**\n     * 自行控制扩容大小 \n     * 如果扩容值大于默认值10 则按传入值进行扩容处理判断\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n    /**\n     * 计算最小容量\n     */\n    private static int calculateCapacity(Object[] elementData, int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            return Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        return minCapacity;\n    }\n\n    /**\n     * 根据minCapacity进行扩容\n     */\n    private void ensureCapacityInternal(int minCapacity) {\n        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    }\n\n    /**\n     * 判断是否需要进行扩容操作 如果扩容值大于实际的数组长度则进行扩容\n     */\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n\n    /**\n     * 能分配的最大的数组大小 Integer数值最大值(2^31-1)-8\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * 扩容的核心代码\n     * 每次扩容的大小为 当前数组长度+(数组长度/2)\n     * 如果扩容新容量小于需要扩容量值则覆盖新容量值\n     * 如果扩容新容量大于MAX_ARRAY_SIZE则直接使用Interger.MAX_VALUE否则使用MAX_ARRAY_SIZE\n     */\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n    /**\n     *当需要扩容大于MAX_ARRAY_SIEZ或小于0 返回合适值\n     */\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n}\n\n```","slug":"ArrayList源码阅读","published":1,"updated":"2020-11-18T03:20:58.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9680000jsud7ptlla1q","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>记录学习回顾Java基础学习源码思想ArrayList，平时光顾着写业务代码基础细节都没有进行积累导致出去面试被人家一顿虐，只注重外功不注重内功是不行的。</p>\n</blockquote>\n<h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><p>平时最常用的集合，特点有序查找效率高<code>线程不安全</code>底层是数组实现了动态数组的功能，实现了<code>RandomAccess</code>(快速随机访问)、<code>Cloneable</code>(克隆接口)、<code>Serializabele</code>(序列化)等接口。</p>\n<h3 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h3><pre><code class=\"hljs java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ArrayList</span>&lt;<span class=\"hljs-title\">E</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractList</span>&lt;<span class=\"hljs-title\">E</span>&gt;\n        <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">List</span>&lt;<span class=\"hljs-title\">E</span>&gt;, <span class=\"hljs-title\">RandomAccess</span>, <span class=\"hljs-title\">Cloneable</span>, <span class=\"hljs-title\">java</span>.<span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">Serializable</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> serialVersionUID = <span class=\"hljs-number\">8683452581122892189L</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 默认的初始化容量 10\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> DEFAULT_CAPACITY = <span class=\"hljs-number\">10</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 共享的静态空Object数组用于空实例\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;\n\n    <span class=\"hljs-comment\">/**\n     * 共享的静态空数组实例 用于最常用的new ArrayList() 无参实例使用\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;\n\n    <span class=\"hljs-comment\">/**\n     * 用于存放加入的数据数组 transient 关键字用于标记不需要序列化的字段\n     */</span>\n    <span class=\"hljs-keyword\">transient</span> Object[] elementData; <span class=\"hljs-comment\">// non-private to simplify nested class access</span>\n\n    <span class=\"hljs-comment\">/**\n     * \n     * 整个数组的长度 size 即size()返回值\n     * <span class=\"hljs-doctag\">@serial</span>\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> size;\n\n    <span class=\"hljs-comment\">/**\n     * 有参数的构造函数 initialCapacity 用于给集合初始化容量\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ArrayList</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>  initialCapacity)</span> </span>&#123;\n    \t<span class=\"hljs-comment\">//初始化一个大小为 initialCapacity 的Object数组</span>\n        <span class=\"hljs-keyword\">if</span> (initialCapacity &gt; <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">this</span>.elementData = <span class=\"hljs-keyword\">new</span> Object[initialCapacity];\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (initialCapacity == <span class=\"hljs-number\">0</span>) &#123;\n        \t<span class=\"hljs-comment\">//如果初始容量为0使用静态 EMPTY_ELEMENTDATA 默认的空数组</span>\n            <span class=\"hljs-keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Illegal Capacity: \"</span>+\n                                               initialCapacity);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 最常用的初始化方法\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ArrayList</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * Collection 传入一个集合元素列表 E为泛型 指定传入的集合类型\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ArrayList</span><span class=\"hljs-params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;\n    \t<span class=\"hljs-comment\">//集合转化为数组 并初始化elementData</span>\n        elementData = c.toArray();\n        <span class=\"hljs-comment\">//初始化size的值</span>\n        <span class=\"hljs-keyword\">if</span> ((size = elementData.length) != <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>\n            <span class=\"hljs-comment\">// 由于传入的集合真实类型不一样所以需要调用 Arrays.copyOf 复制到一个新的Object[]数组中，以便可以存放任意类型</span>\n            <span class=\"hljs-keyword\">if</span> (elementData.getClass() != Object[]<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n                <span class=\"hljs-title\">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            <span class=\"hljs-comment\">// replace with empty array.</span>\n            <span class=\"hljs-keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     *修改当前容器值为实际元素的个数\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">trimToSize</span><span class=\"hljs-params\">()</span> </span>&#123;\n        modCount++;\n        <span class=\"hljs-keyword\">if</span> (size &lt; elementData.length) &#123;\n            elementData = (size == <span class=\"hljs-number\">0</span>)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 自行控制扩容大小 \n     * 如果扩容值大于默认值10 则按传入值进行扩容处理判断\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ensureCapacity</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        <span class=\"hljs-keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            <span class=\"hljs-comment\">// any size if not default element table</span>\n            ? <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-comment\">// larger than default for default empty table. It's already</span>\n            <span class=\"hljs-comment\">// supposed to be at default size.</span>\n            : DEFAULT_CAPACITY;\n\n        <span class=\"hljs-keyword\">if</span> (minCapacity &gt; minExpand) &#123;\n            ensureExplicitCapacity(minCapacity);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 计算最小容量\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">calculateCapacity</span><span class=\"hljs-params\">(Object[] elementData, <span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;\n            <span class=\"hljs-keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> minCapacity;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 根据minCapacity进行扩容\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ensureCapacityInternal</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 判断是否需要进行扩容操作 如果扩容值大于实际的数组长度则进行扩容\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ensureExplicitCapacity</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        modCount++;\n\n        <span class=\"hljs-comment\">// overflow-conscious code</span>\n        <span class=\"hljs-keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"hljs-number\">0</span>)\n            grow(minCapacity);\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 能分配的最大的数组大小 Integer数值最大值(2^31-1)-8\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"hljs-number\">8</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 扩容的核心代码\n     * 每次扩容的大小为 当前数组长度+(数组长度/2)\n     * 如果扩容新容量小于需要扩容量值则覆盖新容量值\n     * 如果扩容新容量大于MAX_ARRAY_SIZE则直接使用Interger.MAX_VALUE否则使用MAX_ARRAY_SIZE\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">grow</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        <span class=\"hljs-comment\">// overflow-conscious code</span>\n        <span class=\"hljs-keyword\">int</span> oldCapacity = elementData.length;\n        <span class=\"hljs-keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"hljs-number\">0</span>)\n            newCapacity = minCapacity;\n        <span class=\"hljs-keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"hljs-number\">0</span>)\n            newCapacity = hugeCapacity(minCapacity);\n        <span class=\"hljs-comment\">// minCapacity is usually close to size, so this is a win:</span>\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     *当需要扩容大于MAX_ARRAY_SIEZ或小于0 返回合适值\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hugeCapacity</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (minCapacity &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// overflow</span>\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> OutOfMemoryError();\n        <span class=\"hljs-keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    &#125;\n&#125;</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>记录学习回顾Java基础学习源码思想ArrayList，平时光顾着写业务代码基础细节都没有进行积累导致出去面试被人家一顿虐，只注重外功不注重内功是不行的。</p>\n</blockquote>\n<h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><p>平时最常用的集合，特点有序查找效率高<code>线程不安全</code>底层是数组实现了动态数组的功能，实现了<code>RandomAccess</code>(快速随机访问)、<code>Cloneable</code>(克隆接口)、<code>Serializabele</code>(序列化)等接口。</p>\n<h3 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h3><pre><code class=\"hljs java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ArrayList</span>&lt;<span class=\"hljs-title\">E</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractList</span>&lt;<span class=\"hljs-title\">E</span>&gt;\n        <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">List</span>&lt;<span class=\"hljs-title\">E</span>&gt;, <span class=\"hljs-title\">RandomAccess</span>, <span class=\"hljs-title\">Cloneable</span>, <span class=\"hljs-title\">java</span>.<span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">Serializable</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> serialVersionUID = <span class=\"hljs-number\">8683452581122892189L</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 默认的初始化容量 10\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> DEFAULT_CAPACITY = <span class=\"hljs-number\">10</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 共享的静态空Object数组用于空实例\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;\n\n    <span class=\"hljs-comment\">/**\n     * 共享的静态空数组实例 用于最常用的new ArrayList() 无参实例使用\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;\n\n    <span class=\"hljs-comment\">/**\n     * 用于存放加入的数据数组 transient 关键字用于标记不需要序列化的字段\n     */</span>\n    <span class=\"hljs-keyword\">transient</span> Object[] elementData; <span class=\"hljs-comment\">// non-private to simplify nested class access</span>\n\n    <span class=\"hljs-comment\">/**\n     * \n     * 整个数组的长度 size 即size()返回值\n     * <span class=\"hljs-doctag\">@serial</span>\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> size;\n\n    <span class=\"hljs-comment\">/**\n     * 有参数的构造函数 initialCapacity 用于给集合初始化容量\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ArrayList</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>  initialCapacity)</span> </span>&#123;\n    \t<span class=\"hljs-comment\">//初始化一个大小为 initialCapacity 的Object数组</span>\n        <span class=\"hljs-keyword\">if</span> (initialCapacity &gt; <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">this</span>.elementData = <span class=\"hljs-keyword\">new</span> Object[initialCapacity];\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (initialCapacity == <span class=\"hljs-number\">0</span>) &#123;\n        \t<span class=\"hljs-comment\">//如果初始容量为0使用静态 EMPTY_ELEMENTDATA 默认的空数组</span>\n            <span class=\"hljs-keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Illegal Capacity: \"</span>+\n                                               initialCapacity);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 最常用的初始化方法\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ArrayList</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * Collection 传入一个集合元素列表 E为泛型 指定传入的集合类型\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ArrayList</span><span class=\"hljs-params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;\n    \t<span class=\"hljs-comment\">//集合转化为数组 并初始化elementData</span>\n        elementData = c.toArray();\n        <span class=\"hljs-comment\">//初始化size的值</span>\n        <span class=\"hljs-keyword\">if</span> ((size = elementData.length) != <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>\n            <span class=\"hljs-comment\">// 由于传入的集合真实类型不一样所以需要调用 Arrays.copyOf 复制到一个新的Object[]数组中，以便可以存放任意类型</span>\n            <span class=\"hljs-keyword\">if</span> (elementData.getClass() != Object[]<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n                <span class=\"hljs-title\">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            <span class=\"hljs-comment\">// replace with empty array.</span>\n            <span class=\"hljs-keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     *修改当前容器值为实际元素的个数\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">trimToSize</span><span class=\"hljs-params\">()</span> </span>&#123;\n        modCount++;\n        <span class=\"hljs-keyword\">if</span> (size &lt; elementData.length) &#123;\n            elementData = (size == <span class=\"hljs-number\">0</span>)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 自行控制扩容大小 \n     * 如果扩容值大于默认值10 则按传入值进行扩容处理判断\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ensureCapacity</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        <span class=\"hljs-keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            <span class=\"hljs-comment\">// any size if not default element table</span>\n            ? <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-comment\">// larger than default for default empty table. It's already</span>\n            <span class=\"hljs-comment\">// supposed to be at default size.</span>\n            : DEFAULT_CAPACITY;\n\n        <span class=\"hljs-keyword\">if</span> (minCapacity &gt; minExpand) &#123;\n            ensureExplicitCapacity(minCapacity);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 计算最小容量\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">calculateCapacity</span><span class=\"hljs-params\">(Object[] elementData, <span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;\n            <span class=\"hljs-keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> minCapacity;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 根据minCapacity进行扩容\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ensureCapacityInternal</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 判断是否需要进行扩容操作 如果扩容值大于实际的数组长度则进行扩容\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ensureExplicitCapacity</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        modCount++;\n\n        <span class=\"hljs-comment\">// overflow-conscious code</span>\n        <span class=\"hljs-keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"hljs-number\">0</span>)\n            grow(minCapacity);\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 能分配的最大的数组大小 Integer数值最大值(2^31-1)-8\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"hljs-number\">8</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 扩容的核心代码\n     * 每次扩容的大小为 当前数组长度+(数组长度/2)\n     * 如果扩容新容量小于需要扩容量值则覆盖新容量值\n     * 如果扩容新容量大于MAX_ARRAY_SIZE则直接使用Interger.MAX_VALUE否则使用MAX_ARRAY_SIZE\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">grow</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        <span class=\"hljs-comment\">// overflow-conscious code</span>\n        <span class=\"hljs-keyword\">int</span> oldCapacity = elementData.length;\n        <span class=\"hljs-keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"hljs-number\">0</span>)\n            newCapacity = minCapacity;\n        <span class=\"hljs-keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"hljs-number\">0</span>)\n            newCapacity = hugeCapacity(minCapacity);\n        <span class=\"hljs-comment\">// minCapacity is usually close to size, so this is a win:</span>\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     *当需要扩容大于MAX_ARRAY_SIEZ或小于0 返回合适值\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hugeCapacity</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> minCapacity)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (minCapacity &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// overflow</span>\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> OutOfMemoryError();\n        <span class=\"hljs-keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    &#125;\n&#125;</code></pre>"},{"title":"CentOs FireWall 脚本","date":"2018-07-19T06:20:43.000Z","_content":"\n![Firewalld](http://www.tecmint.com/wp-content/uploads/2016/01/Enable-Disable-Iptables-FirewallD.png)\n\n>经过之前自己搭建了Shadowsocks接触Linux慢慢想深入学习下一些常用Shell，之前在配置Shadowsocks遇到启动服务但是PC客户端连接没有网络，通过查阅一些教程发现Centos7默认开启了防火墙Firewall导致如果没有开放Shadowsocks的相关端口是无法访问的，现在记录下Firewall的一些相关命令\n\n##  1.Firewalld 简介\nCentOs7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念，有图形界面和工具界面，由于我在服务器上使用，图形界面请参照官方文档，本文以字符界面做介绍，firewalld的字符界面管理工具是 firewall-cmd 默认配置文件有两个：/usr/lib/firewalld/ （用户配置地址） 和 /etc/firewalld/ （系统配置，尽量不要修改）\n\n## 2.Zone 概念\nFirewall 能将不同的网络连接归类到不同的信任级别，Zone 提供了以下几个级别\n* drop: 丢弃所有进入的包，而不给出任何响应\n* block: 拒绝所有外部发起的连接，允许内部发起的连接\n* public: 允许指定的进入连接\n* external: 同上，对伪装的进入连接，一般用于路由转发\n* dmz: 允许受限制的进入连接\n* work: 允许受信任的计算机被限制的进入连接，类似 workgroup\n* home: 同上，类似 homegroup\n* internal: 同上，范围针对所有互联网用户\n* trusted: 信任所有连接\n\n## 3.过滤规则\n过滤规则的优先级遵循如下顺序source>interface>firewalld.conf\n* source: 根据源地址过滤\n* interface: 根据网卡过滤\n* service: 根据服务名过滤\n* port: 根据端口过滤\n* icmp-block: icmp 报文过滤，按照 icmp 类型配置\n* masquerade: ip 地址伪装\n* forward-port: 端口转发\n* rule: 自定义规则\n\n## 4.使用方法\nfirewall-cmd [指令] \n--zone 作用域  \n--permanent  永久修改  \n--reload 重载生效 \n--timeout=seconds 持续时间，一般用于调试            \n          \n__使用实例__:\n``` bash\n#查看开放的Zone\nfirewall-cmd --get-active-zones\n#查看firewalld状态\nfirewall-cmd --state\n#查看firewalld开放的端口\nfirewall-cmd --zone=dmz --list-ports\n#重新加载配置 (无需重启)\nfirewall-cmd --reload\n#重新加载配置 (重启服务器加载)\nfirewall-cmd --complete-reload \n#添加一个端口允许访问 (临时添加)\nfirewall-cmd --zone=dwz --add-port=8080/tcp\n#添加一个端口允许访问 (永久添加)\nfirewall-cmd --zone=dwz --add-port=8080/tcp --permanent\n#添加一个端口允许访问 (持续300秒)\nfirewall-cmd --zone=dwz --add-port=8080/tcp --timeout=300\n#添加一个服务允许访问\nfirewall-cmd --zone=dwz --add-service=smtp\n#启用firewalld\nsystemctl start firewalld\n#停止firewalld\nsystemctl stop firewalld\n#重启firewalld\nsystemctrl restart firewalld\n#禁用firewalld\nsystemctrl disable firewalld\n```\n","source":"_posts/CentOs-Firewalld-脚本.md","raw":"---\ntitle: CentOs FireWall 脚本\ndate: 2018-07-19 14:20:43\ncategories: [Linux]\ntags:\n    - Linux\n---\n\n![Firewalld](http://www.tecmint.com/wp-content/uploads/2016/01/Enable-Disable-Iptables-FirewallD.png)\n\n>经过之前自己搭建了Shadowsocks接触Linux慢慢想深入学习下一些常用Shell，之前在配置Shadowsocks遇到启动服务但是PC客户端连接没有网络，通过查阅一些教程发现Centos7默认开启了防火墙Firewall导致如果没有开放Shadowsocks的相关端口是无法访问的，现在记录下Firewall的一些相关命令\n\n##  1.Firewalld 简介\nCentOs7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念，有图形界面和工具界面，由于我在服务器上使用，图形界面请参照官方文档，本文以字符界面做介绍，firewalld的字符界面管理工具是 firewall-cmd 默认配置文件有两个：/usr/lib/firewalld/ （用户配置地址） 和 /etc/firewalld/ （系统配置，尽量不要修改）\n\n## 2.Zone 概念\nFirewall 能将不同的网络连接归类到不同的信任级别，Zone 提供了以下几个级别\n* drop: 丢弃所有进入的包，而不给出任何响应\n* block: 拒绝所有外部发起的连接，允许内部发起的连接\n* public: 允许指定的进入连接\n* external: 同上，对伪装的进入连接，一般用于路由转发\n* dmz: 允许受限制的进入连接\n* work: 允许受信任的计算机被限制的进入连接，类似 workgroup\n* home: 同上，类似 homegroup\n* internal: 同上，范围针对所有互联网用户\n* trusted: 信任所有连接\n\n## 3.过滤规则\n过滤规则的优先级遵循如下顺序source>interface>firewalld.conf\n* source: 根据源地址过滤\n* interface: 根据网卡过滤\n* service: 根据服务名过滤\n* port: 根据端口过滤\n* icmp-block: icmp 报文过滤，按照 icmp 类型配置\n* masquerade: ip 地址伪装\n* forward-port: 端口转发\n* rule: 自定义规则\n\n## 4.使用方法\nfirewall-cmd [指令] \n--zone 作用域  \n--permanent  永久修改  \n--reload 重载生效 \n--timeout=seconds 持续时间，一般用于调试            \n          \n__使用实例__:\n``` bash\n#查看开放的Zone\nfirewall-cmd --get-active-zones\n#查看firewalld状态\nfirewall-cmd --state\n#查看firewalld开放的端口\nfirewall-cmd --zone=dmz --list-ports\n#重新加载配置 (无需重启)\nfirewall-cmd --reload\n#重新加载配置 (重启服务器加载)\nfirewall-cmd --complete-reload \n#添加一个端口允许访问 (临时添加)\nfirewall-cmd --zone=dwz --add-port=8080/tcp\n#添加一个端口允许访问 (永久添加)\nfirewall-cmd --zone=dwz --add-port=8080/tcp --permanent\n#添加一个端口允许访问 (持续300秒)\nfirewall-cmd --zone=dwz --add-port=8080/tcp --timeout=300\n#添加一个服务允许访问\nfirewall-cmd --zone=dwz --add-service=smtp\n#启用firewalld\nsystemctl start firewalld\n#停止firewalld\nsystemctl stop firewalld\n#重启firewalld\nsystemctrl restart firewalld\n#禁用firewalld\nsystemctrl disable firewalld\n```\n","slug":"CentOs-Firewalld-脚本","published":1,"updated":"2020-08-10T01:48:44.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc96e0001jsud8ov3wc58","content":"<p><img src=\"http://www.tecmint.com/wp-content/uploads/2016/01/Enable-Disable-Iptables-FirewallD.png\" srcset=\"/img/loading.gif\" alt=\"Firewalld\"></p>\n<blockquote>\n<p>经过之前自己搭建了Shadowsocks接触Linux慢慢想深入学习下一些常用Shell，之前在配置Shadowsocks遇到启动服务但是PC客户端连接没有网络，通过查阅一些教程发现Centos7默认开启了防火墙Firewall导致如果没有开放Shadowsocks的相关端口是无法访问的，现在记录下Firewall的一些相关命令</p>\n</blockquote>\n<h2 id=\"1-Firewalld-简介\"><a href=\"#1-Firewalld-简介\" class=\"headerlink\" title=\"1.Firewalld 简介\"></a>1.Firewalld 简介</h2><p>CentOs7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念，有图形界面和工具界面，由于我在服务器上使用，图形界面请参照官方文档，本文以字符界面做介绍，firewalld的字符界面管理工具是 firewall-cmd 默认配置文件有两个：/usr/lib/firewalld/ （用户配置地址） 和 /etc/firewalld/ （系统配置，尽量不要修改）</p>\n<h2 id=\"2-Zone-概念\"><a href=\"#2-Zone-概念\" class=\"headerlink\" title=\"2.Zone 概念\"></a>2.Zone 概念</h2><p>Firewall 能将不同的网络连接归类到不同的信任级别，Zone 提供了以下几个级别</p>\n<ul>\n<li>drop: 丢弃所有进入的包，而不给出任何响应</li>\n<li>block: 拒绝所有外部发起的连接，允许内部发起的连接</li>\n<li>public: 允许指定的进入连接</li>\n<li>external: 同上，对伪装的进入连接，一般用于路由转发</li>\n<li>dmz: 允许受限制的进入连接</li>\n<li>work: 允许受信任的计算机被限制的进入连接，类似 workgroup</li>\n<li>home: 同上，类似 homegroup</li>\n<li>internal: 同上，范围针对所有互联网用户</li>\n<li>trusted: 信任所有连接</li>\n</ul>\n<h2 id=\"3-过滤规则\"><a href=\"#3-过滤规则\" class=\"headerlink\" title=\"3.过滤规则\"></a>3.过滤规则</h2><p>过滤规则的优先级遵循如下顺序source&gt;interface&gt;firewalld.conf</p>\n<ul>\n<li>source: 根据源地址过滤</li>\n<li>interface: 根据网卡过滤</li>\n<li>service: 根据服务名过滤</li>\n<li>port: 根据端口过滤</li>\n<li>icmp-block: icmp 报文过滤，按照 icmp 类型配置</li>\n<li>masquerade: ip 地址伪装</li>\n<li>forward-port: 端口转发</li>\n<li>rule: 自定义规则</li>\n</ul>\n<h2 id=\"4-使用方法\"><a href=\"#4-使用方法\" class=\"headerlink\" title=\"4.使用方法\"></a>4.使用方法</h2><p>firewall-cmd [指令]<br>–zone 作用域<br>–permanent  永久修改<br>–reload 重载生效<br>–timeout=seconds 持续时间，一般用于调试            </p>\n<p><strong>使用实例</strong>:<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#查看开放的Zone</span>\nfirewall-cmd --get-active-zones\n<span class=\"hljs-comment\">#查看firewalld状态</span>\nfirewall-cmd --state\n<span class=\"hljs-comment\">#查看firewalld开放的端口</span>\nfirewall-cmd --zone=dmz --list-ports\n<span class=\"hljs-comment\">#重新加载配置 (无需重启)</span>\nfirewall-cmd --reload\n<span class=\"hljs-comment\">#重新加载配置 (重启服务器加载)</span>\nfirewall-cmd --complete-reload \n<span class=\"hljs-comment\">#添加一个端口允许访问 (临时添加)</span>\nfirewall-cmd --zone=dwz --add-port=8080/tcp\n<span class=\"hljs-comment\">#添加一个端口允许访问 (永久添加)</span>\nfirewall-cmd --zone=dwz --add-port=8080/tcp --permanent\n<span class=\"hljs-comment\">#添加一个端口允许访问 (持续300秒)</span>\nfirewall-cmd --zone=dwz --add-port=8080/tcp --timeout=300\n<span class=\"hljs-comment\">#添加一个服务允许访问</span>\nfirewall-cmd --zone=dwz --add-service=smtp\n<span class=\"hljs-comment\">#启用firewalld</span>\nsystemctl start firewalld\n<span class=\"hljs-comment\">#停止firewalld</span>\nsystemctl stop firewalld\n<span class=\"hljs-comment\">#重启firewalld</span>\nsystemctrl restart firewalld\n<span class=\"hljs-comment\">#禁用firewalld</span>\nsystemctrl <span class=\"hljs-built_in\">disable</span> firewalld</code></pre></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.tecmint.com/wp-content/uploads/2016/01/Enable-Disable-Iptables-FirewallD.png\" srcset=\"/img/loading.gif\" alt=\"Firewalld\"></p>\n<blockquote>\n<p>经过之前自己搭建了Shadowsocks接触Linux慢慢想深入学习下一些常用Shell，之前在配置Shadowsocks遇到启动服务但是PC客户端连接没有网络，通过查阅一些教程发现Centos7默认开启了防火墙Firewall导致如果没有开放Shadowsocks的相关端口是无法访问的，现在记录下Firewall的一些相关命令</p>\n</blockquote>\n<h2 id=\"1-Firewalld-简介\"><a href=\"#1-Firewalld-简介\" class=\"headerlink\" title=\"1.Firewalld 简介\"></a>1.Firewalld 简介</h2><p>CentOs7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念，有图形界面和工具界面，由于我在服务器上使用，图形界面请参照官方文档，本文以字符界面做介绍，firewalld的字符界面管理工具是 firewall-cmd 默认配置文件有两个：/usr/lib/firewalld/ （用户配置地址） 和 /etc/firewalld/ （系统配置，尽量不要修改）</p>\n<h2 id=\"2-Zone-概念\"><a href=\"#2-Zone-概念\" class=\"headerlink\" title=\"2.Zone 概念\"></a>2.Zone 概念</h2><p>Firewall 能将不同的网络连接归类到不同的信任级别，Zone 提供了以下几个级别</p>\n<ul>\n<li>drop: 丢弃所有进入的包，而不给出任何响应</li>\n<li>block: 拒绝所有外部发起的连接，允许内部发起的连接</li>\n<li>public: 允许指定的进入连接</li>\n<li>external: 同上，对伪装的进入连接，一般用于路由转发</li>\n<li>dmz: 允许受限制的进入连接</li>\n<li>work: 允许受信任的计算机被限制的进入连接，类似 workgroup</li>\n<li>home: 同上，类似 homegroup</li>\n<li>internal: 同上，范围针对所有互联网用户</li>\n<li>trusted: 信任所有连接</li>\n</ul>\n<h2 id=\"3-过滤规则\"><a href=\"#3-过滤规则\" class=\"headerlink\" title=\"3.过滤规则\"></a>3.过滤规则</h2><p>过滤规则的优先级遵循如下顺序source&gt;interface&gt;firewalld.conf</p>\n<ul>\n<li>source: 根据源地址过滤</li>\n<li>interface: 根据网卡过滤</li>\n<li>service: 根据服务名过滤</li>\n<li>port: 根据端口过滤</li>\n<li>icmp-block: icmp 报文过滤，按照 icmp 类型配置</li>\n<li>masquerade: ip 地址伪装</li>\n<li>forward-port: 端口转发</li>\n<li>rule: 自定义规则</li>\n</ul>\n<h2 id=\"4-使用方法\"><a href=\"#4-使用方法\" class=\"headerlink\" title=\"4.使用方法\"></a>4.使用方法</h2><p>firewall-cmd [指令]<br>–zone 作用域<br>–permanent  永久修改<br>–reload 重载生效<br>–timeout=seconds 持续时间，一般用于调试            </p>\n<p><strong>使用实例</strong>:<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#查看开放的Zone</span>\nfirewall-cmd --get-active-zones\n<span class=\"hljs-comment\">#查看firewalld状态</span>\nfirewall-cmd --state\n<span class=\"hljs-comment\">#查看firewalld开放的端口</span>\nfirewall-cmd --zone=dmz --list-ports\n<span class=\"hljs-comment\">#重新加载配置 (无需重启)</span>\nfirewall-cmd --reload\n<span class=\"hljs-comment\">#重新加载配置 (重启服务器加载)</span>\nfirewall-cmd --complete-reload \n<span class=\"hljs-comment\">#添加一个端口允许访问 (临时添加)</span>\nfirewall-cmd --zone=dwz --add-port=8080/tcp\n<span class=\"hljs-comment\">#添加一个端口允许访问 (永久添加)</span>\nfirewall-cmd --zone=dwz --add-port=8080/tcp --permanent\n<span class=\"hljs-comment\">#添加一个端口允许访问 (持续300秒)</span>\nfirewall-cmd --zone=dwz --add-port=8080/tcp --timeout=300\n<span class=\"hljs-comment\">#添加一个服务允许访问</span>\nfirewall-cmd --zone=dwz --add-service=smtp\n<span class=\"hljs-comment\">#启用firewalld</span>\nsystemctl start firewalld\n<span class=\"hljs-comment\">#停止firewalld</span>\nsystemctl stop firewalld\n<span class=\"hljs-comment\">#重启firewalld</span>\nsystemctrl restart firewalld\n<span class=\"hljs-comment\">#禁用firewalld</span>\nsystemctrl <span class=\"hljs-built_in\">disable</span> firewalld</code></pre></p>\n"},{"title":"Docker 环境搭建","date":"2018-08-20T06:11:30.000Z","_content":"\n>开发->部署测试->发布正式 在整体流程中每个人的开发环境可能各不相同、编译环境、运行环境。单机服务调整控制环境版本等可以保证发布一致性，但是如果当业务越来越庞大集群处理时需要部署多台机器时，可能每台机器的大大小小差异都会导致发布失败，处理起来非常麻烦。docker虚拟化来处理能保证发布环境一致性，可移植。通过docker 镜像你可以在任何版本linux服务器上进行发布。每个镜像就相当于个一个系统相互不影响独立环境。\n\n\n![docker](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018020901.png)\n\n## 1.Docker 介绍\nDocker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。\n\nDocker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。\n\n总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。\n\n## 2.Docker 安装\n我的VPS用的 Centos 7 那就用本版本记录搭建过程，docker的版本用CE社区版\n``` bash\n#下载yum-utils工具用于管理yum-config-manager可以配置源\nyum install yum-utils\n#添加docker-ce源\nyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n#查询docker-ce版本\nyum list docker-ce --showduplicates | sort -r \n#指定安装18.06.0 版本\nyum install dock-ce-18.06.0.ce\n```\n安装docker，默认是安装最高版本测试可以用，但是生产环境为了稳定尽量指定版本(stable稳定版)\n\n## 3.Docker 常用命令\n\n``` bash\n#启动docker服务\nsystemctl start docker\n#自动启动docker服务\nsystemctl enable docker\n```\n安装docker,默认是安装最高版本测试可以用，但是生产环境为了稳定尽量指定版本(`stable稳定版`)\n\n## 3.Docker 镜像 容器\n#### 镜像查询拉取\n安装 docker 完毕，可以尝试安装一个镜像并运行，搜索镜像使用 `docker search [镜像名称]`,搜索的镜像 `OFFICAL` 标识的为官方镜像，其余的都是非官方人员自行构建的镜像并上传库共享。\n![docker-search-alpine](/images/docker-search.png)\n使用 `docker pull alpine` 下载拉取alpine镜像,然后使用`docker images` 查看镜像已有镜像，这里以`alpine`为模板\n![docker-images](/images/docker-images.png)\n\n#### 运行容器\n基于alpine镜像启动一个容器 \n``` bash\ndocker run -itd -p  8081:8081 --name myTest  alpine\n```\n- -i：以交互模式运行容器，通常与 -t 同时使用\n- -d: 后台运行容器，并返回容器ID\n- -t : 为容器重新分配一个伪输入终端，通常与 -i 同时使用\n- -p: 端口映射，格式为：主机(宿主)端口:容器端口 8080端口的访问转发到容器的8080端口上\n- --name: 为容器指定一个容器名\n- alpine：这是指用 `alpine` 镜像为基础来启动容器。\n\n启动完毕后 `docker ps` 查看正在运行的容器,  `docker ps -a` 查看容器。\n\n#### 容器操作\n\n``` bash\n##### myTest 为容器名称 ##### \n#进行容器\ndocker attach myTest\n#容器中执行脚本返回结果 (由于是alpine所以执行的)\ndocker exec -it myTest /bin/sh\n#删除容器\ndocker rm myTest\n#启动已有容器\ndocker start myTest\n#停止容器\ndocker stop myTest\n```\n在容器中退出容器时需要注意的是通过`exit`返回宿主主机会导致容器直接停止并不是我们想要的结果，官方给出的退出容器并使其在后台继续运行使用 `ctrl+p+q` 安全退出不影响容器运行。 \n\n## 4.DockerFile\nDockerfile 是一个文本文件，其内包含了一条条的指令`(Instruction)`，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。我们可以根据实际的开发需求通过`dockerfile`来自定义镜像，JUST DO IT！\n\n##### FROM 指令\nFROM <image\\>:<tag\\> 相当于建造一个大楼地基的选择，选择不同的地基来搭建不一样的大楼。\n- 操作系统类基础搭建例如 `ubuntu`、`dabin`、`centos`\n- 开发语言作为基础搭建例如`java`、`nodejs`、`python` \n- 服务类镜像作为基础 `oralce`、`mysql`、`nginx`、`tomcat`\n- 自定义混合类作为基础在其他自定义环境镜像基础上搭建\n\n所有的镜像地基都可以从docker库中拉取，选择合理的基础镜像可以让你更快的去构建你的镜像，省心省力。\n\n#### RUN 指令\nRUN 就像是执行shell指令，常常用于更新安装需要的生产软件服务等。RUN有2种执行方式\n- shell 格式： RUN <命令> ，就像直接在命令行中输入的命令一样：`RUN apt-get --update`\n- exec 格式： RUN [\"可执行文件\", \"参数1\", \"参数2\"]：`RUN [\"apt-get\",\"--update\"]`\n\n\n__注意__：多行命令不要写多个`RUN`，原因是`Dockerfile`中每一个指令都会建立一层.多少个`RUN`就构建了多少层镜像，会造成镜像的臃肿多层，不仅仅增加了构件部署的时间，还容易出错。`RUN`书写时的换行符是`\\`，记得下载压缩软件操作完毕后`rm`不必要的软件压缩包和缓存让镜像更精简。\n\n#### CMD 指令\n`CMD` 指令的格式和 `RUN` 相似也是两种格式，`CMD` 执行脚本在`dockerfile`只能存在一条，多条只执行最后一条，当有多个时只会执行最后一个，一般用于执行开启某些服务 `tomcat`、`oracle`、`nginx`等。\n\n#### ENTRYPOINT 指令\n`ENTRYPOINT` 执行脚本在`dockerfile`只能存在一条，多条只执行最后一条，容器启动后执行且不会被`docker run`提供的参数覆盖。\n\n### RUN  ENTRYPOINT  CMD 小结\n- `CMD` 和 `ENTRYPOINT` 推荐使用`Exec`格式，因为指令可读性更强，更容易理解。`RUN` 则两种格式都可以。\n- `RUN`用来执行脚本构建基础镜像，`CMD` `ENTRYPOINT` 用来构建完镜像容器启动后执行一些操作。\n- `CMD` 会被`docker run` 后的执行脚本覆盖不执行，`ENTRYPOINT` 则不会被覆盖始终会被执行，如果需要覆盖运行需要`–entrypoint`参数。\n- `ENTRYPOINT` 和 `CMD` 同时存在时谁在最后谁能执行，`CMD` 可作为 `ENTRYPOINT` 的执行参数灵活配合使用。\n\n#### COPY 指令\n用于从上下文路径复制文件到容器目标路径中，`copy package.json /usr/src/app/` 把`package.json`复制到容器 `/usr/src/app`路径下\n- COPY <源路径>... <目标路径>\n- COPY [\"<源路径>\"，......，\"<目标路径>\"]  `......`代表若干源路径\n\n#### ADD 指令\n`ADD` 指令和 `COPY` 的格式和性质基本一致，是在 `COPY` 基础上增加了一些功能。比如`<源路径>`可以是一个`URL`，这种情况下 Docker 引擎会试图去下载这个链接的文件放到`<目标路径>`去。如果`<源路径>`为一个` tar` 压缩文件的话，压缩格式为`gzip` , `bzip2` 以及 `xz` 的情况下，`ADD`指令将会自动解压缩这个压缩文件到`<目标路径>`去。`ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢，`ADD` 还包含了一些复杂的的功能其行为也不一定清晰，所以官方推荐使用`COPY`来进行文件的复制。\n\n#### ENV 指令\n`ENV` 用于设置环境变量在后续的指令可以直接引用\n- ENV <key\\> <value\\>\n- ENV <key1\\>=<value1\\> <key2\\>=<value2\\>...\n\n##### Docker build构建\n所有的脚本编写完毕使用`docker bulid` 对 Dockerfile 进行构建，详细的命令如下\n``` bash\n\n```\n\n``` bash\n#基于镜像 这里使用alpine 主要是体积小构建速度更快\nFROM alpine\n#构建维修者 \nMAINTAINER 285635652@qq.com\nRUN apt-get update / && apt-get java\n```\n\n\n\n","source":"_posts/Docker环境搭建.md","raw":"---\ntitle: Docker 环境搭建\ndate: 2018-08-20 14:11:30\ncategories: [技术]\ntags:\n    - Java\n---\n\n>开发->部署测试->发布正式 在整体流程中每个人的开发环境可能各不相同、编译环境、运行环境。单机服务调整控制环境版本等可以保证发布一致性，但是如果当业务越来越庞大集群处理时需要部署多台机器时，可能每台机器的大大小小差异都会导致发布失败，处理起来非常麻烦。docker虚拟化来处理能保证发布环境一致性，可移植。通过docker 镜像你可以在任何版本linux服务器上进行发布。每个镜像就相当于个一个系统相互不影响独立环境。\n\n\n![docker](http://www.ruanyifeng.com/blogimg/asset/2018/bg2018020901.png)\n\n## 1.Docker 介绍\nDocker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。\n\nDocker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。\n\n总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。\n\n## 2.Docker 安装\n我的VPS用的 Centos 7 那就用本版本记录搭建过程，docker的版本用CE社区版\n``` bash\n#下载yum-utils工具用于管理yum-config-manager可以配置源\nyum install yum-utils\n#添加docker-ce源\nyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n#查询docker-ce版本\nyum list docker-ce --showduplicates | sort -r \n#指定安装18.06.0 版本\nyum install dock-ce-18.06.0.ce\n```\n安装docker，默认是安装最高版本测试可以用，但是生产环境为了稳定尽量指定版本(stable稳定版)\n\n## 3.Docker 常用命令\n\n``` bash\n#启动docker服务\nsystemctl start docker\n#自动启动docker服务\nsystemctl enable docker\n```\n安装docker,默认是安装最高版本测试可以用，但是生产环境为了稳定尽量指定版本(`stable稳定版`)\n\n## 3.Docker 镜像 容器\n#### 镜像查询拉取\n安装 docker 完毕，可以尝试安装一个镜像并运行，搜索镜像使用 `docker search [镜像名称]`,搜索的镜像 `OFFICAL` 标识的为官方镜像，其余的都是非官方人员自行构建的镜像并上传库共享。\n![docker-search-alpine](/images/docker-search.png)\n使用 `docker pull alpine` 下载拉取alpine镜像,然后使用`docker images` 查看镜像已有镜像，这里以`alpine`为模板\n![docker-images](/images/docker-images.png)\n\n#### 运行容器\n基于alpine镜像启动一个容器 \n``` bash\ndocker run -itd -p  8081:8081 --name myTest  alpine\n```\n- -i：以交互模式运行容器，通常与 -t 同时使用\n- -d: 后台运行容器，并返回容器ID\n- -t : 为容器重新分配一个伪输入终端，通常与 -i 同时使用\n- -p: 端口映射，格式为：主机(宿主)端口:容器端口 8080端口的访问转发到容器的8080端口上\n- --name: 为容器指定一个容器名\n- alpine：这是指用 `alpine` 镜像为基础来启动容器。\n\n启动完毕后 `docker ps` 查看正在运行的容器,  `docker ps -a` 查看容器。\n\n#### 容器操作\n\n``` bash\n##### myTest 为容器名称 ##### \n#进行容器\ndocker attach myTest\n#容器中执行脚本返回结果 (由于是alpine所以执行的)\ndocker exec -it myTest /bin/sh\n#删除容器\ndocker rm myTest\n#启动已有容器\ndocker start myTest\n#停止容器\ndocker stop myTest\n```\n在容器中退出容器时需要注意的是通过`exit`返回宿主主机会导致容器直接停止并不是我们想要的结果，官方给出的退出容器并使其在后台继续运行使用 `ctrl+p+q` 安全退出不影响容器运行。 \n\n## 4.DockerFile\nDockerfile 是一个文本文件，其内包含了一条条的指令`(Instruction)`，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。我们可以根据实际的开发需求通过`dockerfile`来自定义镜像，JUST DO IT！\n\n##### FROM 指令\nFROM <image\\>:<tag\\> 相当于建造一个大楼地基的选择，选择不同的地基来搭建不一样的大楼。\n- 操作系统类基础搭建例如 `ubuntu`、`dabin`、`centos`\n- 开发语言作为基础搭建例如`java`、`nodejs`、`python` \n- 服务类镜像作为基础 `oralce`、`mysql`、`nginx`、`tomcat`\n- 自定义混合类作为基础在其他自定义环境镜像基础上搭建\n\n所有的镜像地基都可以从docker库中拉取，选择合理的基础镜像可以让你更快的去构建你的镜像，省心省力。\n\n#### RUN 指令\nRUN 就像是执行shell指令，常常用于更新安装需要的生产软件服务等。RUN有2种执行方式\n- shell 格式： RUN <命令> ，就像直接在命令行中输入的命令一样：`RUN apt-get --update`\n- exec 格式： RUN [\"可执行文件\", \"参数1\", \"参数2\"]：`RUN [\"apt-get\",\"--update\"]`\n\n\n__注意__：多行命令不要写多个`RUN`，原因是`Dockerfile`中每一个指令都会建立一层.多少个`RUN`就构建了多少层镜像，会造成镜像的臃肿多层，不仅仅增加了构件部署的时间，还容易出错。`RUN`书写时的换行符是`\\`，记得下载压缩软件操作完毕后`rm`不必要的软件压缩包和缓存让镜像更精简。\n\n#### CMD 指令\n`CMD` 指令的格式和 `RUN` 相似也是两种格式，`CMD` 执行脚本在`dockerfile`只能存在一条，多条只执行最后一条，当有多个时只会执行最后一个，一般用于执行开启某些服务 `tomcat`、`oracle`、`nginx`等。\n\n#### ENTRYPOINT 指令\n`ENTRYPOINT` 执行脚本在`dockerfile`只能存在一条，多条只执行最后一条，容器启动后执行且不会被`docker run`提供的参数覆盖。\n\n### RUN  ENTRYPOINT  CMD 小结\n- `CMD` 和 `ENTRYPOINT` 推荐使用`Exec`格式，因为指令可读性更强，更容易理解。`RUN` 则两种格式都可以。\n- `RUN`用来执行脚本构建基础镜像，`CMD` `ENTRYPOINT` 用来构建完镜像容器启动后执行一些操作。\n- `CMD` 会被`docker run` 后的执行脚本覆盖不执行，`ENTRYPOINT` 则不会被覆盖始终会被执行，如果需要覆盖运行需要`–entrypoint`参数。\n- `ENTRYPOINT` 和 `CMD` 同时存在时谁在最后谁能执行，`CMD` 可作为 `ENTRYPOINT` 的执行参数灵活配合使用。\n\n#### COPY 指令\n用于从上下文路径复制文件到容器目标路径中，`copy package.json /usr/src/app/` 把`package.json`复制到容器 `/usr/src/app`路径下\n- COPY <源路径>... <目标路径>\n- COPY [\"<源路径>\"，......，\"<目标路径>\"]  `......`代表若干源路径\n\n#### ADD 指令\n`ADD` 指令和 `COPY` 的格式和性质基本一致，是在 `COPY` 基础上增加了一些功能。比如`<源路径>`可以是一个`URL`，这种情况下 Docker 引擎会试图去下载这个链接的文件放到`<目标路径>`去。如果`<源路径>`为一个` tar` 压缩文件的话，压缩格式为`gzip` , `bzip2` 以及 `xz` 的情况下，`ADD`指令将会自动解压缩这个压缩文件到`<目标路径>`去。`ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢，`ADD` 还包含了一些复杂的的功能其行为也不一定清晰，所以官方推荐使用`COPY`来进行文件的复制。\n\n#### ENV 指令\n`ENV` 用于设置环境变量在后续的指令可以直接引用\n- ENV <key\\> <value\\>\n- ENV <key1\\>=<value1\\> <key2\\>=<value2\\>...\n\n##### Docker build构建\n所有的脚本编写完毕使用`docker bulid` 对 Dockerfile 进行构建，详细的命令如下\n``` bash\n\n```\n\n``` bash\n#基于镜像 这里使用alpine 主要是体积小构建速度更快\nFROM alpine\n#构建维修者 \nMAINTAINER 285635652@qq.com\nRUN apt-get update / && apt-get java\n```\n\n\n\n","slug":"Docker环境搭建","published":1,"updated":"2020-11-19T02:09:20.535Z","_id":"ckhmyc96k0004jsudy8u8fkfx","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>开发-&gt;部署测试-&gt;发布正式 在整体流程中每个人的开发环境可能各不相同、编译环境、运行环境。单机服务调整控制环境版本等可以保证发布一致性，但是如果当业务越来越庞大集群处理时需要部署多台机器时，可能每台机器的大大小小差异都会导致发布失败，处理起来非常麻烦。docker虚拟化来处理能保证发布环境一致性，可移植。通过docker 镜像你可以在任何版本linux服务器上进行发布。每个镜像就相当于个一个系统相互不影响独立环境。</p>\n</blockquote>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2018/bg2018020901.png\" srcset=\"/img/loading.gif\" alt=\"docker\"></p>\n<h2 id=\"1-Docker-介绍\"><a href=\"#1-Docker-介绍\" class=\"headerlink\" title=\"1.Docker 介绍\"></a>1.Docker 介绍</h2><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>\n<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>\n<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>\n<h2 id=\"2-Docker-安装\"><a href=\"#2-Docker-安装\" class=\"headerlink\" title=\"2.Docker 安装\"></a>2.Docker 安装</h2><p>我的VPS用的 Centos 7 那就用本版本记录搭建过程，docker的版本用CE社区版<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#下载yum-utils工具用于管理yum-config-manager可以配置源</span>\nyum install yum-utils\n<span class=\"hljs-comment\">#添加docker-ce源</span>\nyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n<span class=\"hljs-comment\">#查询docker-ce版本</span>\nyum list docker-ce --showduplicates | sort -r \n<span class=\"hljs-comment\">#指定安装18.06.0 版本</span>\nyum install dock-ce-18.06.0.ce</code></pre></p>\n<p>安装docker，默认是安装最高版本测试可以用，但是生产环境为了稳定尽量指定版本(stable稳定版)</p>\n<h2 id=\"3-Docker-常用命令\"><a href=\"#3-Docker-常用命令\" class=\"headerlink\" title=\"3.Docker 常用命令\"></a>3.Docker 常用命令</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#启动docker服务</span>\nsystemctl start docker\n<span class=\"hljs-comment\">#自动启动docker服务</span>\nsystemctl <span class=\"hljs-built_in\">enable</span> docker</code></pre>\n<p>安装docker,默认是安装最高版本测试可以用，但是生产环境为了稳定尽量指定版本(<code>stable稳定版</code>)</p>\n<h2 id=\"3-Docker-镜像-容器\"><a href=\"#3-Docker-镜像-容器\" class=\"headerlink\" title=\"3.Docker 镜像 容器\"></a>3.Docker 镜像 容器</h2><h4 id=\"镜像查询拉取\"><a href=\"#镜像查询拉取\" class=\"headerlink\" title=\"镜像查询拉取\"></a>镜像查询拉取</h4><p>安装 docker 完毕，可以尝试安装一个镜像并运行，搜索镜像使用 <code>docker search [镜像名称]</code>,搜索的镜像 <code>OFFICAL</code> 标识的为官方镜像，其余的都是非官方人员自行构建的镜像并上传库共享。<br><img src=\"/images/docker-search.png\" srcset=\"/img/loading.gif\" alt=\"docker-search-alpine\"><br>使用 <code>docker pull alpine</code> 下载拉取alpine镜像,然后使用<code>docker images</code> 查看镜像已有镜像，这里以<code>alpine</code>为模板<br><img src=\"/images/docker-images.png\" srcset=\"/img/loading.gif\" alt=\"docker-images\"></p>\n<h4 id=\"运行容器\"><a href=\"#运行容器\" class=\"headerlink\" title=\"运行容器\"></a>运行容器</h4><p>基于alpine镜像启动一个容器<br><pre><code class=\"hljs bash\">docker run -itd -p  8081:8081 --name myTest  alpine</code></pre></p>\n<ul>\n<li>-i：以交互模式运行容器，通常与 -t 同时使用</li>\n<li>-d: 后台运行容器，并返回容器ID</li>\n<li>-t : 为容器重新分配一个伪输入终端，通常与 -i 同时使用</li>\n<li>-p: 端口映射，格式为：主机(宿主)端口:容器端口 8080端口的访问转发到容器的8080端口上</li>\n<li>–name: 为容器指定一个容器名</li>\n<li>alpine：这是指用 <code>alpine</code> 镜像为基础来启动容器。</li>\n</ul>\n<p>启动完毕后 <code>docker ps</code> 查看正在运行的容器,  <code>docker ps -a</code> 查看容器。</p>\n<h4 id=\"容器操作\"><a href=\"#容器操作\" class=\"headerlink\" title=\"容器操作\"></a>容器操作</h4><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">##### myTest 为容器名称 ##### </span>\n<span class=\"hljs-comment\">#进行容器</span>\ndocker attach myTest\n<span class=\"hljs-comment\">#容器中执行脚本返回结果 (由于是alpine所以执行的)</span>\ndocker <span class=\"hljs-built_in\">exec</span> -it myTest /bin/sh\n<span class=\"hljs-comment\">#删除容器</span>\ndocker rm myTest\n<span class=\"hljs-comment\">#启动已有容器</span>\ndocker start myTest\n<span class=\"hljs-comment\">#停止容器</span>\ndocker stop myTest</code></pre>\n<p>在容器中退出容器时需要注意的是通过<code>exit</code>返回宿主主机会导致容器直接停止并不是我们想要的结果，官方给出的退出容器并使其在后台继续运行使用 <code>ctrl+p+q</code> 安全退出不影响容器运行。 </p>\n<h2 id=\"4-DockerFile\"><a href=\"#4-DockerFile\" class=\"headerlink\" title=\"4.DockerFile\"></a>4.DockerFile</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的指令<code>(Instruction)</code>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。我们可以根据实际的开发需求通过<code>dockerfile</code>来自定义镜像，JUST DO IT！</p>\n<h5 id=\"FROM-指令\"><a href=\"#FROM-指令\" class=\"headerlink\" title=\"FROM 指令\"></a>FROM 指令</h5><p>FROM &lt;image>:&lt;tag> 相当于建造一个大楼地基的选择，选择不同的地基来搭建不一样的大楼。</p>\n<ul>\n<li>操作系统类基础搭建例如 <code>ubuntu</code>、<code>dabin</code>、<code>centos</code></li>\n<li>开发语言作为基础搭建例如<code>java</code>、<code>nodejs</code>、<code>python</code> </li>\n<li>服务类镜像作为基础 <code>oralce</code>、<code>mysql</code>、<code>nginx</code>、<code>tomcat</code></li>\n<li>自定义混合类作为基础在其他自定义环境镜像基础上搭建</li>\n</ul>\n<p>所有的镜像地基都可以从docker库中拉取，选择合理的基础镜像可以让你更快的去构建你的镜像，省心省力。</p>\n<h4 id=\"RUN-指令\"><a href=\"#RUN-指令\" class=\"headerlink\" title=\"RUN 指令\"></a>RUN 指令</h4><p>RUN 就像是执行shell指令，常常用于更新安装需要的生产软件服务等。RUN有2种执行方式</p>\n<ul>\n<li>shell 格式： RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样：<code>RUN apt-get --update</code></li>\n<li>exec 格式： RUN [“可执行文件”, “参数1”, “参数2”]：<code>RUN [&quot;apt-get&quot;,&quot;--update&quot;]</code></li>\n</ul>\n<p><strong>注意</strong>：多行命令不要写多个<code>RUN</code>，原因是<code>Dockerfile</code>中每一个指令都会建立一层.多少个<code>RUN</code>就构建了多少层镜像，会造成镜像的臃肿多层，不仅仅增加了构件部署的时间，还容易出错。<code>RUN</code>书写时的换行符是<code>\\</code>，记得下载压缩软件操作完毕后<code>rm</code>不必要的软件压缩包和缓存让镜像更精简。</p>\n<h4 id=\"CMD-指令\"><a href=\"#CMD-指令\" class=\"headerlink\" title=\"CMD 指令\"></a>CMD 指令</h4><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似也是两种格式，<code>CMD</code> 执行脚本在<code>dockerfile</code>只能存在一条，多条只执行最后一条，当有多个时只会执行最后一个，一般用于执行开启某些服务 <code>tomcat</code>、<code>oracle</code>、<code>nginx</code>等。</p>\n<h4 id=\"ENTRYPOINT-指令\"><a href=\"#ENTRYPOINT-指令\" class=\"headerlink\" title=\"ENTRYPOINT 指令\"></a>ENTRYPOINT 指令</h4><p><code>ENTRYPOINT</code> 执行脚本在<code>dockerfile</code>只能存在一条，多条只执行最后一条，容器启动后执行且不会被<code>docker run</code>提供的参数覆盖。</p>\n<h3 id=\"RUN-ENTRYPOINT-CMD-小结\"><a href=\"#RUN-ENTRYPOINT-CMD-小结\" class=\"headerlink\" title=\"RUN  ENTRYPOINT  CMD 小结\"></a>RUN  ENTRYPOINT  CMD 小结</h3><ul>\n<li><code>CMD</code> 和 <code>ENTRYPOINT</code> 推荐使用<code>Exec</code>格式，因为指令可读性更强，更容易理解。<code>RUN</code> 则两种格式都可以。</li>\n<li><code>RUN</code>用来执行脚本构建基础镜像，<code>CMD</code> <code>ENTRYPOINT</code> 用来构建完镜像容器启动后执行一些操作。</li>\n<li><code>CMD</code> 会被<code>docker run</code> 后的执行脚本覆盖不执行，<code>ENTRYPOINT</code> 则不会被覆盖始终会被执行，如果需要覆盖运行需要<code>–entrypoint</code>参数。</li>\n<li><code>ENTRYPOINT</code> 和 <code>CMD</code> 同时存在时谁在最后谁能执行，<code>CMD</code> 可作为 <code>ENTRYPOINT</code> 的执行参数灵活配合使用。</li>\n</ul>\n<h4 id=\"COPY-指令\"><a href=\"#COPY-指令\" class=\"headerlink\" title=\"COPY 指令\"></a>COPY 指令</h4><p>用于从上下文路径复制文件到容器目标路径中，<code>copy package.json /usr/src/app/</code> 把<code>package.json</code>复制到容器 <code>/usr/src/app</code>路径下</p>\n<ul>\n<li>COPY &lt;源路径&gt;… &lt;目标路径&gt;</li>\n<li>COPY [“&lt;源路径&gt;”，……，”&lt;目标路径&gt;”]  <code>......</code>代表若干源路径</li>\n</ul>\n<h4 id=\"ADD-指令\"><a href=\"#ADD-指令\" class=\"headerlink\" title=\"ADD 指令\"></a>ADD 指令</h4><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致，是在 <code>COPY</code> 基础上增加了一些功能。比如<code>&lt;源路径&gt;</code>可以是一个<code>URL</code>，这种情况下 Docker 引擎会试图去下载这个链接的文件放到<code>&lt;目标路径&gt;</code>去。如果<code>&lt;源路径&gt;</code>为一个<code>tar</code> 压缩文件的话，压缩格式为<code>gzip</code> , <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code>指令将会自动解压缩这个压缩文件到<code>&lt;目标路径&gt;</code>去。<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢，<code>ADD</code> 还包含了一些复杂的的功能其行为也不一定清晰，所以官方推荐使用<code>COPY</code>来进行文件的复制。</p>\n<h4 id=\"ENV-指令\"><a href=\"#ENV-指令\" class=\"headerlink\" title=\"ENV 指令\"></a>ENV 指令</h4><p><code>ENV</code> 用于设置环境变量在后续的指令可以直接引用</p>\n<ul>\n<li>ENV &lt;key> &lt;value></li>\n<li>ENV &lt;key1>=&lt;value1> &lt;key2>=&lt;value2>…</li>\n</ul>\n<h5 id=\"Docker-build构建\"><a href=\"#Docker-build构建\" class=\"headerlink\" title=\"Docker build构建\"></a>Docker build构建</h5><p>所有的脚本编写完毕使用<code>docker bulid</code> 对 Dockerfile 进行构建，详细的命令如下<br><pre><code class=\"hljs bash\">\n</code></pre></p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#基于镜像 这里使用alpine 主要是体积小构建速度更快</span>\nFROM alpine\n<span class=\"hljs-comment\">#构建维修者 </span>\nMAINTAINER 285635652@qq.com\nRUN apt-get update / &amp;&amp; apt-get java</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>开发-&gt;部署测试-&gt;发布正式 在整体流程中每个人的开发环境可能各不相同、编译环境、运行环境。单机服务调整控制环境版本等可以保证发布一致性，但是如果当业务越来越庞大集群处理时需要部署多台机器时，可能每台机器的大大小小差异都会导致发布失败，处理起来非常麻烦。docker虚拟化来处理能保证发布环境一致性，可移植。通过docker 镜像你可以在任何版本linux服务器上进行发布。每个镜像就相当于个一个系统相互不影响独立环境。</p>\n</blockquote>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2018/bg2018020901.png\" srcset=\"/img/loading.gif\" alt=\"docker\"></p>\n<h2 id=\"1-Docker-介绍\"><a href=\"#1-Docker-介绍\" class=\"headerlink\" title=\"1.Docker 介绍\"></a>1.Docker 介绍</h2><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>\n<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>\n<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>\n<h2 id=\"2-Docker-安装\"><a href=\"#2-Docker-安装\" class=\"headerlink\" title=\"2.Docker 安装\"></a>2.Docker 安装</h2><p>我的VPS用的 Centos 7 那就用本版本记录搭建过程，docker的版本用CE社区版<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#下载yum-utils工具用于管理yum-config-manager可以配置源</span>\nyum install yum-utils\n<span class=\"hljs-comment\">#添加docker-ce源</span>\nyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n<span class=\"hljs-comment\">#查询docker-ce版本</span>\nyum list docker-ce --showduplicates | sort -r \n<span class=\"hljs-comment\">#指定安装18.06.0 版本</span>\nyum install dock-ce-18.06.0.ce</code></pre></p>\n<p>安装docker，默认是安装最高版本测试可以用，但是生产环境为了稳定尽量指定版本(stable稳定版)</p>\n<h2 id=\"3-Docker-常用命令\"><a href=\"#3-Docker-常用命令\" class=\"headerlink\" title=\"3.Docker 常用命令\"></a>3.Docker 常用命令</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#启动docker服务</span>\nsystemctl start docker\n<span class=\"hljs-comment\">#自动启动docker服务</span>\nsystemctl <span class=\"hljs-built_in\">enable</span> docker</code></pre>\n<p>安装docker,默认是安装最高版本测试可以用，但是生产环境为了稳定尽量指定版本(<code>stable稳定版</code>)</p>\n<h2 id=\"3-Docker-镜像-容器\"><a href=\"#3-Docker-镜像-容器\" class=\"headerlink\" title=\"3.Docker 镜像 容器\"></a>3.Docker 镜像 容器</h2><h4 id=\"镜像查询拉取\"><a href=\"#镜像查询拉取\" class=\"headerlink\" title=\"镜像查询拉取\"></a>镜像查询拉取</h4><p>安装 docker 完毕，可以尝试安装一个镜像并运行，搜索镜像使用 <code>docker search [镜像名称]</code>,搜索的镜像 <code>OFFICAL</code> 标识的为官方镜像，其余的都是非官方人员自行构建的镜像并上传库共享。<br><img src=\"/images/docker-search.png\" srcset=\"/img/loading.gif\" alt=\"docker-search-alpine\"><br>使用 <code>docker pull alpine</code> 下载拉取alpine镜像,然后使用<code>docker images</code> 查看镜像已有镜像，这里以<code>alpine</code>为模板<br><img src=\"/images/docker-images.png\" srcset=\"/img/loading.gif\" alt=\"docker-images\"></p>\n<h4 id=\"运行容器\"><a href=\"#运行容器\" class=\"headerlink\" title=\"运行容器\"></a>运行容器</h4><p>基于alpine镜像启动一个容器<br><pre><code class=\"hljs bash\">docker run -itd -p  8081:8081 --name myTest  alpine</code></pre></p>\n<ul>\n<li>-i：以交互模式运行容器，通常与 -t 同时使用</li>\n<li>-d: 后台运行容器，并返回容器ID</li>\n<li>-t : 为容器重新分配一个伪输入终端，通常与 -i 同时使用</li>\n<li>-p: 端口映射，格式为：主机(宿主)端口:容器端口 8080端口的访问转发到容器的8080端口上</li>\n<li>–name: 为容器指定一个容器名</li>\n<li>alpine：这是指用 <code>alpine</code> 镜像为基础来启动容器。</li>\n</ul>\n<p>启动完毕后 <code>docker ps</code> 查看正在运行的容器,  <code>docker ps -a</code> 查看容器。</p>\n<h4 id=\"容器操作\"><a href=\"#容器操作\" class=\"headerlink\" title=\"容器操作\"></a>容器操作</h4><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">##### myTest 为容器名称 ##### </span>\n<span class=\"hljs-comment\">#进行容器</span>\ndocker attach myTest\n<span class=\"hljs-comment\">#容器中执行脚本返回结果 (由于是alpine所以执行的)</span>\ndocker <span class=\"hljs-built_in\">exec</span> -it myTest /bin/sh\n<span class=\"hljs-comment\">#删除容器</span>\ndocker rm myTest\n<span class=\"hljs-comment\">#启动已有容器</span>\ndocker start myTest\n<span class=\"hljs-comment\">#停止容器</span>\ndocker stop myTest</code></pre>\n<p>在容器中退出容器时需要注意的是通过<code>exit</code>返回宿主主机会导致容器直接停止并不是我们想要的结果，官方给出的退出容器并使其在后台继续运行使用 <code>ctrl+p+q</code> 安全退出不影响容器运行。 </p>\n<h2 id=\"4-DockerFile\"><a href=\"#4-DockerFile\" class=\"headerlink\" title=\"4.DockerFile\"></a>4.DockerFile</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的指令<code>(Instruction)</code>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。我们可以根据实际的开发需求通过<code>dockerfile</code>来自定义镜像，JUST DO IT！</p>\n<h5 id=\"FROM-指令\"><a href=\"#FROM-指令\" class=\"headerlink\" title=\"FROM 指令\"></a>FROM 指令</h5><p>FROM &lt;image>:&lt;tag> 相当于建造一个大楼地基的选择，选择不同的地基来搭建不一样的大楼。</p>\n<ul>\n<li>操作系统类基础搭建例如 <code>ubuntu</code>、<code>dabin</code>、<code>centos</code></li>\n<li>开发语言作为基础搭建例如<code>java</code>、<code>nodejs</code>、<code>python</code> </li>\n<li>服务类镜像作为基础 <code>oralce</code>、<code>mysql</code>、<code>nginx</code>、<code>tomcat</code></li>\n<li>自定义混合类作为基础在其他自定义环境镜像基础上搭建</li>\n</ul>\n<p>所有的镜像地基都可以从docker库中拉取，选择合理的基础镜像可以让你更快的去构建你的镜像，省心省力。</p>\n<h4 id=\"RUN-指令\"><a href=\"#RUN-指令\" class=\"headerlink\" title=\"RUN 指令\"></a>RUN 指令</h4><p>RUN 就像是执行shell指令，常常用于更新安装需要的生产软件服务等。RUN有2种执行方式</p>\n<ul>\n<li>shell 格式： RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样：<code>RUN apt-get --update</code></li>\n<li>exec 格式： RUN [“可执行文件”, “参数1”, “参数2”]：<code>RUN [&quot;apt-get&quot;,&quot;--update&quot;]</code></li>\n</ul>\n<p><strong>注意</strong>：多行命令不要写多个<code>RUN</code>，原因是<code>Dockerfile</code>中每一个指令都会建立一层.多少个<code>RUN</code>就构建了多少层镜像，会造成镜像的臃肿多层，不仅仅增加了构件部署的时间，还容易出错。<code>RUN</code>书写时的换行符是<code>\\</code>，记得下载压缩软件操作完毕后<code>rm</code>不必要的软件压缩包和缓存让镜像更精简。</p>\n<h4 id=\"CMD-指令\"><a href=\"#CMD-指令\" class=\"headerlink\" title=\"CMD 指令\"></a>CMD 指令</h4><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似也是两种格式，<code>CMD</code> 执行脚本在<code>dockerfile</code>只能存在一条，多条只执行最后一条，当有多个时只会执行最后一个，一般用于执行开启某些服务 <code>tomcat</code>、<code>oracle</code>、<code>nginx</code>等。</p>\n<h4 id=\"ENTRYPOINT-指令\"><a href=\"#ENTRYPOINT-指令\" class=\"headerlink\" title=\"ENTRYPOINT 指令\"></a>ENTRYPOINT 指令</h4><p><code>ENTRYPOINT</code> 执行脚本在<code>dockerfile</code>只能存在一条，多条只执行最后一条，容器启动后执行且不会被<code>docker run</code>提供的参数覆盖。</p>\n<h3 id=\"RUN-ENTRYPOINT-CMD-小结\"><a href=\"#RUN-ENTRYPOINT-CMD-小结\" class=\"headerlink\" title=\"RUN  ENTRYPOINT  CMD 小结\"></a>RUN  ENTRYPOINT  CMD 小结</h3><ul>\n<li><code>CMD</code> 和 <code>ENTRYPOINT</code> 推荐使用<code>Exec</code>格式，因为指令可读性更强，更容易理解。<code>RUN</code> 则两种格式都可以。</li>\n<li><code>RUN</code>用来执行脚本构建基础镜像，<code>CMD</code> <code>ENTRYPOINT</code> 用来构建完镜像容器启动后执行一些操作。</li>\n<li><code>CMD</code> 会被<code>docker run</code> 后的执行脚本覆盖不执行，<code>ENTRYPOINT</code> 则不会被覆盖始终会被执行，如果需要覆盖运行需要<code>–entrypoint</code>参数。</li>\n<li><code>ENTRYPOINT</code> 和 <code>CMD</code> 同时存在时谁在最后谁能执行，<code>CMD</code> 可作为 <code>ENTRYPOINT</code> 的执行参数灵活配合使用。</li>\n</ul>\n<h4 id=\"COPY-指令\"><a href=\"#COPY-指令\" class=\"headerlink\" title=\"COPY 指令\"></a>COPY 指令</h4><p>用于从上下文路径复制文件到容器目标路径中，<code>copy package.json /usr/src/app/</code> 把<code>package.json</code>复制到容器 <code>/usr/src/app</code>路径下</p>\n<ul>\n<li>COPY &lt;源路径&gt;… &lt;目标路径&gt;</li>\n<li>COPY [“&lt;源路径&gt;”，……，”&lt;目标路径&gt;”]  <code>......</code>代表若干源路径</li>\n</ul>\n<h4 id=\"ADD-指令\"><a href=\"#ADD-指令\" class=\"headerlink\" title=\"ADD 指令\"></a>ADD 指令</h4><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致，是在 <code>COPY</code> 基础上增加了一些功能。比如<code>&lt;源路径&gt;</code>可以是一个<code>URL</code>，这种情况下 Docker 引擎会试图去下载这个链接的文件放到<code>&lt;目标路径&gt;</code>去。如果<code>&lt;源路径&gt;</code>为一个<code>tar</code> 压缩文件的话，压缩格式为<code>gzip</code> , <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code>指令将会自动解压缩这个压缩文件到<code>&lt;目标路径&gt;</code>去。<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢，<code>ADD</code> 还包含了一些复杂的的功能其行为也不一定清晰，所以官方推荐使用<code>COPY</code>来进行文件的复制。</p>\n<h4 id=\"ENV-指令\"><a href=\"#ENV-指令\" class=\"headerlink\" title=\"ENV 指令\"></a>ENV 指令</h4><p><code>ENV</code> 用于设置环境变量在后续的指令可以直接引用</p>\n<ul>\n<li>ENV &lt;key> &lt;value></li>\n<li>ENV &lt;key1>=&lt;value1> &lt;key2>=&lt;value2>…</li>\n</ul>\n<h5 id=\"Docker-build构建\"><a href=\"#Docker-build构建\" class=\"headerlink\" title=\"Docker build构建\"></a>Docker build构建</h5><p>所有的脚本编写完毕使用<code>docker bulid</code> 对 Dockerfile 进行构建，详细的命令如下<br><pre><code class=\"hljs bash\">\n</code></pre></p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#基于镜像 这里使用alpine 主要是体积小构建速度更快</span>\nFROM alpine\n<span class=\"hljs-comment\">#构建维修者 </span>\nMAINTAINER 285635652@qq.com\nRUN apt-get update / &amp;&amp; apt-get java</code></pre>\n"},{"title":"EasyExcel 简单的Excel 处理工具","toc":false,"date":"2020-08-14T06:32:43.000Z","_content":"\n![Java](/images/java.jpg)\n\n> 项目里经常会用到报表导出功能或者导入功能，最近发现阿里也出了开源的Excel组件 EasyExcel，写一个DEMO尝试用下\n\n### EasyExcel \n先附上 [Github 开源地址](https://github.com/alibaba/easyexcel) [官方文档](https://www.yuque.com/easyexcel/doc/easyexcel)，maven 加入依赖就可以迅速开始开发\n``` xml\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>easyexcel</artifactId>\n  <version>${easyexcel.version}</version>\n</dependency>\n```\n\n### 写 Excel \n``` java\n/**\n  * 最简单的读\n  * <p>1. 创建excel对应的实体对象 参照{@link DemoData}\n  * <p>2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照{@link DemoDataListener}\n  * <p>3. 直接读即可\n  */\n@Test\npublic void simpleRead() {\n   String fileName = TestFileUtil.getPath() + \"demo\" + File.separator + \"demo.xlsx\";\n   // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭\n   EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).sheet().doRead();\n}\n```\n\n``` java\n@Data\npublic class DemoData {\n    @ExcelProperty(\"字符串标题\")\n    private String string;\n    @ExcelProperty(\"日期标题\")\n    private Date date;\n    @ExcelProperty(\"数字标题\")\n    private Double doubleData;\n    /**\n     * 忽略这个字段\n     */\n    @ExcelIgnore\n    private String ignore;\n}\n```\n\n#### @ExcelProperty\n\n|参数|类型|用处|\n|-|-|-|\n|value|String[]|表格中的列名，当为空时默认使用字段名，多个列名可以组合复杂的表头|\n|index|int|写入表格中指定列|\n|order|int|写入顺序，默认按照字段顺序|\n|converter|Class<? extends Converter>|转化器用于对字段进行自定义处理，EasyExcel 提供了大量默认转化器|\n\n#### @ContentFontStyle @HeadFontStyle\n用于设置单元格和表头内容字体格式的注解\n\n|参数|类型|含义|\n|-|-|-|\n|fontName|string|字体名称|\n|fontHeightInPoints|short|字体高度|\n|italic|boolean|是否斜体|\n|strikeout|boolean|是否设置删除水平线|\n|color|\tshort|字体颜色|\n|typeOffset|short|偏移量|\n|underline|byte|下划线|\n|bold|boolean|是否加粗|\n|charset|int|编码格式|\n\n#### @ContentStyle @HeadStyle\n用于设置单元格和表头样式注解\n\n|参数|类型|含义|\n|-|-|-|\n|dataFormat|shor|数据格式化|\n|hidden|boolean|样式隐藏|\n|locked|boolean|样式锁定|\n|quotePrefix|boolean|在单元格前面增加`符号，数字或公式将以字符串形式展示|\n|horizontalAlignment|HorizontalAlignment|设置是否水平居中|\n|wrapped|boolean|设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见|\n|verticalAlignment|boolean|设置是否垂直居中|\n|rotation|short|设置单元格中文本旋转角度。03版本的Excel旋转角度区间为-90°~90°，07版本的Excel旋转角度区间为0°~180°|\n|indent|short|设置单元格中缩进文本的空格数|\n|borderLeft|BorderStyle|设置左边框的样式|\n|borderRight|BorderStyle|设置右边框样式|\n|borderTop|BorderStyle|设置上边框样式|\n|borderBottom|BorderStyle|设置下边框样式|\n|leftBorderColor|short|设置左边框颜色|\n|rightBorderColor|short|设置右边框颜色|\n|topBorderColor|short|设置上边框颜色|\n|bottomBorderColor|short|设置下边框颜色|\n|fillPatternType|FillPatternType|设置填充类型|\n|fillBackgroundColor|short|设置背景色|\n|fillForegroundColor|short|设置前景色|\n|shrinkToFit|boolean|设置自动单元格自动大小|\n\n#### @ContentRowHeight @HeadRowHeight\n用于设置单元和和表头行高注解\n\n|参数|类型|含义|\n|-|-|-|\n|value|short|行高|\n\n#### @ColumnWidth \n用于设置单元格的列宽，作用类属于全局，当某字段作用覆盖全局设置，最大值为255\n\n|参数|类型|含义|\n|-|-|-|\n|value|short|列宽|\n\n#### @ExcelIgnore\n用于屏蔽不需要写入Excel的字段标记\n\n#### @DateTimeFormat @NumberFormat \n时间类字符串格式化、数字格式例如金额千分值、百分号等\n\n#### HorizontalCellStyleStrategy 自定义单元格样式策略\n自定义样式通过·registerWriteHandler 注册写入处理器\n``` java\n    /**\n     * 自定义样式\n     * <p>1. 创建excel对应的实体对象 参照{@link DemoData}\n     * <p>2. 创建一个style策略 并注册\n     * <p>3. 直接写即可\n     */\n    @Test\n    public void styleWrite() {\n        String fileName = TestFileUtil.getPath() + \"styleWrite\" + System.currentTimeMillis() + \".xlsx\";\n        // 头的策略\n        WriteCellStyle headWriteCellStyle = new WriteCellStyle();\n        // 背景设置为红色\n        headWriteCellStyle.setFillForegroundColor(IndexedColors.RED.getIndex());\n        WriteFont headWriteFont = new WriteFont();\n        headWriteFont.setFontHeightInPoints((short)20);\n        headWriteCellStyle.setWriteFont(headWriteFont);\n        // 内容的策略\n        WriteCellStyle contentWriteCellStyle = new WriteCellStyle();\n        // 这里需要指定 FillPatternType 为FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色.头默认了 FillPatternType所以可以不指定\n        contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);\n        // 背景绿色\n        contentWriteCellStyle.setFillForegroundColor(IndexedColors.GREEN.getIndex());\n        WriteFont contentWriteFont = new WriteFont();\n        // 字体大小\n        contentWriteFont.setFontHeightInPoints((short)20);\n        contentWriteCellStyle.setWriteFont(contentWriteFont);\n        // 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现\n        HorizontalCellStyleStrategy horizontalCellStyleStrategy =\n            new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);\n\n        // 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭\n        EasyExcel.write(fileName, DemoData.class).registerWriteHandler(horizontalCellStyleStrategy).sheet(\"模板\")\n            .doWrite(data());\n    }\n```","source":"_posts/EasyExcel-简单的Excel-处理工具.md","raw":"---\ntitle: EasyExcel 简单的Excel 处理工具\ntags:\n  - Java\ncategories:\n  - 技术\ntoc: false\ndate: 2020-08-14 14:32:43\n---\n\n![Java](/images/java.jpg)\n\n> 项目里经常会用到报表导出功能或者导入功能，最近发现阿里也出了开源的Excel组件 EasyExcel，写一个DEMO尝试用下\n\n### EasyExcel \n先附上 [Github 开源地址](https://github.com/alibaba/easyexcel) [官方文档](https://www.yuque.com/easyexcel/doc/easyexcel)，maven 加入依赖就可以迅速开始开发\n``` xml\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>easyexcel</artifactId>\n  <version>${easyexcel.version}</version>\n</dependency>\n```\n\n### 写 Excel \n``` java\n/**\n  * 最简单的读\n  * <p>1. 创建excel对应的实体对象 参照{@link DemoData}\n  * <p>2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照{@link DemoDataListener}\n  * <p>3. 直接读即可\n  */\n@Test\npublic void simpleRead() {\n   String fileName = TestFileUtil.getPath() + \"demo\" + File.separator + \"demo.xlsx\";\n   // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭\n   EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).sheet().doRead();\n}\n```\n\n``` java\n@Data\npublic class DemoData {\n    @ExcelProperty(\"字符串标题\")\n    private String string;\n    @ExcelProperty(\"日期标题\")\n    private Date date;\n    @ExcelProperty(\"数字标题\")\n    private Double doubleData;\n    /**\n     * 忽略这个字段\n     */\n    @ExcelIgnore\n    private String ignore;\n}\n```\n\n#### @ExcelProperty\n\n|参数|类型|用处|\n|-|-|-|\n|value|String[]|表格中的列名，当为空时默认使用字段名，多个列名可以组合复杂的表头|\n|index|int|写入表格中指定列|\n|order|int|写入顺序，默认按照字段顺序|\n|converter|Class<? extends Converter>|转化器用于对字段进行自定义处理，EasyExcel 提供了大量默认转化器|\n\n#### @ContentFontStyle @HeadFontStyle\n用于设置单元格和表头内容字体格式的注解\n\n|参数|类型|含义|\n|-|-|-|\n|fontName|string|字体名称|\n|fontHeightInPoints|short|字体高度|\n|italic|boolean|是否斜体|\n|strikeout|boolean|是否设置删除水平线|\n|color|\tshort|字体颜色|\n|typeOffset|short|偏移量|\n|underline|byte|下划线|\n|bold|boolean|是否加粗|\n|charset|int|编码格式|\n\n#### @ContentStyle @HeadStyle\n用于设置单元格和表头样式注解\n\n|参数|类型|含义|\n|-|-|-|\n|dataFormat|shor|数据格式化|\n|hidden|boolean|样式隐藏|\n|locked|boolean|样式锁定|\n|quotePrefix|boolean|在单元格前面增加`符号，数字或公式将以字符串形式展示|\n|horizontalAlignment|HorizontalAlignment|设置是否水平居中|\n|wrapped|boolean|设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见|\n|verticalAlignment|boolean|设置是否垂直居中|\n|rotation|short|设置单元格中文本旋转角度。03版本的Excel旋转角度区间为-90°~90°，07版本的Excel旋转角度区间为0°~180°|\n|indent|short|设置单元格中缩进文本的空格数|\n|borderLeft|BorderStyle|设置左边框的样式|\n|borderRight|BorderStyle|设置右边框样式|\n|borderTop|BorderStyle|设置上边框样式|\n|borderBottom|BorderStyle|设置下边框样式|\n|leftBorderColor|short|设置左边框颜色|\n|rightBorderColor|short|设置右边框颜色|\n|topBorderColor|short|设置上边框颜色|\n|bottomBorderColor|short|设置下边框颜色|\n|fillPatternType|FillPatternType|设置填充类型|\n|fillBackgroundColor|short|设置背景色|\n|fillForegroundColor|short|设置前景色|\n|shrinkToFit|boolean|设置自动单元格自动大小|\n\n#### @ContentRowHeight @HeadRowHeight\n用于设置单元和和表头行高注解\n\n|参数|类型|含义|\n|-|-|-|\n|value|short|行高|\n\n#### @ColumnWidth \n用于设置单元格的列宽，作用类属于全局，当某字段作用覆盖全局设置，最大值为255\n\n|参数|类型|含义|\n|-|-|-|\n|value|short|列宽|\n\n#### @ExcelIgnore\n用于屏蔽不需要写入Excel的字段标记\n\n#### @DateTimeFormat @NumberFormat \n时间类字符串格式化、数字格式例如金额千分值、百分号等\n\n#### HorizontalCellStyleStrategy 自定义单元格样式策略\n自定义样式通过·registerWriteHandler 注册写入处理器\n``` java\n    /**\n     * 自定义样式\n     * <p>1. 创建excel对应的实体对象 参照{@link DemoData}\n     * <p>2. 创建一个style策略 并注册\n     * <p>3. 直接写即可\n     */\n    @Test\n    public void styleWrite() {\n        String fileName = TestFileUtil.getPath() + \"styleWrite\" + System.currentTimeMillis() + \".xlsx\";\n        // 头的策略\n        WriteCellStyle headWriteCellStyle = new WriteCellStyle();\n        // 背景设置为红色\n        headWriteCellStyle.setFillForegroundColor(IndexedColors.RED.getIndex());\n        WriteFont headWriteFont = new WriteFont();\n        headWriteFont.setFontHeightInPoints((short)20);\n        headWriteCellStyle.setWriteFont(headWriteFont);\n        // 内容的策略\n        WriteCellStyle contentWriteCellStyle = new WriteCellStyle();\n        // 这里需要指定 FillPatternType 为FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色.头默认了 FillPatternType所以可以不指定\n        contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);\n        // 背景绿色\n        contentWriteCellStyle.setFillForegroundColor(IndexedColors.GREEN.getIndex());\n        WriteFont contentWriteFont = new WriteFont();\n        // 字体大小\n        contentWriteFont.setFontHeightInPoints((short)20);\n        contentWriteCellStyle.setWriteFont(contentWriteFont);\n        // 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现\n        HorizontalCellStyleStrategy horizontalCellStyleStrategy =\n            new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);\n\n        // 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭\n        EasyExcel.write(fileName, DemoData.class).registerWriteHandler(horizontalCellStyleStrategy).sheet(\"模板\")\n            .doWrite(data());\n    }\n```","slug":"EasyExcel-简单的Excel-处理工具","published":1,"updated":"2020-08-26T03:55:55.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc96m0005jsudc3wbwbdx","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>项目里经常会用到报表导出功能或者导入功能，最近发现阿里也出了开源的Excel组件 EasyExcel，写一个DEMO尝试用下</p>\n</blockquote>\n<h3 id=\"EasyExcel\"><a href=\"#EasyExcel\" class=\"headerlink\" title=\"EasyExcel\"></a>EasyExcel</h3><p>先附上 <a href=\"https://github.com/alibaba/easyexcel\" target=\"_blank\" rel=\"noopener\">Github 开源地址</a> <a href=\"https://www.yuque.com/easyexcel/doc/easyexcel\" target=\"_blank\" rel=\"noopener\">官方文档</a>，maven 加入依赖就可以迅速开始开发<br><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>easyexcel<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>$&#123;easyexcel.version&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre></p>\n<h3 id=\"写-Excel\"><a href=\"#写-Excel\" class=\"headerlink\" title=\"写 Excel\"></a>写 Excel</h3><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n  * 最简单的读\n  * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;<span class=\"hljs-doctag\">@link</span> DemoData&#125;\n  * &lt;p&gt;2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照&#123;<span class=\"hljs-doctag\">@link</span> DemoDataListener&#125;\n  * &lt;p&gt;3. 直接读即可\n  */</span>\n<span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">simpleRead</span><span class=\"hljs-params\">()</span> </span>&#123;\n   String fileName = TestFileUtil.getPath() + <span class=\"hljs-string\">\"demo\"</span> + File.separator + <span class=\"hljs-string\">\"demo.xlsx\"</span>;\n   <span class=\"hljs-comment\">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span>\n   EasyExcel.read(fileName, DemoData<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">new</span> <span class=\"hljs-title\">DemoDataListener</span>()).<span class=\"hljs-title\">sheet</span>().<span class=\"hljs-title\">doRead</span>()</span>;\n&#125;</code></pre>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoData</span> </span>&#123;\n    <span class=\"hljs-meta\">@ExcelProperty</span>(<span class=\"hljs-string\">\"字符串标题\"</span>)\n    <span class=\"hljs-keyword\">private</span> String string;\n    <span class=\"hljs-meta\">@ExcelProperty</span>(<span class=\"hljs-string\">\"日期标题\"</span>)\n    <span class=\"hljs-keyword\">private</span> Date date;\n    <span class=\"hljs-meta\">@ExcelProperty</span>(<span class=\"hljs-string\">\"数字标题\"</span>)\n    <span class=\"hljs-keyword\">private</span> Double doubleData;\n    <span class=\"hljs-comment\">/**\n     * 忽略这个字段\n     */</span>\n    <span class=\"hljs-meta\">@ExcelIgnore</span>\n    <span class=\"hljs-keyword\">private</span> String ignore;\n&#125;</code></pre>\n<h4 id=\"ExcelProperty\"><a href=\"#ExcelProperty\" class=\"headerlink\" title=\"@ExcelProperty\"></a>@ExcelProperty</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>用处</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>String[]</td>\n<td>表格中的列名，当为空时默认使用字段名，多个列名可以组合复杂的表头</td>\n</tr>\n<tr>\n<td>index</td>\n<td>int</td>\n<td>写入表格中指定列</td>\n</tr>\n<tr>\n<td>order</td>\n<td>int</td>\n<td>写入顺序，默认按照字段顺序</td>\n</tr>\n<tr>\n<td>converter</td>\n<td>Class&lt;? extends Converter&gt;</td>\n<td>转化器用于对字段进行自定义处理，EasyExcel 提供了大量默认转化器</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ContentFontStyle-HeadFontStyle\"><a href=\"#ContentFontStyle-HeadFontStyle\" class=\"headerlink\" title=\"@ContentFontStyle @HeadFontStyle\"></a>@ContentFontStyle @HeadFontStyle</h4><p>用于设置单元格和表头内容字体格式的注解</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fontName</td>\n<td>string</td>\n<td>字体名称</td>\n</tr>\n<tr>\n<td>fontHeightInPoints</td>\n<td>short</td>\n<td>字体高度</td>\n</tr>\n<tr>\n<td>italic</td>\n<td>boolean</td>\n<td>是否斜体</td>\n</tr>\n<tr>\n<td>strikeout</td>\n<td>boolean</td>\n<td>是否设置删除水平线</td>\n</tr>\n<tr>\n<td>color</td>\n<td>short</td>\n<td>字体颜色</td>\n</tr>\n<tr>\n<td>typeOffset</td>\n<td>short</td>\n<td>偏移量</td>\n</tr>\n<tr>\n<td>underline</td>\n<td>byte</td>\n<td>下划线</td>\n</tr>\n<tr>\n<td>bold</td>\n<td>boolean</td>\n<td>是否加粗</td>\n</tr>\n<tr>\n<td>charset</td>\n<td>int</td>\n<td>编码格式</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ContentStyle-HeadStyle\"><a href=\"#ContentStyle-HeadStyle\" class=\"headerlink\" title=\"@ContentStyle @HeadStyle\"></a>@ContentStyle @HeadStyle</h4><p>用于设置单元格和表头样式注解</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dataFormat</td>\n<td>shor</td>\n<td>数据格式化</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td>boolean</td>\n<td>样式隐藏</td>\n</tr>\n<tr>\n<td>locked</td>\n<td>boolean</td>\n<td>样式锁定</td>\n</tr>\n<tr>\n<td>quotePrefix</td>\n<td>boolean</td>\n<td>在单元格前面增加`符号，数字或公式将以字符串形式展示</td>\n</tr>\n<tr>\n<td>horizontalAlignment</td>\n<td>HorizontalAlignment</td>\n<td>设置是否水平居中</td>\n</tr>\n<tr>\n<td>wrapped</td>\n<td>boolean</td>\n<td>设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见</td>\n</tr>\n<tr>\n<td>verticalAlignment</td>\n<td>boolean</td>\n<td>设置是否垂直居中</td>\n</tr>\n<tr>\n<td>rotation</td>\n<td>short</td>\n<td>设置单元格中文本旋转角度。03版本的Excel旋转角度区间为-90°~90°，07版本的Excel旋转角度区间为0°~180°</td>\n</tr>\n<tr>\n<td>indent</td>\n<td>short</td>\n<td>设置单元格中缩进文本的空格数</td>\n</tr>\n<tr>\n<td>borderLeft</td>\n<td>BorderStyle</td>\n<td>设置左边框的样式</td>\n</tr>\n<tr>\n<td>borderRight</td>\n<td>BorderStyle</td>\n<td>设置右边框样式</td>\n</tr>\n<tr>\n<td>borderTop</td>\n<td>BorderStyle</td>\n<td>设置上边框样式</td>\n</tr>\n<tr>\n<td>borderBottom</td>\n<td>BorderStyle</td>\n<td>设置下边框样式</td>\n</tr>\n<tr>\n<td>leftBorderColor</td>\n<td>short</td>\n<td>设置左边框颜色</td>\n</tr>\n<tr>\n<td>rightBorderColor</td>\n<td>short</td>\n<td>设置右边框颜色</td>\n</tr>\n<tr>\n<td>topBorderColor</td>\n<td>short</td>\n<td>设置上边框颜色</td>\n</tr>\n<tr>\n<td>bottomBorderColor</td>\n<td>short</td>\n<td>设置下边框颜色</td>\n</tr>\n<tr>\n<td>fillPatternType</td>\n<td>FillPatternType</td>\n<td>设置填充类型</td>\n</tr>\n<tr>\n<td>fillBackgroundColor</td>\n<td>short</td>\n<td>设置背景色</td>\n</tr>\n<tr>\n<td>fillForegroundColor</td>\n<td>short</td>\n<td>设置前景色</td>\n</tr>\n<tr>\n<td>shrinkToFit</td>\n<td>boolean</td>\n<td>设置自动单元格自动大小</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ContentRowHeight-HeadRowHeight\"><a href=\"#ContentRowHeight-HeadRowHeight\" class=\"headerlink\" title=\"@ContentRowHeight @HeadRowHeight\"></a>@ContentRowHeight @HeadRowHeight</h4><p>用于设置单元和和表头行高注解</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>short</td>\n<td>行高</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ColumnWidth\"><a href=\"#ColumnWidth\" class=\"headerlink\" title=\"@ColumnWidth\"></a>@ColumnWidth</h4><p>用于设置单元格的列宽，作用类属于全局，当某字段作用覆盖全局设置，最大值为255</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>short</td>\n<td>列宽</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ExcelIgnore\"><a href=\"#ExcelIgnore\" class=\"headerlink\" title=\"@ExcelIgnore\"></a>@ExcelIgnore</h4><p>用于屏蔽不需要写入Excel的字段标记</p>\n<h4 id=\"DateTimeFormat-NumberFormat\"><a href=\"#DateTimeFormat-NumberFormat\" class=\"headerlink\" title=\"@DateTimeFormat @NumberFormat\"></a>@DateTimeFormat @NumberFormat</h4><p>时间类字符串格式化、数字格式例如金额千分值、百分号等</p>\n<h4 id=\"HorizontalCellStyleStrategy-自定义单元格样式策略\"><a href=\"#HorizontalCellStyleStrategy-自定义单元格样式策略\" class=\"headerlink\" title=\"HorizontalCellStyleStrategy 自定义单元格样式策略\"></a>HorizontalCellStyleStrategy 自定义单元格样式策略</h4><p>自定义样式通过·registerWriteHandler 注册写入处理器<br><pre><code class=\"hljs java\">/**\n * 自定义样式\n * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;@link DemoData&#125;\n * &lt;p&gt;2. 创建一个style策略 并注册\n * &lt;p&gt;3. 直接写即可\n */\n@Test\npublic void styleWrite() &#123;\n    String fileName = TestFileUtil.getPath() + \"styleWrite\" + System.currentTimeMillis() + \".xlsx\";\n    // 头的策略\n    WriteCellStyle headWriteCellStyle = new WriteCellStyle();\n    // 背景设置为红色\n    headWriteCellStyle.setFillForegroundColor(IndexedColors.RED.getIndex());\n    WriteFont headWriteFont = new WriteFont();\n    headWriteFont.setFontHeightInPoints((short)20);\n    headWriteCellStyle.setWriteFont(headWriteFont);\n    // 内容的策略\n    WriteCellStyle contentWriteCellStyle = new WriteCellStyle();\n    // 这里需要指定 FillPatternType 为FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色.头默认了 FillPatternType所以可以不指定\n    contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);\n    // 背景绿色\n    contentWriteCellStyle.setFillForegroundColor(IndexedColors.GREEN.getIndex());\n    WriteFont contentWriteFont = new WriteFont();\n    // 字体大小\n    contentWriteFont.setFontHeightInPoints((short)20);\n    contentWriteCellStyle.setWriteFont(contentWriteFont);\n    // 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现\n    HorizontalCellStyleStrategy horizontalCellStyleStrategy =\n        new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);\n\n    // 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭\n    EasyExcel.write(fileName, DemoData.class).registerWriteHandler(horizontalCellStyleStrategy).sheet(\"模板\")\n        .doWrite(data());\n&#125;</code></pre></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>项目里经常会用到报表导出功能或者导入功能，最近发现阿里也出了开源的Excel组件 EasyExcel，写一个DEMO尝试用下</p>\n</blockquote>\n<h3 id=\"EasyExcel\"><a href=\"#EasyExcel\" class=\"headerlink\" title=\"EasyExcel\"></a>EasyExcel</h3><p>先附上 <a href=\"https://github.com/alibaba/easyexcel\" target=\"_blank\" rel=\"noopener\">Github 开源地址</a> <a href=\"https://www.yuque.com/easyexcel/doc/easyexcel\" target=\"_blank\" rel=\"noopener\">官方文档</a>，maven 加入依赖就可以迅速开始开发<br><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>easyexcel<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>$&#123;easyexcel.version&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre></p>\n<h3 id=\"写-Excel\"><a href=\"#写-Excel\" class=\"headerlink\" title=\"写 Excel\"></a>写 Excel</h3><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n  * 最简单的读\n  * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;<span class=\"hljs-doctag\">@link</span> DemoData&#125;\n  * &lt;p&gt;2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照&#123;<span class=\"hljs-doctag\">@link</span> DemoDataListener&#125;\n  * &lt;p&gt;3. 直接读即可\n  */</span>\n<span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">simpleRead</span><span class=\"hljs-params\">()</span> </span>&#123;\n   String fileName = TestFileUtil.getPath() + <span class=\"hljs-string\">\"demo\"</span> + File.separator + <span class=\"hljs-string\">\"demo.xlsx\"</span>;\n   <span class=\"hljs-comment\">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span>\n   EasyExcel.read(fileName, DemoData<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">new</span> <span class=\"hljs-title\">DemoDataListener</span>()).<span class=\"hljs-title\">sheet</span>().<span class=\"hljs-title\">doRead</span>()</span>;\n&#125;</code></pre>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoData</span> </span>&#123;\n    <span class=\"hljs-meta\">@ExcelProperty</span>(<span class=\"hljs-string\">\"字符串标题\"</span>)\n    <span class=\"hljs-keyword\">private</span> String string;\n    <span class=\"hljs-meta\">@ExcelProperty</span>(<span class=\"hljs-string\">\"日期标题\"</span>)\n    <span class=\"hljs-keyword\">private</span> Date date;\n    <span class=\"hljs-meta\">@ExcelProperty</span>(<span class=\"hljs-string\">\"数字标题\"</span>)\n    <span class=\"hljs-keyword\">private</span> Double doubleData;\n    <span class=\"hljs-comment\">/**\n     * 忽略这个字段\n     */</span>\n    <span class=\"hljs-meta\">@ExcelIgnore</span>\n    <span class=\"hljs-keyword\">private</span> String ignore;\n&#125;</code></pre>\n<h4 id=\"ExcelProperty\"><a href=\"#ExcelProperty\" class=\"headerlink\" title=\"@ExcelProperty\"></a>@ExcelProperty</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>用处</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>String[]</td>\n<td>表格中的列名，当为空时默认使用字段名，多个列名可以组合复杂的表头</td>\n</tr>\n<tr>\n<td>index</td>\n<td>int</td>\n<td>写入表格中指定列</td>\n</tr>\n<tr>\n<td>order</td>\n<td>int</td>\n<td>写入顺序，默认按照字段顺序</td>\n</tr>\n<tr>\n<td>converter</td>\n<td>Class&lt;? extends Converter&gt;</td>\n<td>转化器用于对字段进行自定义处理，EasyExcel 提供了大量默认转化器</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ContentFontStyle-HeadFontStyle\"><a href=\"#ContentFontStyle-HeadFontStyle\" class=\"headerlink\" title=\"@ContentFontStyle @HeadFontStyle\"></a>@ContentFontStyle @HeadFontStyle</h4><p>用于设置单元格和表头内容字体格式的注解</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fontName</td>\n<td>string</td>\n<td>字体名称</td>\n</tr>\n<tr>\n<td>fontHeightInPoints</td>\n<td>short</td>\n<td>字体高度</td>\n</tr>\n<tr>\n<td>italic</td>\n<td>boolean</td>\n<td>是否斜体</td>\n</tr>\n<tr>\n<td>strikeout</td>\n<td>boolean</td>\n<td>是否设置删除水平线</td>\n</tr>\n<tr>\n<td>color</td>\n<td>short</td>\n<td>字体颜色</td>\n</tr>\n<tr>\n<td>typeOffset</td>\n<td>short</td>\n<td>偏移量</td>\n</tr>\n<tr>\n<td>underline</td>\n<td>byte</td>\n<td>下划线</td>\n</tr>\n<tr>\n<td>bold</td>\n<td>boolean</td>\n<td>是否加粗</td>\n</tr>\n<tr>\n<td>charset</td>\n<td>int</td>\n<td>编码格式</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ContentStyle-HeadStyle\"><a href=\"#ContentStyle-HeadStyle\" class=\"headerlink\" title=\"@ContentStyle @HeadStyle\"></a>@ContentStyle @HeadStyle</h4><p>用于设置单元格和表头样式注解</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dataFormat</td>\n<td>shor</td>\n<td>数据格式化</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td>boolean</td>\n<td>样式隐藏</td>\n</tr>\n<tr>\n<td>locked</td>\n<td>boolean</td>\n<td>样式锁定</td>\n</tr>\n<tr>\n<td>quotePrefix</td>\n<td>boolean</td>\n<td>在单元格前面增加`符号，数字或公式将以字符串形式展示</td>\n</tr>\n<tr>\n<td>horizontalAlignment</td>\n<td>HorizontalAlignment</td>\n<td>设置是否水平居中</td>\n</tr>\n<tr>\n<td>wrapped</td>\n<td>boolean</td>\n<td>设置文本是否应换行。将此标志设置为true通过在多行上显示使单元格中的所有内容可见</td>\n</tr>\n<tr>\n<td>verticalAlignment</td>\n<td>boolean</td>\n<td>设置是否垂直居中</td>\n</tr>\n<tr>\n<td>rotation</td>\n<td>short</td>\n<td>设置单元格中文本旋转角度。03版本的Excel旋转角度区间为-90°~90°，07版本的Excel旋转角度区间为0°~180°</td>\n</tr>\n<tr>\n<td>indent</td>\n<td>short</td>\n<td>设置单元格中缩进文本的空格数</td>\n</tr>\n<tr>\n<td>borderLeft</td>\n<td>BorderStyle</td>\n<td>设置左边框的样式</td>\n</tr>\n<tr>\n<td>borderRight</td>\n<td>BorderStyle</td>\n<td>设置右边框样式</td>\n</tr>\n<tr>\n<td>borderTop</td>\n<td>BorderStyle</td>\n<td>设置上边框样式</td>\n</tr>\n<tr>\n<td>borderBottom</td>\n<td>BorderStyle</td>\n<td>设置下边框样式</td>\n</tr>\n<tr>\n<td>leftBorderColor</td>\n<td>short</td>\n<td>设置左边框颜色</td>\n</tr>\n<tr>\n<td>rightBorderColor</td>\n<td>short</td>\n<td>设置右边框颜色</td>\n</tr>\n<tr>\n<td>topBorderColor</td>\n<td>short</td>\n<td>设置上边框颜色</td>\n</tr>\n<tr>\n<td>bottomBorderColor</td>\n<td>short</td>\n<td>设置下边框颜色</td>\n</tr>\n<tr>\n<td>fillPatternType</td>\n<td>FillPatternType</td>\n<td>设置填充类型</td>\n</tr>\n<tr>\n<td>fillBackgroundColor</td>\n<td>short</td>\n<td>设置背景色</td>\n</tr>\n<tr>\n<td>fillForegroundColor</td>\n<td>short</td>\n<td>设置前景色</td>\n</tr>\n<tr>\n<td>shrinkToFit</td>\n<td>boolean</td>\n<td>设置自动单元格自动大小</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ContentRowHeight-HeadRowHeight\"><a href=\"#ContentRowHeight-HeadRowHeight\" class=\"headerlink\" title=\"@ContentRowHeight @HeadRowHeight\"></a>@ContentRowHeight @HeadRowHeight</h4><p>用于设置单元和和表头行高注解</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>short</td>\n<td>行高</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ColumnWidth\"><a href=\"#ColumnWidth\" class=\"headerlink\" title=\"@ColumnWidth\"></a>@ColumnWidth</h4><p>用于设置单元格的列宽，作用类属于全局，当某字段作用覆盖全局设置，最大值为255</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>short</td>\n<td>列宽</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"ExcelIgnore\"><a href=\"#ExcelIgnore\" class=\"headerlink\" title=\"@ExcelIgnore\"></a>@ExcelIgnore</h4><p>用于屏蔽不需要写入Excel的字段标记</p>\n<h4 id=\"DateTimeFormat-NumberFormat\"><a href=\"#DateTimeFormat-NumberFormat\" class=\"headerlink\" title=\"@DateTimeFormat @NumberFormat\"></a>@DateTimeFormat @NumberFormat</h4><p>时间类字符串格式化、数字格式例如金额千分值、百分号等</p>\n<h4 id=\"HorizontalCellStyleStrategy-自定义单元格样式策略\"><a href=\"#HorizontalCellStyleStrategy-自定义单元格样式策略\" class=\"headerlink\" title=\"HorizontalCellStyleStrategy 自定义单元格样式策略\"></a>HorizontalCellStyleStrategy 自定义单元格样式策略</h4><p>自定义样式通过·registerWriteHandler 注册写入处理器<br><pre><code class=\"hljs java\">/**\n * 自定义样式\n * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;@link DemoData&#125;\n * &lt;p&gt;2. 创建一个style策略 并注册\n * &lt;p&gt;3. 直接写即可\n */\n@Test\npublic void styleWrite() &#123;\n    String fileName = TestFileUtil.getPath() + \"styleWrite\" + System.currentTimeMillis() + \".xlsx\";\n    // 头的策略\n    WriteCellStyle headWriteCellStyle = new WriteCellStyle();\n    // 背景设置为红色\n    headWriteCellStyle.setFillForegroundColor(IndexedColors.RED.getIndex());\n    WriteFont headWriteFont = new WriteFont();\n    headWriteFont.setFontHeightInPoints((short)20);\n    headWriteCellStyle.setWriteFont(headWriteFont);\n    // 内容的策略\n    WriteCellStyle contentWriteCellStyle = new WriteCellStyle();\n    // 这里需要指定 FillPatternType 为FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色.头默认了 FillPatternType所以可以不指定\n    contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);\n    // 背景绿色\n    contentWriteCellStyle.setFillForegroundColor(IndexedColors.GREEN.getIndex());\n    WriteFont contentWriteFont = new WriteFont();\n    // 字体大小\n    contentWriteFont.setFontHeightInPoints((short)20);\n    contentWriteCellStyle.setWriteFont(contentWriteFont);\n    // 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现\n    HorizontalCellStyleStrategy horizontalCellStyleStrategy =\n        new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);\n\n    // 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭\n    EasyExcel.write(fileName, DemoData.class).registerWriteHandler(horizontalCellStyleStrategy).sheet(\"模板\")\n        .doWrite(data());\n&#125;</code></pre></p>\n"},{"title":"Hexo部署到VPS自动发布","toc":false,"tag":"Linux","date":"2018-07-26T07:02:30.000Z","_content":"\n![Linux](/images/linux-1.jpg)\n\n> Hexo部署到github访问的速度较慢，所以想着把Hexo直接丢在自己VPS上去，部署一套git环境以后方便自动发布更新\n\n## 1.Git 安装\n``` bash\n#通常使用的方法下载git\nyum -y install git\n#查看版本 这种下载一般不是最新的版本\nyum --version\n```\n发现并不是最新版本逼死强迫症啊，只能通过下载最新git源码自行编译安装。\nGit 的工作需要调用 `curl`，`zlib`，`openssl`，`expat`，`libiconv` 等库的代码，所以需要先安装这些依赖工具。在有 `yum` 的系统上（比如 Fedora）或者有 `apt-get` 的系统上（比如 Debian 体系），可以用   下面的命令安装：\n\n``` bash\n#卸载旧版本git\nyum remove git\n#安装依赖环境\nyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel\n#安装编译工具\nyum install  gcc perl-ExtUtils-MakeMaker\n#下载最新版git\nwget https://github.com/git/git/archive/v2.19.1.tar.gz\n#解压\ntar -zxvf v2.18.0.tar.gz\n#进入解压文件夹\ncd git-2.18.0\n#编译代码 perfix这里为赋值变量\nmake prefix=/usr/local/git all\n#安装软件 \nmake prefix=/usr/local/git install\n#清除编译数据\nmake clean all\n#环境变量配置\necho export PATH=$PATH:/usr/local/git/bin >>/etc/bashrc\n#生效环境变量\nsource /etc/bashrc\n```\n>/etc/profile，/etc/bashrc 是系统全局环境变量设定 ~/.profile，~/.bashrc用户家目录下的私有环境变量设定\n\n## 2.创建 git 仓库\n创建一个git库用来存放Hexo生成的html静态文件和相关资源，然后通过 post-receive 钩子函数进行自动执行脚本讲生成的资源checkout发布到nginx达到自动发布更新的功能。\n``` bash\n#创建git用户\nadduser git\n#设置密码\npasswd git\n#创建Hexo博客库 目录自行选择\nmkdir laochenpiBlog && chown git:git laochenpiBlog\n#laochenpiBlog目录下创建blog.git  --bare裸仓库 没有工作空间\ngit init --bare blog.git && chown git:git -R blog.git \n#laochenpiBlog 目录下创建静态网页库 \nmkdir blog.site && chown git:git blog.site\n#进入钩子函数目录\ncd hooks/\n#创建钩子函数文件\ntouch post-receive && chown git:git post-receive && chmod 755 post-receive\n```\n为Hexo编写自动化脚本在仓库hooks创建脚本 `vi post-receive` ，脚本会在git有收发的时候就会调用执行\n```\ngit --work-tree=/var/laochenpiBlog/blog.site --git-dir=/var/laochenpiBlog/blog.git checkout -f\n```\n\n## 3.Hexo 配置发布测试\n终于把Git环境弄好了，现在就需要修改配置文件`_config.yml` 中的发布项\n``` xml\n#Deployment\n## repo  为你的vps创建的库地址\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo : git@45.77.87.214:/var/laochenpiBlog/blog.git\n  branch: master\n```\n修改完毕，见证奇迹的时候到了，找到自己博客目录下用 `git bash`  发布\n ```\n #清除缓存  重编译  发布\n hexo clean && hexo g && hexo d\n ```\n ![OpenSSH](/images/passwd.png)\n 输入密码发布完毕，然后远程上你的VPS查看下你的 `blog.site` 是否自动 `check out`了最新发布的内容了。\n\n## 4.Git 免密发布\n每次发布都需要输入密码实在是太麻烦了而且在有可能泄露密码引起安全问题，有什么比较方面安全的方式呢，通过google一波发现可以通过秘钥的形式实现无密码发布登录。\n\n秘钥方式通过RSA加密生成公有秘钥，然后把公有秘钥提交到VPS 上的秘钥认证文件中 `authroized_keys`，修改 OpenSSH 客户端的配置 `sshd_config`  实现RSA秘钥认证方式。\n\n那么我们开始吧！\n\n- ##### 服务器端 \n修改 OpenSSH 认证 ` vi /etc/ssh/sshd_config ` \n开启公钥认证 `PubkeyAuthentication yes`   \n认证Keys文件目录 用户/.ssh/文件名 `AuthorizedKeysFile      .ssh/authorized_keys`  \nRSA加密认证 `RSAAuthentication yes` \n\n这里要提示一点 Centos 7 和 Centos 6 遇到的问题，Centos 7 由于OpenSSH版本原因 RSAAuthentication 已经弃用，无需添加修改.\n```\n#用户提交的git用户的秘钥文件夹创建和权限分配#\n——————————————————————————————————————\n#创建认证文件authorized_keys\ntouch /home/git/.ssh/authorized_keys\n#.ssh权限 700 authorized_keys 权限600\nchmod 700 /home/git/.ssh && chmod 600 /home/git/.ssh/authorize_keys\nchown -R  git:git /home/git\n```\n这里要注意 `.ssh` 和 `authorize_keys` 的权限问题和所属用户，可能在加密认证的时候由于权限导致失败，SSH登录日志可以用 `tail /var/log/secure` 查看，`sshd -t`进行查看配置是否正常 需要在~目录下执行，执行`systemctl restart sshd` 重启 `SSH`服务\n\n- ##### 客户端 \n`ssh-keygen -t rsa -C userName`  生成秘钥文件，地址一般在 `~/.ssh` 中。\n`id_rsa` 加密公钥 ` id_rsa.pub` 加密公钥  多用户用`cat` 追加秘钥到认证文件中\n\n``` bash\n#上传认证秘钥到服务器上 对应用户的authorized_keys中\ncat ~/.ssh/id_rsa.pub | ssh git@45.77.87.214 \"cat - >> /home/git/.ssh/authorized_keys\"\n```\n配置完毕后使用 `ssh -vvT git@45.77.87.214` 看看是不是不用密码就可以登录VPS了，然后发布就再也不用密码了，一条命令就OK。\n\n## 5.  Nginx配置映射\n终于到最后一步了，就差最后一步配置 Nginx 服务映射静态文件了。\n``` bash\n#Centos yum源安装\nyum install nginx\n#启动nginx服务\nsystemctl start nginx\n#查看服务状态\nsystemctl status nginx -l\n```\n这里有可能出现的问题：\n1.无法从外网访问 检查下80端口是否开启，添加80端口`firewall-cmd --permanent --zone=public --add-port=80/tcp --permanent` 和 `firewall-cmd --reload` 重载配置\n2.服务可能没有启动成功，排查下配置问题\n\n修改80端口默认映射库地址，`nginx -t`查看nginx配置文件地址  \n\n![nginx configuration file path](/images/nginx.png)\n``` bash\n#停止Nginx服务\nsystemctl stop nginx\n#修改Nginx的配置文件root\nvi /etc/nginx/nginx_conf\n#修改 root 配置hexo静态文件地址，即之前创建的静态文件地址\nroot [hexo静态文件地址]\n#修改完毕退出 重启Nginx服务\nsystemctl start nginx\n```\n修改完毕启动好服务然后通过外网访问你 VPS IP地址即可访问，大功告成以后可以在任意地方通过git提交的方式进行自动发布。请记得随时备份自己的重要文件以免丢失！\n\n## 遇到的问题\n已配置秘钥但是SSH还是需要密码，相信很多小伙伴都遇到过，下面是可能原因\n1. 查看sshd_config 配置文件是否正确开启了3个认证配置，更改后重启OpenSSH服务\n2. 查看下ssh登录日志 排查下原因，可能是认证文件目录权限问题，`.shh 700 ` `authorized_key 600 ` 过大或者过小的权限都有可能导致认证是失败。\n3. `authorized_key` 中秘钥千万千万不要直接从客户端直接复制过来，可能会有空格和其他转义一些特殊情况导致秘钥不正确。可通过 `cat`或`scp` 命令远程进行上传秘钥保证正确性。\n4. Centos 7 版本的 `OpenSSH` RSAAuthentication已经弃用无需设置、添加该设置可能导致启动异常。","source":"_posts/Hexo部署到VPS自动发布.md","raw":"---\ntitle: Hexo部署到VPS自动发布\ntags:\n  - Linux\ncategories:\n  - 技术\ntoc: false\ntag: Linux\ndate: 2018-07-26 15:02:30\n---\n\n![Linux](/images/linux-1.jpg)\n\n> Hexo部署到github访问的速度较慢，所以想着把Hexo直接丢在自己VPS上去，部署一套git环境以后方便自动发布更新\n\n## 1.Git 安装\n``` bash\n#通常使用的方法下载git\nyum -y install git\n#查看版本 这种下载一般不是最新的版本\nyum --version\n```\n发现并不是最新版本逼死强迫症啊，只能通过下载最新git源码自行编译安装。\nGit 的工作需要调用 `curl`，`zlib`，`openssl`，`expat`，`libiconv` 等库的代码，所以需要先安装这些依赖工具。在有 `yum` 的系统上（比如 Fedora）或者有 `apt-get` 的系统上（比如 Debian 体系），可以用   下面的命令安装：\n\n``` bash\n#卸载旧版本git\nyum remove git\n#安装依赖环境\nyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel\n#安装编译工具\nyum install  gcc perl-ExtUtils-MakeMaker\n#下载最新版git\nwget https://github.com/git/git/archive/v2.19.1.tar.gz\n#解压\ntar -zxvf v2.18.0.tar.gz\n#进入解压文件夹\ncd git-2.18.0\n#编译代码 perfix这里为赋值变量\nmake prefix=/usr/local/git all\n#安装软件 \nmake prefix=/usr/local/git install\n#清除编译数据\nmake clean all\n#环境变量配置\necho export PATH=$PATH:/usr/local/git/bin >>/etc/bashrc\n#生效环境变量\nsource /etc/bashrc\n```\n>/etc/profile，/etc/bashrc 是系统全局环境变量设定 ~/.profile，~/.bashrc用户家目录下的私有环境变量设定\n\n## 2.创建 git 仓库\n创建一个git库用来存放Hexo生成的html静态文件和相关资源，然后通过 post-receive 钩子函数进行自动执行脚本讲生成的资源checkout发布到nginx达到自动发布更新的功能。\n``` bash\n#创建git用户\nadduser git\n#设置密码\npasswd git\n#创建Hexo博客库 目录自行选择\nmkdir laochenpiBlog && chown git:git laochenpiBlog\n#laochenpiBlog目录下创建blog.git  --bare裸仓库 没有工作空间\ngit init --bare blog.git && chown git:git -R blog.git \n#laochenpiBlog 目录下创建静态网页库 \nmkdir blog.site && chown git:git blog.site\n#进入钩子函数目录\ncd hooks/\n#创建钩子函数文件\ntouch post-receive && chown git:git post-receive && chmod 755 post-receive\n```\n为Hexo编写自动化脚本在仓库hooks创建脚本 `vi post-receive` ，脚本会在git有收发的时候就会调用执行\n```\ngit --work-tree=/var/laochenpiBlog/blog.site --git-dir=/var/laochenpiBlog/blog.git checkout -f\n```\n\n## 3.Hexo 配置发布测试\n终于把Git环境弄好了，现在就需要修改配置文件`_config.yml` 中的发布项\n``` xml\n#Deployment\n## repo  为你的vps创建的库地址\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo : git@45.77.87.214:/var/laochenpiBlog/blog.git\n  branch: master\n```\n修改完毕，见证奇迹的时候到了，找到自己博客目录下用 `git bash`  发布\n ```\n #清除缓存  重编译  发布\n hexo clean && hexo g && hexo d\n ```\n ![OpenSSH](/images/passwd.png)\n 输入密码发布完毕，然后远程上你的VPS查看下你的 `blog.site` 是否自动 `check out`了最新发布的内容了。\n\n## 4.Git 免密发布\n每次发布都需要输入密码实在是太麻烦了而且在有可能泄露密码引起安全问题，有什么比较方面安全的方式呢，通过google一波发现可以通过秘钥的形式实现无密码发布登录。\n\n秘钥方式通过RSA加密生成公有秘钥，然后把公有秘钥提交到VPS 上的秘钥认证文件中 `authroized_keys`，修改 OpenSSH 客户端的配置 `sshd_config`  实现RSA秘钥认证方式。\n\n那么我们开始吧！\n\n- ##### 服务器端 \n修改 OpenSSH 认证 ` vi /etc/ssh/sshd_config ` \n开启公钥认证 `PubkeyAuthentication yes`   \n认证Keys文件目录 用户/.ssh/文件名 `AuthorizedKeysFile      .ssh/authorized_keys`  \nRSA加密认证 `RSAAuthentication yes` \n\n这里要提示一点 Centos 7 和 Centos 6 遇到的问题，Centos 7 由于OpenSSH版本原因 RSAAuthentication 已经弃用，无需添加修改.\n```\n#用户提交的git用户的秘钥文件夹创建和权限分配#\n——————————————————————————————————————\n#创建认证文件authorized_keys\ntouch /home/git/.ssh/authorized_keys\n#.ssh权限 700 authorized_keys 权限600\nchmod 700 /home/git/.ssh && chmod 600 /home/git/.ssh/authorize_keys\nchown -R  git:git /home/git\n```\n这里要注意 `.ssh` 和 `authorize_keys` 的权限问题和所属用户，可能在加密认证的时候由于权限导致失败，SSH登录日志可以用 `tail /var/log/secure` 查看，`sshd -t`进行查看配置是否正常 需要在~目录下执行，执行`systemctl restart sshd` 重启 `SSH`服务\n\n- ##### 客户端 \n`ssh-keygen -t rsa -C userName`  生成秘钥文件，地址一般在 `~/.ssh` 中。\n`id_rsa` 加密公钥 ` id_rsa.pub` 加密公钥  多用户用`cat` 追加秘钥到认证文件中\n\n``` bash\n#上传认证秘钥到服务器上 对应用户的authorized_keys中\ncat ~/.ssh/id_rsa.pub | ssh git@45.77.87.214 \"cat - >> /home/git/.ssh/authorized_keys\"\n```\n配置完毕后使用 `ssh -vvT git@45.77.87.214` 看看是不是不用密码就可以登录VPS了，然后发布就再也不用密码了，一条命令就OK。\n\n## 5.  Nginx配置映射\n终于到最后一步了，就差最后一步配置 Nginx 服务映射静态文件了。\n``` bash\n#Centos yum源安装\nyum install nginx\n#启动nginx服务\nsystemctl start nginx\n#查看服务状态\nsystemctl status nginx -l\n```\n这里有可能出现的问题：\n1.无法从外网访问 检查下80端口是否开启，添加80端口`firewall-cmd --permanent --zone=public --add-port=80/tcp --permanent` 和 `firewall-cmd --reload` 重载配置\n2.服务可能没有启动成功，排查下配置问题\n\n修改80端口默认映射库地址，`nginx -t`查看nginx配置文件地址  \n\n![nginx configuration file path](/images/nginx.png)\n``` bash\n#停止Nginx服务\nsystemctl stop nginx\n#修改Nginx的配置文件root\nvi /etc/nginx/nginx_conf\n#修改 root 配置hexo静态文件地址，即之前创建的静态文件地址\nroot [hexo静态文件地址]\n#修改完毕退出 重启Nginx服务\nsystemctl start nginx\n```\n修改完毕启动好服务然后通过外网访问你 VPS IP地址即可访问，大功告成以后可以在任意地方通过git提交的方式进行自动发布。请记得随时备份自己的重要文件以免丢失！\n\n## 遇到的问题\n已配置秘钥但是SSH还是需要密码，相信很多小伙伴都遇到过，下面是可能原因\n1. 查看sshd_config 配置文件是否正确开启了3个认证配置，更改后重启OpenSSH服务\n2. 查看下ssh登录日志 排查下原因，可能是认证文件目录权限问题，`.shh 700 ` `authorized_key 600 ` 过大或者过小的权限都有可能导致认证是失败。\n3. `authorized_key` 中秘钥千万千万不要直接从客户端直接复制过来，可能会有空格和其他转义一些特殊情况导致秘钥不正确。可通过 `cat`或`scp` 命令远程进行上传秘钥保证正确性。\n4. Centos 7 版本的 `OpenSSH` RSAAuthentication已经弃用无需设置、添加该设置可能导致启动异常。","slug":"Hexo部署到VPS自动发布","published":1,"updated":"2020-08-10T01:48:44.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc96o0006jsudny4ep3d1","content":"<p><img src=\"/images/linux-1.jpg\" srcset=\"/img/loading.gif\" alt=\"Linux\"></p>\n<blockquote>\n<p>Hexo部署到github访问的速度较慢，所以想着把Hexo直接丢在自己VPS上去，部署一套git环境以后方便自动发布更新</p>\n</blockquote>\n<h2 id=\"1-Git-安装\"><a href=\"#1-Git-安装\" class=\"headerlink\" title=\"1.Git 安装\"></a>1.Git 安装</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#通常使用的方法下载git</span>\nyum -y install git\n<span class=\"hljs-comment\">#查看版本 这种下载一般不是最新的版本</span>\nyum --version</code></pre>\n<p>发现并不是最新版本逼死强迫症啊，只能通过下载最新git源码自行编译安装。<br>Git 的工作需要调用 <code>curl</code>，<code>zlib</code>，<code>openssl</code>，<code>expat</code>，<code>libiconv</code> 等库的代码，所以需要先安装这些依赖工具。在有 <code>yum</code> 的系统上（比如 Fedora）或者有 <code>apt-get</code> 的系统上（比如 Debian 体系），可以用   下面的命令安装：</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#卸载旧版本git</span>\nyum remove git\n<span class=\"hljs-comment\">#安装依赖环境</span>\nyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel\n<span class=\"hljs-comment\">#安装编译工具</span>\nyum install  gcc perl-ExtUtils-MakeMaker\n<span class=\"hljs-comment\">#下载最新版git</span>\nwget https://github.com/git/git/archive/v2.19.1.tar.gz\n<span class=\"hljs-comment\">#解压</span>\ntar -zxvf v2.18.0.tar.gz\n<span class=\"hljs-comment\">#进入解压文件夹</span>\n<span class=\"hljs-built_in\">cd</span> git-2.18.0\n<span class=\"hljs-comment\">#编译代码 perfix这里为赋值变量</span>\nmake prefix=/usr/<span class=\"hljs-built_in\">local</span>/git all\n<span class=\"hljs-comment\">#安装软件 </span>\nmake prefix=/usr/<span class=\"hljs-built_in\">local</span>/git install\n<span class=\"hljs-comment\">#清除编译数据</span>\nmake clean all\n<span class=\"hljs-comment\">#环境变量配置</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$PATH</span>:/usr/<span class=\"hljs-built_in\">local</span>/git/bin &gt;&gt;/etc/bashrc\n<span class=\"hljs-comment\">#生效环境变量</span>\n<span class=\"hljs-built_in\">source</span> /etc/bashrc</code></pre>\n<blockquote>\n<p>/etc/profile，/etc/bashrc 是系统全局环境变量设定 ~/.profile，~/.bashrc用户家目录下的私有环境变量设定</p>\n</blockquote>\n<h2 id=\"2-创建-git-仓库\"><a href=\"#2-创建-git-仓库\" class=\"headerlink\" title=\"2.创建 git 仓库\"></a>2.创建 git 仓库</h2><p>创建一个git库用来存放Hexo生成的html静态文件和相关资源，然后通过 post-receive 钩子函数进行自动执行脚本讲生成的资源checkout发布到nginx达到自动发布更新的功能。<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#创建git用户</span>\nadduser git\n<span class=\"hljs-comment\">#设置密码</span>\npasswd git\n<span class=\"hljs-comment\">#创建Hexo博客库 目录自行选择</span>\nmkdir laochenpiBlog &amp;&amp; chown git:git laochenpiBlog\n<span class=\"hljs-comment\">#laochenpiBlog目录下创建blog.git  --bare裸仓库 没有工作空间</span>\ngit init --bare blog.git &amp;&amp; chown git:git -R blog.git \n<span class=\"hljs-comment\">#laochenpiBlog 目录下创建静态网页库 </span>\nmkdir blog.site &amp;&amp; chown git:git blog.site\n<span class=\"hljs-comment\">#进入钩子函数目录</span>\n<span class=\"hljs-built_in\">cd</span> hooks/\n<span class=\"hljs-comment\">#创建钩子函数文件</span>\ntouch post-receive &amp;&amp; chown git:git post-receive &amp;&amp; chmod 755 post-receive</code></pre></p>\n<p>为Hexo编写自动化脚本在仓库hooks创建脚本 <code>vi post-receive</code> ，脚本会在git有收发的时候就会调用执行<br><pre><code class=\"hljs undefined\">git <span class=\"hljs-attribute\">--work-tree</span>=/var/laochenpiBlog/blog.site <span class=\"hljs-attribute\">--git-dir</span>=/var/laochenpiBlog/blog.git checkout -f</code></pre></p>\n<h2 id=\"3-Hexo-配置发布测试\"><a href=\"#3-Hexo-配置发布测试\" class=\"headerlink\" title=\"3.Hexo 配置发布测试\"></a>3.Hexo 配置发布测试</h2><p>终于把Git环境弄好了，现在就需要修改配置文件<code>_config.yml</code> 中的发布项<br><pre><code class=\"hljs xml\">#Deployment\n## repo  为你的vps创建的库地址\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo : git@45.77.87.214:/var/laochenpiBlog/blog.git\n  branch: master</code></pre></p>\n<p>修改完毕，见证奇迹的时候到了，找到自己博客目录下用 <code>git bash</code>  发布<br> <pre><code class=\"hljs undefined\"><span class=\"hljs-meta\">#清除缓存  重编译  发布</span>\nhexo clean <span class=\"hljs-meta\">&amp;&amp; hexo g &amp;&amp; hexo d</span></code></pre></p>\n<p> <img src=\"/images/passwd.png\" srcset=\"/img/loading.gif\" alt=\"OpenSSH\"><br> 输入密码发布完毕，然后远程上你的VPS查看下你的 <code>blog.site</code> 是否自动 <code>check out</code>了最新发布的内容了。</p>\n<h2 id=\"4-Git-免密发布\"><a href=\"#4-Git-免密发布\" class=\"headerlink\" title=\"4.Git 免密发布\"></a>4.Git 免密发布</h2><p>每次发布都需要输入密码实在是太麻烦了而且在有可能泄露密码引起安全问题，有什么比较方面安全的方式呢，通过google一波发现可以通过秘钥的形式实现无密码发布登录。</p>\n<p>秘钥方式通过RSA加密生成公有秘钥，然后把公有秘钥提交到VPS 上的秘钥认证文件中 <code>authroized_keys</code>，修改 OpenSSH 客户端的配置 <code>sshd_config</code>  实现RSA秘钥认证方式。</p>\n<p>那么我们开始吧！</p>\n<ul>\n<li><h5 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h5>修改 OpenSSH 认证 <code>vi /etc/ssh/sshd_config</code><br>开启公钥认证 <code>PubkeyAuthentication yes</code><br>认证Keys文件目录 用户/.ssh/文件名 <code>AuthorizedKeysFile      .ssh/authorized_keys</code><br>RSA加密认证 <code>RSAAuthentication yes</code> </li>\n</ul>\n<p>这里要提示一点 Centos 7 和 Centos 6 遇到的问题，Centos 7 由于OpenSSH版本原因 RSAAuthentication 已经弃用，无需添加修改.<br><pre><code class=\"hljs undefined\"><span class=\"hljs-meta\">#用户提交的git用户的秘钥文件夹创建和权限分配#</span>\n——————————————————————————————————————\n<span class=\"hljs-meta\">#创建认证文件authorized_keys</span>\ntouch <span class=\"hljs-meta-keyword\">/home/</span>git/.ssh/authorized_keys\n<span class=\"hljs-meta\">#.ssh权限 700 authorized_keys 权限600</span>\nchmod <span class=\"hljs-number\">700</span> <span class=\"hljs-meta-keyword\">/home/</span>git/.ssh &amp;&amp; chmod <span class=\"hljs-number\">600</span> <span class=\"hljs-meta-keyword\">/home/</span>git/.ssh/authorize_keys\nchown -R  git:git <span class=\"hljs-meta-keyword\">/home/</span>git</code></pre></p>\n<p>这里要注意 <code>.ssh</code> 和 <code>authorize_keys</code> 的权限问题和所属用户，可能在加密认证的时候由于权限导致失败，SSH登录日志可以用 <code>tail /var/log/secure</code> 查看，<code>sshd -t</code>进行查看配置是否正常 需要在~目录下执行，执行<code>systemctl restart sshd</code> 重启 <code>SSH</code>服务</p>\n<ul>\n<li><h5 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h5><code>ssh-keygen -t rsa -C userName</code>  生成秘钥文件，地址一般在 <code>~/.ssh</code> 中。<br><code>id_rsa</code> 加密公钥 <code>id_rsa.pub</code> 加密公钥  多用户用<code>cat</code> 追加秘钥到认证文件中</li>\n</ul>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#上传认证秘钥到服务器上 对应用户的authorized_keys中</span>\ncat ~/.ssh/id_rsa.pub | ssh git@45.77.87.214 <span class=\"hljs-string\">\"cat - &gt;&gt; /home/git/.ssh/authorized_keys\"</span></code></pre>\n<p>配置完毕后使用 <code>ssh -vvT git@45.77.87.214</code> 看看是不是不用密码就可以登录VPS了，然后发布就再也不用密码了，一条命令就OK。</p>\n<h2 id=\"5-Nginx配置映射\"><a href=\"#5-Nginx配置映射\" class=\"headerlink\" title=\"5.  Nginx配置映射\"></a>5.  Nginx配置映射</h2><p>终于到最后一步了，就差最后一步配置 Nginx 服务映射静态文件了。<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#Centos yum源安装</span>\nyum install nginx\n<span class=\"hljs-comment\">#启动nginx服务</span>\nsystemctl start nginx\n<span class=\"hljs-comment\">#查看服务状态</span>\nsystemctl status nginx -l</code></pre></p>\n<p>这里有可能出现的问题：<br>1.无法从外网访问 检查下80端口是否开启，添加80端口<code>firewall-cmd --permanent --zone=public --add-port=80/tcp --permanent</code> 和 <code>firewall-cmd --reload</code> 重载配置<br>2.服务可能没有启动成功，排查下配置问题</p>\n<p>修改80端口默认映射库地址，<code>nginx -t</code>查看nginx配置文件地址  </p>\n<p><img src=\"/images/nginx.png\" srcset=\"/img/loading.gif\" alt=\"nginx configuration file path\"><br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#停止Nginx服务</span>\nsystemctl stop nginx\n<span class=\"hljs-comment\">#修改Nginx的配置文件root</span>\nvi /etc/nginx/nginx_conf\n<span class=\"hljs-comment\">#修改 root 配置hexo静态文件地址，即之前创建的静态文件地址</span>\nroot [hexo静态文件地址]\n<span class=\"hljs-comment\">#修改完毕退出 重启Nginx服务</span>\nsystemctl start nginx</code></pre></p>\n<p>修改完毕启动好服务然后通过外网访问你 VPS IP地址即可访问，大功告成以后可以在任意地方通过git提交的方式进行自动发布。请记得随时备份自己的重要文件以免丢失！</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>已配置秘钥但是SSH还是需要密码，相信很多小伙伴都遇到过，下面是可能原因</p>\n<ol>\n<li>查看sshd_config 配置文件是否正确开启了3个认证配置，更改后重启OpenSSH服务</li>\n<li>查看下ssh登录日志 排查下原因，可能是认证文件目录权限问题，<code>.shh 700</code> <code>authorized_key 600</code> 过大或者过小的权限都有可能导致认证是失败。</li>\n<li><code>authorized_key</code> 中秘钥千万千万不要直接从客户端直接复制过来，可能会有空格和其他转义一些特殊情况导致秘钥不正确。可通过 <code>cat</code>或<code>scp</code> 命令远程进行上传秘钥保证正确性。</li>\n<li>Centos 7 版本的 <code>OpenSSH</code> RSAAuthentication已经弃用无需设置、添加该设置可能导致启动异常。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/linux-1.jpg\" srcset=\"/img/loading.gif\" alt=\"Linux\"></p>\n<blockquote>\n<p>Hexo部署到github访问的速度较慢，所以想着把Hexo直接丢在自己VPS上去，部署一套git环境以后方便自动发布更新</p>\n</blockquote>\n<h2 id=\"1-Git-安装\"><a href=\"#1-Git-安装\" class=\"headerlink\" title=\"1.Git 安装\"></a>1.Git 安装</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#通常使用的方法下载git</span>\nyum -y install git\n<span class=\"hljs-comment\">#查看版本 这种下载一般不是最新的版本</span>\nyum --version</code></pre>\n<p>发现并不是最新版本逼死强迫症啊，只能通过下载最新git源码自行编译安装。<br>Git 的工作需要调用 <code>curl</code>，<code>zlib</code>，<code>openssl</code>，<code>expat</code>，<code>libiconv</code> 等库的代码，所以需要先安装这些依赖工具。在有 <code>yum</code> 的系统上（比如 Fedora）或者有 <code>apt-get</code> 的系统上（比如 Debian 体系），可以用   下面的命令安装：</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#卸载旧版本git</span>\nyum remove git\n<span class=\"hljs-comment\">#安装依赖环境</span>\nyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel\n<span class=\"hljs-comment\">#安装编译工具</span>\nyum install  gcc perl-ExtUtils-MakeMaker\n<span class=\"hljs-comment\">#下载最新版git</span>\nwget https://github.com/git/git/archive/v2.19.1.tar.gz\n<span class=\"hljs-comment\">#解压</span>\ntar -zxvf v2.18.0.tar.gz\n<span class=\"hljs-comment\">#进入解压文件夹</span>\n<span class=\"hljs-built_in\">cd</span> git-2.18.0\n<span class=\"hljs-comment\">#编译代码 perfix这里为赋值变量</span>\nmake prefix=/usr/<span class=\"hljs-built_in\">local</span>/git all\n<span class=\"hljs-comment\">#安装软件 </span>\nmake prefix=/usr/<span class=\"hljs-built_in\">local</span>/git install\n<span class=\"hljs-comment\">#清除编译数据</span>\nmake clean all\n<span class=\"hljs-comment\">#环境变量配置</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$PATH</span>:/usr/<span class=\"hljs-built_in\">local</span>/git/bin &gt;&gt;/etc/bashrc\n<span class=\"hljs-comment\">#生效环境变量</span>\n<span class=\"hljs-built_in\">source</span> /etc/bashrc</code></pre>\n<blockquote>\n<p>/etc/profile，/etc/bashrc 是系统全局环境变量设定 ~/.profile，~/.bashrc用户家目录下的私有环境变量设定</p>\n</blockquote>\n<h2 id=\"2-创建-git-仓库\"><a href=\"#2-创建-git-仓库\" class=\"headerlink\" title=\"2.创建 git 仓库\"></a>2.创建 git 仓库</h2><p>创建一个git库用来存放Hexo生成的html静态文件和相关资源，然后通过 post-receive 钩子函数进行自动执行脚本讲生成的资源checkout发布到nginx达到自动发布更新的功能。<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#创建git用户</span>\nadduser git\n<span class=\"hljs-comment\">#设置密码</span>\npasswd git\n<span class=\"hljs-comment\">#创建Hexo博客库 目录自行选择</span>\nmkdir laochenpiBlog &amp;&amp; chown git:git laochenpiBlog\n<span class=\"hljs-comment\">#laochenpiBlog目录下创建blog.git  --bare裸仓库 没有工作空间</span>\ngit init --bare blog.git &amp;&amp; chown git:git -R blog.git \n<span class=\"hljs-comment\">#laochenpiBlog 目录下创建静态网页库 </span>\nmkdir blog.site &amp;&amp; chown git:git blog.site\n<span class=\"hljs-comment\">#进入钩子函数目录</span>\n<span class=\"hljs-built_in\">cd</span> hooks/\n<span class=\"hljs-comment\">#创建钩子函数文件</span>\ntouch post-receive &amp;&amp; chown git:git post-receive &amp;&amp; chmod 755 post-receive</code></pre></p>\n<p>为Hexo编写自动化脚本在仓库hooks创建脚本 <code>vi post-receive</code> ，脚本会在git有收发的时候就会调用执行<br><pre><code class=\"hljs undefined\">git <span class=\"hljs-attribute\">--work-tree</span>=/var/laochenpiBlog/blog.site <span class=\"hljs-attribute\">--git-dir</span>=/var/laochenpiBlog/blog.git checkout -f</code></pre></p>\n<h2 id=\"3-Hexo-配置发布测试\"><a href=\"#3-Hexo-配置发布测试\" class=\"headerlink\" title=\"3.Hexo 配置发布测试\"></a>3.Hexo 配置发布测试</h2><p>终于把Git环境弄好了，现在就需要修改配置文件<code>_config.yml</code> 中的发布项<br><pre><code class=\"hljs xml\">#Deployment\n## repo  为你的vps创建的库地址\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo : git@45.77.87.214:/var/laochenpiBlog/blog.git\n  branch: master</code></pre></p>\n<p>修改完毕，见证奇迹的时候到了，找到自己博客目录下用 <code>git bash</code>  发布<br> <pre><code class=\"hljs undefined\"><span class=\"hljs-meta\">#清除缓存  重编译  发布</span>\nhexo clean <span class=\"hljs-meta\">&amp;&amp; hexo g &amp;&amp; hexo d</span></code></pre></p>\n<p> <img src=\"/images/passwd.png\" srcset=\"/img/loading.gif\" alt=\"OpenSSH\"><br> 输入密码发布完毕，然后远程上你的VPS查看下你的 <code>blog.site</code> 是否自动 <code>check out</code>了最新发布的内容了。</p>\n<h2 id=\"4-Git-免密发布\"><a href=\"#4-Git-免密发布\" class=\"headerlink\" title=\"4.Git 免密发布\"></a>4.Git 免密发布</h2><p>每次发布都需要输入密码实在是太麻烦了而且在有可能泄露密码引起安全问题，有什么比较方面安全的方式呢，通过google一波发现可以通过秘钥的形式实现无密码发布登录。</p>\n<p>秘钥方式通过RSA加密生成公有秘钥，然后把公有秘钥提交到VPS 上的秘钥认证文件中 <code>authroized_keys</code>，修改 OpenSSH 客户端的配置 <code>sshd_config</code>  实现RSA秘钥认证方式。</p>\n<p>那么我们开始吧！</p>\n<ul>\n<li><h5 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h5>修改 OpenSSH 认证 <code>vi /etc/ssh/sshd_config</code><br>开启公钥认证 <code>PubkeyAuthentication yes</code><br>认证Keys文件目录 用户/.ssh/文件名 <code>AuthorizedKeysFile      .ssh/authorized_keys</code><br>RSA加密认证 <code>RSAAuthentication yes</code> </li>\n</ul>\n<p>这里要提示一点 Centos 7 和 Centos 6 遇到的问题，Centos 7 由于OpenSSH版本原因 RSAAuthentication 已经弃用，无需添加修改.<br><pre><code class=\"hljs undefined\"><span class=\"hljs-meta\">#用户提交的git用户的秘钥文件夹创建和权限分配#</span>\n——————————————————————————————————————\n<span class=\"hljs-meta\">#创建认证文件authorized_keys</span>\ntouch <span class=\"hljs-meta-keyword\">/home/</span>git/.ssh/authorized_keys\n<span class=\"hljs-meta\">#.ssh权限 700 authorized_keys 权限600</span>\nchmod <span class=\"hljs-number\">700</span> <span class=\"hljs-meta-keyword\">/home/</span>git/.ssh &amp;&amp; chmod <span class=\"hljs-number\">600</span> <span class=\"hljs-meta-keyword\">/home/</span>git/.ssh/authorize_keys\nchown -R  git:git <span class=\"hljs-meta-keyword\">/home/</span>git</code></pre></p>\n<p>这里要注意 <code>.ssh</code> 和 <code>authorize_keys</code> 的权限问题和所属用户，可能在加密认证的时候由于权限导致失败，SSH登录日志可以用 <code>tail /var/log/secure</code> 查看，<code>sshd -t</code>进行查看配置是否正常 需要在~目录下执行，执行<code>systemctl restart sshd</code> 重启 <code>SSH</code>服务</p>\n<ul>\n<li><h5 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h5><code>ssh-keygen -t rsa -C userName</code>  生成秘钥文件，地址一般在 <code>~/.ssh</code> 中。<br><code>id_rsa</code> 加密公钥 <code>id_rsa.pub</code> 加密公钥  多用户用<code>cat</code> 追加秘钥到认证文件中</li>\n</ul>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#上传认证秘钥到服务器上 对应用户的authorized_keys中</span>\ncat ~/.ssh/id_rsa.pub | ssh git@45.77.87.214 <span class=\"hljs-string\">\"cat - &gt;&gt; /home/git/.ssh/authorized_keys\"</span></code></pre>\n<p>配置完毕后使用 <code>ssh -vvT git@45.77.87.214</code> 看看是不是不用密码就可以登录VPS了，然后发布就再也不用密码了，一条命令就OK。</p>\n<h2 id=\"5-Nginx配置映射\"><a href=\"#5-Nginx配置映射\" class=\"headerlink\" title=\"5.  Nginx配置映射\"></a>5.  Nginx配置映射</h2><p>终于到最后一步了，就差最后一步配置 Nginx 服务映射静态文件了。<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#Centos yum源安装</span>\nyum install nginx\n<span class=\"hljs-comment\">#启动nginx服务</span>\nsystemctl start nginx\n<span class=\"hljs-comment\">#查看服务状态</span>\nsystemctl status nginx -l</code></pre></p>\n<p>这里有可能出现的问题：<br>1.无法从外网访问 检查下80端口是否开启，添加80端口<code>firewall-cmd --permanent --zone=public --add-port=80/tcp --permanent</code> 和 <code>firewall-cmd --reload</code> 重载配置<br>2.服务可能没有启动成功，排查下配置问题</p>\n<p>修改80端口默认映射库地址，<code>nginx -t</code>查看nginx配置文件地址  </p>\n<p><img src=\"/images/nginx.png\" srcset=\"/img/loading.gif\" alt=\"nginx configuration file path\"><br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#停止Nginx服务</span>\nsystemctl stop nginx\n<span class=\"hljs-comment\">#修改Nginx的配置文件root</span>\nvi /etc/nginx/nginx_conf\n<span class=\"hljs-comment\">#修改 root 配置hexo静态文件地址，即之前创建的静态文件地址</span>\nroot [hexo静态文件地址]\n<span class=\"hljs-comment\">#修改完毕退出 重启Nginx服务</span>\nsystemctl start nginx</code></pre></p>\n<p>修改完毕启动好服务然后通过外网访问你 VPS IP地址即可访问，大功告成以后可以在任意地方通过git提交的方式进行自动发布。请记得随时备份自己的重要文件以免丢失！</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>已配置秘钥但是SSH还是需要密码，相信很多小伙伴都遇到过，下面是可能原因</p>\n<ol>\n<li>查看sshd_config 配置文件是否正确开启了3个认证配置，更改后重启OpenSSH服务</li>\n<li>查看下ssh登录日志 排查下原因，可能是认证文件目录权限问题，<code>.shh 700</code> <code>authorized_key 600</code> 过大或者过小的权限都有可能导致认证是失败。</li>\n<li><code>authorized_key</code> 中秘钥千万千万不要直接从客户端直接复制过来，可能会有空格和其他转义一些特殊情况导致秘钥不正确。可通过 <code>cat</code>或<code>scp</code> 命令远程进行上传秘钥保证正确性。</li>\n<li>Centos 7 版本的 <code>OpenSSH</code> RSAAuthentication已经弃用无需设置、添加该设置可能导致启动异常。</li>\n</ol>\n"},{"title":"Chrome Extension 开发笔记","toc":false,"date":"2020-01-17T07:22:32.000Z","_content":"\n> 之前一会有用 Chrome　扩展程序但是一直不知道原因和开发，想着平时逛逛 Nga 各种不想看的栏目和广告背景想着自己做一个插件来提升下使用体验\n\n![](/images/chrome-extension.png)\n\n## Chrome Extension \n谷歌扩展程序是由 html、css、js 等资源组成的一个`.crx` 资源包，可以依附于浏览器修改页面修改自定义页面`css`样式，注入或调用页面的`js`达到一些特殊功能。\n\n谷歌插件提供了丰富的API\n- 书签控制\n- 网络请求控制监听，可以自定义修改请求头\n- 下载控制\n- 弹窗功能\n- 通信功能\n- 云同步存储 `chrome.stroage`\n\n## 项目结构\n### manifest.json\n`manifest.json`是谷歌插件的核心配置中心，包含了插件的各种配置，详细可以参考[官方文档](https://developer.chrome.com/extensions/manifest)\n\n``` json\n{\n  \"manifest_version\": 2,\n  \"name\": \"Nga大漩涡\",\n  \"version\": \"1.0\",\n  \"description\": \"Nga 论坛广告屏蔽,浏览增强\",\n  \"author\": \"李时珍老陈皮\",\n  \"icons\": {\n    \"48\": \"img/icon.png\",\n    \"128\": \"img/icon.png\"\n  },\n  \"browser_action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_popup\": \"popup.html\"\n  },\n  \"content_scripts\":\n  [\n    {\n      // \"<all_urls>\" 表示匹配所有地址\n      \"matches\": [\"https://ngabbs.com/*\",\"https://bbs.nga.cn/*\"],\n      // 多个JS按顺序注入\n      \"js\": [\"js/jquery-1.8.3.js\", \"js/nga.js\"],\n      // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式\n      \"css\": [\"css/nga.css\"],\n      // 代码注入的时间，可选值： \"document_start\", \"document_end\", or \"document_idle\"，最后一个表示页面空闲时，默认document_idle\n      \"run_at\": \"document_end\"\n    }\n  ],\n  \"permissions\": [\n    // 右键菜单\n    \"contextMenus\",\n    // 标签\n    \"tabs\",\n    // 通知\n    \"notifications\",\n    // web请求\n    \"webRequest\",\n    // 阻塞式web请求\n    \"webRequestBlocking\",\n    // 插件本地存储\n    \"storage\",\n    // 可以通过executeScript或者insertCSS访问的网站\n    \"http://*/*\",\n    // 可以通过executeScript或者insertCSS访问的网站\n    \"https://*/*\"\n  ],\n  // 后台运行脚本页\n  \"background\": {\n    \"page\": \"background.html\"\n  }, \n  // web 访问的资源列表\n  \"web_accessible_resources\": [\n    \"js/inject/nga.inject.js\"\n  ]\n}\n```\n\n\n#### popup\n`popup`是在点击插件图标弹出页面，当鼠标失去焦点后立即关闭生命周期较短所以用于做一些临时交互例如数据的展示查询等\n\n![翻译插件](/images/translationCrx.png)\n\n#### content_scripts\n`content_scripts` 我们可以通过配置向指定页面或者所有页面注入自定义`css`和`js`，`matches`用于配置需要注入的页面，`<all_urls>`表示注入所有无限制，`js`配置脚本列表会根据__顺序__注入，`run_at`配置注入的时间可选`document_start`、 `document_end`、 `document_idle`，默认值为`document_idle`。\n\n> 注意：`content_scripts` 可以访问到页面所有的`DOM`对象，但是无法访问页面`js`对象和函数，它的运行环境与页面运行不在同一环境位面，当我们需要访问页面的函数或者对象时可在`content_scripts`通过使用`DOM`操作像源页面注入脚本。\n``` javascript\nfunction injectJs(path) {\n    let temp = document.createElement('script');\n    temp.setAttribute('type', 'text/javascript');\n    temp.src = chrome.extension.getURL(path);\n    document.head.appendChild(temp);\n}\n```\n可以通过`F12`查看页面元素找到我们注入的脚本与原始页面属于同一运行环境即访问调用同一环境下的所有函数和对象。\n> 注意：注入脚本需要配置声明访问权限 `web_accessible_resources`，否则无法访问\n\n#### background\n`background` 后台脚本生命周期是所有脚本最长的，一直运行在浏览器后台当浏览器关闭时才结束，常用与一些需要长时间运行的脚本，通过`background`配置`page`页面或者`scripts`。\n\n> `background` 可以访问几乎所有的 Api 且能__无限跨域__！，鉴于`backgroud`生命周期过长，长时间占用资源可能导致性能问题，可配置`persistent`为`false`，在被需求依赖时才加载空闲时消亡\n\n#### contextMenus\n右键菜单可以更丰富的操作习惯，例如翻译插件选中一段文字右键可以进行选中翻译，主要通过`chrome.centextMenus` Api 实现，我就想想在逛论坛遇到喜欢的傻吊图右键一键保存岂不是方便多了，代码如下\n``` javascript\n// background.js\nchrome.contextMenus.create({\n\ttype: 'normal'， // 类型，可选：[\"normal\", \"checkbox\", \"radio\", \"separator\"]，默认 normal\n\ttitle: '菜单的名字', // 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本\n\tcontexts: ['page'], // 上下文环境，可选：[\"all\", \"page\", \"frame\", \"selection\", \"link\", \"editable\", \"image\", \"video\", \"audio\"]，默认page\n\tonclick: function(){}, // 单击时触发的方法\n\tparentId: 1, // 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单\n\tdocumentUrlPatterns: 'https://*.baidu.com/*' // 只在某些页面显示此右键菜单\n});\n// 删除某一个菜单项\nchrome.contextMenus.remove(menuItemId)；\n// 删除所有自定义右键菜单\nchrome.contextMenus.removeAll();\n// 更新某一个菜单项\nchrome.contextMenus.update(menuItemId, updateProperties);\n```\n这里只是简单列举一些常用的，完整API参见：https://developer.chrome.com/extensions/contextMenus\n\n\n","source":"_posts/Chrome-Extension-开发笔记.md","raw":"---\ntitle: Chrome Extension 开发笔记\ntags: []\ncategories: [java]\ntoc: false\ndate: 2020-01-17 15:22:32\n---\n\n> 之前一会有用 Chrome　扩展程序但是一直不知道原因和开发，想着平时逛逛 Nga 各种不想看的栏目和广告背景想着自己做一个插件来提升下使用体验\n\n![](/images/chrome-extension.png)\n\n## Chrome Extension \n谷歌扩展程序是由 html、css、js 等资源组成的一个`.crx` 资源包，可以依附于浏览器修改页面修改自定义页面`css`样式，注入或调用页面的`js`达到一些特殊功能。\n\n谷歌插件提供了丰富的API\n- 书签控制\n- 网络请求控制监听，可以自定义修改请求头\n- 下载控制\n- 弹窗功能\n- 通信功能\n- 云同步存储 `chrome.stroage`\n\n## 项目结构\n### manifest.json\n`manifest.json`是谷歌插件的核心配置中心，包含了插件的各种配置，详细可以参考[官方文档](https://developer.chrome.com/extensions/manifest)\n\n``` json\n{\n  \"manifest_version\": 2,\n  \"name\": \"Nga大漩涡\",\n  \"version\": \"1.0\",\n  \"description\": \"Nga 论坛广告屏蔽,浏览增强\",\n  \"author\": \"李时珍老陈皮\",\n  \"icons\": {\n    \"48\": \"img/icon.png\",\n    \"128\": \"img/icon.png\"\n  },\n  \"browser_action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_popup\": \"popup.html\"\n  },\n  \"content_scripts\":\n  [\n    {\n      // \"<all_urls>\" 表示匹配所有地址\n      \"matches\": [\"https://ngabbs.com/*\",\"https://bbs.nga.cn/*\"],\n      // 多个JS按顺序注入\n      \"js\": [\"js/jquery-1.8.3.js\", \"js/nga.js\"],\n      // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式\n      \"css\": [\"css/nga.css\"],\n      // 代码注入的时间，可选值： \"document_start\", \"document_end\", or \"document_idle\"，最后一个表示页面空闲时，默认document_idle\n      \"run_at\": \"document_end\"\n    }\n  ],\n  \"permissions\": [\n    // 右键菜单\n    \"contextMenus\",\n    // 标签\n    \"tabs\",\n    // 通知\n    \"notifications\",\n    // web请求\n    \"webRequest\",\n    // 阻塞式web请求\n    \"webRequestBlocking\",\n    // 插件本地存储\n    \"storage\",\n    // 可以通过executeScript或者insertCSS访问的网站\n    \"http://*/*\",\n    // 可以通过executeScript或者insertCSS访问的网站\n    \"https://*/*\"\n  ],\n  // 后台运行脚本页\n  \"background\": {\n    \"page\": \"background.html\"\n  }, \n  // web 访问的资源列表\n  \"web_accessible_resources\": [\n    \"js/inject/nga.inject.js\"\n  ]\n}\n```\n\n\n#### popup\n`popup`是在点击插件图标弹出页面，当鼠标失去焦点后立即关闭生命周期较短所以用于做一些临时交互例如数据的展示查询等\n\n![翻译插件](/images/translationCrx.png)\n\n#### content_scripts\n`content_scripts` 我们可以通过配置向指定页面或者所有页面注入自定义`css`和`js`，`matches`用于配置需要注入的页面，`<all_urls>`表示注入所有无限制，`js`配置脚本列表会根据__顺序__注入，`run_at`配置注入的时间可选`document_start`、 `document_end`、 `document_idle`，默认值为`document_idle`。\n\n> 注意：`content_scripts` 可以访问到页面所有的`DOM`对象，但是无法访问页面`js`对象和函数，它的运行环境与页面运行不在同一环境位面，当我们需要访问页面的函数或者对象时可在`content_scripts`通过使用`DOM`操作像源页面注入脚本。\n``` javascript\nfunction injectJs(path) {\n    let temp = document.createElement('script');\n    temp.setAttribute('type', 'text/javascript');\n    temp.src = chrome.extension.getURL(path);\n    document.head.appendChild(temp);\n}\n```\n可以通过`F12`查看页面元素找到我们注入的脚本与原始页面属于同一运行环境即访问调用同一环境下的所有函数和对象。\n> 注意：注入脚本需要配置声明访问权限 `web_accessible_resources`，否则无法访问\n\n#### background\n`background` 后台脚本生命周期是所有脚本最长的，一直运行在浏览器后台当浏览器关闭时才结束，常用与一些需要长时间运行的脚本，通过`background`配置`page`页面或者`scripts`。\n\n> `background` 可以访问几乎所有的 Api 且能__无限跨域__！，鉴于`backgroud`生命周期过长，长时间占用资源可能导致性能问题，可配置`persistent`为`false`，在被需求依赖时才加载空闲时消亡\n\n#### contextMenus\n右键菜单可以更丰富的操作习惯，例如翻译插件选中一段文字右键可以进行选中翻译，主要通过`chrome.centextMenus` Api 实现，我就想想在逛论坛遇到喜欢的傻吊图右键一键保存岂不是方便多了，代码如下\n``` javascript\n// background.js\nchrome.contextMenus.create({\n\ttype: 'normal'， // 类型，可选：[\"normal\", \"checkbox\", \"radio\", \"separator\"]，默认 normal\n\ttitle: '菜单的名字', // 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本\n\tcontexts: ['page'], // 上下文环境，可选：[\"all\", \"page\", \"frame\", \"selection\", \"link\", \"editable\", \"image\", \"video\", \"audio\"]，默认page\n\tonclick: function(){}, // 单击时触发的方法\n\tparentId: 1, // 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单\n\tdocumentUrlPatterns: 'https://*.baidu.com/*' // 只在某些页面显示此右键菜单\n});\n// 删除某一个菜单项\nchrome.contextMenus.remove(menuItemId)；\n// 删除所有自定义右键菜单\nchrome.contextMenus.removeAll();\n// 更新某一个菜单项\nchrome.contextMenus.update(menuItemId, updateProperties);\n```\n这里只是简单列举一些常用的，完整API参见：https://developer.chrome.com/extensions/contextMenus\n\n\n","slug":"Chrome-Extension-开发笔记","published":1,"updated":"2020-11-18T03:21:12.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc96r000ajsudwpxbtw4t","content":"<blockquote>\n<p>之前一会有用 Chrome　扩展程序但是一直不知道原因和开发，想着平时逛逛 Nga 各种不想看的栏目和广告背景想着自己做一个插件来提升下使用体验</p>\n</blockquote>\n<p><img src=\"/images/chrome-extension.png\" srcset=\"/img/loading.gif\" alt></p>\n<h2 id=\"Chrome-Extension\"><a href=\"#Chrome-Extension\" class=\"headerlink\" title=\"Chrome Extension\"></a>Chrome Extension</h2><p>谷歌扩展程序是由 html、css、js 等资源组成的一个<code>.crx</code> 资源包，可以依附于浏览器修改页面修改自定义页面<code>css</code>样式，注入或调用页面的<code>js</code>达到一些特殊功能。</p>\n<p>谷歌插件提供了丰富的API</p>\n<ul>\n<li>书签控制</li>\n<li>网络请求控制监听，可以自定义修改请求头</li>\n<li>下载控制</li>\n<li>弹窗功能</li>\n<li>通信功能</li>\n<li>云同步存储 <code>chrome.stroage</code></li>\n</ul>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><h3 id=\"manifest-json\"><a href=\"#manifest-json\" class=\"headerlink\" title=\"manifest.json\"></a>manifest.json</h3><p><code>manifest.json</code>是谷歌插件的核心配置中心，包含了插件的各种配置，详细可以参考<a href=\"https://developer.chrome.com/extensions/manifest\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">\"manifest_version\"</span>: <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"Nga大漩涡\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"1.0\"</span>,\n  <span class=\"hljs-attr\">\"description\"</span>: <span class=\"hljs-string\">\"Nga 论坛广告屏蔽,浏览增强\"</span>,\n  <span class=\"hljs-attr\">\"author\"</span>: <span class=\"hljs-string\">\"李时珍老陈皮\"</span>,\n  <span class=\"hljs-attr\">\"icons\"</span>: &#123;\n    <span class=\"hljs-attr\">\"48\"</span>: <span class=\"hljs-string\">\"img/icon.png\"</span>,\n    <span class=\"hljs-attr\">\"128\"</span>: <span class=\"hljs-string\">\"img/icon.png\"</span>\n  &#125;,\n  <span class=\"hljs-attr\">\"browser_action\"</span>: &#123;\n    <span class=\"hljs-attr\">\"default_icon\"</span>: <span class=\"hljs-string\">\"img/icon.png\"</span>,\n    <span class=\"hljs-attr\">\"default_popup\"</span>: <span class=\"hljs-string\">\"popup.html\"</span>\n  &#125;,\n  <span class=\"hljs-attr\">\"content_scripts\"</span>:\n  [\n    &#123;\n      <span class=\"hljs-comment\">// \"&lt;all_urls&gt;\" 表示匹配所有地址</span>\n      <span class=\"hljs-attr\">\"matches\"</span>: [<span class=\"hljs-string\">\"https://ngabbs.com/*\"</span>,<span class=\"hljs-string\">\"https://bbs.nga.cn/*\"</span>],\n      <span class=\"hljs-comment\">// 多个JS按顺序注入</span>\n      <span class=\"hljs-attr\">\"js\"</span>: [<span class=\"hljs-string\">\"js/jquery-1.8.3.js\"</span>, <span class=\"hljs-string\">\"js/nga.js\"</span>],\n      <span class=\"hljs-comment\">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span>\n      <span class=\"hljs-attr\">\"css\"</span>: [<span class=\"hljs-string\">\"css/nga.css\"</span>],\n      <span class=\"hljs-comment\">// 代码注入的时间，可选值： \"document_start\", \"document_end\", or \"document_idle\"，最后一个表示页面空闲时，默认document_idle</span>\n      <span class=\"hljs-attr\">\"run_at\"</span>: <span class=\"hljs-string\">\"document_end\"</span>\n    &#125;\n  ],\n  <span class=\"hljs-attr\">\"permissions\"</span>: [\n    <span class=\"hljs-comment\">// 右键菜单</span>\n    <span class=\"hljs-string\">\"contextMenus\"</span>,\n    <span class=\"hljs-comment\">// 标签</span>\n    <span class=\"hljs-string\">\"tabs\"</span>,\n    <span class=\"hljs-comment\">// 通知</span>\n    <span class=\"hljs-string\">\"notifications\"</span>,\n    <span class=\"hljs-comment\">// web请求</span>\n    <span class=\"hljs-string\">\"webRequest\"</span>,\n    <span class=\"hljs-comment\">// 阻塞式web请求</span>\n    <span class=\"hljs-string\">\"webRequestBlocking\"</span>,\n    <span class=\"hljs-comment\">// 插件本地存储</span>\n    <span class=\"hljs-string\">\"storage\"</span>,\n    <span class=\"hljs-comment\">// 可以通过executeScript或者insertCSS访问的网站</span>\n    <span class=\"hljs-string\">\"http://*/*\"</span>,\n    <span class=\"hljs-comment\">// 可以通过executeScript或者insertCSS访问的网站</span>\n    <span class=\"hljs-string\">\"https://*/*\"</span>\n  ],\n  <span class=\"hljs-comment\">// 后台运行脚本页</span>\n  <span class=\"hljs-attr\">\"background\"</span>: &#123;\n    <span class=\"hljs-attr\">\"page\"</span>: <span class=\"hljs-string\">\"background.html\"</span>\n  &#125;, \n  <span class=\"hljs-comment\">// web 访问的资源列表</span>\n  <span class=\"hljs-attr\">\"web_accessible_resources\"</span>: [\n    <span class=\"hljs-string\">\"js/inject/nga.inject.js\"</span>\n  ]\n&#125;</code></pre>\n<h4 id=\"popup\"><a href=\"#popup\" class=\"headerlink\" title=\"popup\"></a>popup</h4><p><code>popup</code>是在点击插件图标弹出页面，当鼠标失去焦点后立即关闭生命周期较短所以用于做一些临时交互例如数据的展示查询等</p>\n<p><img src=\"/images/translationCrx.png\" srcset=\"/img/loading.gif\" alt=\"翻译插件\"></p>\n<h4 id=\"content-scripts\"><a href=\"#content-scripts\" class=\"headerlink\" title=\"content_scripts\"></a>content_scripts</h4><p><code>content_scripts</code> 我们可以通过配置向指定页面或者所有页面注入自定义<code>css</code>和<code>js</code>，<code>matches</code>用于配置需要注入的页面，<code>&lt;all_urls&gt;</code>表示注入所有无限制，<code>js</code>配置脚本列表会根据<strong>顺序</strong>注入，<code>run_at</code>配置注入的时间可选<code>document_start</code>、 <code>document_end</code>、 <code>document_idle</code>，默认值为<code>document_idle</code>。</p>\n<blockquote>\n<p>注意：<code>content_scripts</code> 可以访问到页面所有的<code>DOM</code>对象，但是无法访问页面<code>js</code>对象和函数，它的运行环境与页面运行不在同一环境位面，当我们需要访问页面的函数或者对象时可在<code>content_scripts</code>通过使用<code>DOM</code>操作像源页面注入脚本。<br><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">injectJs</span>(<span class=\"hljs-params\">path</span>) </span>&#123;\n    <span class=\"hljs-keyword\">let</span> temp = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'script'</span>);\n    temp.setAttribute(<span class=\"hljs-string\">'type'</span>, <span class=\"hljs-string\">'text/javascript'</span>);\n    temp.src = chrome.extension.getURL(path);\n    <span class=\"hljs-built_in\">document</span>.head.appendChild(temp);\n&#125;</code></pre></p>\n</blockquote>\n<p>可以通过<code>F12</code>查看页面元素找到我们注入的脚本与原始页面属于同一运行环境即访问调用同一环境下的所有函数和对象。</p>\n<blockquote>\n<p>注意：注入脚本需要配置声明访问权限 <code>web_accessible_resources</code>，否则无法访问</p>\n</blockquote>\n<h4 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h4><p><code>background</code> 后台脚本生命周期是所有脚本最长的，一直运行在浏览器后台当浏览器关闭时才结束，常用与一些需要长时间运行的脚本，通过<code>background</code>配置<code>page</code>页面或者<code>scripts</code>。</p>\n<blockquote>\n<p><code>background</code> 可以访问几乎所有的 Api 且能<strong>无限跨域</strong>！，鉴于<code>backgroud</code>生命周期过长，长时间占用资源可能导致性能问题，可配置<code>persistent</code>为<code>false</code>，在被需求依赖时才加载空闲时消亡</p>\n</blockquote>\n<h4 id=\"contextMenus\"><a href=\"#contextMenus\" class=\"headerlink\" title=\"contextMenus\"></a>contextMenus</h4><p>右键菜单可以更丰富的操作习惯，例如翻译插件选中一段文字右键可以进行选中翻译，主要通过<code>chrome.centextMenus</code> Api 实现，我就想想在逛论坛遇到喜欢的傻吊图右键一键保存岂不是方便多了，代码如下<br><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// background.js</span>\nchrome.contextMenus.create(&#123;\n\t<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'normal'</span>， <span class=\"hljs-comment\">// 类型，可选：[\"normal\", \"checkbox\", \"radio\", \"separator\"]，默认 normal</span>\n\t<span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'菜单的名字'</span>, <span class=\"hljs-comment\">// 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本</span>\n\t<span class=\"hljs-attr\">contexts</span>: [<span class=\"hljs-string\">'page'</span>], <span class=\"hljs-comment\">// 上下文环境，可选：[\"all\", \"page\", \"frame\", \"selection\", \"link\", \"editable\", \"image\", \"video\", \"audio\"]，默认page</span>\n\t<span class=\"hljs-attr\">onclick</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125;, <span class=\"hljs-comment\">// 单击时触发的方法</span>\n\t<span class=\"hljs-attr\">parentId</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单</span>\n\t<span class=\"hljs-attr\">documentUrlPatterns</span>: <span class=\"hljs-string\">'https://*.baidu.com/*'</span> <span class=\"hljs-comment\">// 只在某些页面显示此右键菜单</span>\n&#125;);\n<span class=\"hljs-comment\">// 删除某一个菜单项</span>\nchrome.contextMenus.remove(menuItemId)；\n<span class=\"hljs-comment\">// 删除所有自定义右键菜单</span>\nchrome.contextMenus.removeAll();\n<span class=\"hljs-comment\">// 更新某一个菜单项</span>\nchrome.contextMenus.update(menuItemId, updateProperties);</code></pre></p>\n<p>这里只是简单列举一些常用的，完整API参见：<a href=\"https://developer.chrome.com/extensions/contextMenus\" target=\"_blank\" rel=\"noopener\">https://developer.chrome.com/extensions/contextMenus</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>之前一会有用 Chrome　扩展程序但是一直不知道原因和开发，想着平时逛逛 Nga 各种不想看的栏目和广告背景想着自己做一个插件来提升下使用体验</p>\n</blockquote>\n<p><img src=\"/images/chrome-extension.png\" srcset=\"/img/loading.gif\" alt></p>\n<h2 id=\"Chrome-Extension\"><a href=\"#Chrome-Extension\" class=\"headerlink\" title=\"Chrome Extension\"></a>Chrome Extension</h2><p>谷歌扩展程序是由 html、css、js 等资源组成的一个<code>.crx</code> 资源包，可以依附于浏览器修改页面修改自定义页面<code>css</code>样式，注入或调用页面的<code>js</code>达到一些特殊功能。</p>\n<p>谷歌插件提供了丰富的API</p>\n<ul>\n<li>书签控制</li>\n<li>网络请求控制监听，可以自定义修改请求头</li>\n<li>下载控制</li>\n<li>弹窗功能</li>\n<li>通信功能</li>\n<li>云同步存储 <code>chrome.stroage</code></li>\n</ul>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><h3 id=\"manifest-json\"><a href=\"#manifest-json\" class=\"headerlink\" title=\"manifest.json\"></a>manifest.json</h3><p><code>manifest.json</code>是谷歌插件的核心配置中心，包含了插件的各种配置，详细可以参考<a href=\"https://developer.chrome.com/extensions/manifest\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">\"manifest_version\"</span>: <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"Nga大漩涡\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"1.0\"</span>,\n  <span class=\"hljs-attr\">\"description\"</span>: <span class=\"hljs-string\">\"Nga 论坛广告屏蔽,浏览增强\"</span>,\n  <span class=\"hljs-attr\">\"author\"</span>: <span class=\"hljs-string\">\"李时珍老陈皮\"</span>,\n  <span class=\"hljs-attr\">\"icons\"</span>: &#123;\n    <span class=\"hljs-attr\">\"48\"</span>: <span class=\"hljs-string\">\"img/icon.png\"</span>,\n    <span class=\"hljs-attr\">\"128\"</span>: <span class=\"hljs-string\">\"img/icon.png\"</span>\n  &#125;,\n  <span class=\"hljs-attr\">\"browser_action\"</span>: &#123;\n    <span class=\"hljs-attr\">\"default_icon\"</span>: <span class=\"hljs-string\">\"img/icon.png\"</span>,\n    <span class=\"hljs-attr\">\"default_popup\"</span>: <span class=\"hljs-string\">\"popup.html\"</span>\n  &#125;,\n  <span class=\"hljs-attr\">\"content_scripts\"</span>:\n  [\n    &#123;\n      <span class=\"hljs-comment\">// \"&lt;all_urls&gt;\" 表示匹配所有地址</span>\n      <span class=\"hljs-attr\">\"matches\"</span>: [<span class=\"hljs-string\">\"https://ngabbs.com/*\"</span>,<span class=\"hljs-string\">\"https://bbs.nga.cn/*\"</span>],\n      <span class=\"hljs-comment\">// 多个JS按顺序注入</span>\n      <span class=\"hljs-attr\">\"js\"</span>: [<span class=\"hljs-string\">\"js/jquery-1.8.3.js\"</span>, <span class=\"hljs-string\">\"js/nga.js\"</span>],\n      <span class=\"hljs-comment\">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span>\n      <span class=\"hljs-attr\">\"css\"</span>: [<span class=\"hljs-string\">\"css/nga.css\"</span>],\n      <span class=\"hljs-comment\">// 代码注入的时间，可选值： \"document_start\", \"document_end\", or \"document_idle\"，最后一个表示页面空闲时，默认document_idle</span>\n      <span class=\"hljs-attr\">\"run_at\"</span>: <span class=\"hljs-string\">\"document_end\"</span>\n    &#125;\n  ],\n  <span class=\"hljs-attr\">\"permissions\"</span>: [\n    <span class=\"hljs-comment\">// 右键菜单</span>\n    <span class=\"hljs-string\">\"contextMenus\"</span>,\n    <span class=\"hljs-comment\">// 标签</span>\n    <span class=\"hljs-string\">\"tabs\"</span>,\n    <span class=\"hljs-comment\">// 通知</span>\n    <span class=\"hljs-string\">\"notifications\"</span>,\n    <span class=\"hljs-comment\">// web请求</span>\n    <span class=\"hljs-string\">\"webRequest\"</span>,\n    <span class=\"hljs-comment\">// 阻塞式web请求</span>\n    <span class=\"hljs-string\">\"webRequestBlocking\"</span>,\n    <span class=\"hljs-comment\">// 插件本地存储</span>\n    <span class=\"hljs-string\">\"storage\"</span>,\n    <span class=\"hljs-comment\">// 可以通过executeScript或者insertCSS访问的网站</span>\n    <span class=\"hljs-string\">\"http://*/*\"</span>,\n    <span class=\"hljs-comment\">// 可以通过executeScript或者insertCSS访问的网站</span>\n    <span class=\"hljs-string\">\"https://*/*\"</span>\n  ],\n  <span class=\"hljs-comment\">// 后台运行脚本页</span>\n  <span class=\"hljs-attr\">\"background\"</span>: &#123;\n    <span class=\"hljs-attr\">\"page\"</span>: <span class=\"hljs-string\">\"background.html\"</span>\n  &#125;, \n  <span class=\"hljs-comment\">// web 访问的资源列表</span>\n  <span class=\"hljs-attr\">\"web_accessible_resources\"</span>: [\n    <span class=\"hljs-string\">\"js/inject/nga.inject.js\"</span>\n  ]\n&#125;</code></pre>\n<h4 id=\"popup\"><a href=\"#popup\" class=\"headerlink\" title=\"popup\"></a>popup</h4><p><code>popup</code>是在点击插件图标弹出页面，当鼠标失去焦点后立即关闭生命周期较短所以用于做一些临时交互例如数据的展示查询等</p>\n<p><img src=\"/images/translationCrx.png\" srcset=\"/img/loading.gif\" alt=\"翻译插件\"></p>\n<h4 id=\"content-scripts\"><a href=\"#content-scripts\" class=\"headerlink\" title=\"content_scripts\"></a>content_scripts</h4><p><code>content_scripts</code> 我们可以通过配置向指定页面或者所有页面注入自定义<code>css</code>和<code>js</code>，<code>matches</code>用于配置需要注入的页面，<code>&lt;all_urls&gt;</code>表示注入所有无限制，<code>js</code>配置脚本列表会根据<strong>顺序</strong>注入，<code>run_at</code>配置注入的时间可选<code>document_start</code>、 <code>document_end</code>、 <code>document_idle</code>，默认值为<code>document_idle</code>。</p>\n<blockquote>\n<p>注意：<code>content_scripts</code> 可以访问到页面所有的<code>DOM</code>对象，但是无法访问页面<code>js</code>对象和函数，它的运行环境与页面运行不在同一环境位面，当我们需要访问页面的函数或者对象时可在<code>content_scripts</code>通过使用<code>DOM</code>操作像源页面注入脚本。<br><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">injectJs</span>(<span class=\"hljs-params\">path</span>) </span>&#123;\n    <span class=\"hljs-keyword\">let</span> temp = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'script'</span>);\n    temp.setAttribute(<span class=\"hljs-string\">'type'</span>, <span class=\"hljs-string\">'text/javascript'</span>);\n    temp.src = chrome.extension.getURL(path);\n    <span class=\"hljs-built_in\">document</span>.head.appendChild(temp);\n&#125;</code></pre></p>\n</blockquote>\n<p>可以通过<code>F12</code>查看页面元素找到我们注入的脚本与原始页面属于同一运行环境即访问调用同一环境下的所有函数和对象。</p>\n<blockquote>\n<p>注意：注入脚本需要配置声明访问权限 <code>web_accessible_resources</code>，否则无法访问</p>\n</blockquote>\n<h4 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h4><p><code>background</code> 后台脚本生命周期是所有脚本最长的，一直运行在浏览器后台当浏览器关闭时才结束，常用与一些需要长时间运行的脚本，通过<code>background</code>配置<code>page</code>页面或者<code>scripts</code>。</p>\n<blockquote>\n<p><code>background</code> 可以访问几乎所有的 Api 且能<strong>无限跨域</strong>！，鉴于<code>backgroud</code>生命周期过长，长时间占用资源可能导致性能问题，可配置<code>persistent</code>为<code>false</code>，在被需求依赖时才加载空闲时消亡</p>\n</blockquote>\n<h4 id=\"contextMenus\"><a href=\"#contextMenus\" class=\"headerlink\" title=\"contextMenus\"></a>contextMenus</h4><p>右键菜单可以更丰富的操作习惯，例如翻译插件选中一段文字右键可以进行选中翻译，主要通过<code>chrome.centextMenus</code> Api 实现，我就想想在逛论坛遇到喜欢的傻吊图右键一键保存岂不是方便多了，代码如下<br><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// background.js</span>\nchrome.contextMenus.create(&#123;\n\t<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'normal'</span>， <span class=\"hljs-comment\">// 类型，可选：[\"normal\", \"checkbox\", \"radio\", \"separator\"]，默认 normal</span>\n\t<span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'菜单的名字'</span>, <span class=\"hljs-comment\">// 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本</span>\n\t<span class=\"hljs-attr\">contexts</span>: [<span class=\"hljs-string\">'page'</span>], <span class=\"hljs-comment\">// 上下文环境，可选：[\"all\", \"page\", \"frame\", \"selection\", \"link\", \"editable\", \"image\", \"video\", \"audio\"]，默认page</span>\n\t<span class=\"hljs-attr\">onclick</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;&#125;, <span class=\"hljs-comment\">// 单击时触发的方法</span>\n\t<span class=\"hljs-attr\">parentId</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单</span>\n\t<span class=\"hljs-attr\">documentUrlPatterns</span>: <span class=\"hljs-string\">'https://*.baidu.com/*'</span> <span class=\"hljs-comment\">// 只在某些页面显示此右键菜单</span>\n&#125;);\n<span class=\"hljs-comment\">// 删除某一个菜单项</span>\nchrome.contextMenus.remove(menuItemId)；\n<span class=\"hljs-comment\">// 删除所有自定义右键菜单</span>\nchrome.contextMenus.removeAll();\n<span class=\"hljs-comment\">// 更新某一个菜单项</span>\nchrome.contextMenus.update(menuItemId, updateProperties);</code></pre></p>\n<p>这里只是简单列举一些常用的，完整API参见：<a href=\"https://developer.chrome.com/extensions/contextMenus\" target=\"_blank\" rel=\"noopener\">https://developer.chrome.com/extensions/contextMenus</a></p>\n"},{"title":"Http 知识","toc":false,"date":"2019-04-24T07:23:55.000Z","_content":"\n![](/images/http.jpg)\n\n> 记录一些常用的 Http 知识用于以后回来查询复习了解\n\n### Http 状态码\n当你请求服务器后会返回各种`Http`状态码用于表示请求状态，最常见的有`404`、`500`、`200`、`304`\n\n- ### 2XX 成功处理请求\n200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 \n201   （已创建）  请求成功并且服务器创建了新的资源。 \n202   （已接受）  服务器已接受请求，但尚未处理。 \n203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。 \n204   （无内容）  服务器成功处理了请求，但没有返回任何内容。 \n205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。\n206   （部分内容）  服务器成功处理了部分 GET 请求。\n- ### 3XX 请求完成，需要进一步操作\n300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 \n301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\n302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。\n304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 \n305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 \n307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n- ### 4XX 请求错误，无法处理\n400   （错误请求） 服务器不理解请求的语法。 \n401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 \n403   （禁止） 服务器拒绝请求。\n404   （未找到） 服务器找不到请求的网页。\n405   （方法禁用） 禁用请求中指定的方法。 \n406   （不接受） 无法使用请求的内容特性响应请求的网页。 \n407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。\n408   （请求超时）  服务器等候请求时发生超时。 \n409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 \n410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 \n411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 \n412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 \n413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 \n414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 \n415   （不支持的媒体类型） 请求的格式不受请求页面的支持。 \n416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 \n417   （未满足期望值） 服务器未满足\"期望\"请求标头字段的要求。\n- ### 5XX 请求完成，但是服务器内部发生错误\n500   （服务器内部错误）  服务器遇到错误，无法完成请求。 \n501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 \n502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 \n503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 \n504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 \n505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。","source":"_posts/Http 知识.md","raw":"---\ntitle: Http 知识\ntags:\n  - 前端\ncategories:\n  - Java\ntoc: false\ndate: 2019-04-24 15:23:55\n---\n\n![](/images/http.jpg)\n\n> 记录一些常用的 Http 知识用于以后回来查询复习了解\n\n### Http 状态码\n当你请求服务器后会返回各种`Http`状态码用于表示请求状态，最常见的有`404`、`500`、`200`、`304`\n\n- ### 2XX 成功处理请求\n200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 \n201   （已创建）  请求成功并且服务器创建了新的资源。 \n202   （已接受）  服务器已接受请求，但尚未处理。 \n203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。 \n204   （无内容）  服务器成功处理了请求，但没有返回任何内容。 \n205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。\n206   （部分内容）  服务器成功处理了部分 GET 请求。\n- ### 3XX 请求完成，需要进一步操作\n300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 \n301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\n302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。\n304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 \n305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 \n307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n- ### 4XX 请求错误，无法处理\n400   （错误请求） 服务器不理解请求的语法。 \n401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 \n403   （禁止） 服务器拒绝请求。\n404   （未找到） 服务器找不到请求的网页。\n405   （方法禁用） 禁用请求中指定的方法。 \n406   （不接受） 无法使用请求的内容特性响应请求的网页。 \n407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。\n408   （请求超时）  服务器等候请求时发生超时。 \n409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 \n410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 \n411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 \n412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 \n413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 \n414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 \n415   （不支持的媒体类型） 请求的格式不受请求页面的支持。 \n416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 \n417   （未满足期望值） 服务器未满足\"期望\"请求标头字段的要求。\n- ### 5XX 请求完成，但是服务器内部发生错误\n500   （服务器内部错误）  服务器遇到错误，无法完成请求。 \n501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 \n502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 \n503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 \n504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 \n505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。","slug":"Http 知识","published":1,"updated":"2020-08-10T01:48:44.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc96t000cjsudumtwo4uh","content":"<p><img src=\"/images/http.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录一些常用的 Http 知识用于以后回来查询复习了解</p>\n</blockquote>\n<h3 id=\"Http-状态码\"><a href=\"#Http-状态码\" class=\"headerlink\" title=\"Http 状态码\"></a>Http 状态码</h3><p>当你请求服务器后会返回各种<code>Http</code>状态码用于表示请求状态，最常见的有<code>404</code>、<code>500</code>、<code>200</code>、<code>304</code></p>\n<ul>\n<li><h3 id=\"2XX-成功处理请求\"><a href=\"#2XX-成功处理请求\" class=\"headerlink\" title=\"2XX 成功处理请求\"></a>2XX 成功处理请求</h3>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201   （已创建）  请求成功并且服务器创建了新的资源。<br>202   （已接受）  服务器已接受请求，但尚未处理。<br>203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。<br>205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206   （部分内容）  服务器成功处理了部分 GET 请求。</li>\n<li><h3 id=\"3XX-请求完成，需要进一步操作\"><a href=\"#3XX-请求完成，需要进一步操作\" class=\"headerlink\" title=\"3XX 请求完成，需要进一步操作\"></a>3XX 请求完成，需要进一步操作</h3>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>\n<li><h3 id=\"4XX-请求错误，无法处理\"><a href=\"#4XX-请求错误，无法处理\" class=\"headerlink\" title=\"4XX 请求错误，无法处理\"></a>4XX 请求错误，无法处理</h3>400   （错误请求） 服务器不理解请求的语法。<br>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403   （禁止） 服务器拒绝请求。<br>404   （未找到） 服务器找不到请求的网页。<br>405   （方法禁用） 禁用请求中指定的方法。<br>406   （不接受） 无法使用请求的内容特性响应请求的网页。<br>407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408   （请求超时）  服务器等候请求时发生超时。<br>409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。<br>411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415   （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</li>\n<li><h3 id=\"5XX-请求完成，但是服务器内部发生错误\"><a href=\"#5XX-请求完成，但是服务器内部发生错误\" class=\"headerlink\" title=\"5XX 请求完成，但是服务器内部发生错误\"></a>5XX 请求完成，但是服务器内部发生错误</h3>500   （服务器内部错误）  服务器遇到错误，无法完成请求。<br>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/http.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录一些常用的 Http 知识用于以后回来查询复习了解</p>\n</blockquote>\n<h3 id=\"Http-状态码\"><a href=\"#Http-状态码\" class=\"headerlink\" title=\"Http 状态码\"></a>Http 状态码</h3><p>当你请求服务器后会返回各种<code>Http</code>状态码用于表示请求状态，最常见的有<code>404</code>、<code>500</code>、<code>200</code>、<code>304</code></p>\n<ul>\n<li><h3 id=\"2XX-成功处理请求\"><a href=\"#2XX-成功处理请求\" class=\"headerlink\" title=\"2XX 成功处理请求\"></a>2XX 成功处理请求</h3>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201   （已创建）  请求成功并且服务器创建了新的资源。<br>202   （已接受）  服务器已接受请求，但尚未处理。<br>203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。<br>205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206   （部分内容）  服务器成功处理了部分 GET 请求。</li>\n<li><h3 id=\"3XX-请求完成，需要进一步操作\"><a href=\"#3XX-请求完成，需要进一步操作\" class=\"headerlink\" title=\"3XX 请求完成，需要进一步操作\"></a>3XX 请求完成，需要进一步操作</h3>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>\n<li><h3 id=\"4XX-请求错误，无法处理\"><a href=\"#4XX-请求错误，无法处理\" class=\"headerlink\" title=\"4XX 请求错误，无法处理\"></a>4XX 请求错误，无法处理</h3>400   （错误请求） 服务器不理解请求的语法。<br>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403   （禁止） 服务器拒绝请求。<br>404   （未找到） 服务器找不到请求的网页。<br>405   （方法禁用） 禁用请求中指定的方法。<br>406   （不接受） 无法使用请求的内容特性响应请求的网页。<br>407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408   （请求超时）  服务器等候请求时发生超时。<br>409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。<br>411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415   （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</li>\n<li><h3 id=\"5XX-请求完成，但是服务器内部发生错误\"><a href=\"#5XX-请求完成，但是服务器内部发生错误\" class=\"headerlink\" title=\"5XX 请求完成，但是服务器内部发生错误\"></a>5XX 请求完成，但是服务器内部发生错误</h3>500   （服务器内部错误）  服务器遇到错误，无法完成请求。<br>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</li>\n</ul>\n"},{"title":"IDEA 快捷键备份","toc":false,"date":"2019-08-14T02:26:12.000Z","_content":"\n![](/images/java.jpg)\n\n> IDEA 快捷键备份记录\n\n### IDEA 常用快捷键\nCtrl+B 快速打开光标处的类或方法\nCtrl+N 查找类\nCtrl+R 替换文本\nCtrl+F 查找文本\nCtrl+U 转到父类\nCtrl+T 从远程库更新代码(Git/Svn等)\nCtrl+E 最近打开的文件\nCtrl+H 显示类结构图\nCtrl+P 方法参数提示\nCtrl+Q 显示注释文档\nCtrl+O 重写方法\nCtrl+G 跳转到指定行\nCtrl+X 删除行\nCtrl+D 复制行\nCtrl+W 选择单词继而语句继而行继而函数\nCtrl+[或]，可以跑到大括号的开头与结尾\nCtrl+/ 或 Ctrl+Shift+/  注释\nCtrl+空格 代码提示\nCtrl+\"+\"/\"-\" 展开或折叠当前方法\n\nCtrl+Alt+I 选中代码块进行自动缩进\nCtrl+Alt+T 可以把代码包在一个块内，例如：try/catch、if\nCtrl+Alt+B 跳转到方法实现处\nCtrl+Alt+L 格式化代码\nCtrl+Alt+O 优化导入的类和包\nCtrl+Alt+Space 类名或接口名提示\n\nCtrl+F2，停止\nCtrl+Shift+F 全局搜索\nCtrl+Shift+T 创建Test测试\nCtrl+Shift+W 缩小选择范围\nCtrl+Shift+V 使用的剪贴板内容选择插入到文本\nCtrl+Shift+H 查找被调用的所有类\nCtrl+Shift+J 整合两行\nCtrl+Shift+N 查找文件\nCtrl+Shift+U 大小写转化\nCtrl+Shift+\"+\"/\"-\" 展开或折叠当前类所有方法\nCtrl+Shift+↑/↓ 移动整行代码\nCtrl+Shift+Backspace 跳转到最近一次修改光标处\nCtrl+Shift+Space 自动补全代码\nCtrl+Shift+F9 编译项目\nCtrl+Shift+F10 启动项目\n\nCtrl+Shift+Alt+C 复制代码引用\nCtrl+Shift+Alt+N 查找类中的方法或变量\nCtrl+Shift+Alt+L 格式化当前类\nCtrl+Shift+Alt+T 重构代码\n\nShift+Enter 向下插入新行\nShift+F6 重命名类\n\nAlt+Home 跳转到导航栏\nAlt+/ 代码提示 \nAlt+Q 当前类的声明\nAlt+↑/↓ 方法切换\nAlt+←/→ 视图切换\nAlt+F1 查找代码所在位置\nAlt+1 快速打开或隐藏工程面板\nAlt+2 收藏面板\nAlt+6 TODO面板\nAlt+7 代码结构面板\nAlt+Insert 生成代码(如get,set方法,构造函数等)\nAlt+Shift+C 对比最近修改的代码\nAlt+Shift+F9 选择 Debug\nAlt+Shift+F10 选择 Run\nShift+F6  重构-重命\n\nF2 高亮错误或警告快速定位\nF9 启动历史项目","source":"_posts/IDEA-快捷键备份.md","raw":"---\ntitle: IDEA 快捷键备份\ntags:\n  - 复习\ncategories:\n  - 技术\ntoc: false\ndate: 2019-08-14 10:26:12\n---\n\n![](/images/java.jpg)\n\n> IDEA 快捷键备份记录\n\n### IDEA 常用快捷键\nCtrl+B 快速打开光标处的类或方法\nCtrl+N 查找类\nCtrl+R 替换文本\nCtrl+F 查找文本\nCtrl+U 转到父类\nCtrl+T 从远程库更新代码(Git/Svn等)\nCtrl+E 最近打开的文件\nCtrl+H 显示类结构图\nCtrl+P 方法参数提示\nCtrl+Q 显示注释文档\nCtrl+O 重写方法\nCtrl+G 跳转到指定行\nCtrl+X 删除行\nCtrl+D 复制行\nCtrl+W 选择单词继而语句继而行继而函数\nCtrl+[或]，可以跑到大括号的开头与结尾\nCtrl+/ 或 Ctrl+Shift+/  注释\nCtrl+空格 代码提示\nCtrl+\"+\"/\"-\" 展开或折叠当前方法\n\nCtrl+Alt+I 选中代码块进行自动缩进\nCtrl+Alt+T 可以把代码包在一个块内，例如：try/catch、if\nCtrl+Alt+B 跳转到方法实现处\nCtrl+Alt+L 格式化代码\nCtrl+Alt+O 优化导入的类和包\nCtrl+Alt+Space 类名或接口名提示\n\nCtrl+F2，停止\nCtrl+Shift+F 全局搜索\nCtrl+Shift+T 创建Test测试\nCtrl+Shift+W 缩小选择范围\nCtrl+Shift+V 使用的剪贴板内容选择插入到文本\nCtrl+Shift+H 查找被调用的所有类\nCtrl+Shift+J 整合两行\nCtrl+Shift+N 查找文件\nCtrl+Shift+U 大小写转化\nCtrl+Shift+\"+\"/\"-\" 展开或折叠当前类所有方法\nCtrl+Shift+↑/↓ 移动整行代码\nCtrl+Shift+Backspace 跳转到最近一次修改光标处\nCtrl+Shift+Space 自动补全代码\nCtrl+Shift+F9 编译项目\nCtrl+Shift+F10 启动项目\n\nCtrl+Shift+Alt+C 复制代码引用\nCtrl+Shift+Alt+N 查找类中的方法或变量\nCtrl+Shift+Alt+L 格式化当前类\nCtrl+Shift+Alt+T 重构代码\n\nShift+Enter 向下插入新行\nShift+F6 重命名类\n\nAlt+Home 跳转到导航栏\nAlt+/ 代码提示 \nAlt+Q 当前类的声明\nAlt+↑/↓ 方法切换\nAlt+←/→ 视图切换\nAlt+F1 查找代码所在位置\nAlt+1 快速打开或隐藏工程面板\nAlt+2 收藏面板\nAlt+6 TODO面板\nAlt+7 代码结构面板\nAlt+Insert 生成代码(如get,set方法,构造函数等)\nAlt+Shift+C 对比最近修改的代码\nAlt+Shift+F9 选择 Debug\nAlt+Shift+F10 选择 Run\nShift+F6  重构-重命\n\nF2 高亮错误或警告快速定位\nF9 启动历史项目","slug":"IDEA-快捷键备份","published":1,"updated":"2020-08-10T01:48:44.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc972000gjsud7jpnbfks","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>IDEA 快捷键备份记录</p>\n</blockquote>\n<h3 id=\"IDEA-常用快捷键\"><a href=\"#IDEA-常用快捷键\" class=\"headerlink\" title=\"IDEA 常用快捷键\"></a>IDEA 常用快捷键</h3><p>Ctrl+B 快速打开光标处的类或方法<br>Ctrl+N 查找类<br>Ctrl+R 替换文本<br>Ctrl+F 查找文本<br>Ctrl+U 转到父类<br>Ctrl+T 从远程库更新代码(Git/Svn等)<br>Ctrl+E 最近打开的文件<br>Ctrl+H 显示类结构图<br>Ctrl+P 方法参数提示<br>Ctrl+Q 显示注释文档<br>Ctrl+O 重写方法<br>Ctrl+G 跳转到指定行<br>Ctrl+X 删除行<br>Ctrl+D 复制行<br>Ctrl+W 选择单词继而语句继而行继而函数<br>Ctrl+[或]，可以跑到大括号的开头与结尾<br>Ctrl+/ 或 Ctrl+Shift+/  注释<br>Ctrl+空格 代码提示<br>Ctrl+”+”/“-“ 展开或折叠当前方法</p>\n<p>Ctrl+Alt+I 选中代码块进行自动缩进<br>Ctrl+Alt+T 可以把代码包在一个块内，例如：try/catch、if<br>Ctrl+Alt+B 跳转到方法实现处<br>Ctrl+Alt+L 格式化代码<br>Ctrl+Alt+O 优化导入的类和包<br>Ctrl+Alt+Space 类名或接口名提示</p>\n<p>Ctrl+F2，停止<br>Ctrl+Shift+F 全局搜索<br>Ctrl+Shift+T 创建Test测试<br>Ctrl+Shift+W 缩小选择范围<br>Ctrl+Shift+V 使用的剪贴板内容选择插入到文本<br>Ctrl+Shift+H 查找被调用的所有类<br>Ctrl+Shift+J 整合两行<br>Ctrl+Shift+N 查找文件<br>Ctrl+Shift+U 大小写转化<br>Ctrl+Shift+”+”/“-“ 展开或折叠当前类所有方法<br>Ctrl+Shift+↑/↓ 移动整行代码<br>Ctrl+Shift+Backspace 跳转到最近一次修改光标处<br>Ctrl+Shift+Space 自动补全代码<br>Ctrl+Shift+F9 编译项目<br>Ctrl+Shift+F10 启动项目</p>\n<p>Ctrl+Shift+Alt+C 复制代码引用<br>Ctrl+Shift+Alt+N 查找类中的方法或变量<br>Ctrl+Shift+Alt+L 格式化当前类<br>Ctrl+Shift+Alt+T 重构代码</p>\n<p>Shift+Enter 向下插入新行<br>Shift+F6 重命名类</p>\n<p>Alt+Home 跳转到导航栏<br>Alt+/ 代码提示<br>Alt+Q 当前类的声明<br>Alt+↑/↓ 方法切换<br>Alt+←/→ 视图切换<br>Alt+F1 查找代码所在位置<br>Alt+1 快速打开或隐藏工程面板<br>Alt+2 收藏面板<br>Alt+6 TODO面板<br>Alt+7 代码结构面板<br>Alt+Insert 生成代码(如get,set方法,构造函数等)<br>Alt+Shift+C 对比最近修改的代码<br>Alt+Shift+F9 选择 Debug<br>Alt+Shift+F10 选择 Run<br>Shift+F6  重构-重命</p>\n<p>F2 高亮错误或警告快速定位<br>F9 启动历史项目</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>IDEA 快捷键备份记录</p>\n</blockquote>\n<h3 id=\"IDEA-常用快捷键\"><a href=\"#IDEA-常用快捷键\" class=\"headerlink\" title=\"IDEA 常用快捷键\"></a>IDEA 常用快捷键</h3><p>Ctrl+B 快速打开光标处的类或方法<br>Ctrl+N 查找类<br>Ctrl+R 替换文本<br>Ctrl+F 查找文本<br>Ctrl+U 转到父类<br>Ctrl+T 从远程库更新代码(Git/Svn等)<br>Ctrl+E 最近打开的文件<br>Ctrl+H 显示类结构图<br>Ctrl+P 方法参数提示<br>Ctrl+Q 显示注释文档<br>Ctrl+O 重写方法<br>Ctrl+G 跳转到指定行<br>Ctrl+X 删除行<br>Ctrl+D 复制行<br>Ctrl+W 选择单词继而语句继而行继而函数<br>Ctrl+[或]，可以跑到大括号的开头与结尾<br>Ctrl+/ 或 Ctrl+Shift+/  注释<br>Ctrl+空格 代码提示<br>Ctrl+”+”/“-“ 展开或折叠当前方法</p>\n<p>Ctrl+Alt+I 选中代码块进行自动缩进<br>Ctrl+Alt+T 可以把代码包在一个块内，例如：try/catch、if<br>Ctrl+Alt+B 跳转到方法实现处<br>Ctrl+Alt+L 格式化代码<br>Ctrl+Alt+O 优化导入的类和包<br>Ctrl+Alt+Space 类名或接口名提示</p>\n<p>Ctrl+F2，停止<br>Ctrl+Shift+F 全局搜索<br>Ctrl+Shift+T 创建Test测试<br>Ctrl+Shift+W 缩小选择范围<br>Ctrl+Shift+V 使用的剪贴板内容选择插入到文本<br>Ctrl+Shift+H 查找被调用的所有类<br>Ctrl+Shift+J 整合两行<br>Ctrl+Shift+N 查找文件<br>Ctrl+Shift+U 大小写转化<br>Ctrl+Shift+”+”/“-“ 展开或折叠当前类所有方法<br>Ctrl+Shift+↑/↓ 移动整行代码<br>Ctrl+Shift+Backspace 跳转到最近一次修改光标处<br>Ctrl+Shift+Space 自动补全代码<br>Ctrl+Shift+F9 编译项目<br>Ctrl+Shift+F10 启动项目</p>\n<p>Ctrl+Shift+Alt+C 复制代码引用<br>Ctrl+Shift+Alt+N 查找类中的方法或变量<br>Ctrl+Shift+Alt+L 格式化当前类<br>Ctrl+Shift+Alt+T 重构代码</p>\n<p>Shift+Enter 向下插入新行<br>Shift+F6 重命名类</p>\n<p>Alt+Home 跳转到导航栏<br>Alt+/ 代码提示<br>Alt+Q 当前类的声明<br>Alt+↑/↓ 方法切换<br>Alt+←/→ 视图切换<br>Alt+F1 查找代码所在位置<br>Alt+1 快速打开或隐藏工程面板<br>Alt+2 收藏面板<br>Alt+6 TODO面板<br>Alt+7 代码结构面板<br>Alt+Insert 生成代码(如get,set方法,构造函数等)<br>Alt+Shift+C 对比最近修改的代码<br>Alt+Shift+F9 选择 Debug<br>Alt+Shift+F10 选择 Run<br>Shift+F6  重构-重命</p>\n<p>F2 高亮错误或警告快速定位<br>F9 启动历史项目</p>\n"},{"title":"JVM 内存区域","toc":false,"date":"2019-03-21T13:01:28.000Z","_content":"\n![Java](/images/java.jpg)\n\n\n>JVM 复习基本概念学习和记录\n\n## 概述\n对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。\n\n## JVM 运行时候数据区域\nJava 虚拟机在执行 java 程序的过程中会把管理的内存划分为若干个不同的数据区域，JDK 1.8 和之前的版本有不同。\n![JDK 1.8之前内存划分](/images/JVM-1.8-before.png)\n![JDK 1.8版本的内存划分](/images/JVM-1.8-after.png)\n\n- ##### 线程私有的：\n  [程序计数器](#程序计数器)、[虚拟机栈](#虚拟机栈)、[本地方法栈](#本地方法栈)\n  \n- ##### 线程共享的：\n [堆](#堆)、[方法区](#方法区)、直接内存（非运行数据区的一部分） \n\n- ##### [直接内存](#直接内存) \n\n### 程序计数器\n程序计数器（`Pargram Counter Register`）是一块很小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 字节码解释器工作通过改变计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖此计数器。多线程中每个线程都有一个计数器用来记录线程执行的位置，每个计数器之间相互不影响独立，独立存储，被称为“线程私有”的内存。\n\n__程序计数器是唯一一个不会出现`OutOfMemoryError`的内存区域，它的生命周期随着线程的创建才创建，结束而结束。__\n\n### 虚拟机栈\n Java 虚拟机栈（`Jasva Virtual Machine Stacks`）也是私有内存，它的生命周期和线程一样，描述的是 Java 方法执行的内存模型： 每个方法在执行的同时都会创建一个帧栈（`Stack Frame`）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的执行完成的过程对应着每个帧栈在虚拟栈中入栈到出栈的过程。\n\n __局部变量表__的主要存放了编译期可知的各种__基本数据类型__（`boolean`、`byte`、`char`、`short`、`int`、`float`、`long`、`double`）、对象引用（`reference`类型，不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）\n\n __虚拟机栈只会出现2种异常__\n - __StackOverFlowError__：如虚拟机不支持内存动态扩展，当线程请求栈的深度大于虚拟机的最大阈值，则会抛出`StackOverFlowError`。\n - __OutOfMemoryError__：如果虚拟机支持内存动态扩展，当线程申请内存无法再动态扩展时，会抛出`OutOfMemoryError`\n\n\n### 本地方法栈\n__虚拟机栈为虚拟机执行 Java 方法（`字节码`）服务，而本地方法栈为虚拟机使用`Native`方法服务。在`HotSpot`中 Java 虚拟机合二为一。__\n\n## 堆\nJava 堆（`Java Heap`）是虚拟机所管理的内存中最大的一块，Java 堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建用于存放几乎所有的对象实例和数组。\n\nJava 堆是 垃圾回收器管理的主要区域 GC 堆（`Garbage Collector Heap`）,垃圾回收采用`分代垃圾收集算法`，可以细分为：`新生代`和`老年代`,在细致点可分为：`Eden`空间、`From Survivor`、`To Survivor`空间等。\n![内存划分](/images/MemorySplit.png)\n`eden`、`s0`、`s1`区属于新生代，`tentired`区属于老年区。\n\n通常虚拟机的内存拓展是通过（`-Xms` 和 `-Xms`控制）。\n\n### 方法区\n方法区（`Method Area`）和 Java 堆一样属于共享的内存区域，用于存放已经被虚拟机啊加载的类信息、常量、静态变量、即时编译器后的代码等数据。为区分 Java 堆，方法区也叫`Non-Heap（非堆）`。\n\n__JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。__\n\n\n### 运行时常量池\n运行时常量（`Running Constant Pool`）是方法区的一部分。`Class`文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池（`Constant Pool Table`），用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n![常量池](/images/ConstantPoolTable.jpg)\n\n__JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。__\n\n\n### 直接内存\n直接内存（`Direct Memory`）不是虚拟机运行时数据区的一部分，也不是虚拟机规范中划分的内存区域。\n\nJDK 1.4中新加入的`NIO`(`New Input/OutPut`)类，引入基于通道(`Channel`)与缓冲区（`Buffer`）的`I/O`方式，它可以直接通过`Native`函数直接分配堆外内存，然后通过`Java`中`DirectByBuffer`对象来操作这些内存。这样避免 `Java 堆`和 `Native 堆`之间来回复制数据浪费性能。\n\n__直接内存分配不受 Java 堆的限制，但是受限于机器的物理内存大小和逻辑器寻址空间限制。__\n\n\n> 所有内容摘自 《深入理解 Java 虚拟机》  和 https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md","source":"_posts/JVM 内存区域.md","raw":"---\ntitle: JVM 内存区域\ntags:\n  - Java\n  - Jvm\ncategories:\n  - Java\ntoc: false\ndate: 2019-03-21 21:01:28\n---\n\n![Java](/images/java.jpg)\n\n\n>JVM 复习基本概念学习和记录\n\n## 概述\n对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。\n\n## JVM 运行时候数据区域\nJava 虚拟机在执行 java 程序的过程中会把管理的内存划分为若干个不同的数据区域，JDK 1.8 和之前的版本有不同。\n![JDK 1.8之前内存划分](/images/JVM-1.8-before.png)\n![JDK 1.8版本的内存划分](/images/JVM-1.8-after.png)\n\n- ##### 线程私有的：\n  [程序计数器](#程序计数器)、[虚拟机栈](#虚拟机栈)、[本地方法栈](#本地方法栈)\n  \n- ##### 线程共享的：\n [堆](#堆)、[方法区](#方法区)、直接内存（非运行数据区的一部分） \n\n- ##### [直接内存](#直接内存) \n\n### 程序计数器\n程序计数器（`Pargram Counter Register`）是一块很小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 字节码解释器工作通过改变计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖此计数器。多线程中每个线程都有一个计数器用来记录线程执行的位置，每个计数器之间相互不影响独立，独立存储，被称为“线程私有”的内存。\n\n__程序计数器是唯一一个不会出现`OutOfMemoryError`的内存区域，它的生命周期随着线程的创建才创建，结束而结束。__\n\n### 虚拟机栈\n Java 虚拟机栈（`Jasva Virtual Machine Stacks`）也是私有内存，它的生命周期和线程一样，描述的是 Java 方法执行的内存模型： 每个方法在执行的同时都会创建一个帧栈（`Stack Frame`）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的执行完成的过程对应着每个帧栈在虚拟栈中入栈到出栈的过程。\n\n __局部变量表__的主要存放了编译期可知的各种__基本数据类型__（`boolean`、`byte`、`char`、`short`、`int`、`float`、`long`、`double`）、对象引用（`reference`类型，不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）\n\n __虚拟机栈只会出现2种异常__\n - __StackOverFlowError__：如虚拟机不支持内存动态扩展，当线程请求栈的深度大于虚拟机的最大阈值，则会抛出`StackOverFlowError`。\n - __OutOfMemoryError__：如果虚拟机支持内存动态扩展，当线程申请内存无法再动态扩展时，会抛出`OutOfMemoryError`\n\n\n### 本地方法栈\n__虚拟机栈为虚拟机执行 Java 方法（`字节码`）服务，而本地方法栈为虚拟机使用`Native`方法服务。在`HotSpot`中 Java 虚拟机合二为一。__\n\n## 堆\nJava 堆（`Java Heap`）是虚拟机所管理的内存中最大的一块，Java 堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建用于存放几乎所有的对象实例和数组。\n\nJava 堆是 垃圾回收器管理的主要区域 GC 堆（`Garbage Collector Heap`）,垃圾回收采用`分代垃圾收集算法`，可以细分为：`新生代`和`老年代`,在细致点可分为：`Eden`空间、`From Survivor`、`To Survivor`空间等。\n![内存划分](/images/MemorySplit.png)\n`eden`、`s0`、`s1`区属于新生代，`tentired`区属于老年区。\n\n通常虚拟机的内存拓展是通过（`-Xms` 和 `-Xms`控制）。\n\n### 方法区\n方法区（`Method Area`）和 Java 堆一样属于共享的内存区域，用于存放已经被虚拟机啊加载的类信息、常量、静态变量、即时编译器后的代码等数据。为区分 Java 堆，方法区也叫`Non-Heap（非堆）`。\n\n__JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。__\n\n\n### 运行时常量池\n运行时常量（`Running Constant Pool`）是方法区的一部分。`Class`文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池（`Constant Pool Table`），用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n![常量池](/images/ConstantPoolTable.jpg)\n\n__JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。__\n\n\n### 直接内存\n直接内存（`Direct Memory`）不是虚拟机运行时数据区的一部分，也不是虚拟机规范中划分的内存区域。\n\nJDK 1.4中新加入的`NIO`(`New Input/OutPut`)类，引入基于通道(`Channel`)与缓冲区（`Buffer`）的`I/O`方式，它可以直接通过`Native`函数直接分配堆外内存，然后通过`Java`中`DirectByBuffer`对象来操作这些内存。这样避免 `Java 堆`和 `Native 堆`之间来回复制数据浪费性能。\n\n__直接内存分配不受 Java 堆的限制，但是受限于机器的物理内存大小和逻辑器寻址空间限制。__\n\n\n> 所有内容摘自 《深入理解 Java 虚拟机》  和 https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md","slug":"JVM 内存区域","published":1,"updated":"2020-08-10T01:48:44.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc975000ijsudkfsdkvmf","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>JVM 复习基本概念学习和记录</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>\n<h2 id=\"JVM-运行时候数据区域\"><a href=\"#JVM-运行时候数据区域\" class=\"headerlink\" title=\"JVM 运行时候数据区域\"></a>JVM 运行时候数据区域</h2><p>Java 虚拟机在执行 java 程序的过程中会把管理的内存划分为若干个不同的数据区域，JDK 1.8 和之前的版本有不同。<br><img src=\"/images/JVM-1.8-before.png\" srcset=\"/img/loading.gif\" alt=\"JDK 1.8之前内存划分\"><br><img src=\"/images/JVM-1.8-after.png\" srcset=\"/img/loading.gif\" alt=\"JDK 1.8版本的内存划分\"></p>\n<ul>\n<li><h5 id=\"线程私有的：\"><a href=\"#线程私有的：\" class=\"headerlink\" title=\"线程私有的：\"></a>线程私有的：</h5><p><a href=\"#程序计数器\">程序计数器</a>、<a href=\"#虚拟机栈\">虚拟机栈</a>、<a href=\"#本地方法栈\">本地方法栈</a></p>\n</li>\n<li><h5 id=\"线程共享的：\"><a href=\"#线程共享的：\" class=\"headerlink\" title=\"线程共享的：\"></a>线程共享的：</h5><p><a href=\"#堆\">堆</a>、<a href=\"#方法区\">方法区</a>、直接内存（非运行数据区的一部分） </p>\n</li>\n<li><h5 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a><a href=\"#直接内存\">直接内存</a></h5></li>\n</ul>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器（<code>Pargram Counter Register</code>）是一块很小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 字节码解释器工作通过改变计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖此计数器。多线程中每个线程都有一个计数器用来记录线程执行的位置，每个计数器之间相互不影响独立，独立存储，被称为“线程私有”的内存。</p>\n<p><strong>程序计数器是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域，它的生命周期随着线程的创建才创建，结束而结束。</strong></p>\n<h3 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h3><p> Java 虚拟机栈（<code>Jasva Virtual Machine Stacks</code>）也是私有内存，它的生命周期和线程一样，描述的是 Java 方法执行的内存模型： 每个方法在执行的同时都会创建一个帧栈（<code>Stack Frame</code>）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的执行完成的过程对应着每个帧栈在虚拟栈中入栈到出栈的过程。</p>\n<p> <strong>局部变量表</strong>的主要存放了编译期可知的各种<strong>基本数据类型</strong>（<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>）、对象引用（<code>reference</code>类型，不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</p>\n<p> <strong>虚拟机栈只会出现2种异常</strong></p>\n<ul>\n<li><strong>StackOverFlowError</strong>：如虚拟机不支持内存动态扩展，当线程请求栈的深度大于虚拟机的最大阈值，则会抛出<code>StackOverFlowError</code>。</li>\n<li><strong>OutOfMemoryError</strong>：如果虚拟机支持内存动态扩展，当线程申请内存无法再动态扩展时，会抛出<code>OutOfMemoryError</code></li>\n</ul>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p><strong>虚拟机栈为虚拟机执行 Java 方法（<code>字节码</code>）服务，而本地方法栈为虚拟机使用<code>Native</code>方法服务。在<code>HotSpot</code>中 Java 虚拟机合二为一。</strong></p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>Java 堆（<code>Java Heap</code>）是虚拟机所管理的内存中最大的一块，Java 堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建用于存放几乎所有的对象实例和数组。</p>\n<p>Java 堆是 垃圾回收器管理的主要区域 GC 堆（<code>Garbage Collector Heap</code>）,垃圾回收采用<code>分代垃圾收集算法</code>，可以细分为：<code>新生代</code>和<code>老年代</code>,在细致点可分为：<code>Eden</code>空间、<code>From Survivor</code>、<code>To Survivor</code>空间等。<br><img src=\"/images/MemorySplit.png\" srcset=\"/img/loading.gif\" alt=\"内存划分\"><br><code>eden</code>、<code>s0</code>、<code>s1</code>区属于新生代，<code>tentired</code>区属于老年区。</p>\n<p>通常虚拟机的内存拓展是通过（<code>-Xms</code> 和 <code>-Xms</code>控制）。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>方法区（<code>Method Area</code>）和 Java 堆一样属于共享的内存区域，用于存放已经被虚拟机啊加载的类信息、常量、静态变量、即时编译器后的代码等数据。为区分 Java 堆，方法区也叫<code>Non-Heap（非堆）</code>。</p>\n<p><strong>JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。</strong></p>\n<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h3><p>运行时常量（<code>Running Constant Pool</code>）是方法区的一部分。<code>Class</code>文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池（<code>Constant Pool Table</code>），用于存放编译期生成的各种<code>字面量</code>和<code>符号引用</code>，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br><img src=\"/images/ConstantPoolTable.jpg\" srcset=\"/img/loading.gif\" alt=\"常量池\"></p>\n<p><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p>\n<h3 id=\"直接内存-1\"><a href=\"#直接内存-1\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h3><p>直接内存（<code>Direct Memory</code>）不是虚拟机运行时数据区的一部分，也不是虚拟机规范中划分的内存区域。</p>\n<p>JDK 1.4中新加入的<code>NIO</code>(<code>New Input/OutPut</code>)类，引入基于通道(<code>Channel</code>)与缓冲区（<code>Buffer</code>）的<code>I/O</code>方式，它可以直接通过<code>Native</code>函数直接分配堆外内存，然后通过<code>Java</code>中<code>DirectByBuffer</code>对象来操作这些内存。这样避免 <code>Java 堆</code>和 <code>Native 堆</code>之间来回复制数据浪费性能。</p>\n<p><strong>直接内存分配不受 Java 堆的限制，但是受限于机器的物理内存大小和逻辑器寻址空间限制。</strong></p>\n<blockquote>\n<p>所有内容摘自 《深入理解 Java 虚拟机》  和 <a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>JVM 复习基本概念学习和记录</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>\n<h2 id=\"JVM-运行时候数据区域\"><a href=\"#JVM-运行时候数据区域\" class=\"headerlink\" title=\"JVM 运行时候数据区域\"></a>JVM 运行时候数据区域</h2><p>Java 虚拟机在执行 java 程序的过程中会把管理的内存划分为若干个不同的数据区域，JDK 1.8 和之前的版本有不同。<br><img src=\"/images/JVM-1.8-before.png\" srcset=\"/img/loading.gif\" alt=\"JDK 1.8之前内存划分\"><br><img src=\"/images/JVM-1.8-after.png\" srcset=\"/img/loading.gif\" alt=\"JDK 1.8版本的内存划分\"></p>\n<ul>\n<li><h5 id=\"线程私有的：\"><a href=\"#线程私有的：\" class=\"headerlink\" title=\"线程私有的：\"></a>线程私有的：</h5><p><a href=\"#程序计数器\">程序计数器</a>、<a href=\"#虚拟机栈\">虚拟机栈</a>、<a href=\"#本地方法栈\">本地方法栈</a></p>\n</li>\n<li><h5 id=\"线程共享的：\"><a href=\"#线程共享的：\" class=\"headerlink\" title=\"线程共享的：\"></a>线程共享的：</h5><p><a href=\"#堆\">堆</a>、<a href=\"#方法区\">方法区</a>、直接内存（非运行数据区的一部分） </p>\n</li>\n<li><h5 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a><a href=\"#直接内存\">直接内存</a></h5></li>\n</ul>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器（<code>Pargram Counter Register</code>）是一块很小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 字节码解释器工作通过改变计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖此计数器。多线程中每个线程都有一个计数器用来记录线程执行的位置，每个计数器之间相互不影响独立，独立存储，被称为“线程私有”的内存。</p>\n<p><strong>程序计数器是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域，它的生命周期随着线程的创建才创建，结束而结束。</strong></p>\n<h3 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h3><p> Java 虚拟机栈（<code>Jasva Virtual Machine Stacks</code>）也是私有内存，它的生命周期和线程一样，描述的是 Java 方法执行的内存模型： 每个方法在执行的同时都会创建一个帧栈（<code>Stack Frame</code>）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的执行完成的过程对应着每个帧栈在虚拟栈中入栈到出栈的过程。</p>\n<p> <strong>局部变量表</strong>的主要存放了编译期可知的各种<strong>基本数据类型</strong>（<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>）、对象引用（<code>reference</code>类型，不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</p>\n<p> <strong>虚拟机栈只会出现2种异常</strong></p>\n<ul>\n<li><strong>StackOverFlowError</strong>：如虚拟机不支持内存动态扩展，当线程请求栈的深度大于虚拟机的最大阈值，则会抛出<code>StackOverFlowError</code>。</li>\n<li><strong>OutOfMemoryError</strong>：如果虚拟机支持内存动态扩展，当线程申请内存无法再动态扩展时，会抛出<code>OutOfMemoryError</code></li>\n</ul>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p><strong>虚拟机栈为虚拟机执行 Java 方法（<code>字节码</code>）服务，而本地方法栈为虚拟机使用<code>Native</code>方法服务。在<code>HotSpot</code>中 Java 虚拟机合二为一。</strong></p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>Java 堆（<code>Java Heap</code>）是虚拟机所管理的内存中最大的一块，Java 堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建用于存放几乎所有的对象实例和数组。</p>\n<p>Java 堆是 垃圾回收器管理的主要区域 GC 堆（<code>Garbage Collector Heap</code>）,垃圾回收采用<code>分代垃圾收集算法</code>，可以细分为：<code>新生代</code>和<code>老年代</code>,在细致点可分为：<code>Eden</code>空间、<code>From Survivor</code>、<code>To Survivor</code>空间等。<br><img src=\"/images/MemorySplit.png\" srcset=\"/img/loading.gif\" alt=\"内存划分\"><br><code>eden</code>、<code>s0</code>、<code>s1</code>区属于新生代，<code>tentired</code>区属于老年区。</p>\n<p>通常虚拟机的内存拓展是通过（<code>-Xms</code> 和 <code>-Xms</code>控制）。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>方法区（<code>Method Area</code>）和 Java 堆一样属于共享的内存区域，用于存放已经被虚拟机啊加载的类信息、常量、静态变量、即时编译器后的代码等数据。为区分 Java 堆，方法区也叫<code>Non-Heap（非堆）</code>。</p>\n<p><strong>JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。</strong></p>\n<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h3><p>运行时常量（<code>Running Constant Pool</code>）是方法区的一部分。<code>Class</code>文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池（<code>Constant Pool Table</code>），用于存放编译期生成的各种<code>字面量</code>和<code>符号引用</code>，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br><img src=\"/images/ConstantPoolTable.jpg\" srcset=\"/img/loading.gif\" alt=\"常量池\"></p>\n<p><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p>\n<h3 id=\"直接内存-1\"><a href=\"#直接内存-1\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h3><p>直接内存（<code>Direct Memory</code>）不是虚拟机运行时数据区的一部分，也不是虚拟机规范中划分的内存区域。</p>\n<p>JDK 1.4中新加入的<code>NIO</code>(<code>New Input/OutPut</code>)类，引入基于通道(<code>Channel</code>)与缓冲区（<code>Buffer</code>）的<code>I/O</code>方式，它可以直接通过<code>Native</code>函数直接分配堆外内存，然后通过<code>Java</code>中<code>DirectByBuffer</code>对象来操作这些内存。这样避免 <code>Java 堆</code>和 <code>Native 堆</code>之间来回复制数据浪费性能。</p>\n<p><strong>直接内存分配不受 Java 堆的限制，但是受限于机器的物理内存大小和逻辑器寻址空间限制。</strong></p>\n<blockquote>\n<p>所有内容摘自 《深入理解 Java 虚拟机》  和 <a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md</a></p>\n</blockquote>\n"},{"title":"JVM 对象创建过程","toc":false,"date":"2019-04-17T13:01:28.000Z","_content":"\n![Java](/images/java.jpg)\n\n\n>JVM 复习基本概念学习和记录\n\n## 对象创建过程\n![对象创建过程](/images/jvm-ObjectCreate.jpg)\n- __类加载检查__：遇到`new`指令时，先会检查下常量池是否存在该类的符号引用，并检查是否`加载过`、`解析`、和`初始化`过，如果没有则进行类加载过程。\n\n- __分配内存__：类加载检查通过，虚拟机会在`Java 堆`中为对象划分一块区域， 内存大小在类加载完成后确定，","source":"_posts/JVM 对象创建.md","raw":"---\ntitle: JVM 对象创建过程\ntags:\n  - Jvm\ncategories:\n  - Java\ntoc: false\ndate: 2019-04-17 21:01:28\n---\n\n![Java](/images/java.jpg)\n\n\n>JVM 复习基本概念学习和记录\n\n## 对象创建过程\n![对象创建过程](/images/jvm-ObjectCreate.jpg)\n- __类加载检查__：遇到`new`指令时，先会检查下常量池是否存在该类的符号引用，并检查是否`加载过`、`解析`、和`初始化`过，如果没有则进行类加载过程。\n\n- __分配内存__：类加载检查通过，虚拟机会在`Java 堆`中为对象划分一块区域， 内存大小在类加载完成后确定，","slug":"JVM 对象创建","published":1,"updated":"2020-08-10T01:48:44.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc979000mjsudvt3tw2fq","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>JVM 复习基本概念学习和记录</p>\n</blockquote>\n<h2 id=\"对象创建过程\"><a href=\"#对象创建过程\" class=\"headerlink\" title=\"对象创建过程\"></a>对象创建过程</h2><p><img src=\"/images/jvm-ObjectCreate.jpg\" srcset=\"/img/loading.gif\" alt=\"对象创建过程\"></p>\n<ul>\n<li><p><strong>类加载检查</strong>：遇到<code>new</code>指令时，先会检查下常量池是否存在该类的符号引用，并检查是否<code>加载过</code>、<code>解析</code>、和<code>初始化</code>过，如果没有则进行类加载过程。</p>\n</li>\n<li><p><strong>分配内存</strong>：类加载检查通过，虚拟机会在<code>Java 堆</code>中为对象划分一块区域， 内存大小在类加载完成后确定，</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>JVM 复习基本概念学习和记录</p>\n</blockquote>\n<h2 id=\"对象创建过程\"><a href=\"#对象创建过程\" class=\"headerlink\" title=\"对象创建过程\"></a>对象创建过程</h2><p><img src=\"/images/jvm-ObjectCreate.jpg\" srcset=\"/img/loading.gif\" alt=\"对象创建过程\"></p>\n<ul>\n<li><p><strong>类加载检查</strong>：遇到<code>new</code>指令时，先会检查下常量池是否存在该类的符号引用，并检查是否<code>加载过</code>、<code>解析</code>、和<code>初始化</code>过，如果没有则进行类加载过程。</p>\n</li>\n<li><p><strong>分配内存</strong>：类加载检查通过，虚拟机会在<code>Java 堆</code>中为对象划分一块区域， 内存大小在类加载完成后确定，</p>\n</li>\n</ul>\n"},{"title":"JVM 类加载","date":"2019-03-21T13:01:28.000Z","_content":"![Java](/images/java.jpg)\n\n\n>JVM 复习基本概念学习和记录\n\n## 概述\n","source":"_posts/JVM 类加载.md","raw":"---\ntitle: JVM 类加载\ndate: 2019-03-21 21:01:28\ncategories: [Java]\ntags:\n\t- Java\n\t- Jvm\n---\n![Java](/images/java.jpg)\n\n\n>JVM 复习基本概念学习和记录\n\n## 概述\n","slug":"JVM 类加载","published":1,"updated":"2020-08-10T01:48:44.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc97b000pjsudr7v6ezgl","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>JVM 复习基本概念学习和记录</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>JVM 复习基本概念学习和记录</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2>"},{"title":"Java 引用类型","toc":false,"date":"2020-08-26T07:40:50.000Z","_content":"\n![](/images/java.jpg)\n\n### 强引用 StrongReference\n最常见的引用类型 `Object o = new Object()`，特点当`JVM`内存不足时也不会被`GC`回收除非置为`null`，在一个内部方法有一个强引用时，引用保存在**方法栈**中，实际的内容会保存在**堆**中，当方法执行完毕后退出方法栈，引用对象的**引用数**变为**0**，这个对象则被`GC`回收 \n\n**ArrayList 就是通过 clear 把底层数组循环置为 Null，让 gc 来进行回收工作**\n``` java\n/**\n     * Removes all of the elements from this list.  The list will\n     * be empty after this call returns.\n     */\n    public void clear() {\n        modCount++;\n        // clear to let GC do its work\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n        size = 0;\n    }\n```\n\n### 软引用 SoftReference\n如果一个对象具有软引用，只有当内存不足时才会进行回收，一般用于图片缓存、网页缓存等，例如在`spring-retry` 就有使用`SoftReferenceMapRetryContextCache`软引用作为重试上下文缓存，当内存不足的时候被`GC`回收，内存足够的时候避免创建浪费性能，也能避免大量创建引发**OOM**\n\n``` java\nObejct a = new Object()\nSoftReference soft = new SoftReference(a);\nsoft.get();\n```\n\n### 弱引用 WeckReference\n弱引用描述被必须对象的，无论内存是否充足都会被`GC`所回收（未被强引用），`ThreadLocal`的实现就有用到软引用\n\n``` java\n@Data\n@AllArgsConstructor\npublic class Test {\n    private String name;\n\n    public static void main(String[] args) throws InterruptedException {\n        Test t = new Test(\"123\");\n        WeakReference weakReference = new WeakReference(t);\n        System.gc();\n        System.out.println(weakReference.get());\n        t = null;\n        System.gc();\n        System.out.println(weakReference.get());\n    }\n}\n```\n\n>> 第一次输出 **Test(name=123)**，因为有强引用`t`指向，当把`t = null`执行完后进行垃圾回收则输出 **null**\n\n### 虚引用 PhantomReference\n无论是否被强引用、内存充足都会`GC`回收，在使用虚引用必须配合`ReferenceQueue`引用队列使用，它的主要作用是跟踪对象的垃圾回收的状态，当对象被回收后会将引用加入到引用队列中，以便后续进行其他行为操作，例如 `WeakHashMap`,其内部维护了`ReferenceQueue`当`Key`值被回收时，会删除相关的`Entry`","source":"_posts/Java-引用类型.md","raw":"---\ntitle: Java 引用类型\ntags:\n  - 复习\ncategories:\n  - Java\ntoc: false\ndate: 2020-08-26 15:40:50\n---\n\n![](/images/java.jpg)\n\n### 强引用 StrongReference\n最常见的引用类型 `Object o = new Object()`，特点当`JVM`内存不足时也不会被`GC`回收除非置为`null`，在一个内部方法有一个强引用时，引用保存在**方法栈**中，实际的内容会保存在**堆**中，当方法执行完毕后退出方法栈，引用对象的**引用数**变为**0**，这个对象则被`GC`回收 \n\n**ArrayList 就是通过 clear 把底层数组循环置为 Null，让 gc 来进行回收工作**\n``` java\n/**\n     * Removes all of the elements from this list.  The list will\n     * be empty after this call returns.\n     */\n    public void clear() {\n        modCount++;\n        // clear to let GC do its work\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n        size = 0;\n    }\n```\n\n### 软引用 SoftReference\n如果一个对象具有软引用，只有当内存不足时才会进行回收，一般用于图片缓存、网页缓存等，例如在`spring-retry` 就有使用`SoftReferenceMapRetryContextCache`软引用作为重试上下文缓存，当内存不足的时候被`GC`回收，内存足够的时候避免创建浪费性能，也能避免大量创建引发**OOM**\n\n``` java\nObejct a = new Object()\nSoftReference soft = new SoftReference(a);\nsoft.get();\n```\n\n### 弱引用 WeckReference\n弱引用描述被必须对象的，无论内存是否充足都会被`GC`所回收（未被强引用），`ThreadLocal`的实现就有用到软引用\n\n``` java\n@Data\n@AllArgsConstructor\npublic class Test {\n    private String name;\n\n    public static void main(String[] args) throws InterruptedException {\n        Test t = new Test(\"123\");\n        WeakReference weakReference = new WeakReference(t);\n        System.gc();\n        System.out.println(weakReference.get());\n        t = null;\n        System.gc();\n        System.out.println(weakReference.get());\n    }\n}\n```\n\n>> 第一次输出 **Test(name=123)**，因为有强引用`t`指向，当把`t = null`执行完后进行垃圾回收则输出 **null**\n\n### 虚引用 PhantomReference\n无论是否被强引用、内存充足都会`GC`回收，在使用虚引用必须配合`ReferenceQueue`引用队列使用，它的主要作用是跟踪对象的垃圾回收的状态，当对象被回收后会将引用加入到引用队列中，以便后续进行其他行为操作，例如 `WeakHashMap`,其内部维护了`ReferenceQueue`当`Key`值被回收时，会删除相关的`Entry`","slug":"Java-引用类型","published":1,"updated":"2020-09-14T08:16:37.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc97e000tjsudhkbimj8c","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"强引用-StrongReference\"><a href=\"#强引用-StrongReference\" class=\"headerlink\" title=\"强引用 StrongReference\"></a>强引用 StrongReference</h3><p>最常见的引用类型 <code>Object o = new Object()</code>，特点当<code>JVM</code>内存不足时也不会被<code>GC</code>回收除非置为<code>null</code>，在一个内部方法有一个强引用时，引用保存在<strong>方法栈</strong>中，实际的内容会保存在<strong>堆</strong>中，当方法执行完毕后退出方法栈，引用对象的<strong>引用数</strong>变为<strong>0</strong>，这个对象则被<code>GC</code>回收 </p>\n<p><strong>ArrayList 就是通过 clear 把底层数组循环置为 Null，让 gc 来进行回收工作</strong><br><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n     * Removes all of the elements from this list.  The list will\n     * be empty after this call returns.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span> </span>&#123;\n        modCount++;\n        <span class=\"hljs-comment\">// clear to let GC do its work</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)\n            elementData[i] = <span class=\"hljs-keyword\">null</span>;\n        size = <span class=\"hljs-number\">0</span>;\n    &#125;</code></pre></p>\n<h3 id=\"软引用-SoftReference\"><a href=\"#软引用-SoftReference\" class=\"headerlink\" title=\"软引用 SoftReference\"></a>软引用 SoftReference</h3><p>如果一个对象具有软引用，只有当内存不足时才会进行回收，一般用于图片缓存、网页缓存等，例如在<code>spring-retry</code> 就有使用<code>SoftReferenceMapRetryContextCache</code>软引用作为重试上下文缓存，当内存不足的时候被<code>GC</code>回收，内存足够的时候避免创建浪费性能，也能避免大量创建引发<strong>OOM</strong></p>\n<pre><code class=\"hljs java\">Obejct a = <span class=\"hljs-keyword\">new</span> Object()\nSoftReference soft = <span class=\"hljs-keyword\">new</span> SoftReference(a);\nsoft.get();</code></pre>\n<h3 id=\"弱引用-WeckReference\"><a href=\"#弱引用-WeckReference\" class=\"headerlink\" title=\"弱引用 WeckReference\"></a>弱引用 WeckReference</h3><p>弱引用描述被必须对象的，无论内存是否充足都会被<code>GC</code>所回收（未被强引用），<code>ThreadLocal</code>的实现就有用到软引用</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-meta\">@AllArgsConstructor</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> String name;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n        Test t = <span class=\"hljs-keyword\">new</span> Test(<span class=\"hljs-string\">\"123\"</span>);\n        WeakReference weakReference = <span class=\"hljs-keyword\">new</span> WeakReference(t);\n        System.gc();\n        System.out.println(weakReference.get());\n        t = <span class=\"hljs-keyword\">null</span>;\n        System.gc();\n        System.out.println(weakReference.get());\n    &#125;\n&#125;</code></pre>\n<blockquote>\n<blockquote>\n<p>第一次输出 <strong>Test(name=123)</strong>，因为有强引用<code>t</code>指向，当把<code>t = null</code>执行完后进行垃圾回收则输出 <strong>null</strong></p>\n</blockquote>\n</blockquote>\n<h3 id=\"虚引用-PhantomReference\"><a href=\"#虚引用-PhantomReference\" class=\"headerlink\" title=\"虚引用 PhantomReference\"></a>虚引用 PhantomReference</h3><p>无论是否被强引用、内存充足都会<code>GC</code>回收，在使用虚引用必须配合<code>ReferenceQueue</code>引用队列使用，它的主要作用是跟踪对象的垃圾回收的状态，当对象被回收后会将引用加入到引用队列中，以便后续进行其他行为操作，例如 <code>WeakHashMap</code>,其内部维护了<code>ReferenceQueue</code>当<code>Key</code>值被回收时，会删除相关的<code>Entry</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"强引用-StrongReference\"><a href=\"#强引用-StrongReference\" class=\"headerlink\" title=\"强引用 StrongReference\"></a>强引用 StrongReference</h3><p>最常见的引用类型 <code>Object o = new Object()</code>，特点当<code>JVM</code>内存不足时也不会被<code>GC</code>回收除非置为<code>null</code>，在一个内部方法有一个强引用时，引用保存在<strong>方法栈</strong>中，实际的内容会保存在<strong>堆</strong>中，当方法执行完毕后退出方法栈，引用对象的<strong>引用数</strong>变为<strong>0</strong>，这个对象则被<code>GC</code>回收 </p>\n<p><strong>ArrayList 就是通过 clear 把底层数组循环置为 Null，让 gc 来进行回收工作</strong><br><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n     * Removes all of the elements from this list.  The list will\n     * be empty after this call returns.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">clear</span><span class=\"hljs-params\">()</span> </span>&#123;\n        modCount++;\n        <span class=\"hljs-comment\">// clear to let GC do its work</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)\n            elementData[i] = <span class=\"hljs-keyword\">null</span>;\n        size = <span class=\"hljs-number\">0</span>;\n    &#125;</code></pre></p>\n<h3 id=\"软引用-SoftReference\"><a href=\"#软引用-SoftReference\" class=\"headerlink\" title=\"软引用 SoftReference\"></a>软引用 SoftReference</h3><p>如果一个对象具有软引用，只有当内存不足时才会进行回收，一般用于图片缓存、网页缓存等，例如在<code>spring-retry</code> 就有使用<code>SoftReferenceMapRetryContextCache</code>软引用作为重试上下文缓存，当内存不足的时候被<code>GC</code>回收，内存足够的时候避免创建浪费性能，也能避免大量创建引发<strong>OOM</strong></p>\n<pre><code class=\"hljs java\">Obejct a = <span class=\"hljs-keyword\">new</span> Object()\nSoftReference soft = <span class=\"hljs-keyword\">new</span> SoftReference(a);\nsoft.get();</code></pre>\n<h3 id=\"弱引用-WeckReference\"><a href=\"#弱引用-WeckReference\" class=\"headerlink\" title=\"弱引用 WeckReference\"></a>弱引用 WeckReference</h3><p>弱引用描述被必须对象的，无论内存是否充足都会被<code>GC</code>所回收（未被强引用），<code>ThreadLocal</code>的实现就有用到软引用</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-meta\">@AllArgsConstructor</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> String name;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>&#123;\n        Test t = <span class=\"hljs-keyword\">new</span> Test(<span class=\"hljs-string\">\"123\"</span>);\n        WeakReference weakReference = <span class=\"hljs-keyword\">new</span> WeakReference(t);\n        System.gc();\n        System.out.println(weakReference.get());\n        t = <span class=\"hljs-keyword\">null</span>;\n        System.gc();\n        System.out.println(weakReference.get());\n    &#125;\n&#125;</code></pre>\n<blockquote>\n<blockquote>\n<p>第一次输出 <strong>Test(name=123)</strong>，因为有强引用<code>t</code>指向，当把<code>t = null</code>执行完后进行垃圾回收则输出 <strong>null</strong></p>\n</blockquote>\n</blockquote>\n<h3 id=\"虚引用-PhantomReference\"><a href=\"#虚引用-PhantomReference\" class=\"headerlink\" title=\"虚引用 PhantomReference\"></a>虚引用 PhantomReference</h3><p>无论是否被强引用、内存充足都会<code>GC</code>回收，在使用虚引用必须配合<code>ReferenceQueue</code>引用队列使用，它的主要作用是跟踪对象的垃圾回收的状态，当对象被回收后会将引用加入到引用队列中，以便后续进行其他行为操作，例如 <code>WeakHashMap</code>,其内部维护了<code>ReferenceQueue</code>当<code>Key</code>值被回收时，会删除相关的<code>Entry</code></p>\n"},{"title":"Java 排序方法总结","toc":false,"date":"2019-07-25T08:42:11.000Z","_content":"\n![](/images/sort-algorithms.png)\n\n> 经常项目中会遇到排序问题面试也会问，收集下各种排序思想和代码实现以便加深记忆\n\n\n![](/images/sortTable.png)\n\n\n### 冒泡排序（Bubble Sort）\n访问数组的所有元素每次比较两个相邻元素如果符合条件则置换位置一直到所有相邻元素满足条件\n![图解](/images/bubble-sort.gif)\n\n###### 代码实现\n``` java\npublic static void bubble_sort(int[] sortArray) {\n    for (int i = 0; i < sortArray.length; i++) {\n        // 内循环控制需要比较(length-i-1)次 \n        // 每次循环会把最大值置换到最右边  \n        for (int j = 0; j < sortArray.length - i - 1; j++) {\n            if (sortArray[j] > sortArray[j + 1]) {\n                int temp = sortArray[j + 1];\n                sortArray[j + 1] = sortArray[j];\n                sortArray[j] = temp;\n            }\n        }\n    }\n    System.out.println(Arrays.toString(sortArray));\n}\n```\n\n### 选择排序（Selection Sort）\n从无序序列中寻找最小值置换到无序序列起始位置即有序序列最末段，循环`n-1`次使其所有元素排序完成\n![图解](/images/selection-sort.gif)\n\n##### 代码实现\n``` java\npublic static void selection_sort(int[] sortArray){\n    // 外循环控制无序列区的范围 从0  到 length\n    for(int i=0;i<sortArray.length;i++){\n        int minIndex=i;\n        // 内循环查找无序列区最小值下标 无序列区首位置为i\n        for(int j=i;j<sortArray.length;j++){\n            if(sortArray[j]<sortArray[minIndex]){\n                minIndex=j;\n            }\n        }\n        // 将最小值置换到无序列区首位置\n        int temp=sortArray[minIndex];\n        sortArray[minIndex]=sortArray[i];\n        sortArray[i]=temp;\n    }\n    System.out.println(Arrays.toString(sortArray));\n}\n```\n\n### 插入排序 （Insertion Sort）\n将数组中所有的元素依次跟之前的元素相比较，如遇到比自身小的元素则进行交换直到比较所有元素\n\n![图解](/images/insert-sort.gif)\n\n###### 代码实现\n``` java\npublic static void insert_sort(int[] sortArray){\n    // 外循环取出移动元素\n    for (int i = 1; i < sortArray.length-1; i++) {\n        int comparativeValue = sortArray[i+1];\n        // 内循环比较值前所有元素进行对比\n        // 小于则进行位置后移直到所有元素比较完毕或遇到大于等于的元素进去插入\n        int preIndex  = i;\n        while (preIndex  >= 0 && sortArray[preIndex] > comparativeValue) {\n            sortArray[preIndex+1] = sortArray[preIndex];\n            preIndex --;\n        }\n        sortArray[preIndex+1] = comparativeValue;\n    }\n    System.out.println(Arrays.toString(sortArray));\n}\n```\n\n### 希尔排序（Shell Sort）\n\n希尔排序又称__递减增量排序算法__属于插入排序改进版，算法思想为讲整个待排序记录分割为若干个子序列进行直接插入排序，然后再对所有子序列进行直接插入排序\n\n\n\n### 快速排序","source":"_posts/Java-排序方法总结.md","raw":"---\ntitle: Java 排序方法总结\ntags:\n  - 复习\ncategories:\n  - Java\ntoc: false\ndate: 2019-07-25 16:42:11\n---\n\n![](/images/sort-algorithms.png)\n\n> 经常项目中会遇到排序问题面试也会问，收集下各种排序思想和代码实现以便加深记忆\n\n\n![](/images/sortTable.png)\n\n\n### 冒泡排序（Bubble Sort）\n访问数组的所有元素每次比较两个相邻元素如果符合条件则置换位置一直到所有相邻元素满足条件\n![图解](/images/bubble-sort.gif)\n\n###### 代码实现\n``` java\npublic static void bubble_sort(int[] sortArray) {\n    for (int i = 0; i < sortArray.length; i++) {\n        // 内循环控制需要比较(length-i-1)次 \n        // 每次循环会把最大值置换到最右边  \n        for (int j = 0; j < sortArray.length - i - 1; j++) {\n            if (sortArray[j] > sortArray[j + 1]) {\n                int temp = sortArray[j + 1];\n                sortArray[j + 1] = sortArray[j];\n                sortArray[j] = temp;\n            }\n        }\n    }\n    System.out.println(Arrays.toString(sortArray));\n}\n```\n\n### 选择排序（Selection Sort）\n从无序序列中寻找最小值置换到无序序列起始位置即有序序列最末段，循环`n-1`次使其所有元素排序完成\n![图解](/images/selection-sort.gif)\n\n##### 代码实现\n``` java\npublic static void selection_sort(int[] sortArray){\n    // 外循环控制无序列区的范围 从0  到 length\n    for(int i=0;i<sortArray.length;i++){\n        int minIndex=i;\n        // 内循环查找无序列区最小值下标 无序列区首位置为i\n        for(int j=i;j<sortArray.length;j++){\n            if(sortArray[j]<sortArray[minIndex]){\n                minIndex=j;\n            }\n        }\n        // 将最小值置换到无序列区首位置\n        int temp=sortArray[minIndex];\n        sortArray[minIndex]=sortArray[i];\n        sortArray[i]=temp;\n    }\n    System.out.println(Arrays.toString(sortArray));\n}\n```\n\n### 插入排序 （Insertion Sort）\n将数组中所有的元素依次跟之前的元素相比较，如遇到比自身小的元素则进行交换直到比较所有元素\n\n![图解](/images/insert-sort.gif)\n\n###### 代码实现\n``` java\npublic static void insert_sort(int[] sortArray){\n    // 外循环取出移动元素\n    for (int i = 1; i < sortArray.length-1; i++) {\n        int comparativeValue = sortArray[i+1];\n        // 内循环比较值前所有元素进行对比\n        // 小于则进行位置后移直到所有元素比较完毕或遇到大于等于的元素进去插入\n        int preIndex  = i;\n        while (preIndex  >= 0 && sortArray[preIndex] > comparativeValue) {\n            sortArray[preIndex+1] = sortArray[preIndex];\n            preIndex --;\n        }\n        sortArray[preIndex+1] = comparativeValue;\n    }\n    System.out.println(Arrays.toString(sortArray));\n}\n```\n\n### 希尔排序（Shell Sort）\n\n希尔排序又称__递减增量排序算法__属于插入排序改进版，算法思想为讲整个待排序记录分割为若干个子序列进行直接插入排序，然后再对所有子序列进行直接插入排序\n\n\n\n### 快速排序","slug":"Java-排序方法总结","published":1,"updated":"2020-08-10T01:48:44.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc97g000wjsudbkikj5jz","content":"<p><img src=\"/images/sort-algorithms.png\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>经常项目中会遇到排序问题面试也会问，收集下各种排序思想和代码实现以便加深记忆</p>\n</blockquote>\n<p><img src=\"/images/sortTable.png\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"冒泡排序（Bubble-Sort）\"><a href=\"#冒泡排序（Bubble-Sort）\" class=\"headerlink\" title=\"冒泡排序（Bubble Sort）\"></a>冒泡排序（Bubble Sort）</h3><p>访问数组的所有元素每次比较两个相邻元素如果符合条件则置换位置一直到所有相邻元素满足条件<br><img src=\"/images/bubble-sort.gif\" srcset=\"/img/loading.gif\" alt=\"图解\"></p>\n<h6 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h6><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bubble_sort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] sortArray)</span> </span>&#123;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; sortArray.length; i++) &#123;\n        <span class=\"hljs-comment\">// 内循环控制需要比较(length-i-1)次 </span>\n        <span class=\"hljs-comment\">// 每次循环会把最大值置换到最右边  </span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; sortArray.length - i - <span class=\"hljs-number\">1</span>; j++) &#123;\n            <span class=\"hljs-keyword\">if</span> (sortArray[j] &gt; sortArray[j + <span class=\"hljs-number\">1</span>]) &#123;\n                <span class=\"hljs-keyword\">int</span> temp = sortArray[j + <span class=\"hljs-number\">1</span>];\n                sortArray[j + <span class=\"hljs-number\">1</span>] = sortArray[j];\n                sortArray[j] = temp;\n            &#125;\n        &#125;\n    &#125;\n    System.out.println(Arrays.toString(sortArray));\n&#125;</code></pre>\n<h3 id=\"选择排序（Selection-Sort）\"><a href=\"#选择排序（Selection-Sort）\" class=\"headerlink\" title=\"选择排序（Selection Sort）\"></a>选择排序（Selection Sort）</h3><p>从无序序列中寻找最小值置换到无序序列起始位置即有序序列最末段，循环<code>n-1</code>次使其所有元素排序完成<br><img src=\"/images/selection-sort.gif\" srcset=\"/img/loading.gif\" alt=\"图解\"></p>\n<h5 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h5><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">selection_sort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] sortArray)</span></span>&#123;\n    <span class=\"hljs-comment\">// 外循环控制无序列区的范围 从0  到 length</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;sortArray.length;i++)&#123;\n        <span class=\"hljs-keyword\">int</span> minIndex=i;\n        <span class=\"hljs-comment\">// 内循环查找无序列区最小值下标 无序列区首位置为i</span>\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i;j&lt;sortArray.length;j++)&#123;\n            <span class=\"hljs-keyword\">if</span>(sortArray[j]&lt;sortArray[minIndex])&#123;\n                minIndex=j;\n            &#125;\n        &#125;\n        <span class=\"hljs-comment\">// 将最小值置换到无序列区首位置</span>\n        <span class=\"hljs-keyword\">int</span> temp=sortArray[minIndex];\n        sortArray[minIndex]=sortArray[i];\n        sortArray[i]=temp;\n    &#125;\n    System.out.println(Arrays.toString(sortArray));\n&#125;</code></pre>\n<h3 id=\"插入排序-（Insertion-Sort）\"><a href=\"#插入排序-（Insertion-Sort）\" class=\"headerlink\" title=\"插入排序 （Insertion Sort）\"></a>插入排序 （Insertion Sort）</h3><p>将数组中所有的元素依次跟之前的元素相比较，如遇到比自身小的元素则进行交换直到比较所有元素</p>\n<p><img src=\"/images/insert-sort.gif\" srcset=\"/img/loading.gif\" alt=\"图解\"></p>\n<h6 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h6><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert_sort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] sortArray)</span></span>&#123;\n    <span class=\"hljs-comment\">// 外循环取出移动元素</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; sortArray.length-<span class=\"hljs-number\">1</span>; i++) &#123;\n        <span class=\"hljs-keyword\">int</span> comparativeValue = sortArray[i+<span class=\"hljs-number\">1</span>];\n        <span class=\"hljs-comment\">// 内循环比较值前所有元素进行对比</span>\n        <span class=\"hljs-comment\">// 小于则进行位置后移直到所有元素比较完毕或遇到大于等于的元素进去插入</span>\n        <span class=\"hljs-keyword\">int</span> preIndex  = i;\n        <span class=\"hljs-keyword\">while</span> (preIndex  &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; sortArray[preIndex] &gt; comparativeValue) &#123;\n            sortArray[preIndex+<span class=\"hljs-number\">1</span>] = sortArray[preIndex];\n            preIndex --;\n        &#125;\n        sortArray[preIndex+<span class=\"hljs-number\">1</span>] = comparativeValue;\n    &#125;\n    System.out.println(Arrays.toString(sortArray));\n&#125;</code></pre>\n<h3 id=\"希尔排序（Shell-Sort）\"><a href=\"#希尔排序（Shell-Sort）\" class=\"headerlink\" title=\"希尔排序（Shell Sort）\"></a>希尔排序（Shell Sort）</h3><p>希尔排序又称<strong>递减增量排序算法</strong>属于插入排序改进版，算法思想为讲整个待排序记录分割为若干个子序列进行直接插入排序，然后再对所有子序列进行直接插入排序</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/sort-algorithms.png\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>经常项目中会遇到排序问题面试也会问，收集下各种排序思想和代码实现以便加深记忆</p>\n</blockquote>\n<p><img src=\"/images/sortTable.png\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"冒泡排序（Bubble-Sort）\"><a href=\"#冒泡排序（Bubble-Sort）\" class=\"headerlink\" title=\"冒泡排序（Bubble Sort）\"></a>冒泡排序（Bubble Sort）</h3><p>访问数组的所有元素每次比较两个相邻元素如果符合条件则置换位置一直到所有相邻元素满足条件<br><img src=\"/images/bubble-sort.gif\" srcset=\"/img/loading.gif\" alt=\"图解\"></p>\n<h6 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h6><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bubble_sort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] sortArray)</span> </span>&#123;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; sortArray.length; i++) &#123;\n        <span class=\"hljs-comment\">// 内循环控制需要比较(length-i-1)次 </span>\n        <span class=\"hljs-comment\">// 每次循环会把最大值置换到最右边  </span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; sortArray.length - i - <span class=\"hljs-number\">1</span>; j++) &#123;\n            <span class=\"hljs-keyword\">if</span> (sortArray[j] &gt; sortArray[j + <span class=\"hljs-number\">1</span>]) &#123;\n                <span class=\"hljs-keyword\">int</span> temp = sortArray[j + <span class=\"hljs-number\">1</span>];\n                sortArray[j + <span class=\"hljs-number\">1</span>] = sortArray[j];\n                sortArray[j] = temp;\n            &#125;\n        &#125;\n    &#125;\n    System.out.println(Arrays.toString(sortArray));\n&#125;</code></pre>\n<h3 id=\"选择排序（Selection-Sort）\"><a href=\"#选择排序（Selection-Sort）\" class=\"headerlink\" title=\"选择排序（Selection Sort）\"></a>选择排序（Selection Sort）</h3><p>从无序序列中寻找最小值置换到无序序列起始位置即有序序列最末段，循环<code>n-1</code>次使其所有元素排序完成<br><img src=\"/images/selection-sort.gif\" srcset=\"/img/loading.gif\" alt=\"图解\"></p>\n<h5 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h5><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">selection_sort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] sortArray)</span></span>&#123;\n    <span class=\"hljs-comment\">// 外循环控制无序列区的范围 从0  到 length</span>\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;sortArray.length;i++)&#123;\n        <span class=\"hljs-keyword\">int</span> minIndex=i;\n        <span class=\"hljs-comment\">// 内循环查找无序列区最小值下标 无序列区首位置为i</span>\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i;j&lt;sortArray.length;j++)&#123;\n            <span class=\"hljs-keyword\">if</span>(sortArray[j]&lt;sortArray[minIndex])&#123;\n                minIndex=j;\n            &#125;\n        &#125;\n        <span class=\"hljs-comment\">// 将最小值置换到无序列区首位置</span>\n        <span class=\"hljs-keyword\">int</span> temp=sortArray[minIndex];\n        sortArray[minIndex]=sortArray[i];\n        sortArray[i]=temp;\n    &#125;\n    System.out.println(Arrays.toString(sortArray));\n&#125;</code></pre>\n<h3 id=\"插入排序-（Insertion-Sort）\"><a href=\"#插入排序-（Insertion-Sort）\" class=\"headerlink\" title=\"插入排序 （Insertion Sort）\"></a>插入排序 （Insertion Sort）</h3><p>将数组中所有的元素依次跟之前的元素相比较，如遇到比自身小的元素则进行交换直到比较所有元素</p>\n<p><img src=\"/images/insert-sort.gif\" srcset=\"/img/loading.gif\" alt=\"图解\"></p>\n<h6 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h6><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert_sort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] sortArray)</span></span>&#123;\n    <span class=\"hljs-comment\">// 外循环取出移动元素</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; sortArray.length-<span class=\"hljs-number\">1</span>; i++) &#123;\n        <span class=\"hljs-keyword\">int</span> comparativeValue = sortArray[i+<span class=\"hljs-number\">1</span>];\n        <span class=\"hljs-comment\">// 内循环比较值前所有元素进行对比</span>\n        <span class=\"hljs-comment\">// 小于则进行位置后移直到所有元素比较完毕或遇到大于等于的元素进去插入</span>\n        <span class=\"hljs-keyword\">int</span> preIndex  = i;\n        <span class=\"hljs-keyword\">while</span> (preIndex  &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; sortArray[preIndex] &gt; comparativeValue) &#123;\n            sortArray[preIndex+<span class=\"hljs-number\">1</span>] = sortArray[preIndex];\n            preIndex --;\n        &#125;\n        sortArray[preIndex+<span class=\"hljs-number\">1</span>] = comparativeValue;\n    &#125;\n    System.out.println(Arrays.toString(sortArray));\n&#125;</code></pre>\n<h3 id=\"希尔排序（Shell-Sort）\"><a href=\"#希尔排序（Shell-Sort）\" class=\"headerlink\" title=\"希尔排序（Shell Sort）\"></a>希尔排序（Shell Sort）</h3><p>希尔排序又称<strong>递减增量排序算法</strong>属于插入排序改进版，算法思想为讲整个待排序记录分割为若干个子序列进行直接插入排序，然后再对所有子序列进行直接插入排序</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3>"},{"title":"Java 集合总结","toc":false,"date":"2019-07-22T08:43:25.000Z","_content":"\n![Java](/images/java.jpg)\n\n> 记录回顾下 Java 集合内容，面试会经常会问到各种集合的特点和区别，在不同情况下合理使用集合处理数据\n\n\n## Java 集合\nJava 集合分为两大接口`Collection`（元素集合）、`Map`（键值对集合），根据两大接口又分为各类集合\n\n![](/images/collection.png)\n\n### Map 键值对\nMap 由 key 和 value 键值对组成，key 不重复存入重复的 key 会覆盖原有 value\n\n|集合|数据结构|是否有序|线程安全|特点|\n|:-|:-:|:-:|:-:|:-:|\n|HashMap|数组和链表|无序|不安全|链表长度大于阈值8则转化成红黑树，小于6则转回链表|\n|TreeMap|red-black（红-黑）树|无序|不安全|映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序|\n|LinkedHashMap|链表|有序|不安全|允许使用 Null 键值|\n\n### Collection 集合\n\n#### List 接口\nList 代表有序的 Collection 且元素可以重复，用户对插入的元素位置精确把控，数组维护整个集合顺序，同时可以通过 index 下标直接访问相应的元素\n\n|集合|数据结构|是否有序|线程安全|特点|\n|:-|:-:|:-:|:-:|:-:|\n|ArrayList|数组|有序|不安全|随机访问、查询效率高|\n|Vector|数组|有序|安全||\n|LinkedList|双向链表|有序|不安全|插入删除效率高，可从头尾顺序进行插入删除|\n\n#### Set 接口\nSet 代表无序的 Collection 且不包含重复元素，可以存入有且只有一个`Null`元素\n\n|集合|数据结构|是否有序|线程安全|特点|\n|:-|:-:|:-:|:-:|:-:|\n|HashSet|简化版 HashMap|无序|不安全|内部由 HashMap 实现 key 为存入数据 Value 都为同一个 Object 对象，HashMap 的 key不可重复特性实现去重效果|\n|TreeSet|TreeMap 实现|无序|不安全|内部由 TreeMap 实现的有序二叉树，基本类型按照自然顺序排序，对象则根据 Comparator 进行自动排序|\n|LinkedHashSet|双向链表|有序|不安全|HashSet 子类内部由链表来维护插入元素顺序|","source":"_posts/Java-集合总结.md","raw":"---\ntitle: Java 集合总结\ntags:\n  - 复习\ncategories:\n  - Java\ntoc: false\ndate: 2019-07-22 16:43:25\n---\n\n![Java](/images/java.jpg)\n\n> 记录回顾下 Java 集合内容，面试会经常会问到各种集合的特点和区别，在不同情况下合理使用集合处理数据\n\n\n## Java 集合\nJava 集合分为两大接口`Collection`（元素集合）、`Map`（键值对集合），根据两大接口又分为各类集合\n\n![](/images/collection.png)\n\n### Map 键值对\nMap 由 key 和 value 键值对组成，key 不重复存入重复的 key 会覆盖原有 value\n\n|集合|数据结构|是否有序|线程安全|特点|\n|:-|:-:|:-:|:-:|:-:|\n|HashMap|数组和链表|无序|不安全|链表长度大于阈值8则转化成红黑树，小于6则转回链表|\n|TreeMap|red-black（红-黑）树|无序|不安全|映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序|\n|LinkedHashMap|链表|有序|不安全|允许使用 Null 键值|\n\n### Collection 集合\n\n#### List 接口\nList 代表有序的 Collection 且元素可以重复，用户对插入的元素位置精确把控，数组维护整个集合顺序，同时可以通过 index 下标直接访问相应的元素\n\n|集合|数据结构|是否有序|线程安全|特点|\n|:-|:-:|:-:|:-:|:-:|\n|ArrayList|数组|有序|不安全|随机访问、查询效率高|\n|Vector|数组|有序|安全||\n|LinkedList|双向链表|有序|不安全|插入删除效率高，可从头尾顺序进行插入删除|\n\n#### Set 接口\nSet 代表无序的 Collection 且不包含重复元素，可以存入有且只有一个`Null`元素\n\n|集合|数据结构|是否有序|线程安全|特点|\n|:-|:-:|:-:|:-:|:-:|\n|HashSet|简化版 HashMap|无序|不安全|内部由 HashMap 实现 key 为存入数据 Value 都为同一个 Object 对象，HashMap 的 key不可重复特性实现去重效果|\n|TreeSet|TreeMap 实现|无序|不安全|内部由 TreeMap 实现的有序二叉树，基本类型按照自然顺序排序，对象则根据 Comparator 进行自动排序|\n|LinkedHashSet|双向链表|有序|不安全|HashSet 子类内部由链表来维护插入元素顺序|","slug":"Java-集合总结","published":1,"updated":"2020-08-10T01:48:44.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc97k0010jsudo5serpch","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>记录回顾下 Java 集合内容，面试会经常会问到各种集合的特点和区别，在不同情况下合理使用集合处理数据</p>\n</blockquote>\n<h2 id=\"Java-集合\"><a href=\"#Java-集合\" class=\"headerlink\" title=\"Java 集合\"></a>Java 集合</h2><p>Java 集合分为两大接口<code>Collection</code>（元素集合）、<code>Map</code>（键值对集合），根据两大接口又分为各类集合</p>\n<p><img src=\"/images/collection.png\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"Map-键值对\"><a href=\"#Map-键值对\" class=\"headerlink\" title=\"Map 键值对\"></a>Map 键值对</h3><p>Map 由 key 和 value 键值对组成，key 不重复存入重复的 key 会覆盖原有 value</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">集合</th>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">是否有序</th>\n<th style=\"text-align:center\">线程安全</th>\n<th style=\"text-align:center\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">HashMap</td>\n<td style=\"text-align:center\">数组和链表</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">链表长度大于阈值8则转化成红黑树，小于6则转回链表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TreeMap</td>\n<td style=\"text-align:center\">red-black（红-黑）树</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedHashMap</td>\n<td style=\"text-align:center\">链表</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">允许使用 Null 键值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Collection-集合\"><a href=\"#Collection-集合\" class=\"headerlink\" title=\"Collection 集合\"></a>Collection 集合</h3><h4 id=\"List-接口\"><a href=\"#List-接口\" class=\"headerlink\" title=\"List 接口\"></a>List 接口</h4><p>List 代表有序的 Collection 且元素可以重复，用户对插入的元素位置精确把控，数组维护整个集合顺序，同时可以通过 index 下标直接访问相应的元素</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">集合</th>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">是否有序</th>\n<th style=\"text-align:center\">线程安全</th>\n<th style=\"text-align:center\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ArrayList</td>\n<td style=\"text-align:center\">数组</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">随机访问、查询效率高</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Vector</td>\n<td style=\"text-align:center\">数组</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">安全</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedList</td>\n<td style=\"text-align:center\">双向链表</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">插入删除效率高，可从头尾顺序进行插入删除</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Set-接口\"><a href=\"#Set-接口\" class=\"headerlink\" title=\"Set 接口\"></a>Set 接口</h4><p>Set 代表无序的 Collection 且不包含重复元素，可以存入有且只有一个<code>Null</code>元素</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">集合</th>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">是否有序</th>\n<th style=\"text-align:center\">线程安全</th>\n<th style=\"text-align:center\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">HashSet</td>\n<td style=\"text-align:center\">简化版 HashMap</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">内部由 HashMap 实现 key 为存入数据 Value 都为同一个 Object 对象，HashMap 的 key不可重复特性实现去重效果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TreeSet</td>\n<td style=\"text-align:center\">TreeMap 实现</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">内部由 TreeMap 实现的有序二叉树，基本类型按照自然顺序排序，对象则根据 Comparator 进行自动排序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedHashSet</td>\n<td style=\"text-align:center\">双向链表</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">HashSet 子类内部由链表来维护插入元素顺序</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>记录回顾下 Java 集合内容，面试会经常会问到各种集合的特点和区别，在不同情况下合理使用集合处理数据</p>\n</blockquote>\n<h2 id=\"Java-集合\"><a href=\"#Java-集合\" class=\"headerlink\" title=\"Java 集合\"></a>Java 集合</h2><p>Java 集合分为两大接口<code>Collection</code>（元素集合）、<code>Map</code>（键值对集合），根据两大接口又分为各类集合</p>\n<p><img src=\"/images/collection.png\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"Map-键值对\"><a href=\"#Map-键值对\" class=\"headerlink\" title=\"Map 键值对\"></a>Map 键值对</h3><p>Map 由 key 和 value 键值对组成，key 不重复存入重复的 key 会覆盖原有 value</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">集合</th>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">是否有序</th>\n<th style=\"text-align:center\">线程安全</th>\n<th style=\"text-align:center\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">HashMap</td>\n<td style=\"text-align:center\">数组和链表</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">链表长度大于阈值8则转化成红黑树，小于6则转回链表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TreeMap</td>\n<td style=\"text-align:center\">red-black（红-黑）树</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedHashMap</td>\n<td style=\"text-align:center\">链表</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">允许使用 Null 键值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Collection-集合\"><a href=\"#Collection-集合\" class=\"headerlink\" title=\"Collection 集合\"></a>Collection 集合</h3><h4 id=\"List-接口\"><a href=\"#List-接口\" class=\"headerlink\" title=\"List 接口\"></a>List 接口</h4><p>List 代表有序的 Collection 且元素可以重复，用户对插入的元素位置精确把控，数组维护整个集合顺序，同时可以通过 index 下标直接访问相应的元素</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">集合</th>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">是否有序</th>\n<th style=\"text-align:center\">线程安全</th>\n<th style=\"text-align:center\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ArrayList</td>\n<td style=\"text-align:center\">数组</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">随机访问、查询效率高</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Vector</td>\n<td style=\"text-align:center\">数组</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">安全</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedList</td>\n<td style=\"text-align:center\">双向链表</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">插入删除效率高，可从头尾顺序进行插入删除</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Set-接口\"><a href=\"#Set-接口\" class=\"headerlink\" title=\"Set 接口\"></a>Set 接口</h4><p>Set 代表无序的 Collection 且不包含重复元素，可以存入有且只有一个<code>Null</code>元素</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">集合</th>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">是否有序</th>\n<th style=\"text-align:center\">线程安全</th>\n<th style=\"text-align:center\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">HashSet</td>\n<td style=\"text-align:center\">简化版 HashMap</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">内部由 HashMap 实现 key 为存入数据 Value 都为同一个 Object 对象，HashMap 的 key不可重复特性实现去重效果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TreeSet</td>\n<td style=\"text-align:center\">TreeMap 实现</td>\n<td style=\"text-align:center\">无序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">内部由 TreeMap 实现的有序二叉树，基本类型按照自然顺序排序，对象则根据 Comparator 进行自动排序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedHashSet</td>\n<td style=\"text-align:center\">双向链表</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">不安全</td>\n<td style=\"text-align:center\">HashSet 子类内部由链表来维护插入元素顺序</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"Linux 中判断条件","toc":false,"date":"2019-08-08T02:38:34.000Z","_content":"\n![](/images/linux-1.jpg)\n\n> 学习记录下 Linux下判断条件 便于回来翻查\n\n### if 基本语法\n``` bash\nif [comand]; then \n   执行语句\nelif [comand]; then\n   执行语句\nelse\n   执行语句\nfi\n```\n\n### 文件判断\n[-d File] 存在且为文件夹\n[-f File] 存在且为普通文件\n[-s File] 存在且大小不为0\n[-x File] 存在且为可执行\n[-r File] 存在且为可读\n[-w File] 存在且为写\n\n### 字符串判断\n[-z String] 是否为空长度为0\n[-n String] 是否为非空 non-zero\n[String] 是否为非空与[-n String]一样的功能\n[String1 == String2] String 是否相等\n[String1 != String2] String 是否不相等\n\n### 数字判断\n[Int1 -eq Int2] 是否相等\n[Int1 -ne Int2] 是否不相等\n[Int1 -gt Int2] 是否大于\n[Int1 -lt Int2] 是否小于\n[Int1 -ge Int2] 是否大于等于\n[Int1 -le Int2] 是否小于等于\n\t\n### 逻辑连接符\n-a 且 &&\n-o 或者 ||\n! 非","source":"_posts/Linux-中判断条件.md","raw":"---\ntitle: Linux 中判断条件\ntags:\n  - Linux\ncategories:\n  - Linux\ntoc: false\ndate: 2019-08-08 10:38:34\n---\n\n![](/images/linux-1.jpg)\n\n> 学习记录下 Linux下判断条件 便于回来翻查\n\n### if 基本语法\n``` bash\nif [comand]; then \n   执行语句\nelif [comand]; then\n   执行语句\nelse\n   执行语句\nfi\n```\n\n### 文件判断\n[-d File] 存在且为文件夹\n[-f File] 存在且为普通文件\n[-s File] 存在且大小不为0\n[-x File] 存在且为可执行\n[-r File] 存在且为可读\n[-w File] 存在且为写\n\n### 字符串判断\n[-z String] 是否为空长度为0\n[-n String] 是否为非空 non-zero\n[String] 是否为非空与[-n String]一样的功能\n[String1 == String2] String 是否相等\n[String1 != String2] String 是否不相等\n\n### 数字判断\n[Int1 -eq Int2] 是否相等\n[Int1 -ne Int2] 是否不相等\n[Int1 -gt Int2] 是否大于\n[Int1 -lt Int2] 是否小于\n[Int1 -ge Int2] 是否大于等于\n[Int1 -le Int2] 是否小于等于\n\t\n### 逻辑连接符\n-a 且 &&\n-o 或者 ||\n! 非","slug":"Linux-中判断条件","published":1,"updated":"2020-08-10T01:48:44.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc97m0013jsudly48l4ov","content":"<p><img src=\"/images/linux-1.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>学习记录下 Linux下判断条件 便于回来翻查</p>\n</blockquote>\n<h3 id=\"if-基本语法\"><a href=\"#if-基本语法\" class=\"headerlink\" title=\"if 基本语法\"></a>if 基本语法</h3><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">if</span> [comand]; <span class=\"hljs-keyword\">then</span> \n   执行语句\n<span class=\"hljs-keyword\">elif</span> [comand]; <span class=\"hljs-keyword\">then</span>\n   执行语句\n<span class=\"hljs-keyword\">else</span>\n   执行语句\n<span class=\"hljs-keyword\">fi</span></code></pre>\n<h3 id=\"文件判断\"><a href=\"#文件判断\" class=\"headerlink\" title=\"文件判断\"></a>文件判断</h3><p>[-d File] 存在且为文件夹<br>[-f File] 存在且为普通文件<br>[-s File] 存在且大小不为0<br>[-x File] 存在且为可执行<br>[-r File] 存在且为可读<br>[-w File] 存在且为写</p>\n<h3 id=\"字符串判断\"><a href=\"#字符串判断\" class=\"headerlink\" title=\"字符串判断\"></a>字符串判断</h3><p>[-z String] 是否为空长度为0<br>[-n String] 是否为非空 non-zero<br>[String] 是否为非空与[-n String]一样的功能<br>[String1 == String2] String 是否相等<br>[String1 != String2] String 是否不相等</p>\n<h3 id=\"数字判断\"><a href=\"#数字判断\" class=\"headerlink\" title=\"数字判断\"></a>数字判断</h3><p>[Int1 -eq Int2] 是否相等<br>[Int1 -ne Int2] 是否不相等<br>[Int1 -gt Int2] 是否大于<br>[Int1 -lt Int2] 是否小于<br>[Int1 -ge Int2] 是否大于等于<br>[Int1 -le Int2] 是否小于等于</p>\n<h3 id=\"逻辑连接符\"><a href=\"#逻辑连接符\" class=\"headerlink\" title=\"逻辑连接符\"></a>逻辑连接符</h3><p>-a 且 &amp;&amp;<br>-o 或者 ||<br>! 非</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/linux-1.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>学习记录下 Linux下判断条件 便于回来翻查</p>\n</blockquote>\n<h3 id=\"if-基本语法\"><a href=\"#if-基本语法\" class=\"headerlink\" title=\"if 基本语法\"></a>if 基本语法</h3><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">if</span> [comand]; <span class=\"hljs-keyword\">then</span> \n   执行语句\n<span class=\"hljs-keyword\">elif</span> [comand]; <span class=\"hljs-keyword\">then</span>\n   执行语句\n<span class=\"hljs-keyword\">else</span>\n   执行语句\n<span class=\"hljs-keyword\">fi</span></code></pre>\n<h3 id=\"文件判断\"><a href=\"#文件判断\" class=\"headerlink\" title=\"文件判断\"></a>文件判断</h3><p>[-d File] 存在且为文件夹<br>[-f File] 存在且为普通文件<br>[-s File] 存在且大小不为0<br>[-x File] 存在且为可执行<br>[-r File] 存在且为可读<br>[-w File] 存在且为写</p>\n<h3 id=\"字符串判断\"><a href=\"#字符串判断\" class=\"headerlink\" title=\"字符串判断\"></a>字符串判断</h3><p>[-z String] 是否为空长度为0<br>[-n String] 是否为非空 non-zero<br>[String] 是否为非空与[-n String]一样的功能<br>[String1 == String2] String 是否相等<br>[String1 != String2] String 是否不相等</p>\n<h3 id=\"数字判断\"><a href=\"#数字判断\" class=\"headerlink\" title=\"数字判断\"></a>数字判断</h3><p>[Int1 -eq Int2] 是否相等<br>[Int1 -ne Int2] 是否不相等<br>[Int1 -gt Int2] 是否大于<br>[Int1 -lt Int2] 是否小于<br>[Int1 -ge Int2] 是否大于等于<br>[Int1 -le Int2] 是否小于等于</p>\n<h3 id=\"逻辑连接符\"><a href=\"#逻辑连接符\" class=\"headerlink\" title=\"逻辑连接符\"></a>逻辑连接符</h3><p>-a 且 &amp;&amp;<br>-o 或者 ||<br>! 非</p>\n"},{"title":"Linux 关机重启命令","date":"2018-07-25T05:50:04.000Z","_content":"\n![Linux](/images/linux-1.jpg)\n\n>记录学习鸟哥的私房菜之开启重启shell笔记，主要有命令shutdown，reboot，halt，poweroff\n\n## 1.Shutdown 命令介绍\n- 可以自由的选择关机模式：关机、重启或者进入单用户操作模式即可\n- 可以设置关机时间：设置在特定时间或经过多少时长后关闭，也可以立刻关闭\n- 可以自定义关机消息：在关闭服务可以通知其他登录的用户\n- 可以发送警告命令：在执行一些测试脚本或者可以影响到其他的登录用户的操作时，可以发送警告信息进行提示，但不是真的关机  \n\n\n``` bash\n#脚本参数 shutdown [-t秒] [-arkhncfF] 时间 [警告消息]\n-t sec： -t 后单位/秒 经过多少秒后执行\n-k      ：不是真关机仅发出警告信息\n-r      ：服务关闭后，关闭并重启\n-h      : 服务关闭后，立刻关机\n-c     ：取消已经在进行中的关闭操作\n-f      ：关机启动后，启动略过fsck磁盘检查\n-F     ：关机启动后 ，强制进行fsck磁盘检查\n# 3600秒后进行关闭并提示警告语\nshutdown -t 3600    'Computer will shutdown after 30 min'\n```\n\n\n","source":"_posts/Linux-关机重启命令.md","raw":"---\ntitle: Linux 关机重启命令\ndate: 2018-07-25 13:50:04\ncategories: [Linux]\ntags:\n    - Linux\n---\n\n![Linux](/images/linux-1.jpg)\n\n>记录学习鸟哥的私房菜之开启重启shell笔记，主要有命令shutdown，reboot，halt，poweroff\n\n## 1.Shutdown 命令介绍\n- 可以自由的选择关机模式：关机、重启或者进入单用户操作模式即可\n- 可以设置关机时间：设置在特定时间或经过多少时长后关闭，也可以立刻关闭\n- 可以自定义关机消息：在关闭服务可以通知其他登录的用户\n- 可以发送警告命令：在执行一些测试脚本或者可以影响到其他的登录用户的操作时，可以发送警告信息进行提示，但不是真的关机  \n\n\n``` bash\n#脚本参数 shutdown [-t秒] [-arkhncfF] 时间 [警告消息]\n-t sec： -t 后单位/秒 经过多少秒后执行\n-k      ：不是真关机仅发出警告信息\n-r      ：服务关闭后，关闭并重启\n-h      : 服务关闭后，立刻关机\n-c     ：取消已经在进行中的关闭操作\n-f      ：关机启动后，启动略过fsck磁盘检查\n-F     ：关机启动后 ，强制进行fsck磁盘检查\n# 3600秒后进行关闭并提示警告语\nshutdown -t 3600    'Computer will shutdown after 30 min'\n```\n\n\n","slug":"Linux-关机重启命令","published":1,"updated":"2020-08-10T01:48:44.726Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc97o0017jsudu8jua8qk","content":"<p><img src=\"/images/linux-1.jpg\" srcset=\"/img/loading.gif\" alt=\"Linux\"></p>\n<blockquote>\n<p>记录学习鸟哥的私房菜之开启重启shell笔记，主要有命令shutdown，reboot，halt，poweroff</p>\n</blockquote>\n<h2 id=\"1-Shutdown-命令介绍\"><a href=\"#1-Shutdown-命令介绍\" class=\"headerlink\" title=\"1.Shutdown 命令介绍\"></a>1.Shutdown 命令介绍</h2><ul>\n<li>可以自由的选择关机模式：关机、重启或者进入单用户操作模式即可</li>\n<li>可以设置关机时间：设置在特定时间或经过多少时长后关闭，也可以立刻关闭</li>\n<li>可以自定义关机消息：在关闭服务可以通知其他登录的用户</li>\n<li>可以发送警告命令：在执行一些测试脚本或者可以影响到其他的登录用户的操作时，可以发送警告信息进行提示，但不是真的关机  </li>\n</ul>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#脚本参数 shutdown [-t秒] [-arkhncfF] 时间 [警告消息]</span>\n-t sec： -t 后单位/秒 经过多少秒后执行\n-k      ：不是真关机仅发出警告信息\n-r      ：服务关闭后，关闭并重启\n-h      : 服务关闭后，立刻关机\n-c     ：取消已经在进行中的关闭操作\n-f      ：关机启动后，启动略过fsck磁盘检查\n-F     ：关机启动后 ，强制进行fsck磁盘检查\n<span class=\"hljs-comment\"># 3600秒后进行关闭并提示警告语</span>\nshutdown -t 3600    <span class=\"hljs-string\">'Computer will shutdown after 30 min'</span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/linux-1.jpg\" srcset=\"/img/loading.gif\" alt=\"Linux\"></p>\n<blockquote>\n<p>记录学习鸟哥的私房菜之开启重启shell笔记，主要有命令shutdown，reboot，halt，poweroff</p>\n</blockquote>\n<h2 id=\"1-Shutdown-命令介绍\"><a href=\"#1-Shutdown-命令介绍\" class=\"headerlink\" title=\"1.Shutdown 命令介绍\"></a>1.Shutdown 命令介绍</h2><ul>\n<li>可以自由的选择关机模式：关机、重启或者进入单用户操作模式即可</li>\n<li>可以设置关机时间：设置在特定时间或经过多少时长后关闭，也可以立刻关闭</li>\n<li>可以自定义关机消息：在关闭服务可以通知其他登录的用户</li>\n<li>可以发送警告命令：在执行一些测试脚本或者可以影响到其他的登录用户的操作时，可以发送警告信息进行提示，但不是真的关机  </li>\n</ul>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#脚本参数 shutdown [-t秒] [-arkhncfF] 时间 [警告消息]</span>\n-t sec： -t 后单位/秒 经过多少秒后执行\n-k      ：不是真关机仅发出警告信息\n-r      ：服务关闭后，关闭并重启\n-h      : 服务关闭后，立刻关机\n-c     ：取消已经在进行中的关闭操作\n-f      ：关机启动后，启动略过fsck磁盘检查\n-F     ：关机启动后 ，强制进行fsck磁盘检查\n<span class=\"hljs-comment\"># 3600秒后进行关闭并提示警告语</span>\nshutdown -t 3600    <span class=\"hljs-string\">'Computer will shutdown after 30 min'</span></code></pre>\n"},{"title":"Linux 字体背景颜色设置","toc":false,"date":"2019-08-08T07:18:38.000Z","_content":"\n![](/images/linux-1.jpg)\n\n### 颜色范围\n![](/images/color-scope.png)\n\n例如我们打印红色警告字体 `echo -e '\\033[31m[警告]红色警告提示\\031[0m'`其中`\\033[31m`为红色颜色\n\n\n### 颜色设置\n![](/images/color-setting.png)\n``` bash\necho -e \"\\033[40;37m oldboy trainning \\033[0m\"    黑底白字（字体颜色匹配上面的，自己更改）\necho -e \"\\033[41;37m oldboy trainning \\033[0m\"    红底白字\necho -e \"\\033[42;37m oldboy trainning \\033[0m\"    绿底白字\necho -e \"\\033[43;37m oldboy trainning \\033[0m\"    黄底白字\necho -e \"\\033[44;37m oldboy trainning \\033[0m\"    蓝底白字\necho -e \"\\033[45;37m oldboy trainning \\033[0m\"    紫底白字\necho -e \"\\033[46;37m oldboy trainning \\033[0m\"    天蓝白字\necho -e \"\\033[47;30m oldboy trainning \\033[0m\"    白底黑字\n```","source":"_posts/Linux-字体背景颜色设置.md","raw":"---\ntitle: Linux 字体背景颜色设置\ntags:\n  - Linux\ncategories:\n  - Linux\ntoc: false\ndate: 2019-08-08 15:18:38\n---\n\n![](/images/linux-1.jpg)\n\n### 颜色范围\n![](/images/color-scope.png)\n\n例如我们打印红色警告字体 `echo -e '\\033[31m[警告]红色警告提示\\031[0m'`其中`\\033[31m`为红色颜色\n\n\n### 颜色设置\n![](/images/color-setting.png)\n``` bash\necho -e \"\\033[40;37m oldboy trainning \\033[0m\"    黑底白字（字体颜色匹配上面的，自己更改）\necho -e \"\\033[41;37m oldboy trainning \\033[0m\"    红底白字\necho -e \"\\033[42;37m oldboy trainning \\033[0m\"    绿底白字\necho -e \"\\033[43;37m oldboy trainning \\033[0m\"    黄底白字\necho -e \"\\033[44;37m oldboy trainning \\033[0m\"    蓝底白字\necho -e \"\\033[45;37m oldboy trainning \\033[0m\"    紫底白字\necho -e \"\\033[46;37m oldboy trainning \\033[0m\"    天蓝白字\necho -e \"\\033[47;30m oldboy trainning \\033[0m\"    白底黑字\n```","slug":"Linux-字体背景颜色设置","published":1,"updated":"2020-08-10T01:48:44.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc97q001ajsudlifq8xvk","content":"<p><img src=\"/images/linux-1.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"颜色范围\"><a href=\"#颜色范围\" class=\"headerlink\" title=\"颜色范围\"></a>颜色范围</h3><p><img src=\"/images/color-scope.png\" srcset=\"/img/loading.gif\" alt></p>\n<p>例如我们打印红色警告字体 <code>echo -e &#39;\\033[31m[警告]红色警告提示\\031[0m&#39;</code>其中<code>\\033[31m</code>为红色颜色</p>\n<h3 id=\"颜色设置\"><a href=\"#颜色设置\" class=\"headerlink\" title=\"颜色设置\"></a>颜色设置</h3><p><img src=\"/images/color-setting.png\" srcset=\"/img/loading.gif\" alt><br><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[40;37m oldboy trainning \\033[0m\"</span>    黑底白字（字体颜色匹配上面的，自己更改）\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[41;37m oldboy trainning \\033[0m\"</span>    红底白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[42;37m oldboy trainning \\033[0m\"</span>    绿底白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[43;37m oldboy trainning \\033[0m\"</span>    黄底白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[44;37m oldboy trainning \\033[0m\"</span>    蓝底白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[45;37m oldboy trainning \\033[0m\"</span>    紫底白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[46;37m oldboy trainning \\033[0m\"</span>    天蓝白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[47;30m oldboy trainning \\033[0m\"</span>    白底黑字</code></pre></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/linux-1.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"颜色范围\"><a href=\"#颜色范围\" class=\"headerlink\" title=\"颜色范围\"></a>颜色范围</h3><p><img src=\"/images/color-scope.png\" srcset=\"/img/loading.gif\" alt></p>\n<p>例如我们打印红色警告字体 <code>echo -e &#39;\\033[31m[警告]红色警告提示\\031[0m&#39;</code>其中<code>\\033[31m</code>为红色颜色</p>\n<h3 id=\"颜色设置\"><a href=\"#颜色设置\" class=\"headerlink\" title=\"颜色设置\"></a>颜色设置</h3><p><img src=\"/images/color-setting.png\" srcset=\"/img/loading.gif\" alt><br><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[40;37m oldboy trainning \\033[0m\"</span>    黑底白字（字体颜色匹配上面的，自己更改）\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[41;37m oldboy trainning \\033[0m\"</span>    红底白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[42;37m oldboy trainning \\033[0m\"</span>    绿底白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[43;37m oldboy trainning \\033[0m\"</span>    黄底白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[44;37m oldboy trainning \\033[0m\"</span>    蓝底白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[45;37m oldboy trainning \\033[0m\"</span>    紫底白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[46;37m oldboy trainning \\033[0m\"</span>    天蓝白字\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\033[47;30m oldboy trainning \\033[0m\"</span>    白底黑字</code></pre></p>\n"},{"title":"Linux 文件权限管理","date":"2018-07-25T07:07:09.000Z","_content":"\n![Linux](/images/linux-1.jpg)\n\n>为了保证文件系统的安全隐私，对文件进行权限控制，防止非法用户查看、修改、删除等操作。只有在指定用户或用户组才能进行操作，例如一些隐私文件或者文件夹不想被其他人进行访问查看可对文件进行权限控制。\n\n## 1. ls 命令查询文件属性\n``` bash\n[root@vultr ~]# ls -al\ntotal 44\ndr-xr-x---  4     root     root    4096      Jul 19 05:05 .\ndr-xr-xr-x 18    root     root    4096      Jun  5 21:42 ..\n-rw-------  1     root     root    4369       Jul 25 07:02 .bash_history\n-rw-r--r--  1     root     root    18           Dec 29  2013 .bash_logout\n-rw-r--r--  1     root     root     176         Dec 29  2013 .bash_profile\n-rw-r--r--  1     root     root     176         Dec 29  2013 .bashrc\ndrwx------ 3     root     root     4096       Jul 18 07:35 .cache\n-rw-r--r--  1     root     root      100         Dec 29  2013 .cshrc\ndrwxr----- 3     root     root      4096       Jun  5 21:45 .pki\n-rw-r--r--  1     root     root      129         Dec 29  2013 .tcshrc\n[权限]    [连接数][所有者][用户组][文件容量][修改时间] [文件名]\n```\n- ##### [权限]  \n第一个字符代表文件是 \"目录、文件或链接文件等\"\n    `[d]` 代表是目录，例如 .pki\n    `[-]` 代表是文件，例如 .tcshrc\n    `[l]` 代表为链接文件(linkfile)\n    `[b]` 代表设备文件里的可以供存储的接口设备\n    `[c]` 代表设备文件里的串行端口，例如键盘、鼠标\n接下来的3个为位一组，均为 \"rwx\" 3个参数组合\n    `[r]` 代表read 可读\n    `[w]` 代表write 可写\n    `[x]` 代表execute 可执行\n    `[-]` 代表没有权限\n    第一组代表 \"文件所有者的权限\"，第二组代表 \"同用户组的权限\"，第三组代表 \"其他非本用户组的权限\"\n- __[连接数]__ 文件的硬链接个数\n-  __[所有者]__ 文件的所有者账号\n- __[用户组]__ 文件的所有用户组\n- __[文件容量]__ 文件的容量 单位/B\n- __[修改时间]__ 文件的创建时间或最近的一次修改时间\n- __[文件名]__     文件的名称 带 \".\" 则表示当前文件为`隐藏文件`\n    \n## 3.改变文件属性和权限命令\n- ##### chgrp 改变文件所属用户组\n改变的用户组必须存在于`/etc/group`，对于不存在的用户组改变会执行失败\n``` bash\n#示例 [-R] 递归 文件或者目录下所有的的文件\nchgrp [-R] [文件或目录]\n#更新install.log用户组为user\nchgrp user install.log\n```\n- ##### chown 改变文件所有者\n改变的用户必须存在于`/etc/passwd`，对于不存在的用户改变会执行失败\n``` bash\n#示例 [-R] 递归 文件或者目录下所有的的文件\nchown [-R] [文件或目录]\n#更新install.log用户所属为test\nchown test install.log\n#可用.[用户组] 改变用户组 将install.log所属用户组改为groupTest\nchown .groupTest install.log\n```\n- ##### chmod 改变文件的权限\n改变rwx 读写执 3个权限，3个身份`owner`，`group`，`others`，组合9个权限。  \n  - 数字类型改变权限:\n  权限rwx按分数 `r : 4` ` w : 2`  `x : 1`，改变权限的组合方式按分数来决定权限rwxrwxrwx 对应777，rw--wx--- 对应610\n``` bash\n#示例 [-R] 递归 文件或者目录下所有的的文件\nchmod [-R] [分数组合] [文件或目录]\n#改变install.log的权限 763代表了 rwxrw---x\nchown 763 install.log\n```\n  - 符号类型改变权限:\n权限rwx按符号 u(user)，g(group)，o(others)，a(all)，+(加入)，-(除去)，=(设置)组合。\n``` bash\n#用户拥有读写，用户组读，其他执行 u=rw-，g=r--，o=--x\nchmod u=rw-，g=r--，o=--x install.log\n#所有身份都去除写权限 \nchmod a-r install.log\n#所有身份都添加执行权限\nchmod a+x install.log\n```\n\n## 2.RWX 对于文件和目录的差别\n##### 对于文件来说：\n- r  (read)  可以读取文件的实际内容\n- w (write) 可以编辑、新增、或修改文件的内容，但是不能删除文件\n- x (execute) 可以执行，可执行并非由文件的后缀来决定例如常见的`.exe` `.bat` `.com` 等，而是由x 属性来决定\n\n##### 对于文件目录来说：\n- r  (read contents in directory)  可以查询该目录下的文件名数据既可使用`ls`查询\n- w (modify contents of directory) 可以新建新的文件和目录、删除已存在的文件和目录（无视改文件的权限控制）、转义目录内的文件和文件夹\n- x (access directory) 可以进入该目录文件 既可使用`cd`进入该目录\n","source":"_posts/Linux-文件权限管理.md","raw":"---\ntitle: Linux 文件权限管理\ndate: 2018-07-25 15:07:09\ncategories: [Linux]\ntags:\n    - Linux\n---\n\n![Linux](/images/linux-1.jpg)\n\n>为了保证文件系统的安全隐私，对文件进行权限控制，防止非法用户查看、修改、删除等操作。只有在指定用户或用户组才能进行操作，例如一些隐私文件或者文件夹不想被其他人进行访问查看可对文件进行权限控制。\n\n## 1. ls 命令查询文件属性\n``` bash\n[root@vultr ~]# ls -al\ntotal 44\ndr-xr-x---  4     root     root    4096      Jul 19 05:05 .\ndr-xr-xr-x 18    root     root    4096      Jun  5 21:42 ..\n-rw-------  1     root     root    4369       Jul 25 07:02 .bash_history\n-rw-r--r--  1     root     root    18           Dec 29  2013 .bash_logout\n-rw-r--r--  1     root     root     176         Dec 29  2013 .bash_profile\n-rw-r--r--  1     root     root     176         Dec 29  2013 .bashrc\ndrwx------ 3     root     root     4096       Jul 18 07:35 .cache\n-rw-r--r--  1     root     root      100         Dec 29  2013 .cshrc\ndrwxr----- 3     root     root      4096       Jun  5 21:45 .pki\n-rw-r--r--  1     root     root      129         Dec 29  2013 .tcshrc\n[权限]    [连接数][所有者][用户组][文件容量][修改时间] [文件名]\n```\n- ##### [权限]  \n第一个字符代表文件是 \"目录、文件或链接文件等\"\n    `[d]` 代表是目录，例如 .pki\n    `[-]` 代表是文件，例如 .tcshrc\n    `[l]` 代表为链接文件(linkfile)\n    `[b]` 代表设备文件里的可以供存储的接口设备\n    `[c]` 代表设备文件里的串行端口，例如键盘、鼠标\n接下来的3个为位一组，均为 \"rwx\" 3个参数组合\n    `[r]` 代表read 可读\n    `[w]` 代表write 可写\n    `[x]` 代表execute 可执行\n    `[-]` 代表没有权限\n    第一组代表 \"文件所有者的权限\"，第二组代表 \"同用户组的权限\"，第三组代表 \"其他非本用户组的权限\"\n- __[连接数]__ 文件的硬链接个数\n-  __[所有者]__ 文件的所有者账号\n- __[用户组]__ 文件的所有用户组\n- __[文件容量]__ 文件的容量 单位/B\n- __[修改时间]__ 文件的创建时间或最近的一次修改时间\n- __[文件名]__     文件的名称 带 \".\" 则表示当前文件为`隐藏文件`\n    \n## 3.改变文件属性和权限命令\n- ##### chgrp 改变文件所属用户组\n改变的用户组必须存在于`/etc/group`，对于不存在的用户组改变会执行失败\n``` bash\n#示例 [-R] 递归 文件或者目录下所有的的文件\nchgrp [-R] [文件或目录]\n#更新install.log用户组为user\nchgrp user install.log\n```\n- ##### chown 改变文件所有者\n改变的用户必须存在于`/etc/passwd`，对于不存在的用户改变会执行失败\n``` bash\n#示例 [-R] 递归 文件或者目录下所有的的文件\nchown [-R] [文件或目录]\n#更新install.log用户所属为test\nchown test install.log\n#可用.[用户组] 改变用户组 将install.log所属用户组改为groupTest\nchown .groupTest install.log\n```\n- ##### chmod 改变文件的权限\n改变rwx 读写执 3个权限，3个身份`owner`，`group`，`others`，组合9个权限。  \n  - 数字类型改变权限:\n  权限rwx按分数 `r : 4` ` w : 2`  `x : 1`，改变权限的组合方式按分数来决定权限rwxrwxrwx 对应777，rw--wx--- 对应610\n``` bash\n#示例 [-R] 递归 文件或者目录下所有的的文件\nchmod [-R] [分数组合] [文件或目录]\n#改变install.log的权限 763代表了 rwxrw---x\nchown 763 install.log\n```\n  - 符号类型改变权限:\n权限rwx按符号 u(user)，g(group)，o(others)，a(all)，+(加入)，-(除去)，=(设置)组合。\n``` bash\n#用户拥有读写，用户组读，其他执行 u=rw-，g=r--，o=--x\nchmod u=rw-，g=r--，o=--x install.log\n#所有身份都去除写权限 \nchmod a-r install.log\n#所有身份都添加执行权限\nchmod a+x install.log\n```\n\n## 2.RWX 对于文件和目录的差别\n##### 对于文件来说：\n- r  (read)  可以读取文件的实际内容\n- w (write) 可以编辑、新增、或修改文件的内容，但是不能删除文件\n- x (execute) 可以执行，可执行并非由文件的后缀来决定例如常见的`.exe` `.bat` `.com` 等，而是由x 属性来决定\n\n##### 对于文件目录来说：\n- r  (read contents in directory)  可以查询该目录下的文件名数据既可使用`ls`查询\n- w (modify contents of directory) 可以新建新的文件和目录、删除已存在的文件和目录（无视改文件的权限控制）、转义目录内的文件和文件夹\n- x (access directory) 可以进入该目录文件 既可使用`cd`进入该目录\n","slug":"Linux-文件权限管理","published":1,"updated":"2020-08-10T01:48:44.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc97s001djsudi7rtr2mv","content":"<p><img src=\"/images/linux-1.jpg\" srcset=\"/img/loading.gif\" alt=\"Linux\"></p>\n<blockquote>\n<p>为了保证文件系统的安全隐私，对文件进行权限控制，防止非法用户查看、修改、删除等操作。只有在指定用户或用户组才能进行操作，例如一些隐私文件或者文件夹不想被其他人进行访问查看可对文件进行权限控制。</p>\n</blockquote>\n<h2 id=\"1-ls-命令查询文件属性\"><a href=\"#1-ls-命令查询文件属性\" class=\"headerlink\" title=\"1. ls 命令查询文件属性\"></a>1. ls 命令查询文件属性</h2><pre><code class=\"hljs bash\">[root@vultr ~]<span class=\"hljs-comment\"># ls -al</span>\ntotal 44\ndr-xr-x---  4     root     root    4096      Jul 19 05:05 .\ndr-xr-xr-x 18    root     root    4096      Jun  5 21:42 ..\n-rw-------  1     root     root    4369       Jul 25 07:02 .bash_history\n-rw-r--r--  1     root     root    18           Dec 29  2013 .bash_logout\n-rw-r--r--  1     root     root     176         Dec 29  2013 .bash_profile\n-rw-r--r--  1     root     root     176         Dec 29  2013 .bashrc\ndrwx------ 3     root     root     4096       Jul 18 07:35 .cache\n-rw-r--r--  1     root     root      100         Dec 29  2013 .cshrc\ndrwxr----- 3     root     root      4096       Jun  5 21:45 .pki\n-rw-r--r--  1     root     root      129         Dec 29  2013 .tcshrc\n[权限]    [连接数][所有者][用户组][文件容量][修改时间] [文件名]</code></pre>\n<ul>\n<li><h5 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"[权限]\"></a>[权限]</h5>第一个字符代表文件是 “目录、文件或链接文件等”<br>  <code>[d]</code> 代表是目录，例如 .pki<br>  <code>[-]</code> 代表是文件，例如 .tcshrc<br>  <code>[l]</code> 代表为链接文件(linkfile)<br>  <code>[b]</code> 代表设备文件里的可以供存储的接口设备<br>  <code>[c]</code> 代表设备文件里的串行端口，例如键盘、鼠标<br>接下来的3个为位一组，均为 “rwx” 3个参数组合<br>  <code>[r]</code> 代表read 可读<br>  <code>[w]</code> 代表write 可写<br>  <code>[x]</code> 代表execute 可执行<br>  <code>[-]</code> 代表没有权限<br>  第一组代表 “文件所有者的权限”，第二组代表 “同用户组的权限”，第三组代表 “其他非本用户组的权限”</li>\n<li><strong>[连接数]</strong> 文件的硬链接个数</li>\n<li><strong>[所有者]</strong> 文件的所有者账号</li>\n<li><strong>[用户组]</strong> 文件的所有用户组</li>\n<li><strong>[文件容量]</strong> 文件的容量 单位/B</li>\n<li><strong>[修改时间]</strong> 文件的创建时间或最近的一次修改时间</li>\n<li><strong>[文件名]</strong>     文件的名称 带 “.” 则表示当前文件为<code>隐藏文件</code></li>\n</ul>\n<h2 id=\"3-改变文件属性和权限命令\"><a href=\"#3-改变文件属性和权限命令\" class=\"headerlink\" title=\"3.改变文件属性和权限命令\"></a>3.改变文件属性和权限命令</h2><ul>\n<li><h5 id=\"chgrp-改变文件所属用户组\"><a href=\"#chgrp-改变文件所属用户组\" class=\"headerlink\" title=\"chgrp 改变文件所属用户组\"></a>chgrp 改变文件所属用户组</h5><p>改变的用户组必须存在于<code>/etc/group</code>，对于不存在的用户组改变会执行失败</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#示例 [-R] 递归 文件或者目录下所有的的文件</span>\nchgrp [-R] [文件或目录]\n<span class=\"hljs-comment\">#更新install.log用户组为user</span>\nchgrp user install.log</code></pre>\n</li>\n<li><h5 id=\"chown-改变文件所有者\"><a href=\"#chown-改变文件所有者\" class=\"headerlink\" title=\"chown 改变文件所有者\"></a>chown 改变文件所有者</h5><p>改变的用户必须存在于<code>/etc/passwd</code>，对于不存在的用户改变会执行失败</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#示例 [-R] 递归 文件或者目录下所有的的文件</span>\nchown [-R] [文件或目录]\n<span class=\"hljs-comment\">#更新install.log用户所属为test</span>\nchown <span class=\"hljs-built_in\">test</span> install.log\n<span class=\"hljs-comment\">#可用.[用户组] 改变用户组 将install.log所属用户组改为groupTest</span>\nchown .groupTest install.log</code></pre>\n</li>\n<li><h5 id=\"chmod-改变文件的权限\"><a href=\"#chmod-改变文件的权限\" class=\"headerlink\" title=\"chmod 改变文件的权限\"></a>chmod 改变文件的权限</h5><p>改变rwx 读写执 3个权限，3个身份<code>owner</code>，<code>group</code>，<code>others</code>，组合9个权限。  </p>\n<ul>\n<li><p>数字类型改变权限:<br>权限rwx按分数 <code>r : 4</code> <code>w : 2</code>  <code>x : 1</code>，改变权限的组合方式按分数来决定权限rwxrwxrwx 对应777，rw–wx— 对应610</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#示例 [-R] 递归 文件或者目录下所有的的文件</span>\nchmod [-R] [分数组合] [文件或目录]\n<span class=\"hljs-comment\">#改变install.log的权限 763代表了 rwxrw---x</span>\nchown 763 install.log</code></pre>\n</li>\n<li><p>符号类型改变权限:<br>权限rwx按符号 u(user)，g(group)，o(others)，a(all)，+(加入)，-(除去)，=(设置)组合。</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#用户拥有读写，用户组读，其他执行 u=rw-，g=r--，o=--x</span>\nchmod u=rw-，g=r--，o=--x install.log\n<span class=\"hljs-comment\">#所有身份都去除写权限 </span>\nchmod a-r install.log\n<span class=\"hljs-comment\">#所有身份都添加执行权限</span>\nchmod a+x install.log</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-RWX-对于文件和目录的差别\"><a href=\"#2-RWX-对于文件和目录的差别\" class=\"headerlink\" title=\"2.RWX 对于文件和目录的差别\"></a>2.RWX 对于文件和目录的差别</h2><h5 id=\"对于文件来说：\"><a href=\"#对于文件来说：\" class=\"headerlink\" title=\"对于文件来说：\"></a>对于文件来说：</h5><ul>\n<li>r  (read)  可以读取文件的实际内容</li>\n<li>w (write) 可以编辑、新增、或修改文件的内容，但是不能删除文件</li>\n<li>x (execute) 可以执行，可执行并非由文件的后缀来决定例如常见的<code>.exe</code> <code>.bat</code> <code>.com</code> 等，而是由x 属性来决定</li>\n</ul>\n<h5 id=\"对于文件目录来说：\"><a href=\"#对于文件目录来说：\" class=\"headerlink\" title=\"对于文件目录来说：\"></a>对于文件目录来说：</h5><ul>\n<li>r  (read contents in directory)  可以查询该目录下的文件名数据既可使用<code>ls</code>查询</li>\n<li>w (modify contents of directory) 可以新建新的文件和目录、删除已存在的文件和目录（无视改文件的权限控制）、转义目录内的文件和文件夹</li>\n<li>x (access directory) 可以进入该目录文件 既可使用<code>cd</code>进入该目录</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/linux-1.jpg\" srcset=\"/img/loading.gif\" alt=\"Linux\"></p>\n<blockquote>\n<p>为了保证文件系统的安全隐私，对文件进行权限控制，防止非法用户查看、修改、删除等操作。只有在指定用户或用户组才能进行操作，例如一些隐私文件或者文件夹不想被其他人进行访问查看可对文件进行权限控制。</p>\n</blockquote>\n<h2 id=\"1-ls-命令查询文件属性\"><a href=\"#1-ls-命令查询文件属性\" class=\"headerlink\" title=\"1. ls 命令查询文件属性\"></a>1. ls 命令查询文件属性</h2><pre><code class=\"hljs bash\">[root@vultr ~]<span class=\"hljs-comment\"># ls -al</span>\ntotal 44\ndr-xr-x---  4     root     root    4096      Jul 19 05:05 .\ndr-xr-xr-x 18    root     root    4096      Jun  5 21:42 ..\n-rw-------  1     root     root    4369       Jul 25 07:02 .bash_history\n-rw-r--r--  1     root     root    18           Dec 29  2013 .bash_logout\n-rw-r--r--  1     root     root     176         Dec 29  2013 .bash_profile\n-rw-r--r--  1     root     root     176         Dec 29  2013 .bashrc\ndrwx------ 3     root     root     4096       Jul 18 07:35 .cache\n-rw-r--r--  1     root     root      100         Dec 29  2013 .cshrc\ndrwxr----- 3     root     root      4096       Jun  5 21:45 .pki\n-rw-r--r--  1     root     root      129         Dec 29  2013 .tcshrc\n[权限]    [连接数][所有者][用户组][文件容量][修改时间] [文件名]</code></pre>\n<ul>\n<li><h5 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"[权限]\"></a>[权限]</h5>第一个字符代表文件是 “目录、文件或链接文件等”<br>  <code>[d]</code> 代表是目录，例如 .pki<br>  <code>[-]</code> 代表是文件，例如 .tcshrc<br>  <code>[l]</code> 代表为链接文件(linkfile)<br>  <code>[b]</code> 代表设备文件里的可以供存储的接口设备<br>  <code>[c]</code> 代表设备文件里的串行端口，例如键盘、鼠标<br>接下来的3个为位一组，均为 “rwx” 3个参数组合<br>  <code>[r]</code> 代表read 可读<br>  <code>[w]</code> 代表write 可写<br>  <code>[x]</code> 代表execute 可执行<br>  <code>[-]</code> 代表没有权限<br>  第一组代表 “文件所有者的权限”，第二组代表 “同用户组的权限”，第三组代表 “其他非本用户组的权限”</li>\n<li><strong>[连接数]</strong> 文件的硬链接个数</li>\n<li><strong>[所有者]</strong> 文件的所有者账号</li>\n<li><strong>[用户组]</strong> 文件的所有用户组</li>\n<li><strong>[文件容量]</strong> 文件的容量 单位/B</li>\n<li><strong>[修改时间]</strong> 文件的创建时间或最近的一次修改时间</li>\n<li><strong>[文件名]</strong>     文件的名称 带 “.” 则表示当前文件为<code>隐藏文件</code></li>\n</ul>\n<h2 id=\"3-改变文件属性和权限命令\"><a href=\"#3-改变文件属性和权限命令\" class=\"headerlink\" title=\"3.改变文件属性和权限命令\"></a>3.改变文件属性和权限命令</h2><ul>\n<li><h5 id=\"chgrp-改变文件所属用户组\"><a href=\"#chgrp-改变文件所属用户组\" class=\"headerlink\" title=\"chgrp 改变文件所属用户组\"></a>chgrp 改变文件所属用户组</h5><p>改变的用户组必须存在于<code>/etc/group</code>，对于不存在的用户组改变会执行失败</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#示例 [-R] 递归 文件或者目录下所有的的文件</span>\nchgrp [-R] [文件或目录]\n<span class=\"hljs-comment\">#更新install.log用户组为user</span>\nchgrp user install.log</code></pre>\n</li>\n<li><h5 id=\"chown-改变文件所有者\"><a href=\"#chown-改变文件所有者\" class=\"headerlink\" title=\"chown 改变文件所有者\"></a>chown 改变文件所有者</h5><p>改变的用户必须存在于<code>/etc/passwd</code>，对于不存在的用户改变会执行失败</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#示例 [-R] 递归 文件或者目录下所有的的文件</span>\nchown [-R] [文件或目录]\n<span class=\"hljs-comment\">#更新install.log用户所属为test</span>\nchown <span class=\"hljs-built_in\">test</span> install.log\n<span class=\"hljs-comment\">#可用.[用户组] 改变用户组 将install.log所属用户组改为groupTest</span>\nchown .groupTest install.log</code></pre>\n</li>\n<li><h5 id=\"chmod-改变文件的权限\"><a href=\"#chmod-改变文件的权限\" class=\"headerlink\" title=\"chmod 改变文件的权限\"></a>chmod 改变文件的权限</h5><p>改变rwx 读写执 3个权限，3个身份<code>owner</code>，<code>group</code>，<code>others</code>，组合9个权限。  </p>\n<ul>\n<li><p>数字类型改变权限:<br>权限rwx按分数 <code>r : 4</code> <code>w : 2</code>  <code>x : 1</code>，改变权限的组合方式按分数来决定权限rwxrwxrwx 对应777，rw–wx— 对应610</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#示例 [-R] 递归 文件或者目录下所有的的文件</span>\nchmod [-R] [分数组合] [文件或目录]\n<span class=\"hljs-comment\">#改变install.log的权限 763代表了 rwxrw---x</span>\nchown 763 install.log</code></pre>\n</li>\n<li><p>符号类型改变权限:<br>权限rwx按符号 u(user)，g(group)，o(others)，a(all)，+(加入)，-(除去)，=(设置)组合。</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#用户拥有读写，用户组读，其他执行 u=rw-，g=r--，o=--x</span>\nchmod u=rw-，g=r--，o=--x install.log\n<span class=\"hljs-comment\">#所有身份都去除写权限 </span>\nchmod a-r install.log\n<span class=\"hljs-comment\">#所有身份都添加执行权限</span>\nchmod a+x install.log</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-RWX-对于文件和目录的差别\"><a href=\"#2-RWX-对于文件和目录的差别\" class=\"headerlink\" title=\"2.RWX 对于文件和目录的差别\"></a>2.RWX 对于文件和目录的差别</h2><h5 id=\"对于文件来说：\"><a href=\"#对于文件来说：\" class=\"headerlink\" title=\"对于文件来说：\"></a>对于文件来说：</h5><ul>\n<li>r  (read)  可以读取文件的实际内容</li>\n<li>w (write) 可以编辑、新增、或修改文件的内容，但是不能删除文件</li>\n<li>x (execute) 可以执行，可执行并非由文件的后缀来决定例如常见的<code>.exe</code> <code>.bat</code> <code>.com</code> 等，而是由x 属性来决定</li>\n</ul>\n<h5 id=\"对于文件目录来说：\"><a href=\"#对于文件目录来说：\" class=\"headerlink\" title=\"对于文件目录来说：\"></a>对于文件目录来说：</h5><ul>\n<li>r  (read contents in directory)  可以查询该目录下的文件名数据既可使用<code>ls</code>查询</li>\n<li>w (modify contents of directory) 可以新建新的文件和目录、删除已存在的文件和目录（无视改文件的权限控制）、转义目录内的文件和文件夹</li>\n<li>x (access directory) 可以进入该目录文件 既可使用<code>cd</code>进入该目录</li>\n</ul>\n"},{"title":"Linux 搭建 Shadowsocks","toc":false,"date":"2018-07-13T08:25:43.000Z","_content":"\n![Shadowsocks](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1531801271142&di=761db1c2eaadf98b71507ffb63bdde32&imgtype=0&src=http%3A%2F%2Fn1.itc.cn%2Fimg8%2Fwb%2Fsmccloud%2Frecom%2F2015%2F07%2F14%2F143686120068151458.JPEG)\n\n>作为一个码农没有科学上网怎么能行，刚好Vultr新注册送钱买一个云主机玩玩，以CentOs7做一个教程，之前在网上找的搭建方法很多错误导致一直不成功现在自己整理并通过测试，踩了很多坑\n\n\n## 1.Shadowsocks 环境准备\n \n``` bash\n#安装epel扩展源\nyum install epel-release\n#安装Pip\nyum -y install python-pip\n#升级Pip\npip install --upgrade pip \n#清除yum缓存\nyum clean all\n#安装shadowsocks客户端\npip install shadowsocks\n```\n\n## 2.Shadowsocks 配置\n\n``` bash\n#创建shadowsocks配置\nvi /etc/shadowsocks.json\n#单用户\n { \n    \"server\":\"server_ip\"， \n    \"server_port\":25， \n    \"local_address\": \"127.0.0.1\"， \n    \"local_port\":1080， \n    \"password\":\"password\"，\n    \"timeout\":300， \n    \"method\":\"aes-256-cfb\"， \n    \"fast_open\": false \n }\n\n#多用户\n{\n    \"server\":\"server_ip\"，\n    \"port_password\":{\n        \"port_1\":\"pwd1\"，\n        \"port_2\":\"pwd2\"，\n        \"port_3\":\"pwd3\"\n    }，\n    \"local_address\":\"127.0.0.1\"，\n    \"local_port\":1080，\n    \"timeout\":300，\n    \"method\":\"aes-256-cfb\"\n}\n```\n**参数详解**:\n* server 服务器地址 127.0.0.1 或者0.0.0.0\n* server_port 服务端口号 外部连接需要填写的服务端口号\n* local_port 本地端口号\n* password 连接密码\n* timeout 超时时间\n* method 加密方式\n\n## 3.Shadowsocks 启动\n``` bash   \n#启动\nssserver -c /etc/shadowsocks.json -d start\n#停止\nssserver -c /etc/shadowsocks.json -d stop\n```\n由于每次都需要服务器重启都需要手动去启动不便，可以注册成服务自动启动\n``` bash\n#创建服务脚本 servicename 填写shadowsocks\nvi /etc/systemd/system/[servicename].service\n\n#编辑脚本\n[Unit]\nDescription=Shadowsocks\n\n[Service]\nTimeoutStartSec=0\nExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json start\nExecStop=/usr/bin/ssserver -c /etc/shadowsocks.json stop\n\n\n[Install]\nWantedBy=multi-user.target\n```\n这里会遇到一个坑：ExecStart 这里填写的启动脚本 少了一个start不知道是不是我本身脚本问题\n\n**参数详解**:\n* Description服务描述\n* ExecStart 服务启动执行脚本\n* ExecStop 服务停止执行脚本\n* WantedBy 系统以该形式运行时，服务方可启动\n\n## 4.Systemctl 命令\n注册服务 `systemctl enable shadowsocks`\n所有服务 `systemctl list-units --type=service`\n服务状态 `systemctl status shadowsocks -l `\n启动服务 `systemctl start shadowsocks`\n停止服务 `systemctl stop shadowsocks`\n重启服务 `systemctl restart shadowsocks`\n\n## 5.Shadowsocks 客户端安装\n\n环境支持\n- [Shadowsocks for Win](https://github.com/shadowsocks/shadowsocks-windows/releases)\n- [Microsoft .NET Framework 4.6.2](https://www.microsoft.com/en-US/download/details.aspx?id=53344) \n- [Microsoft Visual C++ 2015 Redistributable (x86) ](https://www.microsoft.com/en-us/download/details.aspx?id=53840)\n安装完毕配置启动即可\n\n### 贴士提示\n* CentOs7需要配置下防火墙端口白名单\n``` bash\n#添加端口号8388(设置的server-port) --permanent永久生效\nfirewall-cmd --zone=public --add-port=8388/tcp --permanent \n#重载配置\nfirewall-cmd --reload\n```","source":"_posts/Linxu搭建SS.md","raw":"---\ntitle: Linux 搭建 Shadowsocks\ntags:\n  - Linux\ncategories:\n  - Linux\ntoc: false\ndate: 2018-07-13 16:25:43\n---\n\n![Shadowsocks](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1531801271142&di=761db1c2eaadf98b71507ffb63bdde32&imgtype=0&src=http%3A%2F%2Fn1.itc.cn%2Fimg8%2Fwb%2Fsmccloud%2Frecom%2F2015%2F07%2F14%2F143686120068151458.JPEG)\n\n>作为一个码农没有科学上网怎么能行，刚好Vultr新注册送钱买一个云主机玩玩，以CentOs7做一个教程，之前在网上找的搭建方法很多错误导致一直不成功现在自己整理并通过测试，踩了很多坑\n\n\n## 1.Shadowsocks 环境准备\n \n``` bash\n#安装epel扩展源\nyum install epel-release\n#安装Pip\nyum -y install python-pip\n#升级Pip\npip install --upgrade pip \n#清除yum缓存\nyum clean all\n#安装shadowsocks客户端\npip install shadowsocks\n```\n\n## 2.Shadowsocks 配置\n\n``` bash\n#创建shadowsocks配置\nvi /etc/shadowsocks.json\n#单用户\n { \n    \"server\":\"server_ip\"， \n    \"server_port\":25， \n    \"local_address\": \"127.0.0.1\"， \n    \"local_port\":1080， \n    \"password\":\"password\"，\n    \"timeout\":300， \n    \"method\":\"aes-256-cfb\"， \n    \"fast_open\": false \n }\n\n#多用户\n{\n    \"server\":\"server_ip\"，\n    \"port_password\":{\n        \"port_1\":\"pwd1\"，\n        \"port_2\":\"pwd2\"，\n        \"port_3\":\"pwd3\"\n    }，\n    \"local_address\":\"127.0.0.1\"，\n    \"local_port\":1080，\n    \"timeout\":300，\n    \"method\":\"aes-256-cfb\"\n}\n```\n**参数详解**:\n* server 服务器地址 127.0.0.1 或者0.0.0.0\n* server_port 服务端口号 外部连接需要填写的服务端口号\n* local_port 本地端口号\n* password 连接密码\n* timeout 超时时间\n* method 加密方式\n\n## 3.Shadowsocks 启动\n``` bash   \n#启动\nssserver -c /etc/shadowsocks.json -d start\n#停止\nssserver -c /etc/shadowsocks.json -d stop\n```\n由于每次都需要服务器重启都需要手动去启动不便，可以注册成服务自动启动\n``` bash\n#创建服务脚本 servicename 填写shadowsocks\nvi /etc/systemd/system/[servicename].service\n\n#编辑脚本\n[Unit]\nDescription=Shadowsocks\n\n[Service]\nTimeoutStartSec=0\nExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json start\nExecStop=/usr/bin/ssserver -c /etc/shadowsocks.json stop\n\n\n[Install]\nWantedBy=multi-user.target\n```\n这里会遇到一个坑：ExecStart 这里填写的启动脚本 少了一个start不知道是不是我本身脚本问题\n\n**参数详解**:\n* Description服务描述\n* ExecStart 服务启动执行脚本\n* ExecStop 服务停止执行脚本\n* WantedBy 系统以该形式运行时，服务方可启动\n\n## 4.Systemctl 命令\n注册服务 `systemctl enable shadowsocks`\n所有服务 `systemctl list-units --type=service`\n服务状态 `systemctl status shadowsocks -l `\n启动服务 `systemctl start shadowsocks`\n停止服务 `systemctl stop shadowsocks`\n重启服务 `systemctl restart shadowsocks`\n\n## 5.Shadowsocks 客户端安装\n\n环境支持\n- [Shadowsocks for Win](https://github.com/shadowsocks/shadowsocks-windows/releases)\n- [Microsoft .NET Framework 4.6.2](https://www.microsoft.com/en-US/download/details.aspx?id=53344) \n- [Microsoft Visual C++ 2015 Redistributable (x86) ](https://www.microsoft.com/en-us/download/details.aspx?id=53840)\n安装完毕配置启动即可\n\n### 贴士提示\n* CentOs7需要配置下防火墙端口白名单\n``` bash\n#添加端口号8388(设置的server-port) --permanent永久生效\nfirewall-cmd --zone=public --add-port=8388/tcp --permanent \n#重载配置\nfirewall-cmd --reload\n```","slug":"Linxu搭建SS","published":1,"updated":"2020-08-10T01:48:44.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc97v001hjsudugehu0px","content":"<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531801271142&amp;di=761db1c2eaadf98b71507ffb63bdde32&amp;imgtype=0&amp;src=http%3A%2F%2Fn1.itc.cn%2Fimg8%2Fwb%2Fsmccloud%2Frecom%2F2015%2F07%2F14%2F143686120068151458.JPEG\" srcset=\"/img/loading.gif\" alt=\"Shadowsocks\"></p>\n<blockquote>\n<p>作为一个码农没有科学上网怎么能行，刚好Vultr新注册送钱买一个云主机玩玩，以CentOs7做一个教程，之前在网上找的搭建方法很多错误导致一直不成功现在自己整理并通过测试，踩了很多坑</p>\n</blockquote>\n<h2 id=\"1-Shadowsocks-环境准备\"><a href=\"#1-Shadowsocks-环境准备\" class=\"headerlink\" title=\"1.Shadowsocks 环境准备\"></a>1.Shadowsocks 环境准备</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#安装epel扩展源</span>\nyum install epel-release\n<span class=\"hljs-comment\">#安装Pip</span>\nyum -y install python-pip\n<span class=\"hljs-comment\">#升级Pip</span>\npip install --upgrade pip \n<span class=\"hljs-comment\">#清除yum缓存</span>\nyum clean all\n<span class=\"hljs-comment\">#安装shadowsocks客户端</span>\npip install shadowsocks</code></pre>\n<h2 id=\"2-Shadowsocks-配置\"><a href=\"#2-Shadowsocks-配置\" class=\"headerlink\" title=\"2.Shadowsocks 配置\"></a>2.Shadowsocks 配置</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#创建shadowsocks配置</span>\nvi /etc/shadowsocks.json\n<span class=\"hljs-comment\">#单用户</span>\n &#123; \n    <span class=\"hljs-string\">\"server\"</span>:<span class=\"hljs-string\">\"server_ip\"</span>， \n    <span class=\"hljs-string\">\"server_port\"</span>:25， \n    <span class=\"hljs-string\">\"local_address\"</span>: <span class=\"hljs-string\">\"127.0.0.1\"</span>， \n    <span class=\"hljs-string\">\"local_port\"</span>:1080， \n    <span class=\"hljs-string\">\"password\"</span>:<span class=\"hljs-string\">\"password\"</span>，\n    <span class=\"hljs-string\">\"timeout\"</span>:300， \n    <span class=\"hljs-string\">\"method\"</span>:<span class=\"hljs-string\">\"aes-256-cfb\"</span>， \n    <span class=\"hljs-string\">\"fast_open\"</span>: <span class=\"hljs-literal\">false</span> \n &#125;\n\n<span class=\"hljs-comment\">#多用户</span>\n&#123;\n    <span class=\"hljs-string\">\"server\"</span>:<span class=\"hljs-string\">\"server_ip\"</span>，\n    <span class=\"hljs-string\">\"port_password\"</span>:&#123;\n        <span class=\"hljs-string\">\"port_1\"</span>:<span class=\"hljs-string\">\"pwd1\"</span>，\n        <span class=\"hljs-string\">\"port_2\"</span>:<span class=\"hljs-string\">\"pwd2\"</span>，\n        <span class=\"hljs-string\">\"port_3\"</span>:<span class=\"hljs-string\">\"pwd3\"</span>\n    &#125;，\n    <span class=\"hljs-string\">\"local_address\"</span>:<span class=\"hljs-string\">\"127.0.0.1\"</span>，\n    <span class=\"hljs-string\">\"local_port\"</span>:1080，\n    <span class=\"hljs-string\">\"timeout\"</span>:300，\n    <span class=\"hljs-string\">\"method\"</span>:<span class=\"hljs-string\">\"aes-256-cfb\"</span>\n&#125;</code></pre>\n<p><strong>参数详解</strong>:</p>\n<ul>\n<li>server 服务器地址 127.0.0.1 或者0.0.0.0</li>\n<li>server_port 服务端口号 外部连接需要填写的服务端口号</li>\n<li>local_port 本地端口号</li>\n<li>password 连接密码</li>\n<li>timeout 超时时间</li>\n<li>method 加密方式</li>\n</ul>\n<h2 id=\"3-Shadowsocks-启动\"><a href=\"#3-Shadowsocks-启动\" class=\"headerlink\" title=\"3.Shadowsocks 启动\"></a>3.Shadowsocks 启动</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#启动</span>\nssserver -c /etc/shadowsocks.json -d start\n<span class=\"hljs-comment\">#停止</span>\nssserver -c /etc/shadowsocks.json -d stop</code></pre>\n<p>由于每次都需要服务器重启都需要手动去启动不便，可以注册成服务自动启动<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#创建服务脚本 servicename 填写shadowsocks</span>\nvi /etc/systemd/system/[servicename].service\n\n<span class=\"hljs-comment\">#编辑脚本</span>\n[Unit]\nDescription=Shadowsocks\n\n[Service]\nTimeoutStartSec=0\nExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json start\nExecStop=/usr/bin/ssserver -c /etc/shadowsocks.json stop\n\n\n[Install]\nWantedBy=multi-user.target</code></pre></p>\n<p>这里会遇到一个坑：ExecStart 这里填写的启动脚本 少了一个start不知道是不是我本身脚本问题</p>\n<p><strong>参数详解</strong>:</p>\n<ul>\n<li>Description服务描述</li>\n<li>ExecStart 服务启动执行脚本</li>\n<li>ExecStop 服务停止执行脚本</li>\n<li>WantedBy 系统以该形式运行时，服务方可启动</li>\n</ul>\n<h2 id=\"4-Systemctl-命令\"><a href=\"#4-Systemctl-命令\" class=\"headerlink\" title=\"4.Systemctl 命令\"></a>4.Systemctl 命令</h2><p>注册服务 <code>systemctl enable shadowsocks</code><br>所有服务 <code>systemctl list-units --type=service</code><br>服务状态 <code>systemctl status shadowsocks -l</code><br>启动服务 <code>systemctl start shadowsocks</code><br>停止服务 <code>systemctl stop shadowsocks</code><br>重启服务 <code>systemctl restart shadowsocks</code></p>\n<h2 id=\"5-Shadowsocks-客户端安装\"><a href=\"#5-Shadowsocks-客户端安装\" class=\"headerlink\" title=\"5.Shadowsocks 客户端安装\"></a>5.Shadowsocks 客户端安装</h2><p>环境支持</p>\n<ul>\n<li><a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases\" target=\"_blank\" rel=\"noopener\">Shadowsocks for Win</a></li>\n<li><a href=\"https://www.microsoft.com/en-US/download/details.aspx?id=53344\" target=\"_blank\" rel=\"noopener\">Microsoft .NET Framework 4.6.2</a> </li>\n<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=53840\" target=\"_blank\" rel=\"noopener\">Microsoft Visual C++ 2015 Redistributable (x86) </a><br>安装完毕配置启动即可</li>\n</ul>\n<h3 id=\"贴士提示\"><a href=\"#贴士提示\" class=\"headerlink\" title=\"贴士提示\"></a>贴士提示</h3><ul>\n<li>CentOs7需要配置下防火墙端口白名单<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#添加端口号8388(设置的server-port) --permanent永久生效</span>\nfirewall-cmd --zone=public --add-port=8388/tcp --permanent \n<span class=\"hljs-comment\">#重载配置</span>\nfirewall-cmd --reload</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531801271142&amp;di=761db1c2eaadf98b71507ffb63bdde32&amp;imgtype=0&amp;src=http%3A%2F%2Fn1.itc.cn%2Fimg8%2Fwb%2Fsmccloud%2Frecom%2F2015%2F07%2F14%2F143686120068151458.JPEG\" srcset=\"/img/loading.gif\" alt=\"Shadowsocks\"></p>\n<blockquote>\n<p>作为一个码农没有科学上网怎么能行，刚好Vultr新注册送钱买一个云主机玩玩，以CentOs7做一个教程，之前在网上找的搭建方法很多错误导致一直不成功现在自己整理并通过测试，踩了很多坑</p>\n</blockquote>\n<h2 id=\"1-Shadowsocks-环境准备\"><a href=\"#1-Shadowsocks-环境准备\" class=\"headerlink\" title=\"1.Shadowsocks 环境准备\"></a>1.Shadowsocks 环境准备</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#安装epel扩展源</span>\nyum install epel-release\n<span class=\"hljs-comment\">#安装Pip</span>\nyum -y install python-pip\n<span class=\"hljs-comment\">#升级Pip</span>\npip install --upgrade pip \n<span class=\"hljs-comment\">#清除yum缓存</span>\nyum clean all\n<span class=\"hljs-comment\">#安装shadowsocks客户端</span>\npip install shadowsocks</code></pre>\n<h2 id=\"2-Shadowsocks-配置\"><a href=\"#2-Shadowsocks-配置\" class=\"headerlink\" title=\"2.Shadowsocks 配置\"></a>2.Shadowsocks 配置</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#创建shadowsocks配置</span>\nvi /etc/shadowsocks.json\n<span class=\"hljs-comment\">#单用户</span>\n &#123; \n    <span class=\"hljs-string\">\"server\"</span>:<span class=\"hljs-string\">\"server_ip\"</span>， \n    <span class=\"hljs-string\">\"server_port\"</span>:25， \n    <span class=\"hljs-string\">\"local_address\"</span>: <span class=\"hljs-string\">\"127.0.0.1\"</span>， \n    <span class=\"hljs-string\">\"local_port\"</span>:1080， \n    <span class=\"hljs-string\">\"password\"</span>:<span class=\"hljs-string\">\"password\"</span>，\n    <span class=\"hljs-string\">\"timeout\"</span>:300， \n    <span class=\"hljs-string\">\"method\"</span>:<span class=\"hljs-string\">\"aes-256-cfb\"</span>， \n    <span class=\"hljs-string\">\"fast_open\"</span>: <span class=\"hljs-literal\">false</span> \n &#125;\n\n<span class=\"hljs-comment\">#多用户</span>\n&#123;\n    <span class=\"hljs-string\">\"server\"</span>:<span class=\"hljs-string\">\"server_ip\"</span>，\n    <span class=\"hljs-string\">\"port_password\"</span>:&#123;\n        <span class=\"hljs-string\">\"port_1\"</span>:<span class=\"hljs-string\">\"pwd1\"</span>，\n        <span class=\"hljs-string\">\"port_2\"</span>:<span class=\"hljs-string\">\"pwd2\"</span>，\n        <span class=\"hljs-string\">\"port_3\"</span>:<span class=\"hljs-string\">\"pwd3\"</span>\n    &#125;，\n    <span class=\"hljs-string\">\"local_address\"</span>:<span class=\"hljs-string\">\"127.0.0.1\"</span>，\n    <span class=\"hljs-string\">\"local_port\"</span>:1080，\n    <span class=\"hljs-string\">\"timeout\"</span>:300，\n    <span class=\"hljs-string\">\"method\"</span>:<span class=\"hljs-string\">\"aes-256-cfb\"</span>\n&#125;</code></pre>\n<p><strong>参数详解</strong>:</p>\n<ul>\n<li>server 服务器地址 127.0.0.1 或者0.0.0.0</li>\n<li>server_port 服务端口号 外部连接需要填写的服务端口号</li>\n<li>local_port 本地端口号</li>\n<li>password 连接密码</li>\n<li>timeout 超时时间</li>\n<li>method 加密方式</li>\n</ul>\n<h2 id=\"3-Shadowsocks-启动\"><a href=\"#3-Shadowsocks-启动\" class=\"headerlink\" title=\"3.Shadowsocks 启动\"></a>3.Shadowsocks 启动</h2><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#启动</span>\nssserver -c /etc/shadowsocks.json -d start\n<span class=\"hljs-comment\">#停止</span>\nssserver -c /etc/shadowsocks.json -d stop</code></pre>\n<p>由于每次都需要服务器重启都需要手动去启动不便，可以注册成服务自动启动<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#创建服务脚本 servicename 填写shadowsocks</span>\nvi /etc/systemd/system/[servicename].service\n\n<span class=\"hljs-comment\">#编辑脚本</span>\n[Unit]\nDescription=Shadowsocks\n\n[Service]\nTimeoutStartSec=0\nExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json start\nExecStop=/usr/bin/ssserver -c /etc/shadowsocks.json stop\n\n\n[Install]\nWantedBy=multi-user.target</code></pre></p>\n<p>这里会遇到一个坑：ExecStart 这里填写的启动脚本 少了一个start不知道是不是我本身脚本问题</p>\n<p><strong>参数详解</strong>:</p>\n<ul>\n<li>Description服务描述</li>\n<li>ExecStart 服务启动执行脚本</li>\n<li>ExecStop 服务停止执行脚本</li>\n<li>WantedBy 系统以该形式运行时，服务方可启动</li>\n</ul>\n<h2 id=\"4-Systemctl-命令\"><a href=\"#4-Systemctl-命令\" class=\"headerlink\" title=\"4.Systemctl 命令\"></a>4.Systemctl 命令</h2><p>注册服务 <code>systemctl enable shadowsocks</code><br>所有服务 <code>systemctl list-units --type=service</code><br>服务状态 <code>systemctl status shadowsocks -l</code><br>启动服务 <code>systemctl start shadowsocks</code><br>停止服务 <code>systemctl stop shadowsocks</code><br>重启服务 <code>systemctl restart shadowsocks</code></p>\n<h2 id=\"5-Shadowsocks-客户端安装\"><a href=\"#5-Shadowsocks-客户端安装\" class=\"headerlink\" title=\"5.Shadowsocks 客户端安装\"></a>5.Shadowsocks 客户端安装</h2><p>环境支持</p>\n<ul>\n<li><a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases\" target=\"_blank\" rel=\"noopener\">Shadowsocks for Win</a></li>\n<li><a href=\"https://www.microsoft.com/en-US/download/details.aspx?id=53344\" target=\"_blank\" rel=\"noopener\">Microsoft .NET Framework 4.6.2</a> </li>\n<li><a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=53840\" target=\"_blank\" rel=\"noopener\">Microsoft Visual C++ 2015 Redistributable (x86) </a><br>安装完毕配置启动即可</li>\n</ul>\n<h3 id=\"贴士提示\"><a href=\"#贴士提示\" class=\"headerlink\" title=\"贴士提示\"></a>贴士提示</h3><ul>\n<li>CentOs7需要配置下防火墙端口白名单<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#添加端口号8388(设置的server-port) --permanent永久生效</span>\nfirewall-cmd --zone=public --add-port=8388/tcp --permanent \n<span class=\"hljs-comment\">#重载配置</span>\nfirewall-cmd --reload</code></pre></li>\n</ul>\n"},{"title":"Logstash同步数据库","toc":false,"date":"2018-05-25T08:27:08.000Z","_content":"\n![](/images/es.jpg)\n\n>由于业务需求需要同步某些数据库的表数据更新修改删除需同步ES保证同步性，在进行curd用AOP可实现同步，但是考虑到解耦分离后续系统水平拓展，查询资料可以用Logstash进行同步Es，Logstash 是开源的服务器端数据处理管道，能够同时 从多个来源采集数据、转换数据，然后将数据发送到Elasticsearch.\n\n\n\n## 1.Logstash依赖环境\n* JDK1.8 [下载地址](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)\n* Ruby环境 [下载地址](http://www.ruby-lang.org/en/downloads/)\n* logstash 6.3.1 [下载地址](https://www.elastic.co/downloads/logstash)\n\n## 2.Logstash同步配置文件\n>Logstash由三个组件构造成，分别是input、filter以及output。我们可以吧Logstash三个组件的工作流理解为：input收集数据，filter处理数据，output输出数据。至于怎么收集、去哪收集、怎么处理、处理什么、怎么发生以及发送到哪等等一些列的问题就是我们接下啦要讨论的一个重点。\n```\ninput {\n    jdbc{\n    #数据库驱动jar包\n        jdbc_driver_library => \"\\policySyn\\ojdbc6.jar\"\n    #数据库地址\n        jdbc_connection_string => \"jdbc:oracle:thin:@192.168.105.16:1523:gnnt\"\n    #数据库用户名密码\n        jdbc_user => \"plane_tick\"   \n        jdbc_password => \"ora123\"\n    #数据库驱动类\n        jdbc_driver_class => \"Java::oracle.jdbc.driver.OracleDriver\"\n        jdbc_paging_enabled => \"true\"\n        jdbc_page_size => \"50000\"\n    #执行sql绝对路径 或相对路径\n        statement_filepath  => \"\\policySyn\\syn.sql\"\n    #更新时间记录和存放\n        record_last_run => \"true\"\n        last_run_metadata_path => \"\\policySyn\\synDate.txt\"\n    #定时更新频率 20分钟一次\n        schedule => \"* * * * *\"\n    #索引类型\n        type => \"policyteam_dev\"\n    }\n}\n\n//同步目的地\noutput {\n    elasticsearch{\n        hosts => \"http://192.168.105.13:9200\"\n        index => \"policyteam_dev\"\n        document_id => \"%{zcbh}\"\n    }\n    stdout {\n        codec => json_lines\n    }\n}\n```\n## 3.启动同步脚本\n进入Logstash目录bin文件夹下执行脚本\n``` bash \n#config为执行配置文件绝对路径或相对路径\nlogstash -f [config]\n```\n\n> 注意conf 配置文件编码格式必须为ANSI否则无法正常读取配置文件","source":"_posts/Logstah同步Es.md","raw":"---\ntitle: Logstash同步数据库\ntags:\n  - 技术\ncategories:\n  - 技术\ntoc: false\ndate: 2018-05-25 16:27:08\n---\n\n![](/images/es.jpg)\n\n>由于业务需求需要同步某些数据库的表数据更新修改删除需同步ES保证同步性，在进行curd用AOP可实现同步，但是考虑到解耦分离后续系统水平拓展，查询资料可以用Logstash进行同步Es，Logstash 是开源的服务器端数据处理管道，能够同时 从多个来源采集数据、转换数据，然后将数据发送到Elasticsearch.\n\n\n\n## 1.Logstash依赖环境\n* JDK1.8 [下载地址](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)\n* Ruby环境 [下载地址](http://www.ruby-lang.org/en/downloads/)\n* logstash 6.3.1 [下载地址](https://www.elastic.co/downloads/logstash)\n\n## 2.Logstash同步配置文件\n>Logstash由三个组件构造成，分别是input、filter以及output。我们可以吧Logstash三个组件的工作流理解为：input收集数据，filter处理数据，output输出数据。至于怎么收集、去哪收集、怎么处理、处理什么、怎么发生以及发送到哪等等一些列的问题就是我们接下啦要讨论的一个重点。\n```\ninput {\n    jdbc{\n    #数据库驱动jar包\n        jdbc_driver_library => \"\\policySyn\\ojdbc6.jar\"\n    #数据库地址\n        jdbc_connection_string => \"jdbc:oracle:thin:@192.168.105.16:1523:gnnt\"\n    #数据库用户名密码\n        jdbc_user => \"plane_tick\"   \n        jdbc_password => \"ora123\"\n    #数据库驱动类\n        jdbc_driver_class => \"Java::oracle.jdbc.driver.OracleDriver\"\n        jdbc_paging_enabled => \"true\"\n        jdbc_page_size => \"50000\"\n    #执行sql绝对路径 或相对路径\n        statement_filepath  => \"\\policySyn\\syn.sql\"\n    #更新时间记录和存放\n        record_last_run => \"true\"\n        last_run_metadata_path => \"\\policySyn\\synDate.txt\"\n    #定时更新频率 20分钟一次\n        schedule => \"* * * * *\"\n    #索引类型\n        type => \"policyteam_dev\"\n    }\n}\n\n//同步目的地\noutput {\n    elasticsearch{\n        hosts => \"http://192.168.105.13:9200\"\n        index => \"policyteam_dev\"\n        document_id => \"%{zcbh}\"\n    }\n    stdout {\n        codec => json_lines\n    }\n}\n```\n## 3.启动同步脚本\n进入Logstash目录bin文件夹下执行脚本\n``` bash \n#config为执行配置文件绝对路径或相对路径\nlogstash -f [config]\n```\n\n> 注意conf 配置文件编码格式必须为ANSI否则无法正常读取配置文件","slug":"Logstah同步Es","published":1,"updated":"2020-08-10T01:48:44.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc97x001kjsudoa7dcdgq","content":"<p><img src=\"/images/es.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>由于业务需求需要同步某些数据库的表数据更新修改删除需同步ES保证同步性，在进行curd用AOP可实现同步，但是考虑到解耦分离后续系统水平拓展，查询资料可以用Logstash进行同步Es，Logstash 是开源的服务器端数据处理管道，能够同时 从多个来源采集数据、转换数据，然后将数据发送到Elasticsearch.</p>\n</blockquote>\n<h2 id=\"1-Logstash依赖环境\"><a href=\"#1-Logstash依赖环境\" class=\"headerlink\" title=\"1.Logstash依赖环境\"></a>1.Logstash依赖环境</h2><ul>\n<li>JDK1.8 <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">下载地址</a></li>\n<li>Ruby环境 <a href=\"http://www.ruby-lang.org/en/downloads/\" target=\"_blank\" rel=\"noopener\">下载地址</a></li>\n<li>logstash 6.3.1 <a href=\"https://www.elastic.co/downloads/logstash\" target=\"_blank\" rel=\"noopener\">下载地址</a></li>\n</ul>\n<h2 id=\"2-Logstash同步配置文件\"><a href=\"#2-Logstash同步配置文件\" class=\"headerlink\" title=\"2.Logstash同步配置文件\"></a>2.Logstash同步配置文件</h2><blockquote>\n<p>Logstash由三个组件构造成，分别是input、filter以及output。我们可以吧Logstash三个组件的工作流理解为：input收集数据，filter处理数据，output输出数据。至于怎么收集、去哪收集、怎么处理、处理什么、怎么发生以及发送到哪等等一些列的问题就是我们接下啦要讨论的一个重点。<br><pre><code class=\"hljs undefined\"><span class=\"hljs-keyword\">input</span> &#123;\n    jdbc&#123;\n    <span class=\"hljs-comment\">#数据库驱动jar包</span>\n        <span class=\"hljs-attr\">jdbc_driver_library</span> =&gt; <span class=\"hljs-string\">\"\\policySyn\\ojdbc6.jar\"</span>\n    <span class=\"hljs-comment\">#数据库地址</span>\n        <span class=\"hljs-attr\">jdbc_connection_string</span> =&gt; <span class=\"hljs-string\">\"jdbc:oracle:thin:@192.168.105.16:1523:gnnt\"</span>\n    <span class=\"hljs-comment\">#数据库用户名密码</span>\n        <span class=\"hljs-attr\">jdbc_user</span> =&gt; <span class=\"hljs-string\">\"plane_tick\"</span>   \n        <span class=\"hljs-attr\">jdbc_password</span> =&gt; <span class=\"hljs-string\">\"ora123\"</span>\n    <span class=\"hljs-comment\">#数据库驱动类</span>\n        <span class=\"hljs-attr\">jdbc_driver_class</span> =&gt; <span class=\"hljs-string\">\"Java::oracle.jdbc.driver.OracleDriver\"</span>\n        <span class=\"hljs-attr\">jdbc_paging_enabled</span> =&gt; <span class=\"hljs-string\">\"true\"</span>\n        <span class=\"hljs-attr\">jdbc_page_size</span> =&gt; <span class=\"hljs-string\">\"50000\"</span>\n    <span class=\"hljs-comment\">#执行sql绝对路径 或相对路径</span>\n        <span class=\"hljs-attr\">statement_filepath</span>  =&gt; <span class=\"hljs-string\">\"\\policySyn\\syn.sql\"</span>\n    <span class=\"hljs-comment\">#更新时间记录和存放</span>\n        <span class=\"hljs-attr\">record_last_run</span> =&gt; <span class=\"hljs-string\">\"true\"</span>\n        <span class=\"hljs-attr\">last_run_metadata_path</span> =&gt; <span class=\"hljs-string\">\"\\policySyn\\synDate.txt\"</span>\n    <span class=\"hljs-comment\">#定时更新频率 20分钟一次</span>\n        <span class=\"hljs-attr\">schedule</span> =&gt; <span class=\"hljs-string\">\"* * * * *\"</span>\n    <span class=\"hljs-comment\">#索引类型</span>\n        <span class=\"hljs-attr\">type</span> =&gt; <span class=\"hljs-string\">\"policyteam_dev\"</span>\n    &#125;\n&#125;\n\n//同步目的地\n<span class=\"hljs-keyword\">output</span> &#123;\n    elasticsearch&#123;\n        <span class=\"hljs-attr\">hosts</span> =&gt; <span class=\"hljs-string\">\"http://192.168.105.13:9200\"</span>\n        <span class=\"hljs-attr\">index</span> =&gt; <span class=\"hljs-string\">\"policyteam_dev\"</span>\n        <span class=\"hljs-attr\">document_id</span> =&gt; <span class=\"hljs-string\">\"%&#123;zcbh&#125;\"</span>\n    &#125;\n    <span class=\"hljs-keyword\">stdout</span> &#123;\n        <span class=\"hljs-attr\">codec</span> =&gt; json_lines\n    &#125;\n&#125;</code></pre></p>\n</blockquote>\n<h2 id=\"3-启动同步脚本\"><a href=\"#3-启动同步脚本\" class=\"headerlink\" title=\"3.启动同步脚本\"></a>3.启动同步脚本</h2><p>进入Logstash目录bin文件夹下执行脚本<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#config为执行配置文件绝对路径或相对路径</span>\nlogstash -f [config]</code></pre></p>\n<blockquote>\n<p>注意conf 配置文件编码格式必须为ANSI否则无法正常读取配置文件</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/es.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>由于业务需求需要同步某些数据库的表数据更新修改删除需同步ES保证同步性，在进行curd用AOP可实现同步，但是考虑到解耦分离后续系统水平拓展，查询资料可以用Logstash进行同步Es，Logstash 是开源的服务器端数据处理管道，能够同时 从多个来源采集数据、转换数据，然后将数据发送到Elasticsearch.</p>\n</blockquote>\n<h2 id=\"1-Logstash依赖环境\"><a href=\"#1-Logstash依赖环境\" class=\"headerlink\" title=\"1.Logstash依赖环境\"></a>1.Logstash依赖环境</h2><ul>\n<li>JDK1.8 <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">下载地址</a></li>\n<li>Ruby环境 <a href=\"http://www.ruby-lang.org/en/downloads/\" target=\"_blank\" rel=\"noopener\">下载地址</a></li>\n<li>logstash 6.3.1 <a href=\"https://www.elastic.co/downloads/logstash\" target=\"_blank\" rel=\"noopener\">下载地址</a></li>\n</ul>\n<h2 id=\"2-Logstash同步配置文件\"><a href=\"#2-Logstash同步配置文件\" class=\"headerlink\" title=\"2.Logstash同步配置文件\"></a>2.Logstash同步配置文件</h2><blockquote>\n<p>Logstash由三个组件构造成，分别是input、filter以及output。我们可以吧Logstash三个组件的工作流理解为：input收集数据，filter处理数据，output输出数据。至于怎么收集、去哪收集、怎么处理、处理什么、怎么发生以及发送到哪等等一些列的问题就是我们接下啦要讨论的一个重点。<br><pre><code class=\"hljs undefined\"><span class=\"hljs-keyword\">input</span> &#123;\n    jdbc&#123;\n    <span class=\"hljs-comment\">#数据库驱动jar包</span>\n        <span class=\"hljs-attr\">jdbc_driver_library</span> =&gt; <span class=\"hljs-string\">\"\\policySyn\\ojdbc6.jar\"</span>\n    <span class=\"hljs-comment\">#数据库地址</span>\n        <span class=\"hljs-attr\">jdbc_connection_string</span> =&gt; <span class=\"hljs-string\">\"jdbc:oracle:thin:@192.168.105.16:1523:gnnt\"</span>\n    <span class=\"hljs-comment\">#数据库用户名密码</span>\n        <span class=\"hljs-attr\">jdbc_user</span> =&gt; <span class=\"hljs-string\">\"plane_tick\"</span>   \n        <span class=\"hljs-attr\">jdbc_password</span> =&gt; <span class=\"hljs-string\">\"ora123\"</span>\n    <span class=\"hljs-comment\">#数据库驱动类</span>\n        <span class=\"hljs-attr\">jdbc_driver_class</span> =&gt; <span class=\"hljs-string\">\"Java::oracle.jdbc.driver.OracleDriver\"</span>\n        <span class=\"hljs-attr\">jdbc_paging_enabled</span> =&gt; <span class=\"hljs-string\">\"true\"</span>\n        <span class=\"hljs-attr\">jdbc_page_size</span> =&gt; <span class=\"hljs-string\">\"50000\"</span>\n    <span class=\"hljs-comment\">#执行sql绝对路径 或相对路径</span>\n        <span class=\"hljs-attr\">statement_filepath</span>  =&gt; <span class=\"hljs-string\">\"\\policySyn\\syn.sql\"</span>\n    <span class=\"hljs-comment\">#更新时间记录和存放</span>\n        <span class=\"hljs-attr\">record_last_run</span> =&gt; <span class=\"hljs-string\">\"true\"</span>\n        <span class=\"hljs-attr\">last_run_metadata_path</span> =&gt; <span class=\"hljs-string\">\"\\policySyn\\synDate.txt\"</span>\n    <span class=\"hljs-comment\">#定时更新频率 20分钟一次</span>\n        <span class=\"hljs-attr\">schedule</span> =&gt; <span class=\"hljs-string\">\"* * * * *\"</span>\n    <span class=\"hljs-comment\">#索引类型</span>\n        <span class=\"hljs-attr\">type</span> =&gt; <span class=\"hljs-string\">\"policyteam_dev\"</span>\n    &#125;\n&#125;\n\n//同步目的地\n<span class=\"hljs-keyword\">output</span> &#123;\n    elasticsearch&#123;\n        <span class=\"hljs-attr\">hosts</span> =&gt; <span class=\"hljs-string\">\"http://192.168.105.13:9200\"</span>\n        <span class=\"hljs-attr\">index</span> =&gt; <span class=\"hljs-string\">\"policyteam_dev\"</span>\n        <span class=\"hljs-attr\">document_id</span> =&gt; <span class=\"hljs-string\">\"%&#123;zcbh&#125;\"</span>\n    &#125;\n    <span class=\"hljs-keyword\">stdout</span> &#123;\n        <span class=\"hljs-attr\">codec</span> =&gt; json_lines\n    &#125;\n&#125;</code></pre></p>\n</blockquote>\n<h2 id=\"3-启动同步脚本\"><a href=\"#3-启动同步脚本\" class=\"headerlink\" title=\"3.启动同步脚本\"></a>3.启动同步脚本</h2><p>进入Logstash目录bin文件夹下执行脚本<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#config为执行配置文件绝对路径或相对路径</span>\nlogstash -f [config]</code></pre></p>\n<blockquote>\n<p>注意conf 配置文件编码格式必须为ANSI否则无法正常读取配置文件</p>\n</blockquote>\n"},{"title":"Log4j 自定义多文件分离","date":"2018-07-20T09:32:59.000Z","_content":"![Log4j](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1533619453&di=71e7053f6a5104d2ee0501827d562550&imgtype=jpg&er=1&src=http%3A%2F%2Fstatic.open-open.com%2Fnews%2FuploadImg%2F20160530%2F20160530232653_508.jpg)\n\n>在工作开发中遇到一个需求需要通过某一些条件逻辑进行分组细化日志，用配置的一些条件进行不同的日志管理和处理，由于之前的日志没有细化会导致在很多日志中无法更快和更精准的定位某一个模块的错误，如大海捞针效率极低，细分后方便开发和维护人员对日志更快更精准的排查修改BUG。\n\n## 1.Log4j 介绍\n   Log4j有三个主要的组件：Loggers(记录器)，Appenders (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。\n             \n## 2.Log4j 组件\n### Appender 配置\n - ##### ConsoleAppender (控制台)\n    1. Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。\n    2. ImmediateFlush=true：消息都会被立即输出，设为false则不输出，默认值是true。\n    3. Target=System.err：默认值是System.out。\n - ##### FileAppender (文件)\n    1. Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。\n    2. File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。\n - ##### DailyRollingFileAppender (按照日期格式生成)\n    1. DatePattern='.'yyyy-MM：根据时间格式按照年月日为单位生成log文件\n     '.'yyyy-MM：每月\n     '.'yyyy-ww：每周\n     '.'yyyy-MM-dd：每天\n     '.'yyyy-MM-dd-a：每天两次\n     '.'yyyy-MM-dd-HH：每小时\n     '.'yyyy-MM-dd-HH-mm：每分钟\n - ##### RollingFileAppender (文件大小到达指定尺寸的时候产生一个新的文件)\n    1. MaxFileSize=100KB：后缀可以是KB， MB 或者GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。\n    2. MaxBackupIndex=2：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文\n - ##### SocketAppender (发送远程服务 Tip:可配合logstash使用)\n    1. host，String，指定服务器的主机名。（必需）\n    2. immediateFlush，boolean，是否立即flush，还是等待缓存到一定大小后在flush。\n    3. layout，Layout，log event输出的格式。\n    4. port，integer，远程服务器坚挺log event的应用的端口号。\n    5. protocol，String，发送log event所使用的协议，\"TCP\" 或\"UDP\"。\n    6. reconnectionDelay，integer，当连接断开时，延迟等待的ms数。\n    7. name，String ，Appender的名称。\n    8. protocol，String，通讯协议 默认TCP。可选值 \"TCP\" (default)， \"SSL\" or \"UDP\".\n    9. SSL，SslConfiguration，包含密钥存储库和信任存储库的配置.\n    10. filter，Filter，一个过滤器来确定事件应该由这个Appender。 不止一个过滤器 可以通过使用一个CompositeFilter。\n    11. immediateFail，boolean，设置为true时，日志事件不会等待尝试重新连接，将立即如果失败 套接字是不可用的。\n    12. immediateFlush，boolean， 当该值设置成真时，默认情况下，每个写将冲洗。 这将保证写的数据 到磁盘，但可能会影响性能。\n    13. layout，Layout，LogEvent ，布局使用格式。 缺省值是SerializedLayout。\n    14. reconnectionDelay，integer ，如果设置为值大于0，一个错误后SocketManager将尝试重新连接 在指定的毫秒数后的服务器。 如果连接失败 将抛出一个异常(可以被应用程序如果ignoreExceptions是 设置为假)。\n    15. ignoreExceptions，boolean，默认值是真正的添加事件时，遇到了引起异常 内部记录，然后忽略。 当设置为假将传播到异常 调用者。 你必须设置这个假当包装这个AppenderFailoverAppender。\n - ##### SMTPAppender (发送邮件)\n    1. smtpHost= mtp.163.com：邮件服务器地址\n    2. smtpPort=30 ：端口号\n    3. from= ***@**.com：发送方邮箱\n    4. replyTo = ***@**.com： 接收方方邮箱\n    5. smtpUsername = 285635652@qq.com：发送方邮箱账号\n    6. smtpPassword = **********：发送方邮箱密码\n\n    \n>log4j.additivity.[appenderName]=false (用于独立输出日志，Logger只会在自己的appender里输出，而不会在父Logger的appender里输出。)默认为true\n\n\n### Layouts\n- ##### HTMLLayout（以HTML表格形式布局） \n- ##### PatternLayout（可以灵活地指定布局模式） \n- ##### SimpleLayout（包含日志信息的级别和信息字符串） \n- ##### TTCCLayout（包含日志产生的时间、线程、类别等信息）   \n\n## 3.Spring 运用 Log4j\n``` properties\n# LOG4J配置\nlog4j.rootCategory=INFO， stdout， file\nlog4j.logger.errorfile=error，errorfile\n\n# 控制台输出\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss，SSS} %5p %c{1}:%L - %m%n\n\n# root日志输出\nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.file.file=logs/all.log\nlog4j.appender.file.DatePattern='.'yyyy-MM-dd\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss，SSS} %5p %c{1}:%L - %m%n\n\n# error日志输出\nlog4j.appender.errorfile=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.errorfile.file=logs/error.log\nlog4j.appender.errorfile.DatePattern='.'yyyy-MM-dd\nlog4j.appender.errorfile.Threshold = ERROR\nlog4j.appender.errorfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.errorfile.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss，SSS} %5p %c{1}:%L - %m%n\n\n#自定义业务分组 team mytest输出目标\nlog4j.logger.team=INFO，mytest\n#自定义日志输出\n#输出的各种Appender\nlog4j.appender.mytest=org.apache.log4j.DailyRollingFileAppender\n#父类节点不输出 分级\nlog4j.additivity.team=false\n#输出的日志地址\nlog4j.appender.mytest.file=logs/mytest.log\n#记录的时间单位 天 \nlog4j.appender.mytest.DatePattern='.'yyyy-MM-dd\n#布局\nlog4j.appender.mytest.layout=org.apache.log4j.PatternLayout\n#输出内容\nlog4j.appender.mytest.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss，SSS} %5p %c{1}:%L ---- %m%n\n\n```\n\n#### 讲解\n1. rootCategory 主节点 [日志级别]，[输出目标]，[输出目标]，[...]\n2. category 子节点 特别会集成主节点的设置 日志级别\n3. log4j.appender.[输出目标] 日志的输出设置 包含输出格式、布局、方式等\n4. 优先级：DEBUG < INFO < WARN < ERROR < FATAL\n5. PatternLayout 布局 ConversionPattern相关设置  \n%m 输出代码中指定的消息\n%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL\n%r 输出自应用启动到输出该log信息耗费的毫秒数\n%c 输出所属的类目，通常就是所在类的全名\n%t 输出产生该日志事件的线程名\n%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”\n%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MMM ddHH:mm:ss，SSS}，输出类似：2002年10月18日 22：10：28，921\n%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。\n[QC]是log信息的开头，可以为任意字符，一般为项目简称。\n","source":"_posts/Log4j-学习笔记.md","raw":"---\ntitle: Log4j 自定义多文件分离\ndate: 2018-07-20 17:32:59\ncategories: [Spring]\ntags:\n    - Java\n---\n![Log4j](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1533619453&di=71e7053f6a5104d2ee0501827d562550&imgtype=jpg&er=1&src=http%3A%2F%2Fstatic.open-open.com%2Fnews%2FuploadImg%2F20160530%2F20160530232653_508.jpg)\n\n>在工作开发中遇到一个需求需要通过某一些条件逻辑进行分组细化日志，用配置的一些条件进行不同的日志管理和处理，由于之前的日志没有细化会导致在很多日志中无法更快和更精准的定位某一个模块的错误，如大海捞针效率极低，细分后方便开发和维护人员对日志更快更精准的排查修改BUG。\n\n## 1.Log4j 介绍\n   Log4j有三个主要的组件：Loggers(记录器)，Appenders (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。\n             \n## 2.Log4j 组件\n### Appender 配置\n - ##### ConsoleAppender (控制台)\n    1. Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。\n    2. ImmediateFlush=true：消息都会被立即输出，设为false则不输出，默认值是true。\n    3. Target=System.err：默认值是System.out。\n - ##### FileAppender (文件)\n    1. Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。\n    2. File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。\n - ##### DailyRollingFileAppender (按照日期格式生成)\n    1. DatePattern='.'yyyy-MM：根据时间格式按照年月日为单位生成log文件\n     '.'yyyy-MM：每月\n     '.'yyyy-ww：每周\n     '.'yyyy-MM-dd：每天\n     '.'yyyy-MM-dd-a：每天两次\n     '.'yyyy-MM-dd-HH：每小时\n     '.'yyyy-MM-dd-HH-mm：每分钟\n - ##### RollingFileAppender (文件大小到达指定尺寸的时候产生一个新的文件)\n    1. MaxFileSize=100KB：后缀可以是KB， MB 或者GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。\n    2. MaxBackupIndex=2：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文\n - ##### SocketAppender (发送远程服务 Tip:可配合logstash使用)\n    1. host，String，指定服务器的主机名。（必需）\n    2. immediateFlush，boolean，是否立即flush，还是等待缓存到一定大小后在flush。\n    3. layout，Layout，log event输出的格式。\n    4. port，integer，远程服务器坚挺log event的应用的端口号。\n    5. protocol，String，发送log event所使用的协议，\"TCP\" 或\"UDP\"。\n    6. reconnectionDelay，integer，当连接断开时，延迟等待的ms数。\n    7. name，String ，Appender的名称。\n    8. protocol，String，通讯协议 默认TCP。可选值 \"TCP\" (default)， \"SSL\" or \"UDP\".\n    9. SSL，SslConfiguration，包含密钥存储库和信任存储库的配置.\n    10. filter，Filter，一个过滤器来确定事件应该由这个Appender。 不止一个过滤器 可以通过使用一个CompositeFilter。\n    11. immediateFail，boolean，设置为true时，日志事件不会等待尝试重新连接，将立即如果失败 套接字是不可用的。\n    12. immediateFlush，boolean， 当该值设置成真时，默认情况下，每个写将冲洗。 这将保证写的数据 到磁盘，但可能会影响性能。\n    13. layout，Layout，LogEvent ，布局使用格式。 缺省值是SerializedLayout。\n    14. reconnectionDelay，integer ，如果设置为值大于0，一个错误后SocketManager将尝试重新连接 在指定的毫秒数后的服务器。 如果连接失败 将抛出一个异常(可以被应用程序如果ignoreExceptions是 设置为假)。\n    15. ignoreExceptions，boolean，默认值是真正的添加事件时，遇到了引起异常 内部记录，然后忽略。 当设置为假将传播到异常 调用者。 你必须设置这个假当包装这个AppenderFailoverAppender。\n - ##### SMTPAppender (发送邮件)\n    1. smtpHost= mtp.163.com：邮件服务器地址\n    2. smtpPort=30 ：端口号\n    3. from= ***@**.com：发送方邮箱\n    4. replyTo = ***@**.com： 接收方方邮箱\n    5. smtpUsername = 285635652@qq.com：发送方邮箱账号\n    6. smtpPassword = **********：发送方邮箱密码\n\n    \n>log4j.additivity.[appenderName]=false (用于独立输出日志，Logger只会在自己的appender里输出，而不会在父Logger的appender里输出。)默认为true\n\n\n### Layouts\n- ##### HTMLLayout（以HTML表格形式布局） \n- ##### PatternLayout（可以灵活地指定布局模式） \n- ##### SimpleLayout（包含日志信息的级别和信息字符串） \n- ##### TTCCLayout（包含日志产生的时间、线程、类别等信息）   \n\n## 3.Spring 运用 Log4j\n``` properties\n# LOG4J配置\nlog4j.rootCategory=INFO， stdout， file\nlog4j.logger.errorfile=error，errorfile\n\n# 控制台输出\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss，SSS} %5p %c{1}:%L - %m%n\n\n# root日志输出\nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.file.file=logs/all.log\nlog4j.appender.file.DatePattern='.'yyyy-MM-dd\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss，SSS} %5p %c{1}:%L - %m%n\n\n# error日志输出\nlog4j.appender.errorfile=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.errorfile.file=logs/error.log\nlog4j.appender.errorfile.DatePattern='.'yyyy-MM-dd\nlog4j.appender.errorfile.Threshold = ERROR\nlog4j.appender.errorfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.errorfile.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss，SSS} %5p %c{1}:%L - %m%n\n\n#自定义业务分组 team mytest输出目标\nlog4j.logger.team=INFO，mytest\n#自定义日志输出\n#输出的各种Appender\nlog4j.appender.mytest=org.apache.log4j.DailyRollingFileAppender\n#父类节点不输出 分级\nlog4j.additivity.team=false\n#输出的日志地址\nlog4j.appender.mytest.file=logs/mytest.log\n#记录的时间单位 天 \nlog4j.appender.mytest.DatePattern='.'yyyy-MM-dd\n#布局\nlog4j.appender.mytest.layout=org.apache.log4j.PatternLayout\n#输出内容\nlog4j.appender.mytest.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss，SSS} %5p %c{1}:%L ---- %m%n\n\n```\n\n#### 讲解\n1. rootCategory 主节点 [日志级别]，[输出目标]，[输出目标]，[...]\n2. category 子节点 特别会集成主节点的设置 日志级别\n3. log4j.appender.[输出目标] 日志的输出设置 包含输出格式、布局、方式等\n4. 优先级：DEBUG < INFO < WARN < ERROR < FATAL\n5. PatternLayout 布局 ConversionPattern相关设置  \n%m 输出代码中指定的消息\n%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL\n%r 输出自应用启动到输出该log信息耗费的毫秒数\n%c 输出所属的类目，通常就是所在类的全名\n%t 输出产生该日志事件的线程名\n%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”\n%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MMM ddHH:mm:ss，SSS}，输出类似：2002年10月18日 22：10：28，921\n%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。\n[QC]是log信息的开头，可以为任意字符，一般为项目简称。\n","slug":"Log4j-学习笔记","published":1,"updated":"2020-08-10T01:48:44.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc981001ojsudbus61g0n","content":"<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533619453&amp;di=71e7053f6a5104d2ee0501827d562550&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fstatic.open-open.com%2Fnews%2FuploadImg%2F20160530%2F20160530232653_508.jpg\" srcset=\"/img/loading.gif\" alt=\"Log4j\"></p>\n<blockquote>\n<p>在工作开发中遇到一个需求需要通过某一些条件逻辑进行分组细化日志，用配置的一些条件进行不同的日志管理和处理，由于之前的日志没有细化会导致在很多日志中无法更快和更精准的定位某一个模块的错误，如大海捞针效率极低，细分后方便开发和维护人员对日志更快更精准的排查修改BUG。</p>\n</blockquote>\n<h2 id=\"1-Log4j-介绍\"><a href=\"#1-Log4j-介绍\" class=\"headerlink\" title=\"1.Log4j 介绍\"></a>1.Log4j 介绍</h2><p>   Log4j有三个主要的组件：Loggers(记录器)，Appenders (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。</p>\n<h2 id=\"2-Log4j-组件\"><a href=\"#2-Log4j-组件\" class=\"headerlink\" title=\"2.Log4j 组件\"></a>2.Log4j 组件</h2><h3 id=\"Appender-配置\"><a href=\"#Appender-配置\" class=\"headerlink\" title=\"Appender 配置\"></a>Appender 配置</h3><ul>\n<li><h5 id=\"ConsoleAppender-控制台\"><a href=\"#ConsoleAppender-控制台\" class=\"headerlink\" title=\"ConsoleAppender (控制台)\"></a>ConsoleAppender (控制台)</h5><ol>\n<li>Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>\n<li>ImmediateFlush=true：消息都会被立即输出，设为false则不输出，默认值是true。</li>\n<li>Target=System.err：默认值是System.out。</li>\n</ol>\n</li>\n<li><h5 id=\"FileAppender-文件\"><a href=\"#FileAppender-文件\" class=\"headerlink\" title=\"FileAppender (文件)\"></a>FileAppender (文件)</h5><ol>\n<li>Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>\n<li>File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。</li>\n</ol>\n</li>\n<li><h5 id=\"DailyRollingFileAppender-按照日期格式生成\"><a href=\"#DailyRollingFileAppender-按照日期格式生成\" class=\"headerlink\" title=\"DailyRollingFileAppender (按照日期格式生成)\"></a>DailyRollingFileAppender (按照日期格式生成)</h5><ol>\n<li>DatePattern=’.’yyyy-MM：根据时间格式按照年月日为单位生成log文件<br>‘.’yyyy-MM：每月<br>‘.’yyyy-ww：每周<br>‘.’yyyy-MM-dd：每天<br>‘.’yyyy-MM-dd-a：每天两次<br>‘.’yyyy-MM-dd-HH：每小时<br>‘.’yyyy-MM-dd-HH-mm：每分钟</li>\n</ol>\n</li>\n<li><h5 id=\"RollingFileAppender-文件大小到达指定尺寸的时候产生一个新的文件\"><a href=\"#RollingFileAppender-文件大小到达指定尺寸的时候产生一个新的文件\" class=\"headerlink\" title=\"RollingFileAppender (文件大小到达指定尺寸的时候产生一个新的文件)\"></a>RollingFileAppender (文件大小到达指定尺寸的时候产生一个新的文件)</h5><ol>\n<li>MaxFileSize=100KB：后缀可以是KB， MB 或者GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。</li>\n<li>MaxBackupIndex=2：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文</li>\n</ol>\n</li>\n<li><h5 id=\"SocketAppender-发送远程服务-Tip-可配合logstash使用\"><a href=\"#SocketAppender-发送远程服务-Tip-可配合logstash使用\" class=\"headerlink\" title=\"SocketAppender (发送远程服务 Tip:可配合logstash使用)\"></a>SocketAppender (发送远程服务 Tip:可配合logstash使用)</h5><ol>\n<li>host，String，指定服务器的主机名。（必需）</li>\n<li>immediateFlush，boolean，是否立即flush，还是等待缓存到一定大小后在flush。</li>\n<li>layout，Layout，log event输出的格式。</li>\n<li>port，integer，远程服务器坚挺log event的应用的端口号。</li>\n<li>protocol，String，发送log event所使用的协议，”TCP” 或”UDP”。</li>\n<li>reconnectionDelay，integer，当连接断开时，延迟等待的ms数。</li>\n<li>name，String ，Appender的名称。</li>\n<li>protocol，String，通讯协议 默认TCP。可选值 “TCP” (default)， “SSL” or “UDP”.</li>\n<li>SSL，SslConfiguration，包含密钥存储库和信任存储库的配置.</li>\n<li>filter，Filter，一个过滤器来确定事件应该由这个Appender。 不止一个过滤器 可以通过使用一个CompositeFilter。</li>\n<li>immediateFail，boolean，设置为true时，日志事件不会等待尝试重新连接，将立即如果失败 套接字是不可用的。</li>\n<li>immediateFlush，boolean， 当该值设置成真时，默认情况下，每个写将冲洗。 这将保证写的数据 到磁盘，但可能会影响性能。</li>\n<li>layout，Layout，LogEvent ，布局使用格式。 缺省值是SerializedLayout。</li>\n<li>reconnectionDelay，integer ，如果设置为值大于0，一个错误后SocketManager将尝试重新连接 在指定的毫秒数后的服务器。 如果连接失败 将抛出一个异常(可以被应用程序如果ignoreExceptions是 设置为假)。</li>\n<li>ignoreExceptions，boolean，默认值是真正的添加事件时，遇到了引起异常 内部记录，然后忽略。 当设置为假将传播到异常 调用者。 你必须设置这个假当包装这个AppenderFailoverAppender。</li>\n</ol>\n</li>\n<li><h5 id=\"SMTPAppender-发送邮件\"><a href=\"#SMTPAppender-发送邮件\" class=\"headerlink\" title=\"SMTPAppender (发送邮件)\"></a>SMTPAppender (发送邮件)</h5><ol>\n<li>smtpHost= mtp.163.com：邮件服务器地址</li>\n<li>smtpPort=30 ：端口号</li>\n<li>from= <strong>*@</strong>.com：发送方邮箱</li>\n<li>replyTo = <strong>*@</strong>.com： 接收方方邮箱</li>\n<li>smtpUsername = <a href=\"mailto:285635652@qq.com\" target=\"_blank\" rel=\"noopener\">285635652@qq.com</a>：发送方邮箱账号</li>\n<li>smtpPassword = <strong><strong>**</strong></strong>：发送方邮箱密码</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>log4j.additivity.[appenderName]=false (用于独立输出日志，Logger只会在自己的appender里输出，而不会在父Logger的appender里输出。)默认为true</p>\n</blockquote>\n<h3 id=\"Layouts\"><a href=\"#Layouts\" class=\"headerlink\" title=\"Layouts\"></a>Layouts</h3><ul>\n<li><h5 id=\"HTMLLayout（以HTML表格形式布局）\"><a href=\"#HTMLLayout（以HTML表格形式布局）\" class=\"headerlink\" title=\"HTMLLayout（以HTML表格形式布局）\"></a>HTMLLayout（以HTML表格形式布局）</h5></li>\n<li><h5 id=\"PatternLayout（可以灵活地指定布局模式）\"><a href=\"#PatternLayout（可以灵活地指定布局模式）\" class=\"headerlink\" title=\"PatternLayout（可以灵活地指定布局模式）\"></a>PatternLayout（可以灵活地指定布局模式）</h5></li>\n<li><h5 id=\"SimpleLayout（包含日志信息的级别和信息字符串）\"><a href=\"#SimpleLayout（包含日志信息的级别和信息字符串）\" class=\"headerlink\" title=\"SimpleLayout（包含日志信息的级别和信息字符串）\"></a>SimpleLayout（包含日志信息的级别和信息字符串）</h5></li>\n<li><h5 id=\"TTCCLayout（包含日志产生的时间、线程、类别等信息）\"><a href=\"#TTCCLayout（包含日志产生的时间、线程、类别等信息）\" class=\"headerlink\" title=\"TTCCLayout（包含日志产生的时间、线程、类别等信息）\"></a>TTCCLayout（包含日志产生的时间、线程、类别等信息）</h5></li>\n</ul>\n<h2 id=\"3-Spring-运用-Log4j\"><a href=\"#3-Spring-运用-Log4j\" class=\"headerlink\" title=\"3.Spring 运用 Log4j\"></a>3.Spring 运用 Log4j</h2><pre><code class=\"hljs properties\"># LOG4J配置\nlog4j.rootCategory=INFO， stdout， file\nlog4j.logger.errorfile=error，errorfile\n\n# 控制台输出\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss，SSS&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n# root日志输出\nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.file.file=logs/all.log\nlog4j.appender.file.DatePattern=&apos;.&apos;yyyy-MM-dd\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss，SSS&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n# error日志输出\nlog4j.appender.errorfile=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.errorfile.file=logs/error.log\nlog4j.appender.errorfile.DatePattern=&apos;.&apos;yyyy-MM-dd\nlog4j.appender.errorfile.Threshold = ERROR\nlog4j.appender.errorfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.errorfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss，SSS&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n#自定义业务分组 team mytest输出目标\nlog4j.logger.team=INFO，mytest\n#自定义日志输出\n#输出的各种Appender\nlog4j.appender.mytest=org.apache.log4j.DailyRollingFileAppender\n#父类节点不输出 分级\nlog4j.additivity.team=false\n#输出的日志地址\nlog4j.appender.mytest.file=logs/mytest.log\n#记录的时间单位 天 \nlog4j.appender.mytest.DatePattern=&apos;.&apos;yyyy-MM-dd\n#布局\nlog4j.appender.mytest.layout=org.apache.log4j.PatternLayout\n#输出内容\nlog4j.appender.mytest.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss，SSS&#125; %5p %c&#123;1&#125;:%L ---- %m%n</code></pre>\n<h4 id=\"讲解\"><a href=\"#讲解\" class=\"headerlink\" title=\"讲解\"></a>讲解</h4><ol>\n<li>rootCategory 主节点 [日志级别]，[输出目标]，[输出目标]，[…]</li>\n<li>category 子节点 特别会集成主节点的设置 日志级别</li>\n<li>log4j.appender.[输出目标] 日志的输出设置 包含输出格式、布局、方式等</li>\n<li>优先级：DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</li>\n<li>PatternLayout 布局 ConversionPattern相关设置<br>%m 输出代码中指定的消息<br>%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL<br>%r 输出自应用启动到输出该log信息耗费的毫秒数<br>%c 输出所属的类目，通常就是所在类的全名<br>%t 输出产生该日志事件的线程名<br>%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”<br>%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MMM ddHH:mm:ss，SSS}，输出类似：2002年10月18日 22：10：28，921<br>%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。<br>[QC]是log信息的开头，可以为任意字符，一般为项目简称。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533619453&amp;di=71e7053f6a5104d2ee0501827d562550&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fstatic.open-open.com%2Fnews%2FuploadImg%2F20160530%2F20160530232653_508.jpg\" srcset=\"/img/loading.gif\" alt=\"Log4j\"></p>\n<blockquote>\n<p>在工作开发中遇到一个需求需要通过某一些条件逻辑进行分组细化日志，用配置的一些条件进行不同的日志管理和处理，由于之前的日志没有细化会导致在很多日志中无法更快和更精准的定位某一个模块的错误，如大海捞针效率极低，细分后方便开发和维护人员对日志更快更精准的排查修改BUG。</p>\n</blockquote>\n<h2 id=\"1-Log4j-介绍\"><a href=\"#1-Log4j-介绍\" class=\"headerlink\" title=\"1.Log4j 介绍\"></a>1.Log4j 介绍</h2><p>   Log4j有三个主要的组件：Loggers(记录器)，Appenders (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。</p>\n<h2 id=\"2-Log4j-组件\"><a href=\"#2-Log4j-组件\" class=\"headerlink\" title=\"2.Log4j 组件\"></a>2.Log4j 组件</h2><h3 id=\"Appender-配置\"><a href=\"#Appender-配置\" class=\"headerlink\" title=\"Appender 配置\"></a>Appender 配置</h3><ul>\n<li><h5 id=\"ConsoleAppender-控制台\"><a href=\"#ConsoleAppender-控制台\" class=\"headerlink\" title=\"ConsoleAppender (控制台)\"></a>ConsoleAppender (控制台)</h5><ol>\n<li>Threshold=WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>\n<li>ImmediateFlush=true：消息都会被立即输出，设为false则不输出，默认值是true。</li>\n<li>Target=System.err：默认值是System.out。</li>\n</ol>\n</li>\n<li><h5 id=\"FileAppender-文件\"><a href=\"#FileAppender-文件\" class=\"headerlink\" title=\"FileAppender (文件)\"></a>FileAppender (文件)</h5><ol>\n<li>Append=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>\n<li>File=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。</li>\n</ol>\n</li>\n<li><h5 id=\"DailyRollingFileAppender-按照日期格式生成\"><a href=\"#DailyRollingFileAppender-按照日期格式生成\" class=\"headerlink\" title=\"DailyRollingFileAppender (按照日期格式生成)\"></a>DailyRollingFileAppender (按照日期格式生成)</h5><ol>\n<li>DatePattern=’.’yyyy-MM：根据时间格式按照年月日为单位生成log文件<br>‘.’yyyy-MM：每月<br>‘.’yyyy-ww：每周<br>‘.’yyyy-MM-dd：每天<br>‘.’yyyy-MM-dd-a：每天两次<br>‘.’yyyy-MM-dd-HH：每小时<br>‘.’yyyy-MM-dd-HH-mm：每分钟</li>\n</ol>\n</li>\n<li><h5 id=\"RollingFileAppender-文件大小到达指定尺寸的时候产生一个新的文件\"><a href=\"#RollingFileAppender-文件大小到达指定尺寸的时候产生一个新的文件\" class=\"headerlink\" title=\"RollingFileAppender (文件大小到达指定尺寸的时候产生一个新的文件)\"></a>RollingFileAppender (文件大小到达指定尺寸的时候产生一个新的文件)</h5><ol>\n<li>MaxFileSize=100KB：后缀可以是KB， MB 或者GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。</li>\n<li>MaxBackupIndex=2：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文</li>\n</ol>\n</li>\n<li><h5 id=\"SocketAppender-发送远程服务-Tip-可配合logstash使用\"><a href=\"#SocketAppender-发送远程服务-Tip-可配合logstash使用\" class=\"headerlink\" title=\"SocketAppender (发送远程服务 Tip:可配合logstash使用)\"></a>SocketAppender (发送远程服务 Tip:可配合logstash使用)</h5><ol>\n<li>host，String，指定服务器的主机名。（必需）</li>\n<li>immediateFlush，boolean，是否立即flush，还是等待缓存到一定大小后在flush。</li>\n<li>layout，Layout，log event输出的格式。</li>\n<li>port，integer，远程服务器坚挺log event的应用的端口号。</li>\n<li>protocol，String，发送log event所使用的协议，”TCP” 或”UDP”。</li>\n<li>reconnectionDelay，integer，当连接断开时，延迟等待的ms数。</li>\n<li>name，String ，Appender的名称。</li>\n<li>protocol，String，通讯协议 默认TCP。可选值 “TCP” (default)， “SSL” or “UDP”.</li>\n<li>SSL，SslConfiguration，包含密钥存储库和信任存储库的配置.</li>\n<li>filter，Filter，一个过滤器来确定事件应该由这个Appender。 不止一个过滤器 可以通过使用一个CompositeFilter。</li>\n<li>immediateFail，boolean，设置为true时，日志事件不会等待尝试重新连接，将立即如果失败 套接字是不可用的。</li>\n<li>immediateFlush，boolean， 当该值设置成真时，默认情况下，每个写将冲洗。 这将保证写的数据 到磁盘，但可能会影响性能。</li>\n<li>layout，Layout，LogEvent ，布局使用格式。 缺省值是SerializedLayout。</li>\n<li>reconnectionDelay，integer ，如果设置为值大于0，一个错误后SocketManager将尝试重新连接 在指定的毫秒数后的服务器。 如果连接失败 将抛出一个异常(可以被应用程序如果ignoreExceptions是 设置为假)。</li>\n<li>ignoreExceptions，boolean，默认值是真正的添加事件时，遇到了引起异常 内部记录，然后忽略。 当设置为假将传播到异常 调用者。 你必须设置这个假当包装这个AppenderFailoverAppender。</li>\n</ol>\n</li>\n<li><h5 id=\"SMTPAppender-发送邮件\"><a href=\"#SMTPAppender-发送邮件\" class=\"headerlink\" title=\"SMTPAppender (发送邮件)\"></a>SMTPAppender (发送邮件)</h5><ol>\n<li>smtpHost= mtp.163.com：邮件服务器地址</li>\n<li>smtpPort=30 ：端口号</li>\n<li>from= <strong>*@</strong>.com：发送方邮箱</li>\n<li>replyTo = <strong>*@</strong>.com： 接收方方邮箱</li>\n<li>smtpUsername = <a href=\"mailto:285635652@qq.com\" target=\"_blank\" rel=\"noopener\">285635652@qq.com</a>：发送方邮箱账号</li>\n<li>smtpPassword = <strong><strong>**</strong></strong>：发送方邮箱密码</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>log4j.additivity.[appenderName]=false (用于独立输出日志，Logger只会在自己的appender里输出，而不会在父Logger的appender里输出。)默认为true</p>\n</blockquote>\n<h3 id=\"Layouts\"><a href=\"#Layouts\" class=\"headerlink\" title=\"Layouts\"></a>Layouts</h3><ul>\n<li><h5 id=\"HTMLLayout（以HTML表格形式布局）\"><a href=\"#HTMLLayout（以HTML表格形式布局）\" class=\"headerlink\" title=\"HTMLLayout（以HTML表格形式布局）\"></a>HTMLLayout（以HTML表格形式布局）</h5></li>\n<li><h5 id=\"PatternLayout（可以灵活地指定布局模式）\"><a href=\"#PatternLayout（可以灵活地指定布局模式）\" class=\"headerlink\" title=\"PatternLayout（可以灵活地指定布局模式）\"></a>PatternLayout（可以灵活地指定布局模式）</h5></li>\n<li><h5 id=\"SimpleLayout（包含日志信息的级别和信息字符串）\"><a href=\"#SimpleLayout（包含日志信息的级别和信息字符串）\" class=\"headerlink\" title=\"SimpleLayout（包含日志信息的级别和信息字符串）\"></a>SimpleLayout（包含日志信息的级别和信息字符串）</h5></li>\n<li><h5 id=\"TTCCLayout（包含日志产生的时间、线程、类别等信息）\"><a href=\"#TTCCLayout（包含日志产生的时间、线程、类别等信息）\" class=\"headerlink\" title=\"TTCCLayout（包含日志产生的时间、线程、类别等信息）\"></a>TTCCLayout（包含日志产生的时间、线程、类别等信息）</h5></li>\n</ul>\n<h2 id=\"3-Spring-运用-Log4j\"><a href=\"#3-Spring-运用-Log4j\" class=\"headerlink\" title=\"3.Spring 运用 Log4j\"></a>3.Spring 运用 Log4j</h2><pre><code class=\"hljs properties\"># LOG4J配置\nlog4j.rootCategory=INFO， stdout， file\nlog4j.logger.errorfile=error，errorfile\n\n# 控制台输出\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss，SSS&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n# root日志输出\nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.file.file=logs/all.log\nlog4j.appender.file.DatePattern=&apos;.&apos;yyyy-MM-dd\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss，SSS&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n# error日志输出\nlog4j.appender.errorfile=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.errorfile.file=logs/error.log\nlog4j.appender.errorfile.DatePattern=&apos;.&apos;yyyy-MM-dd\nlog4j.appender.errorfile.Threshold = ERROR\nlog4j.appender.errorfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.errorfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss，SSS&#125; %5p %c&#123;1&#125;:%L - %m%n\n\n#自定义业务分组 team mytest输出目标\nlog4j.logger.team=INFO，mytest\n#自定义日志输出\n#输出的各种Appender\nlog4j.appender.mytest=org.apache.log4j.DailyRollingFileAppender\n#父类节点不输出 分级\nlog4j.additivity.team=false\n#输出的日志地址\nlog4j.appender.mytest.file=logs/mytest.log\n#记录的时间单位 天 \nlog4j.appender.mytest.DatePattern=&apos;.&apos;yyyy-MM-dd\n#布局\nlog4j.appender.mytest.layout=org.apache.log4j.PatternLayout\n#输出内容\nlog4j.appender.mytest.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss，SSS&#125; %5p %c&#123;1&#125;:%L ---- %m%n</code></pre>\n<h4 id=\"讲解\"><a href=\"#讲解\" class=\"headerlink\" title=\"讲解\"></a>讲解</h4><ol>\n<li>rootCategory 主节点 [日志级别]，[输出目标]，[输出目标]，[…]</li>\n<li>category 子节点 特别会集成主节点的设置 日志级别</li>\n<li>log4j.appender.[输出目标] 日志的输出设置 包含输出格式、布局、方式等</li>\n<li>优先级：DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</li>\n<li>PatternLayout 布局 ConversionPattern相关设置<br>%m 输出代码中指定的消息<br>%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL<br>%r 输出自应用启动到输出该log信息耗费的毫秒数<br>%c 输出所属的类目，通常就是所在类的全名<br>%t 输出产生该日志事件的线程名<br>%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”<br>%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy MMM ddHH:mm:ss，SSS}，输出类似：2002年10月18日 22：10：28，921<br>%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。<br>[QC]是log信息的开头，可以为任意字符，一般为项目简称。</li>\n</ol>\n"},{"title":"Maven 属性","toc":true,"date":"2019-07-18T02:00:03.000Z","_content":"\n![](/images/maven.jpg)\n\n\n##### Maven 内置属性\nMaven 预定义,用户可以直接使用\n- ${basedir} 表示项目根目录，即包含pom.xml文件目录\n- ${version} 表示项目版本\n- ${project.basedir} 同 ${basedir} \n- ${project.baseUri} 表示项目文件地址\n- ${maven.build.timestamp} 表示项目构件开始时间\n  \n##### Maven POM 属性\n使用 pom 属性可以引用到`pom.xml`文件对应元素的值\n- ${project.build.directory} 表示主源码路径\n- ${project.build.sourceEncoding} 表示主源码的编码格式\n- ${project.build.sourceDirectory} 表示主源码路径\n- ${project.build.finalName} 表示输出文件名称\n- ${project.version} 表示项目版本,与 ${version} 相同\n\n##### Maven 自定义属性\n通过在`pom.xml`定义属性可以在其他地方引用通常在项目中用于定义引入`jar`的版本等\n``` xml\n<properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <version.spring>3.2.9.RELEASE</version.spring>\n    <version.jackson>2.4.4</version.jackson>\n    <java.version>1.7</java.version>\n    <log4j2.version>2.6.2</log4j2.version>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n</properties>\n```\n\n##### 环境变量属性\n所有的环境变量都可以用以`env.`开头的 Maven 属性引用，所有的环境变量都可以用以`env.`开头的Maven属性引用，${env.JAVA_HOME}表示JAVA_HOME环境变量的值\n\n----\n\n##### 参考如下：\nhttp://maven.apache.org/guides/introduction/introduction-to-the-pom.html\nhttp://maven.apache.org/pom.html\nhttp://maven.apache.org/settings.html","source":"_posts/Maven 属性.md","raw":"---\ntitle: Maven 属性\ntags:\n  - Maven\ncategories:\n  - 技术\ntoc: true\ndate: 2019-07-18 10:00:03\n---\n\n![](/images/maven.jpg)\n\n\n##### Maven 内置属性\nMaven 预定义,用户可以直接使用\n- ${basedir} 表示项目根目录，即包含pom.xml文件目录\n- ${version} 表示项目版本\n- ${project.basedir} 同 ${basedir} \n- ${project.baseUri} 表示项目文件地址\n- ${maven.build.timestamp} 表示项目构件开始时间\n  \n##### Maven POM 属性\n使用 pom 属性可以引用到`pom.xml`文件对应元素的值\n- ${project.build.directory} 表示主源码路径\n- ${project.build.sourceEncoding} 表示主源码的编码格式\n- ${project.build.sourceDirectory} 表示主源码路径\n- ${project.build.finalName} 表示输出文件名称\n- ${project.version} 表示项目版本,与 ${version} 相同\n\n##### Maven 自定义属性\n通过在`pom.xml`定义属性可以在其他地方引用通常在项目中用于定义引入`jar`的版本等\n``` xml\n<properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <version.spring>3.2.9.RELEASE</version.spring>\n    <version.jackson>2.4.4</version.jackson>\n    <java.version>1.7</java.version>\n    <log4j2.version>2.6.2</log4j2.version>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n</properties>\n```\n\n##### 环境变量属性\n所有的环境变量都可以用以`env.`开头的 Maven 属性引用，所有的环境变量都可以用以`env.`开头的Maven属性引用，${env.JAVA_HOME}表示JAVA_HOME环境变量的值\n\n----\n\n##### 参考如下：\nhttp://maven.apache.org/guides/introduction/introduction-to-the-pom.html\nhttp://maven.apache.org/pom.html\nhttp://maven.apache.org/settings.html","slug":"Maven 属性","published":1,"updated":"2020-08-10T01:48:44.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc983001rjsudezogmvtk","content":"<p><img src=\"/images/maven.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h5 id=\"Maven-内置属性\"><a href=\"#Maven-内置属性\" class=\"headerlink\" title=\"Maven 内置属性\"></a>Maven 内置属性</h5><p>Maven 预定义,用户可以直接使用</p>\n<ul>\n<li>${basedir} 表示项目根目录，即包含pom.xml文件目录</li>\n<li>${version} 表示项目版本</li>\n<li>${project.basedir} 同 ${basedir} </li>\n<li>${project.baseUri} 表示项目文件地址</li>\n<li>${maven.build.timestamp} 表示项目构件开始时间</li>\n</ul>\n<h5 id=\"Maven-POM-属性\"><a href=\"#Maven-POM-属性\" class=\"headerlink\" title=\"Maven POM 属性\"></a>Maven POM 属性</h5><p>使用 pom 属性可以引用到<code>pom.xml</code>文件对应元素的值</p>\n<ul>\n<li>${project.build.directory} 表示主源码路径</li>\n<li>${project.build.sourceEncoding} 表示主源码的编码格式</li>\n<li>${project.build.sourceDirectory} 表示主源码路径</li>\n<li>${project.build.finalName} 表示输出文件名称</li>\n<li>${project.version} 表示项目版本,与 ${version} 相同</li>\n</ul>\n<h5 id=\"Maven-自定义属性\"><a href=\"#Maven-自定义属性\" class=\"headerlink\" title=\"Maven 自定义属性\"></a>Maven 自定义属性</h5><p>通过在<code>pom.xml</code>定义属性可以在其他地方引用通常在项目中用于定义引入<code>jar</code>的版本等<br><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version.spring</span>&gt;</span>3.2.9.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version.spring</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version.jackson</span>&gt;</span>2.4.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version.jackson</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.7<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">log4j2.version</span>&gt;</span>2.6.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">log4j2.version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">maven.compiler.source</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">maven.compiler.source</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">maven.compiler.target</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">maven.compiler.target</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span></code></pre></p>\n<h5 id=\"环境变量属性\"><a href=\"#环境变量属性\" class=\"headerlink\" title=\"环境变量属性\"></a>环境变量属性</h5><p>所有的环境变量都可以用以<code>env.</code>开头的 Maven 属性引用，所有的环境变量都可以用以<code>env.</code>开头的Maven属性引用，${env.JAVA_HOME}表示JAVA_HOME环境变量的值</p>\n<hr>\n<h5 id=\"参考如下：\"><a href=\"#参考如下：\" class=\"headerlink\" title=\"参考如下：\"></a>参考如下：</h5><p><a href=\"http://maven.apache.org/guides/introduction/introduction-to-the-pom.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/guides/introduction/introduction-to-the-pom.html</a><br><a href=\"http://maven.apache.org/pom.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/pom.html</a><br><a href=\"http://maven.apache.org/settings.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/settings.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/maven.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h5 id=\"Maven-内置属性\"><a href=\"#Maven-内置属性\" class=\"headerlink\" title=\"Maven 内置属性\"></a>Maven 内置属性</h5><p>Maven 预定义,用户可以直接使用</p>\n<ul>\n<li>${basedir} 表示项目根目录，即包含pom.xml文件目录</li>\n<li>${version} 表示项目版本</li>\n<li>${project.basedir} 同 ${basedir} </li>\n<li>${project.baseUri} 表示项目文件地址</li>\n<li>${maven.build.timestamp} 表示项目构件开始时间</li>\n</ul>\n<h5 id=\"Maven-POM-属性\"><a href=\"#Maven-POM-属性\" class=\"headerlink\" title=\"Maven POM 属性\"></a>Maven POM 属性</h5><p>使用 pom 属性可以引用到<code>pom.xml</code>文件对应元素的值</p>\n<ul>\n<li>${project.build.directory} 表示主源码路径</li>\n<li>${project.build.sourceEncoding} 表示主源码的编码格式</li>\n<li>${project.build.sourceDirectory} 表示主源码路径</li>\n<li>${project.build.finalName} 表示输出文件名称</li>\n<li>${project.version} 表示项目版本,与 ${version} 相同</li>\n</ul>\n<h5 id=\"Maven-自定义属性\"><a href=\"#Maven-自定义属性\" class=\"headerlink\" title=\"Maven 自定义属性\"></a>Maven 自定义属性</h5><p>通过在<code>pom.xml</code>定义属性可以在其他地方引用通常在项目中用于定义引入<code>jar</code>的版本等<br><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version.spring</span>&gt;</span>3.2.9.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version.spring</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version.jackson</span>&gt;</span>2.4.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version.jackson</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.7<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">log4j2.version</span>&gt;</span>2.6.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">log4j2.version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">maven.compiler.source</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">maven.compiler.source</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">maven.compiler.target</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">maven.compiler.target</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span></code></pre></p>\n<h5 id=\"环境变量属性\"><a href=\"#环境变量属性\" class=\"headerlink\" title=\"环境变量属性\"></a>环境变量属性</h5><p>所有的环境变量都可以用以<code>env.</code>开头的 Maven 属性引用，所有的环境变量都可以用以<code>env.</code>开头的Maven属性引用，${env.JAVA_HOME}表示JAVA_HOME环境变量的值</p>\n<hr>\n<h5 id=\"参考如下：\"><a href=\"#参考如下：\" class=\"headerlink\" title=\"参考如下：\"></a>参考如下：</h5><p><a href=\"http://maven.apache.org/guides/introduction/introduction-to-the-pom.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/guides/introduction/introduction-to-the-pom.html</a><br><a href=\"http://maven.apache.org/pom.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/pom.html</a><br><a href=\"http://maven.apache.org/settings.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/settings.html</a></p>\n"},{"title":"MySql数据库索引知识","originContent":"","toc":false,"date":"2020-05-27T13:02:41.000Z","_content":"\n![](/images/MySQL.jpg)\n\n### 索引\n- 唯一索引： 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。\n- 主键索引： 特殊的唯一索引，一张表有且仅有一个主键索引，不允许为空值，提高搜索效率并提供唯一约束\n- 组合索引： 多个字段上创建的索引，注意只有在查询条件中包含了第一个字段才会使用索引，使用组合索引遵循左前缀集合\n\nhttps://www.cnblogs.com/developer_chan/p/9208404.html","source":"_posts/MySql数据库索引知识.md","raw":"---\ntitle: MySql数据库索引知识\ntags:\n  - Java\noriginContent: ''\ncategories:\n  - 数据库\ntoc: false\ndate: 2020-05-27 21:02:41\n---\n\n![](/images/MySQL.jpg)\n\n### 索引\n- 唯一索引： 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。\n- 主键索引： 特殊的唯一索引，一张表有且仅有一个主键索引，不允许为空值，提高搜索效率并提供唯一约束\n- 组合索引： 多个字段上创建的索引，注意只有在查询条件中包含了第一个字段才会使用索引，使用组合索引遵循左前缀集合\n\nhttps://www.cnblogs.com/developer_chan/p/9208404.html","slug":"MySql数据库索引知识","published":1,"updated":"2020-08-10T01:48:44.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc986001wjsudl39w530d","content":"<p><img src=\"/images/MySQL.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><ul>\n<li>唯一索引： 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li>\n<li>主键索引： 特殊的唯一索引，一张表有且仅有一个主键索引，不允许为空值，提高搜索效率并提供唯一约束</li>\n<li>组合索引： 多个字段上创建的索引，注意只有在查询条件中包含了第一个字段才会使用索引，使用组合索引遵循左前缀集合</li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/developer_chan/p/9208404.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/developer_chan/p/9208404.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/MySQL.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><ul>\n<li>唯一索引： 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li>\n<li>主键索引： 特殊的唯一索引，一张表有且仅有一个主键索引，不允许为空值，提高搜索效率并提供唯一约束</li>\n<li>组合索引： 多个字段上创建的索引，注意只有在查询条件中包含了第一个字段才会使用索引，使用组合索引遵循左前缀集合</li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/developer_chan/p/9208404.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/developer_chan/p/9208404.html</a></p>\n"},{"title":"MySQL 千行命令","date":"2019-04-01T06:31:10.000Z","_content":"![](/images/MySQL.jpg)\n\n> 转载 https://github.com/Snailclimb/JavaGuide 项目中收集的各类 MySQL 指令\n\n<!-- TOC -->\n- [基本操作](#基本操作)\n- [数据库操作](#数据库操作)\n- [表的操作](#表的操作)\n- [字符集编码](#字符集编码)\n- [数据类型(列类型)](#数据类型列类型)\n- [列属性(列约束)](#列属性列约束)\n- [建表规范](#建表规范)\n- [UNION](#UNION)\n- [子查询](#子查询)\n- [连接查询(join)](#连接查询join)\n- [TRUNCATE](#TRUNCATE)\n- [备份与还原](#备份与还原)\n- [视图](#视图)\n- [事务(transaction)](#事务transaction)\n- [锁表](#锁表)\n- [触发器](#触发器)\n- [SQL编程](#sql编程)\n- [存储过程](#存储过程)\n- [用户和权限管理](#用户和权限管理)\n- [表维护](#表维护)\n- [杂项](#杂项)\n\n<!-- /TOC -->\n\n### 基本操作\n\n``` sql\n/* Windows服务 */\n-- 启动MySQL\nnet start mysql\n-- 创建Windows服务\nsc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)\n/* 连接与断开服务器 */\nmysql -h 地址 -P 端口 -u 用户名 -p 密码\nSHOW PROCESSLIST -- 显示哪些线程正在运行\nSHOW VARIABLES -- 显示系统变量信息\n```\n\n### 数据库操作\n\n``` sql\n/* 数据库操作 */ ------------------\n-- 查看当前数据库\nSELECT DATABASE();\n-- 显示当前时间、用户名、数据库版本\nSELECT now(), user(), version();\n-- 创建库\nCREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项\n# 数据库选项：\n    CHARACTER SET charset_name\n    COLLATE collation_name\n-- 查看已有库\nSHOW DATABASES[ LIKE 'PATTERN']\n-- 查看当前库信息\nSHOW CREATE DATABASE 数据库名\n-- 修改库的选项信息\nALTER DATABASE 库名 选项信息\n-- 删除库\nDROP DATABASE[ IF EXISTS] 数据库名\n# 同时删除该数据库相关的目录及其目录内容\n```\n\n### 表的操作 \n\n``` sql\n-- 创建表\nCREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]\n    每个字段必须有数据类型\n    最后一个字段后不能有逗号\n    TEMPORARY 临时表，会话结束时表自动消失\n    对于字段的定义：\n        字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']\n            \n-- 表选项\n    -- 字符集\n        CHARSET = charset_name\n        如果表没有设定，则使用数据库字符集\n    -- 存储引擎\n        ENGINE = engine_name\n        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同\n        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive\n        不同的引擎在保存表的结构和数据时采用不同的方式\n        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引\n        InnoDB表文件含义：.frm表定义，表空间数据和日志文件\n        SHOW ENGINES -- 显示存储引擎的状态信息\n        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息\n    -- 自增起始数\n    \tAUTO_INCREMENT = 行数\n    -- 数据文件目录\n        DATA DIRECTORY = '目录'\n    -- 索引文件目录\n        INDEX DIRECTORY = '目录'\n    -- 表注释\n        COMMENT = 'string'\n    -- 分区选项\n        PARTITION BY ... (详细见手册)\n-- 查看所有表\n    SHOW TABLES[ LIKE 'pattern']\n    SHOW TABLES FROM  库名\n-- 查看表机构\n    SHOW CREATE TABLE 表名 （信息更详细）\n    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN']\n    SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern']\n-- 修改表\n    -- 修改表本身的选项\n        ALTER TABLE 表名 表的选项\n        eg: ALTER TABLE 表名 ENGINE=MYISAM;\n    -- 对表进行重命名\n        RENAME TABLE 原表名 TO 新表名\n        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）\n        -- RENAME可以交换两个表名\n    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）\n        ALTER TABLE 表名 操作名\n        -- 操作名\n            ADD[ COLUMN] 字段定义       -- 增加字段\n                AFTER 字段名          -- 表示增加在该字段名后面\n                FIRST               -- 表示增加在第一个\n            ADD PRIMARY KEY(字段名)   -- 创建主键\n            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引\n            ADD INDEX [索引名] (字段名) -- 创建普通索引\n            DROP[ COLUMN] 字段名      -- 删除字段\n            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)\n            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改\n            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)\n            DROP INDEX 索引名 -- 删除索引\n            DROP FOREIGN KEY 外键    -- 删除外键\n-- 删除表\nDROP TABLE[ IF EXISTS] 表名 ...\n-- 清空表数据\nTRUNCATE [TABLE] 表名\n-- 复制表结构\nCREATE TABLE 表名 LIKE 要复制的表名\n-- 复制表结构和数据\nCREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名\n-- 检查表是否有错误\nCHECK TABLE tbl_name [, tbl_name] ... [option] ...\n-- 优化表\nOPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\n-- 修复表\nREPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]\n-- 分析表\nANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\n```\n\n### 字符集编码\n\n``` sql\n/* 字符集编码 */ ------------------\n-- MySQL、数据库、表、字段均可设置编码\n-- 数据编码与客户端编码不需一致\nSHOW VARIABLES LIKE 'character_set_%'   -- 查看所有字符集编码项\n    character_set_client        客户端向服务器发送数据时使用的编码\n    character_set_results       服务器端将结果返回给客户端所使用的编码\n    character_set_connection    连接层编码\n    \nSET 变量名 = 变量值\n    SET character_set_client = gbk;\n    SET character_set_results = gbk;\n    SET character_set_connection = gbk;\nSET NAMES GBK;  -- 相当于完成以上三个设置\n\n-- 校对集\n    校对集用以排序\n    SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern']   查看所有字符集\n    SHOW COLLATION [LIKE 'pattern']     查看所有校对集\n    CHARSET 字符集编码     设置字符集编码\n    COLLATE 校对集编码     设置校对集编码\n```\n\n### 数据类型(列类型)\n\n``` sql\n/* 数据类型（列类型） */ ------------------\n1. 数值类型\n-- a. 整型 ----------\n    类型         字节     范围（有符号位）\n    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255\n    smallint    2字节    -32768 ~ 32767\n    mediumint   3字节    -8388608 ~ 8388607\n    int         4字节\n    bigint      8字节\n    int(M)  M表示总位数\n    - 默认存在符号位，unsigned 属性修改\n    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改\n        例：int(5)   插入一个数'123'，补填后为'00123'\n    - 在满足要求的情况下，越小越好。\n    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。\n    \n-- b. 浮点型 ----------\n    类型             字节     范围\n    float(单精度)     4字节\n    double(双精度)    8字节\n    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。\n        不同于整型，前后均会补填0.\n    定义浮点型时，需指定总位数和小数位数。\n        float(M, D)     double(M, D)\n        M表示总位数，D表示小数位数。\n        M和D的大小会决定浮点数的范围。不同于整型的固定范围。\n        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。\n        支持科学计数法表示。\n        浮点数表示近似值。\n        \n-- c. 定点数 ----------\n    decimal -- 可变长度\n    decimal(M, D)   M也表示总位数，D表示小数位数。\n    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。\n    将浮点数转换为字符串来保存，每9位数字保存为4个字节。\n    \n2. 字符串类型\n-- a. char, varchar ----------\n    char    定长字符串，速度快，但浪费空间\n    varchar 变长字符串，速度慢，但节省空间\n    M表示能存储的最大长度，此长度是字符数，非字节数。\n    不同的编码，所占用的空间不同。\n    char,最多255个字符，与编码无关。\n    varchar,最多65535字符，与编码有关。\n    一条有效记录最大不能超过65535个字节。\n        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符\n    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。\n    varchar 的最大有效长度由最大行大小和使用的字符集确定。\n    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。\n    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3\n    \n-- b. blob, text ----------\n    blob 二进制字符串（字节字符串）\n        tinyblob, blob, mediumblob, longblob\n    text 非二进制字符串（字符字符串）\n        tinytext, text, mediumtext, longtext\n    text 在定义时，不需要定义长度，也不会计算总长度。\n    text 类型在定义时，不可给default值\n    \n-- c. binary, varbinary ----------\n    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。\n    char, varchar, text 对应 binary, varbinary, blob.\n    \n3. 日期时间类型\n    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。\n    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59\n    date        3字节    日期         1000-01-01 到 9999-12-31\n    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07\n    time        3字节    时间         -838:59:59 到 838:59:59\n    year        1字节    年份         1901 - 2155\n    \n    datetime    YYYY-MM-DD hh:mm:ss\n    timestamp   YY-MM-DD hh:mm:ss\n                YYYYMMDDhhmmss\n                YYMMDDhhmmss\n                YYYYMMDDhhmmss\n                YYMMDDhhmmss\n    date        YYYY-MM-DD\n                YY-MM-DD\n                YYYYMMDD\n                YYMMDD\n                YYYYMMDD\n                YYMMDD\n    time        hh:mm:ss\n                hhmmss\n                hhmmss\n    year        YYYY\n                YY\n                YYYY\n                YY\n4. 枚举和集合\n-- 枚举(enum) ----------\nenum(val1, val2, val3...)\n    在已知的值中进行单选。最大数量为65535.\n    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。\n    表现为字符串类型，存储却是整型。\n    NULL值的索引是NULL。\n    空字符串错误值的索引值是0。\n    \n-- 集合（set） ----------\nset(val1, val2, val3...)\n    create table tab ( gender set('男', '女', '无') );\n    insert into tab values ('男, 女');\n    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。\n    当创建表时，SET成员值的尾部空格将自动被删除。\n```\n\n### 列属性(列约束)\n\n``` sql\n/* 列属性（列约束） */ ------------------\n1. PRIMARY 主键\n    - 能唯一标识记录的字段，可以作为主键。\n    - 一个表只能有一个主键。\n    - 主键具有唯一性。\n    - 声明字段时，用 primary key 标识。\n        也可以在字段列表之后声明\n            例：create table tab ( id int, stu varchar(10), primary key (id));\n    - 主键字段的值不能为null。\n    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。\n        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));\n        \n2. UNIQUE 唯一索引（唯一约束）\n    使得某字段的值也不能重复。\n    \n3. NULL 约束\n    null不是数据类型，是列的一个属性。\n    表示当前列是否可以为null，表示什么都没有。\n    null, 允许为空。默认。\n    not null, 不允许为空。\n    insert into tab values (null, 'val');\n        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null\n        \n4. DEFAULT 默认值属性\n    当前字段的默认值。\n    insert into tab values (default, 'val');    -- 此时表示强制使用默认值。\n    create table tab ( add_time timestamp default current_timestamp );\n        -- 表示将当前时间的时间戳设为默认值。\n        current_date, current_time\n        \n5. AUTO_INCREMENT 自动增长约束\n    自动增长必须为索引（主键或unique）\n    只能存在一个字段为自动增长。\n    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;\n    \n6. COMMENT 注释\n    例：create table tab ( id int ) comment '注释内容';\n    \n7. FOREIGN KEY 外键约束\n    用于限制主表与从表数据完整性。\n    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);\n        -- 将表t1的t1_id外键关联到表t2的id字段。\n        -- 每个外键都有一个名字，可以通过 constraint 指定\n    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。\n    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。\n    MySQL中，可以对InnoDB引擎使用外键约束：\n    语法：\n    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]\n    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。\n    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。\n    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：\n    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。\n    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。\n    3. restrict，拒绝父表删除和更新。\n    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。\n\n```\n\n### 建表规范\n\n``` sql\n/* 建表规范 */ ------------------\n    -- Normal Format, NF\n        - 每个表保存一个实体信息\n        - 每个具有一个ID字段作为主键\n        - ID主键 + 原子表\n        \n    -- 1NF, 第一范式\n        字段不能再分，就满足第一范式。\n        \n    -- 2NF, 第二范式\n        满足第一范式的前提下，不能出现部分依赖。\n        消除符合主键就可以避免部分依赖。增加单列关键字。\n        \n    -- 3NF, 第三范式\n        满足第二范式的前提下，不能出现传递依赖。\n        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。\n        将一个实体信息的数据放在一个表内实现。\n```\n\n### UNION\n\n``` sql\n/* UNION */ ------------------\n    将多个select查询的结果组合成一个结果集合。\n    SELECT ... UNION [ALL|DISTINCT] SELECT ...\n    默认 DISTINCT 方式，即所有返回的行都是唯一的\n    建议，对每个SELECT查询加上小括号包裹。\n    ORDER BY 排序时，需加上 LIMIT 进行结合。\n    需要各select查询的字段数量一样。\n    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。\n```\n\n### 子查询\n\n``` sql\n/* 子查询 */ ------------------\n    - 子查询需用括号包裹。\n    \n-- from型\n    from后要求是一个表，必须给子查询结果取个别名。\n    - 简化每个查询内的条件。\n    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。\n    - 子查询返回一个表，表型子查询。\n    select * from (select * from tb where id>0) as subfrom where id>1;\n    \n-- where型\n    - 子查询返回一个值，标量子查询。\n    - 不需要给子查询取别名。\n    - where子查询内的表，不能直接用以更新。\n    select * from tb where money = (select max(money) from tb);\n    \n    -- 列子查询\n        如果子查询结果返回的是一列。\n        使用 in 或 not in 完成查询\n        exists 和 not exists 条件\n            如果子查询返回数据，则返回1或0。常用于判断条件。\n            select column1 from t1 where exists (select * from t2);\n            \n    -- 行子查询\n        查询条件是一个行。\n        select * from t1 where (id, gender) in (select id, gender from t2);\n        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)\n        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。\n        \n    -- 特殊运算符\n    != all()    相当于 not in\n    = some()    相当于 in。any 是 some 的别名\n    != some()   不等同于 not in，不等于其中某一个。\n    all, some 可以配合其他运算符一起使用。\n```\n\n### 连接查询(join)\n\n``` sql\n/* 连接查询(join) */ ------------------\n    将多个表的字段进行连接，可以指定连接条件。\n    \n-- 内连接(inner join)\n    - 默认就是内连接，可省略inner。\n    - 只有数据存在时才能发送连接。即连接结果不能出现空行。\n    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）\n    也可用where表示连接条件。\n    还有 using, 但需字段名相同。 using(字段名)\n    -- 交叉连接 cross join\n        即，没有条件的内连接。\n        select * from tb1 cross join tb2;\n        \n-- 外连接(outer join)\n    - 如果数据不存在，也会出现在连接结果中。\n    -- 左外连接 left join\n        如果数据不存在，左表记录会出现，而右表为null填充\n    -- 右外连接 right join\n        如果数据不存在，右表记录会出现，而左表为null填充\n        \n-- 自然连接(natural join)\n    自动判断连接条件完成连接。\n    相当于省略了using，会自动查找相同字段名。\n    natural join\n    natural left join\n    natural right join\nselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;\n```\n\n### TRUNCATE \n\n``` sql\n/* TRUNCATE */ ------------------\nTRUNCATE [TABLE] tbl_name\n清空数据\n删除重建表\n区别：\n1，truncate 是删除表再创建，delete 是逐条删除\n2，truncate 重置auto_increment的值。而delete不会\n3，truncate 不知道删除了几条，而delete知道。\n4，当被用于带分区的表时，truncate 会保留分区\n```\n\n### 备份与还原\n\n``` sql\n/* 备份与还原 */ ------------------\n备份，将数据的结构与表内数据保存起来。\n利用 mysqldump 指令完成。\n\n-- 导出\nmysqldump [options] db_name [tables]\nmysqldump [options] ---database DB1 [DB2 DB3...]\nmysqldump [options] --all--database\n1. 导出一张表\n　　mysqldump -u用户名 -p密码 库名 表名 > 文件名(D:/a.sql)\n2. 导出多张表\n　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 > 文件名(D:/a.sql)\n3. 导出所有表\n　　mysqldump -u用户名 -p密码 库名 > 文件名(D:/a.sql)\n4. 导出一个库\n　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 > 文件名(D:/a.sql)\n可以-w携带WHERE条件\n\n-- 导入\n1. 在登录mysql的情况下：\n　　source  备份文件\n2. 在不登录的情况下\n　　mysql -u用户名 -p密码 库名 < 备份文件\n```\n\n### 视图\n\n``` sql\n什么是视图：\n    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。\n    视图具有表结构文件，但不存在数据文件。\n    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。\n    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。\n\n-- 创建视图\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement\n    - 视图名必须唯一，同时不能与表重名。\n    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。\n    - 可以指定视图执行的算法，通过ALGORITHM指定。\n    - column_list如果存在，则数目必须等于SELECT语句检索的列数\n    \n-- 查看结构\n    SHOW CREATE VIEW view_name\n    \n-- 删除视图\n    - 删除视图后，数据依然存在。\n    - 可同时删除多个视图。\n    DROP VIEW [IF EXISTS] view_name ...\n    \n-- 修改视图结构\n    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。\n    ALTER VIEW view_name [(column_list)] AS select_statement\n    \n-- 视图作用\n    1. 简化业务逻辑\n    2. 对客户端隐藏真实的表结构\n    \n-- 视图算法(ALGORITHM)\n    MERGE       合并\n        将视图的查询语句，与外部查询需要先合并再执行！\n    TEMPTABLE   临时表\n        将视图执行完毕后，形成临时表，再做外层查询！\n    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。\n```\n\n### 事务(transaction) \n\n``` sql\n事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。\n    - 支持连续SQL的集体成功或集体撤销。\n    - 事务是数据库在数据晚自习方面的一个功能。\n    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。\n    - InnoDB被称为事务安全型引擎。\n    \n-- 事务开启\n    START TRANSACTION; 或者 BEGIN;\n    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。\n    \n-- 事务提交\n    COMMIT;\n    \n-- 事务回滚\n    ROLLBACK;\n    如果部分操作发生问题，映射到事务开启前。\n    \n-- 事务的特性\n    1. 原子性（Atomicity）\n        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n    2. 一致性（Consistency）\n        事务前后数据的完整性必须保持一致。\n        - 事务开始和结束时，外部数据一致\n        - 在整个事务过程中，操作是连续的\n    3. 隔离性（Isolation）\n        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。\n    4. 持久性（Durability）\n        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。\n        \n-- 事务的实现\n    1. 要求是事务支持的表类型\n    2. 执行一组相关的操作前开启事务\n    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。\n    \n-- 事务的原理\n    利用InnoDB的自动提交(autocommit)特性完成。\n    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。\n    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。\n    \n-- 注意\n    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。\n    2. 事务不能被嵌套\n    \n-- 保存点\n    SAVEPOINT 保存点名称 -- 设置一个事务保存点\n    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点\n    RELEASE SAVEPOINT 保存点名称 -- 删除保存点\n    \n-- InnoDB自动提交特性设置\n    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。\n    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。\n    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，\n        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)\n        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)\n\n```\n\n### 锁表\n\n``` sql\n/* 锁表 */\n表锁定只用于防止其它客户端进行不正当地读取和写入\nMyISAM 支持表锁，InnoDB 支持行锁\n-- 锁定\n    LOCK TABLES tbl_name [AS alias]\n-- 解锁\n    UNLOCK TABLES\n```\n\n### 触发器\n\n``` sql\n/* 触发器 */ ------------------\n    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象\n    监听：记录的增加、修改、删除。\n    \n-- 创建触发器\nCREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt\n    参数：\n    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。\n    trigger_event指明了激活触发程序的语句的类型\n        INSERT：将新行插入表时激活触发程序\n        UPDATE：更改某一行时激活触发程序\n        DELETE：从表中删除某一行时激活触发程序\n    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。\n    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构\n    \n-- 删除\nDROP TRIGGER [schema_name.]trigger_name\n可以使用old和new代替旧的和新的数据\n    更新操作，更新前是old，更新后是new.\n    删除操作，只有old.\n    增加操作，只有new.\n-- 注意\n    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。\n    \n-- 字符连接函数\nconcat(str1,str2,...])\nconcat_ws(separator,str1,str2,...)\n-- 分支语句\nif 条件 then\n    执行语句\nelseif 条件 then\n    执行语句\nelse\n    执行语句\nend if;\n-- 修改最外层语句结束符\ndelimiter 自定义结束符号\n    SQL语句\n自定义结束符号\ndelimiter ;     -- 修改回原来的分号\n-- 语句块包裹\nbegin\n    语句块\nend\n-- 特殊的执行\n1. 只要添加记录，就会触发程序。\n2. Insert into on duplicate key update 语法会触发：\n    如果没有重复记录，会触发 before insert, after insert;\n    如果有重复记录并更新，会触发 before insert, before update, after update;\n    如果有重复记录但是没有发生更新，则触发 before insert, before update\n3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert\n```\n\n### SQL编程\n\n``` sql\n/* SQL编程 */ ------------------\n--// 局部变量 ----------\n-- 变量声明\n    declare var_name[,...] type [default value]\n    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。\n-- 赋值\n    使用 set 和 select into 语句为变量赋值。\n    - 注意：在函数内是可以使用全局变量（用户自定义的变量）\n--// 全局变量 ----------\n-- 定义、赋值\nset 语句可以定义并为变量赋值。\nset @var = value;\n也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。\n还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。\nselect @var:=20;\nselect @v1:=id, @v2=name from t1 limit 1;\nselect * from tbl_name where @var:=30;\nselect into 可以将表中查询获得的数据赋给变量。\n    -| select max(height) into @max_height from tb;\n-- 自定义变量名\n为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。\n@var=10;\n    - 变量被定义后，在整个会话周期都有效（登录到退出）\n--// 控制结构 ----------\n-- if语句\nif search_condition then\n    statement_list   \n[elseif search_condition then\n    statement_list]\n...\n[else\n    statement_list]\nend if;\n-- case语句\nCASE value WHEN [compare-value] THEN result\n[WHEN [compare-value] THEN result ...]\n[ELSE result]\nEND\n-- while循环\n[begin_label:] while search_condition do\n    statement_list\nend while [end_label];\n- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。\n    -- 退出循环\n        退出整个循环 leave\n        退出当前循环 iterate\n        通过退出的标签决定退出哪个循环\n--// 内置函数 ----------\n-- 数值函数\nabs(x)          -- 绝对值 abs(-10.9) = 10\nformat(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46\nceil(x)         -- 向上取整 ceil(10.1) = 11\nfloor(x)        -- 向下取整 floor (10.1) = 10\nround(x)        -- 四舍五入去整\nmod(m, n)       -- m%n m mod n 求余 10%3=1\npi()            -- 获得圆周率\npow(m, n)       -- m^n\nsqrt(x)         -- 算术平方根\nrand()          -- 随机数\ntruncate(x, d)  -- 截取d位小数\n-- 时间日期函数\nnow(), current_timestamp();     -- 当前日期时间\ncurrent_date();                 -- 当前日期\ncurrent_time();                 -- 当前时间\ndate('yyyy-mm-dd hh:ii:ss');    -- 获取日期部分\ntime('yyyy-mm-dd hh:ii:ss');    -- 获取时间部分\ndate_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间\nunix_timestamp();               -- 获得unix时间戳\nfrom_unixtime();                -- 从时间戳获得时间\n-- 字符串函数\nlength(string)          -- string长度，字节\nchar_length(string)     -- string的字符个数\nsubstring(str, position [,length])      -- 从str的position开始,取length个字符\nreplace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str\ninstr(string ,substring)    -- 返回substring首次在string中出现的位置\nconcat(string [,...])   -- 连接字串\ncharset(str)            -- 返回字串字符集\nlcase(string)           -- 转换成小写\nleft(string, length)    -- 从string2中的左边起取length个字符\nload_file(file_name)    -- 从文件读取内容\nlocate(substring, string [,start_position]) -- 同instr,但可指定开始位置\nlpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length\nltrim(string)           -- 去除前端空格\nrepeat(string, count)   -- 重复count次\nrpad(string, length, pad)   --在str后用pad补充,直到长度为length\nrtrim(string)           -- 去除后端空格\nstrcmp(string1 ,string2)    -- 逐字符比较两字串大小\n-- 流程函数\ncase when [condition] then result [when [condition] then result ...] [else result] end   多分支\nif(expr1,expr2,expr3)  双分支。\n-- 聚合函数\ncount()\nsum();\nmax();\nmin();\navg();\ngroup_concat()\n-- 其他常用函数\nmd5();\ndefault();\n--// 存储函数，自定义函数 ----------\n-- 新建\n    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型\n        函数体\n    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。\n    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。\n    - 参数部分，由\"参数名\"和\"参数类型\"组成。多个参数用逗号隔开。\n    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。\n    - 多条语句应该使用 begin...end 语句块包含。\n    - 一定要有 return 返回值语句。\n-- 删除\n    DROP FUNCTION [IF EXISTS] function_name;\n-- 查看\n    SHOW FUNCTION STATUS LIKE 'partten'\n    SHOW CREATE FUNCTION function_name;\n-- 修改\n    ALTER FUNCTION function_name 函数选项\n--// 存储过程，自定义功能 ----------\n-- 定义\n存储存储过程 是一段代码（过程），存储在数据库中的sql组成。\n一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。\n而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。\n-- 创建\nCREATE PROCEDURE sp_name (参数列表)\n    过程体\n参数列表：不同于函数的参数列表，需要指明参数类型\nIN，表示输入型\nOUT，表示输出型\nINOUT，表示混合型\n注意，没有返回值。\n```\n\n### 存储过程\n\n``` sql\n/* 存储过程 */ ------------------\n存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。\n调用：CALL 过程名\n-- 注意\n- 没有返回值。\n- 只能单独调用，不可夹杂在其他语句中\n-- 参数\nIN|OUT|INOUT 参数名 数据类型\nIN      输入：在调用过程中，将数据输入到过程体内部的参数\nOUT     输出：在调用过程中，将过程体处理完的结果返回到客户端\nINOUT   输入输出：既可输入，也可输出\n-- 语法\nCREATE PROCEDURE 过程名 (参数列表)\nBEGIN\n    过程体\nEND\n```\n\n### 用户和权限管理\n\n``` sql\n/* 用户和权限管理 */ ------------------\n-- root密码重置\n1. 停止MySQL服务\n2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &\n    [Windows] mysqld --skip-grant-tables\n3. use mysql;\n4. UPDATE `user` SET PASSWORD=PASSWORD(\"密码\") WHERE `user` = \"root\";\n5. FLUSH PRIVILEGES;\n用户信息表：mysql.user\n-- 刷新权限\nFLUSH PRIVILEGES;\n-- 增加用户\nCREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)\n    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。\n    - 只能创建用户，不能赋予权限。\n    - 用户名，注意引号：如 'user_name'@'192.168.1.1'\n    - 密码也需引号，纯数字密码也要加引号\n    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD\n-- 重命名用户\nRENAME USER old_user TO new_user\n-- 设置密码\nSET PASSWORD = PASSWORD('密码')  -- 为当前用户设置密码\nSET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码\n-- 删除用户\nDROP USER 用户名\n-- 分配权限/添加用户\nGRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password']\n    - all privileges 表示所有权限\n    - *.* 表示所有库的所有表\n    - 库名.表名 表示某库下面的某表\n    GRANT ALL PRIVILEGES ON `pms`.* TO 'pms'@'%' IDENTIFIED BY 'pms0817';\n-- 查看权限\nSHOW GRANTS FOR 用户名\n    -- 查看当前用户权限\n    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();\n-- 撤消权限\nREVOKE 权限列表 ON 表名 FROM 用户名\nREVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限\n-- 权限层级\n-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。\n全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user\n    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。\n数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host\n    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。\n表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv\n    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。\n列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv\n    当使用REVOKE时，您必须指定与被授权列相同的列。\n-- 权限列表\nALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限\nALTER   -- 允许使用ALTER TABLE\nALTER ROUTINE   -- 更改或取消已存储的子程序\nCREATE  -- 允许使用CREATE TABLE\nCREATE ROUTINE  -- 创建已存储的子程序\nCREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE\nCREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。\nCREATE VIEW     -- 允许使用CREATE VIEW\nDELETE  -- 允许使用DELETE\nDROP    -- 允许使用DROP TABLE\nEXECUTE     -- 允许用户运行已存储的子程序\nFILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE\nINDEX   -- 允许使用CREATE INDEX和DROP INDEX\nINSERT  -- 允许使用INSERT\nLOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES\n```\n","source":"_posts/MySQL千行命令.md","raw":"---\ntitle: MySQL 千行命令\ndate: 2019-04-01 14:31:10\ncategories: [Java]\ntags:\n\t- 数据库\n\t- 文档\n---\n![](/images/MySQL.jpg)\n\n> 转载 https://github.com/Snailclimb/JavaGuide 项目中收集的各类 MySQL 指令\n\n<!-- TOC -->\n- [基本操作](#基本操作)\n- [数据库操作](#数据库操作)\n- [表的操作](#表的操作)\n- [字符集编码](#字符集编码)\n- [数据类型(列类型)](#数据类型列类型)\n- [列属性(列约束)](#列属性列约束)\n- [建表规范](#建表规范)\n- [UNION](#UNION)\n- [子查询](#子查询)\n- [连接查询(join)](#连接查询join)\n- [TRUNCATE](#TRUNCATE)\n- [备份与还原](#备份与还原)\n- [视图](#视图)\n- [事务(transaction)](#事务transaction)\n- [锁表](#锁表)\n- [触发器](#触发器)\n- [SQL编程](#sql编程)\n- [存储过程](#存储过程)\n- [用户和权限管理](#用户和权限管理)\n- [表维护](#表维护)\n- [杂项](#杂项)\n\n<!-- /TOC -->\n\n### 基本操作\n\n``` sql\n/* Windows服务 */\n-- 启动MySQL\nnet start mysql\n-- 创建Windows服务\nsc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)\n/* 连接与断开服务器 */\nmysql -h 地址 -P 端口 -u 用户名 -p 密码\nSHOW PROCESSLIST -- 显示哪些线程正在运行\nSHOW VARIABLES -- 显示系统变量信息\n```\n\n### 数据库操作\n\n``` sql\n/* 数据库操作 */ ------------------\n-- 查看当前数据库\nSELECT DATABASE();\n-- 显示当前时间、用户名、数据库版本\nSELECT now(), user(), version();\n-- 创建库\nCREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项\n# 数据库选项：\n    CHARACTER SET charset_name\n    COLLATE collation_name\n-- 查看已有库\nSHOW DATABASES[ LIKE 'PATTERN']\n-- 查看当前库信息\nSHOW CREATE DATABASE 数据库名\n-- 修改库的选项信息\nALTER DATABASE 库名 选项信息\n-- 删除库\nDROP DATABASE[ IF EXISTS] 数据库名\n# 同时删除该数据库相关的目录及其目录内容\n```\n\n### 表的操作 \n\n``` sql\n-- 创建表\nCREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]\n    每个字段必须有数据类型\n    最后一个字段后不能有逗号\n    TEMPORARY 临时表，会话结束时表自动消失\n    对于字段的定义：\n        字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']\n            \n-- 表选项\n    -- 字符集\n        CHARSET = charset_name\n        如果表没有设定，则使用数据库字符集\n    -- 存储引擎\n        ENGINE = engine_name\n        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同\n        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive\n        不同的引擎在保存表的结构和数据时采用不同的方式\n        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引\n        InnoDB表文件含义：.frm表定义，表空间数据和日志文件\n        SHOW ENGINES -- 显示存储引擎的状态信息\n        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息\n    -- 自增起始数\n    \tAUTO_INCREMENT = 行数\n    -- 数据文件目录\n        DATA DIRECTORY = '目录'\n    -- 索引文件目录\n        INDEX DIRECTORY = '目录'\n    -- 表注释\n        COMMENT = 'string'\n    -- 分区选项\n        PARTITION BY ... (详细见手册)\n-- 查看所有表\n    SHOW TABLES[ LIKE 'pattern']\n    SHOW TABLES FROM  库名\n-- 查看表机构\n    SHOW CREATE TABLE 表名 （信息更详细）\n    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN']\n    SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern']\n-- 修改表\n    -- 修改表本身的选项\n        ALTER TABLE 表名 表的选项\n        eg: ALTER TABLE 表名 ENGINE=MYISAM;\n    -- 对表进行重命名\n        RENAME TABLE 原表名 TO 新表名\n        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）\n        -- RENAME可以交换两个表名\n    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）\n        ALTER TABLE 表名 操作名\n        -- 操作名\n            ADD[ COLUMN] 字段定义       -- 增加字段\n                AFTER 字段名          -- 表示增加在该字段名后面\n                FIRST               -- 表示增加在第一个\n            ADD PRIMARY KEY(字段名)   -- 创建主键\n            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引\n            ADD INDEX [索引名] (字段名) -- 创建普通索引\n            DROP[ COLUMN] 字段名      -- 删除字段\n            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)\n            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改\n            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)\n            DROP INDEX 索引名 -- 删除索引\n            DROP FOREIGN KEY 外键    -- 删除外键\n-- 删除表\nDROP TABLE[ IF EXISTS] 表名 ...\n-- 清空表数据\nTRUNCATE [TABLE] 表名\n-- 复制表结构\nCREATE TABLE 表名 LIKE 要复制的表名\n-- 复制表结构和数据\nCREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名\n-- 检查表是否有错误\nCHECK TABLE tbl_name [, tbl_name] ... [option] ...\n-- 优化表\nOPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\n-- 修复表\nREPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]\n-- 分析表\nANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\n```\n\n### 字符集编码\n\n``` sql\n/* 字符集编码 */ ------------------\n-- MySQL、数据库、表、字段均可设置编码\n-- 数据编码与客户端编码不需一致\nSHOW VARIABLES LIKE 'character_set_%'   -- 查看所有字符集编码项\n    character_set_client        客户端向服务器发送数据时使用的编码\n    character_set_results       服务器端将结果返回给客户端所使用的编码\n    character_set_connection    连接层编码\n    \nSET 变量名 = 变量值\n    SET character_set_client = gbk;\n    SET character_set_results = gbk;\n    SET character_set_connection = gbk;\nSET NAMES GBK;  -- 相当于完成以上三个设置\n\n-- 校对集\n    校对集用以排序\n    SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern']   查看所有字符集\n    SHOW COLLATION [LIKE 'pattern']     查看所有校对集\n    CHARSET 字符集编码     设置字符集编码\n    COLLATE 校对集编码     设置校对集编码\n```\n\n### 数据类型(列类型)\n\n``` sql\n/* 数据类型（列类型） */ ------------------\n1. 数值类型\n-- a. 整型 ----------\n    类型         字节     范围（有符号位）\n    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255\n    smallint    2字节    -32768 ~ 32767\n    mediumint   3字节    -8388608 ~ 8388607\n    int         4字节\n    bigint      8字节\n    int(M)  M表示总位数\n    - 默认存在符号位，unsigned 属性修改\n    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改\n        例：int(5)   插入一个数'123'，补填后为'00123'\n    - 在满足要求的情况下，越小越好。\n    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。\n    \n-- b. 浮点型 ----------\n    类型             字节     范围\n    float(单精度)     4字节\n    double(双精度)    8字节\n    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。\n        不同于整型，前后均会补填0.\n    定义浮点型时，需指定总位数和小数位数。\n        float(M, D)     double(M, D)\n        M表示总位数，D表示小数位数。\n        M和D的大小会决定浮点数的范围。不同于整型的固定范围。\n        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。\n        支持科学计数法表示。\n        浮点数表示近似值。\n        \n-- c. 定点数 ----------\n    decimal -- 可变长度\n    decimal(M, D)   M也表示总位数，D表示小数位数。\n    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。\n    将浮点数转换为字符串来保存，每9位数字保存为4个字节。\n    \n2. 字符串类型\n-- a. char, varchar ----------\n    char    定长字符串，速度快，但浪费空间\n    varchar 变长字符串，速度慢，但节省空间\n    M表示能存储的最大长度，此长度是字符数，非字节数。\n    不同的编码，所占用的空间不同。\n    char,最多255个字符，与编码无关。\n    varchar,最多65535字符，与编码有关。\n    一条有效记录最大不能超过65535个字节。\n        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符\n    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。\n    varchar 的最大有效长度由最大行大小和使用的字符集确定。\n    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。\n    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3\n    \n-- b. blob, text ----------\n    blob 二进制字符串（字节字符串）\n        tinyblob, blob, mediumblob, longblob\n    text 非二进制字符串（字符字符串）\n        tinytext, text, mediumtext, longtext\n    text 在定义时，不需要定义长度，也不会计算总长度。\n    text 类型在定义时，不可给default值\n    \n-- c. binary, varbinary ----------\n    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。\n    char, varchar, text 对应 binary, varbinary, blob.\n    \n3. 日期时间类型\n    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。\n    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59\n    date        3字节    日期         1000-01-01 到 9999-12-31\n    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07\n    time        3字节    时间         -838:59:59 到 838:59:59\n    year        1字节    年份         1901 - 2155\n    \n    datetime    YYYY-MM-DD hh:mm:ss\n    timestamp   YY-MM-DD hh:mm:ss\n                YYYYMMDDhhmmss\n                YYMMDDhhmmss\n                YYYYMMDDhhmmss\n                YYMMDDhhmmss\n    date        YYYY-MM-DD\n                YY-MM-DD\n                YYYYMMDD\n                YYMMDD\n                YYYYMMDD\n                YYMMDD\n    time        hh:mm:ss\n                hhmmss\n                hhmmss\n    year        YYYY\n                YY\n                YYYY\n                YY\n4. 枚举和集合\n-- 枚举(enum) ----------\nenum(val1, val2, val3...)\n    在已知的值中进行单选。最大数量为65535.\n    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。\n    表现为字符串类型，存储却是整型。\n    NULL值的索引是NULL。\n    空字符串错误值的索引值是0。\n    \n-- 集合（set） ----------\nset(val1, val2, val3...)\n    create table tab ( gender set('男', '女', '无') );\n    insert into tab values ('男, 女');\n    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。\n    当创建表时，SET成员值的尾部空格将自动被删除。\n```\n\n### 列属性(列约束)\n\n``` sql\n/* 列属性（列约束） */ ------------------\n1. PRIMARY 主键\n    - 能唯一标识记录的字段，可以作为主键。\n    - 一个表只能有一个主键。\n    - 主键具有唯一性。\n    - 声明字段时，用 primary key 标识。\n        也可以在字段列表之后声明\n            例：create table tab ( id int, stu varchar(10), primary key (id));\n    - 主键字段的值不能为null。\n    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。\n        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));\n        \n2. UNIQUE 唯一索引（唯一约束）\n    使得某字段的值也不能重复。\n    \n3. NULL 约束\n    null不是数据类型，是列的一个属性。\n    表示当前列是否可以为null，表示什么都没有。\n    null, 允许为空。默认。\n    not null, 不允许为空。\n    insert into tab values (null, 'val');\n        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null\n        \n4. DEFAULT 默认值属性\n    当前字段的默认值。\n    insert into tab values (default, 'val');    -- 此时表示强制使用默认值。\n    create table tab ( add_time timestamp default current_timestamp );\n        -- 表示将当前时间的时间戳设为默认值。\n        current_date, current_time\n        \n5. AUTO_INCREMENT 自动增长约束\n    自动增长必须为索引（主键或unique）\n    只能存在一个字段为自动增长。\n    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;\n    \n6. COMMENT 注释\n    例：create table tab ( id int ) comment '注释内容';\n    \n7. FOREIGN KEY 外键约束\n    用于限制主表与从表数据完整性。\n    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);\n        -- 将表t1的t1_id外键关联到表t2的id字段。\n        -- 每个外键都有一个名字，可以通过 constraint 指定\n    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。\n    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。\n    MySQL中，可以对InnoDB引擎使用外键约束：\n    语法：\n    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]\n    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。\n    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。\n    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：\n    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。\n    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。\n    3. restrict，拒绝父表删除和更新。\n    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。\n\n```\n\n### 建表规范\n\n``` sql\n/* 建表规范 */ ------------------\n    -- Normal Format, NF\n        - 每个表保存一个实体信息\n        - 每个具有一个ID字段作为主键\n        - ID主键 + 原子表\n        \n    -- 1NF, 第一范式\n        字段不能再分，就满足第一范式。\n        \n    -- 2NF, 第二范式\n        满足第一范式的前提下，不能出现部分依赖。\n        消除符合主键就可以避免部分依赖。增加单列关键字。\n        \n    -- 3NF, 第三范式\n        满足第二范式的前提下，不能出现传递依赖。\n        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。\n        将一个实体信息的数据放在一个表内实现。\n```\n\n### UNION\n\n``` sql\n/* UNION */ ------------------\n    将多个select查询的结果组合成一个结果集合。\n    SELECT ... UNION [ALL|DISTINCT] SELECT ...\n    默认 DISTINCT 方式，即所有返回的行都是唯一的\n    建议，对每个SELECT查询加上小括号包裹。\n    ORDER BY 排序时，需加上 LIMIT 进行结合。\n    需要各select查询的字段数量一样。\n    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。\n```\n\n### 子查询\n\n``` sql\n/* 子查询 */ ------------------\n    - 子查询需用括号包裹。\n    \n-- from型\n    from后要求是一个表，必须给子查询结果取个别名。\n    - 简化每个查询内的条件。\n    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。\n    - 子查询返回一个表，表型子查询。\n    select * from (select * from tb where id>0) as subfrom where id>1;\n    \n-- where型\n    - 子查询返回一个值，标量子查询。\n    - 不需要给子查询取别名。\n    - where子查询内的表，不能直接用以更新。\n    select * from tb where money = (select max(money) from tb);\n    \n    -- 列子查询\n        如果子查询结果返回的是一列。\n        使用 in 或 not in 完成查询\n        exists 和 not exists 条件\n            如果子查询返回数据，则返回1或0。常用于判断条件。\n            select column1 from t1 where exists (select * from t2);\n            \n    -- 行子查询\n        查询条件是一个行。\n        select * from t1 where (id, gender) in (select id, gender from t2);\n        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)\n        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。\n        \n    -- 特殊运算符\n    != all()    相当于 not in\n    = some()    相当于 in。any 是 some 的别名\n    != some()   不等同于 not in，不等于其中某一个。\n    all, some 可以配合其他运算符一起使用。\n```\n\n### 连接查询(join)\n\n``` sql\n/* 连接查询(join) */ ------------------\n    将多个表的字段进行连接，可以指定连接条件。\n    \n-- 内连接(inner join)\n    - 默认就是内连接，可省略inner。\n    - 只有数据存在时才能发送连接。即连接结果不能出现空行。\n    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）\n    也可用where表示连接条件。\n    还有 using, 但需字段名相同。 using(字段名)\n    -- 交叉连接 cross join\n        即，没有条件的内连接。\n        select * from tb1 cross join tb2;\n        \n-- 外连接(outer join)\n    - 如果数据不存在，也会出现在连接结果中。\n    -- 左外连接 left join\n        如果数据不存在，左表记录会出现，而右表为null填充\n    -- 右外连接 right join\n        如果数据不存在，右表记录会出现，而左表为null填充\n        \n-- 自然连接(natural join)\n    自动判断连接条件完成连接。\n    相当于省略了using，会自动查找相同字段名。\n    natural join\n    natural left join\n    natural right join\nselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;\n```\n\n### TRUNCATE \n\n``` sql\n/* TRUNCATE */ ------------------\nTRUNCATE [TABLE] tbl_name\n清空数据\n删除重建表\n区别：\n1，truncate 是删除表再创建，delete 是逐条删除\n2，truncate 重置auto_increment的值。而delete不会\n3，truncate 不知道删除了几条，而delete知道。\n4，当被用于带分区的表时，truncate 会保留分区\n```\n\n### 备份与还原\n\n``` sql\n/* 备份与还原 */ ------------------\n备份，将数据的结构与表内数据保存起来。\n利用 mysqldump 指令完成。\n\n-- 导出\nmysqldump [options] db_name [tables]\nmysqldump [options] ---database DB1 [DB2 DB3...]\nmysqldump [options] --all--database\n1. 导出一张表\n　　mysqldump -u用户名 -p密码 库名 表名 > 文件名(D:/a.sql)\n2. 导出多张表\n　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 > 文件名(D:/a.sql)\n3. 导出所有表\n　　mysqldump -u用户名 -p密码 库名 > 文件名(D:/a.sql)\n4. 导出一个库\n　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 > 文件名(D:/a.sql)\n可以-w携带WHERE条件\n\n-- 导入\n1. 在登录mysql的情况下：\n　　source  备份文件\n2. 在不登录的情况下\n　　mysql -u用户名 -p密码 库名 < 备份文件\n```\n\n### 视图\n\n``` sql\n什么是视图：\n    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。\n    视图具有表结构文件，但不存在数据文件。\n    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。\n    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。\n\n-- 创建视图\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement\n    - 视图名必须唯一，同时不能与表重名。\n    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。\n    - 可以指定视图执行的算法，通过ALGORITHM指定。\n    - column_list如果存在，则数目必须等于SELECT语句检索的列数\n    \n-- 查看结构\n    SHOW CREATE VIEW view_name\n    \n-- 删除视图\n    - 删除视图后，数据依然存在。\n    - 可同时删除多个视图。\n    DROP VIEW [IF EXISTS] view_name ...\n    \n-- 修改视图结构\n    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。\n    ALTER VIEW view_name [(column_list)] AS select_statement\n    \n-- 视图作用\n    1. 简化业务逻辑\n    2. 对客户端隐藏真实的表结构\n    \n-- 视图算法(ALGORITHM)\n    MERGE       合并\n        将视图的查询语句，与外部查询需要先合并再执行！\n    TEMPTABLE   临时表\n        将视图执行完毕后，形成临时表，再做外层查询！\n    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。\n```\n\n### 事务(transaction) \n\n``` sql\n事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。\n    - 支持连续SQL的集体成功或集体撤销。\n    - 事务是数据库在数据晚自习方面的一个功能。\n    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。\n    - InnoDB被称为事务安全型引擎。\n    \n-- 事务开启\n    START TRANSACTION; 或者 BEGIN;\n    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。\n    \n-- 事务提交\n    COMMIT;\n    \n-- 事务回滚\n    ROLLBACK;\n    如果部分操作发生问题，映射到事务开启前。\n    \n-- 事务的特性\n    1. 原子性（Atomicity）\n        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n    2. 一致性（Consistency）\n        事务前后数据的完整性必须保持一致。\n        - 事务开始和结束时，外部数据一致\n        - 在整个事务过程中，操作是连续的\n    3. 隔离性（Isolation）\n        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。\n    4. 持久性（Durability）\n        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。\n        \n-- 事务的实现\n    1. 要求是事务支持的表类型\n    2. 执行一组相关的操作前开启事务\n    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。\n    \n-- 事务的原理\n    利用InnoDB的自动提交(autocommit)特性完成。\n    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。\n    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。\n    \n-- 注意\n    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。\n    2. 事务不能被嵌套\n    \n-- 保存点\n    SAVEPOINT 保存点名称 -- 设置一个事务保存点\n    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点\n    RELEASE SAVEPOINT 保存点名称 -- 删除保存点\n    \n-- InnoDB自动提交特性设置\n    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。\n    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。\n    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，\n        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)\n        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)\n\n```\n\n### 锁表\n\n``` sql\n/* 锁表 */\n表锁定只用于防止其它客户端进行不正当地读取和写入\nMyISAM 支持表锁，InnoDB 支持行锁\n-- 锁定\n    LOCK TABLES tbl_name [AS alias]\n-- 解锁\n    UNLOCK TABLES\n```\n\n### 触发器\n\n``` sql\n/* 触发器 */ ------------------\n    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象\n    监听：记录的增加、修改、删除。\n    \n-- 创建触发器\nCREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt\n    参数：\n    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。\n    trigger_event指明了激活触发程序的语句的类型\n        INSERT：将新行插入表时激活触发程序\n        UPDATE：更改某一行时激活触发程序\n        DELETE：从表中删除某一行时激活触发程序\n    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。\n    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构\n    \n-- 删除\nDROP TRIGGER [schema_name.]trigger_name\n可以使用old和new代替旧的和新的数据\n    更新操作，更新前是old，更新后是new.\n    删除操作，只有old.\n    增加操作，只有new.\n-- 注意\n    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。\n    \n-- 字符连接函数\nconcat(str1,str2,...])\nconcat_ws(separator,str1,str2,...)\n-- 分支语句\nif 条件 then\n    执行语句\nelseif 条件 then\n    执行语句\nelse\n    执行语句\nend if;\n-- 修改最外层语句结束符\ndelimiter 自定义结束符号\n    SQL语句\n自定义结束符号\ndelimiter ;     -- 修改回原来的分号\n-- 语句块包裹\nbegin\n    语句块\nend\n-- 特殊的执行\n1. 只要添加记录，就会触发程序。\n2. Insert into on duplicate key update 语法会触发：\n    如果没有重复记录，会触发 before insert, after insert;\n    如果有重复记录并更新，会触发 before insert, before update, after update;\n    如果有重复记录但是没有发生更新，则触发 before insert, before update\n3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert\n```\n\n### SQL编程\n\n``` sql\n/* SQL编程 */ ------------------\n--// 局部变量 ----------\n-- 变量声明\n    declare var_name[,...] type [default value]\n    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。\n-- 赋值\n    使用 set 和 select into 语句为变量赋值。\n    - 注意：在函数内是可以使用全局变量（用户自定义的变量）\n--// 全局变量 ----------\n-- 定义、赋值\nset 语句可以定义并为变量赋值。\nset @var = value;\n也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。\n还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。\nselect @var:=20;\nselect @v1:=id, @v2=name from t1 limit 1;\nselect * from tbl_name where @var:=30;\nselect into 可以将表中查询获得的数据赋给变量。\n    -| select max(height) into @max_height from tb;\n-- 自定义变量名\n为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。\n@var=10;\n    - 变量被定义后，在整个会话周期都有效（登录到退出）\n--// 控制结构 ----------\n-- if语句\nif search_condition then\n    statement_list   \n[elseif search_condition then\n    statement_list]\n...\n[else\n    statement_list]\nend if;\n-- case语句\nCASE value WHEN [compare-value] THEN result\n[WHEN [compare-value] THEN result ...]\n[ELSE result]\nEND\n-- while循环\n[begin_label:] while search_condition do\n    statement_list\nend while [end_label];\n- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。\n    -- 退出循环\n        退出整个循环 leave\n        退出当前循环 iterate\n        通过退出的标签决定退出哪个循环\n--// 内置函数 ----------\n-- 数值函数\nabs(x)          -- 绝对值 abs(-10.9) = 10\nformat(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46\nceil(x)         -- 向上取整 ceil(10.1) = 11\nfloor(x)        -- 向下取整 floor (10.1) = 10\nround(x)        -- 四舍五入去整\nmod(m, n)       -- m%n m mod n 求余 10%3=1\npi()            -- 获得圆周率\npow(m, n)       -- m^n\nsqrt(x)         -- 算术平方根\nrand()          -- 随机数\ntruncate(x, d)  -- 截取d位小数\n-- 时间日期函数\nnow(), current_timestamp();     -- 当前日期时间\ncurrent_date();                 -- 当前日期\ncurrent_time();                 -- 当前时间\ndate('yyyy-mm-dd hh:ii:ss');    -- 获取日期部分\ntime('yyyy-mm-dd hh:ii:ss');    -- 获取时间部分\ndate_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间\nunix_timestamp();               -- 获得unix时间戳\nfrom_unixtime();                -- 从时间戳获得时间\n-- 字符串函数\nlength(string)          -- string长度，字节\nchar_length(string)     -- string的字符个数\nsubstring(str, position [,length])      -- 从str的position开始,取length个字符\nreplace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str\ninstr(string ,substring)    -- 返回substring首次在string中出现的位置\nconcat(string [,...])   -- 连接字串\ncharset(str)            -- 返回字串字符集\nlcase(string)           -- 转换成小写\nleft(string, length)    -- 从string2中的左边起取length个字符\nload_file(file_name)    -- 从文件读取内容\nlocate(substring, string [,start_position]) -- 同instr,但可指定开始位置\nlpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length\nltrim(string)           -- 去除前端空格\nrepeat(string, count)   -- 重复count次\nrpad(string, length, pad)   --在str后用pad补充,直到长度为length\nrtrim(string)           -- 去除后端空格\nstrcmp(string1 ,string2)    -- 逐字符比较两字串大小\n-- 流程函数\ncase when [condition] then result [when [condition] then result ...] [else result] end   多分支\nif(expr1,expr2,expr3)  双分支。\n-- 聚合函数\ncount()\nsum();\nmax();\nmin();\navg();\ngroup_concat()\n-- 其他常用函数\nmd5();\ndefault();\n--// 存储函数，自定义函数 ----------\n-- 新建\n    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型\n        函数体\n    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。\n    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。\n    - 参数部分，由\"参数名\"和\"参数类型\"组成。多个参数用逗号隔开。\n    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。\n    - 多条语句应该使用 begin...end 语句块包含。\n    - 一定要有 return 返回值语句。\n-- 删除\n    DROP FUNCTION [IF EXISTS] function_name;\n-- 查看\n    SHOW FUNCTION STATUS LIKE 'partten'\n    SHOW CREATE FUNCTION function_name;\n-- 修改\n    ALTER FUNCTION function_name 函数选项\n--// 存储过程，自定义功能 ----------\n-- 定义\n存储存储过程 是一段代码（过程），存储在数据库中的sql组成。\n一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。\n而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。\n-- 创建\nCREATE PROCEDURE sp_name (参数列表)\n    过程体\n参数列表：不同于函数的参数列表，需要指明参数类型\nIN，表示输入型\nOUT，表示输出型\nINOUT，表示混合型\n注意，没有返回值。\n```\n\n### 存储过程\n\n``` sql\n/* 存储过程 */ ------------------\n存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。\n调用：CALL 过程名\n-- 注意\n- 没有返回值。\n- 只能单独调用，不可夹杂在其他语句中\n-- 参数\nIN|OUT|INOUT 参数名 数据类型\nIN      输入：在调用过程中，将数据输入到过程体内部的参数\nOUT     输出：在调用过程中，将过程体处理完的结果返回到客户端\nINOUT   输入输出：既可输入，也可输出\n-- 语法\nCREATE PROCEDURE 过程名 (参数列表)\nBEGIN\n    过程体\nEND\n```\n\n### 用户和权限管理\n\n``` sql\n/* 用户和权限管理 */ ------------------\n-- root密码重置\n1. 停止MySQL服务\n2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &\n    [Windows] mysqld --skip-grant-tables\n3. use mysql;\n4. UPDATE `user` SET PASSWORD=PASSWORD(\"密码\") WHERE `user` = \"root\";\n5. FLUSH PRIVILEGES;\n用户信息表：mysql.user\n-- 刷新权限\nFLUSH PRIVILEGES;\n-- 增加用户\nCREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)\n    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。\n    - 只能创建用户，不能赋予权限。\n    - 用户名，注意引号：如 'user_name'@'192.168.1.1'\n    - 密码也需引号，纯数字密码也要加引号\n    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD\n-- 重命名用户\nRENAME USER old_user TO new_user\n-- 设置密码\nSET PASSWORD = PASSWORD('密码')  -- 为当前用户设置密码\nSET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码\n-- 删除用户\nDROP USER 用户名\n-- 分配权限/添加用户\nGRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password']\n    - all privileges 表示所有权限\n    - *.* 表示所有库的所有表\n    - 库名.表名 表示某库下面的某表\n    GRANT ALL PRIVILEGES ON `pms`.* TO 'pms'@'%' IDENTIFIED BY 'pms0817';\n-- 查看权限\nSHOW GRANTS FOR 用户名\n    -- 查看当前用户权限\n    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();\n-- 撤消权限\nREVOKE 权限列表 ON 表名 FROM 用户名\nREVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限\n-- 权限层级\n-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。\n全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user\n    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。\n数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host\n    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。\n表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv\n    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。\n列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv\n    当使用REVOKE时，您必须指定与被授权列相同的列。\n-- 权限列表\nALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限\nALTER   -- 允许使用ALTER TABLE\nALTER ROUTINE   -- 更改或取消已存储的子程序\nCREATE  -- 允许使用CREATE TABLE\nCREATE ROUTINE  -- 创建已存储的子程序\nCREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE\nCREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。\nCREATE VIEW     -- 允许使用CREATE VIEW\nDELETE  -- 允许使用DELETE\nDROP    -- 允许使用DROP TABLE\nEXECUTE     -- 允许用户运行已存储的子程序\nFILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE\nINDEX   -- 允许使用CREATE INDEX和DROP INDEX\nINSERT  -- 允许使用INSERT\nLOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES\n```\n","slug":"MySQL千行命令","published":1,"updated":"2020-08-10T01:48:44.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc988001zjsudpy6csg3m","content":"<p><img src=\"/images/MySQL.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>转载 <a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide</a> 项目中收集的各类 MySQL 指令</p>\n</blockquote>\n<!-- TOC -->\n<ul>\n<li><a href=\"#基本操作\">基本操作</a></li>\n<li><a href=\"#数据库操作\">数据库操作</a></li>\n<li><a href=\"#表的操作\">表的操作</a></li>\n<li><a href=\"#字符集编码\">字符集编码</a></li>\n<li><a href=\"#数据类型列类型\">数据类型(列类型)</a></li>\n<li><a href=\"#列属性列约束\">列属性(列约束)</a></li>\n<li><a href=\"#建表规范\">建表规范</a></li>\n<li><a href=\"#UNION\">UNION</a></li>\n<li><a href=\"#子查询\">子查询</a></li>\n<li><a href=\"#连接查询join\">连接查询(join)</a></li>\n<li><a href=\"#TRUNCATE\">TRUNCATE</a></li>\n<li><a href=\"#备份与还原\">备份与还原</a></li>\n<li><a href=\"#视图\">视图</a></li>\n<li><a href=\"#事务transaction\">事务(transaction)</a></li>\n<li><a href=\"#锁表\">锁表</a></li>\n<li><a href=\"#触发器\">触发器</a></li>\n<li><a href=\"#sql编程\">SQL编程</a></li>\n<li><a href=\"#存储过程\">存储过程</a></li>\n<li><a href=\"#用户和权限管理\">用户和权限管理</a></li>\n<li><a href=\"#表维护\">表维护</a></li>\n<li><a href=\"#杂项\">杂项</a></li>\n</ul>\n<!-- /TOC -->\n<h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* Windows服务 */</span>\n<span class=\"hljs-comment\">-- 启动MySQL</span>\nnet <span class=\"hljs-keyword\">start</span> mysql\n<span class=\"hljs-comment\">-- 创建Windows服务</span>\nsc <span class=\"hljs-keyword\">create</span> mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)\n<span class=\"hljs-comment\">/* 连接与断开服务器 */</span>\nmysql -h 地址 -P 端口 -u 用户名 -p 密码\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">PROCESSLIST</span> <span class=\"hljs-comment\">-- 显示哪些线程正在运行</span>\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">VARIABLES</span> <span class=\"hljs-comment\">-- 显示系统变量信息</span></code></pre>\n<h3 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 数据库操作 */</span> <span class=\"hljs-comment\">------------------</span>\n<span class=\"hljs-comment\">-- 查看当前数据库</span>\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DATABASE</span>();\n<span class=\"hljs-comment\">-- 显示当前时间、用户名、数据库版本</span>\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">now</span>(), <span class=\"hljs-keyword\">user</span>(), <span class=\"hljs-keyword\">version</span>();\n<span class=\"hljs-comment\">-- 创建库</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">DATABASE</span>[ <span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">EXISTS</span>] 数据库名 数据库选项\n<span class=\"hljs-comment\"># 数据库选项：</span>\n    <span class=\"hljs-built_in\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> charset_name\n    <span class=\"hljs-keyword\">COLLATE</span> collation_name\n<span class=\"hljs-comment\">-- 查看已有库</span>\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">DATABASES</span>[ <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'PATTERN'</span>]\n<span class=\"hljs-comment\">-- 查看当前库信息</span>\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">DATABASE</span> 数据库名\n<span class=\"hljs-comment\">-- 修改库的选项信息</span>\n<span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">DATABASE</span> 库名 选项信息\n<span class=\"hljs-comment\">-- 删除库</span>\n<span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">DATABASE</span>[ <span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">EXISTS</span>] 数据库名\n<span class=\"hljs-comment\"># 同时删除该数据库相关的目录及其目录内容</span></code></pre>\n<h3 id=\"表的操作\"><a href=\"#表的操作\" class=\"headerlink\" title=\"表的操作\"></a>表的操作</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 创建表</span>\n<span class=\"hljs-keyword\">CREATE</span> [<span class=\"hljs-keyword\">TEMPORARY</span>] <span class=\"hljs-keyword\">TABLE</span>[ <span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">EXISTS</span>] [库名.]表名 ( 表的结构定义 )[ 表选项]\n    每个字段必须有数据类型\n    最后一个字段后不能有逗号\n    <span class=\"hljs-keyword\">TEMPORARY</span> 临时表，会话结束时表自动消失\n    对于字段的定义：\n        字段名 数据类型 [<span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> | <span class=\"hljs-literal\">NULL</span>] [<span class=\"hljs-keyword\">DEFAULT</span> default_value] [AUTO_INCREMENT] [<span class=\"hljs-keyword\">UNIQUE</span> [<span class=\"hljs-keyword\">KEY</span>] | [PRIMARY] <span class=\"hljs-keyword\">KEY</span>] [<span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">'string'</span>]\n            \n<span class=\"hljs-comment\">-- 表选项</span>\n    <span class=\"hljs-comment\">-- 字符集</span>\n        <span class=\"hljs-keyword\">CHARSET</span> = charset_name\n        如果表没有设定，则使用数据库字符集\n    <span class=\"hljs-comment\">-- 存储引擎</span>\n        <span class=\"hljs-keyword\">ENGINE</span> = engine_name\n        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同\n        常见的引擎：<span class=\"hljs-keyword\">InnoDB</span> MyISAM <span class=\"hljs-keyword\">Memory</span>/<span class=\"hljs-keyword\">Heap</span> BDB <span class=\"hljs-keyword\">Merge</span> Example CSV MaxDB <span class=\"hljs-keyword\">Archive</span>\n        不同的引擎在保存表的结构和数据时采用不同的方式\n        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引\n        <span class=\"hljs-keyword\">InnoDB</span>表文件含义：.frm表定义，表空间数据和日志文件\n        <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">ENGINES</span> <span class=\"hljs-comment\">-- 显示存储引擎的状态信息</span>\n        <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">ENGINE</span> 引擎名 &#123;<span class=\"hljs-keyword\">LOGS</span>|<span class=\"hljs-keyword\">STATUS</span>&#125; <span class=\"hljs-comment\">-- 显示存储引擎的日志或状态信息</span>\n    <span class=\"hljs-comment\">-- 自增起始数</span>\n    \tAUTO_INCREMENT = 行数\n    <span class=\"hljs-comment\">-- 数据文件目录</span>\n        <span class=\"hljs-keyword\">DATA</span> <span class=\"hljs-keyword\">DIRECTORY</span> = <span class=\"hljs-string\">'目录'</span>\n    <span class=\"hljs-comment\">-- 索引文件目录</span>\n        <span class=\"hljs-keyword\">INDEX</span> <span class=\"hljs-keyword\">DIRECTORY</span> = <span class=\"hljs-string\">'目录'</span>\n    <span class=\"hljs-comment\">-- 表注释</span>\n        <span class=\"hljs-keyword\">COMMENT</span> = <span class=\"hljs-string\">'string'</span>\n    <span class=\"hljs-comment\">-- 分区选项</span>\n        <span class=\"hljs-keyword\">PARTITION</span> <span class=\"hljs-keyword\">BY</span> ... (详细见手册)\n<span class=\"hljs-comment\">-- 查看所有表</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">TABLES</span>[ <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'pattern'</span>]\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">TABLES</span> <span class=\"hljs-keyword\">FROM</span>  库名\n<span class=\"hljs-comment\">-- 查看表机构</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> 表名 （信息更详细）\n    <span class=\"hljs-keyword\">DESC</span> 表名 / <span class=\"hljs-keyword\">DESCRIBE</span> 表名 / <span class=\"hljs-keyword\">EXPLAIN</span> 表名 / <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">COLUMNS</span> <span class=\"hljs-keyword\">FROM</span> 表名 [<span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'PATTERN'</span>]\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">TABLE</span> <span class=\"hljs-keyword\">STATUS</span> [<span class=\"hljs-keyword\">FROM</span> db_name] [<span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'pattern'</span>]\n<span class=\"hljs-comment\">-- 修改表</span>\n    <span class=\"hljs-comment\">-- 修改表本身的选项</span>\n        <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> 表名 表的选项\n        eg: <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> 表名 <span class=\"hljs-keyword\">ENGINE</span>=MYISAM;\n    <span class=\"hljs-comment\">-- 对表进行重命名</span>\n        <span class=\"hljs-keyword\">RENAME</span> <span class=\"hljs-keyword\">TABLE</span> 原表名 <span class=\"hljs-keyword\">TO</span> 新表名\n        <span class=\"hljs-keyword\">RENAME</span> <span class=\"hljs-keyword\">TABLE</span> 原表名 <span class=\"hljs-keyword\">TO</span> 库名.表名 （可将表移动到另一个数据库）\n        <span class=\"hljs-comment\">-- RENAME可以交换两个表名</span>\n    <span class=\"hljs-comment\">-- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span>\n        <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> 表名 操作名\n        <span class=\"hljs-comment\">-- 操作名</span>\n            <span class=\"hljs-keyword\">ADD</span>[ <span class=\"hljs-keyword\">COLUMN</span>] 字段定义       <span class=\"hljs-comment\">-- 增加字段</span>\n                <span class=\"hljs-keyword\">AFTER</span> 字段名          <span class=\"hljs-comment\">-- 表示增加在该字段名后面</span>\n                <span class=\"hljs-keyword\">FIRST</span>               <span class=\"hljs-comment\">-- 表示增加在第一个</span>\n            <span class=\"hljs-keyword\">ADD</span> PRIMARY <span class=\"hljs-keyword\">KEY</span>(字段名)   <span class=\"hljs-comment\">-- 创建主键</span>\n            <span class=\"hljs-keyword\">ADD</span> <span class=\"hljs-keyword\">UNIQUE</span> [索引名] (字段名)<span class=\"hljs-comment\">-- 创建唯一索引</span>\n            <span class=\"hljs-keyword\">ADD</span> <span class=\"hljs-keyword\">INDEX</span> [索引名] (字段名) <span class=\"hljs-comment\">-- 创建普通索引</span>\n            <span class=\"hljs-keyword\">DROP</span>[ <span class=\"hljs-keyword\">COLUMN</span>] 字段名      <span class=\"hljs-comment\">-- 删除字段</span>\n            <span class=\"hljs-keyword\">MODIFY</span>[ <span class=\"hljs-keyword\">COLUMN</span>] 字段名 字段属性     <span class=\"hljs-comment\">-- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span>\n            <span class=\"hljs-keyword\">CHANGE</span>[ <span class=\"hljs-keyword\">COLUMN</span>] 原字段名 新字段名 字段属性      <span class=\"hljs-comment\">-- 支持对字段名修改</span>\n            <span class=\"hljs-keyword\">DROP</span> PRIMARY <span class=\"hljs-keyword\">KEY</span>    <span class=\"hljs-comment\">-- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span>\n            <span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">INDEX</span> 索引名 <span class=\"hljs-comment\">-- 删除索引</span>\n            <span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">FOREIGN</span> <span class=\"hljs-keyword\">KEY</span> 外键    <span class=\"hljs-comment\">-- 删除外键</span>\n<span class=\"hljs-comment\">-- 删除表</span>\n<span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TABLE</span>[ <span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">EXISTS</span>] 表名 ...\n<span class=\"hljs-comment\">-- 清空表数据</span>\n<span class=\"hljs-keyword\">TRUNCATE</span> [<span class=\"hljs-keyword\">TABLE</span>] 表名\n<span class=\"hljs-comment\">-- 复制表结构</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> 表名 <span class=\"hljs-keyword\">LIKE</span> 要复制的表名\n<span class=\"hljs-comment\">-- 复制表结构和数据</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> 表名 [<span class=\"hljs-keyword\">AS</span>] <span class=\"hljs-keyword\">SELECT</span> * <span class=\"hljs-keyword\">FROM</span> 要复制的表名\n<span class=\"hljs-comment\">-- 检查表是否有错误</span>\n<span class=\"hljs-keyword\">CHECK</span> <span class=\"hljs-keyword\">TABLE</span> tbl_name [, tbl_name] ... [<span class=\"hljs-keyword\">option</span>] ...\n<span class=\"hljs-comment\">-- 优化表</span>\n<span class=\"hljs-keyword\">OPTIMIZE</span> [<span class=\"hljs-keyword\">LOCAL</span> | <span class=\"hljs-keyword\">NO_WRITE_TO_BINLOG</span>] <span class=\"hljs-keyword\">TABLE</span> tbl_name [, tbl_name] ...\n<span class=\"hljs-comment\">-- 修复表</span>\n<span class=\"hljs-keyword\">REPAIR</span> [<span class=\"hljs-keyword\">LOCAL</span> | <span class=\"hljs-keyword\">NO_WRITE_TO_BINLOG</span>] <span class=\"hljs-keyword\">TABLE</span> tbl_name [, tbl_name] ... [<span class=\"hljs-keyword\">QUICK</span>] [<span class=\"hljs-keyword\">EXTENDED</span>] [USE_FRM]\n<span class=\"hljs-comment\">-- 分析表</span>\n<span class=\"hljs-keyword\">ANALYZE</span> [<span class=\"hljs-keyword\">LOCAL</span> | <span class=\"hljs-keyword\">NO_WRITE_TO_BINLOG</span>] <span class=\"hljs-keyword\">TABLE</span> tbl_name [, tbl_name] ...</code></pre>\n<h3 id=\"字符集编码\"><a href=\"#字符集编码\" class=\"headerlink\" title=\"字符集编码\"></a>字符集编码</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 字符集编码 */</span> <span class=\"hljs-comment\">------------------</span>\n<span class=\"hljs-comment\">-- MySQL、数据库、表、字段均可设置编码</span>\n<span class=\"hljs-comment\">-- 数据编码与客户端编码不需一致</span>\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">VARIABLES</span> <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'character_set_%'</span>   <span class=\"hljs-comment\">-- 查看所有字符集编码项</span>\n    character_set_client        客户端向服务器发送数据时使用的编码\n    character_set_results       服务器端将结果返回给客户端所使用的编码\n    character_set_connection    连接层编码\n    \n<span class=\"hljs-keyword\">SET</span> 变量名 = 变量值\n    <span class=\"hljs-keyword\">SET</span> character_set_client = gbk;\n    <span class=\"hljs-keyword\">SET</span> character_set_results = gbk;\n    <span class=\"hljs-keyword\">SET</span> character_set_connection = gbk;\n<span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">NAMES</span> GBK;  <span class=\"hljs-comment\">-- 相当于完成以上三个设置</span>\n\n<span class=\"hljs-comment\">-- 校对集</span>\n    校对集用以排序\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-built_in\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> [<span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'pattern'</span>]/<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">CHARSET</span> [<span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'pattern'</span>]   查看所有字符集\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">COLLATION</span> [<span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'pattern'</span>]     查看所有校对集\n    <span class=\"hljs-keyword\">CHARSET</span> 字符集编码     设置字符集编码\n    <span class=\"hljs-keyword\">COLLATE</span> 校对集编码     设置校对集编码</code></pre>\n<h3 id=\"数据类型-列类型\"><a href=\"#数据类型-列类型\" class=\"headerlink\" title=\"数据类型(列类型)\"></a>数据类型(列类型)</h3><pre><code class=\"hljs sql\">/* 数据类型（列类型） */ ------------------\n1. 数值类型\n-- a. 整型 ----------\n    类型         字节     范围（有符号位）\n    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255\n    smallint    2字节    -32768 ~ 32767\n    mediumint   3字节    -8388608 ~ 8388607\n    int         4字节\n    bigint      8字节\n    int(M)  M表示总位数\n    - 默认存在符号位，unsigned 属性修改\n    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改\n        例：int(5)   插入一个数'123'，补填后为'00123'\n    - 在满足要求的情况下，越小越好。\n    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。\n    \n-- b. 浮点型 ----------\n    类型             字节     范围\n    float(单精度)     4字节\n    double(双精度)    8字节\n    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。\n        不同于整型，前后均会补填0.\n    定义浮点型时，需指定总位数和小数位数。\n        float(M, D)     double(M, D)\n        M表示总位数，D表示小数位数。\n        M和D的大小会决定浮点数的范围。不同于整型的固定范围。\n        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。\n        支持科学计数法表示。\n        浮点数表示近似值。\n        \n-- c. 定点数 ----------\n    decimal -- 可变长度\n    decimal(M, D)   M也表示总位数，D表示小数位数。\n    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。\n    将浮点数转换为字符串来保存，每9位数字保存为4个字节。\n    \n2. 字符串类型\n-- a. char, varchar ----------\n    char    定长字符串，速度快，但浪费空间\n    varchar 变长字符串，速度慢，但节省空间\n    M表示能存储的最大长度，此长度是字符数，非字节数。\n    不同的编码，所占用的空间不同。\n    char,最多255个字符，与编码无关。\n    varchar,最多65535字符，与编码有关。\n    一条有效记录最大不能超过65535个字节。\n        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符\n    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。\n    varchar 的最大有效长度由最大行大小和使用的字符集确定。\n    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。\n    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3\n    \n-- b. blob, text ----------\n    blob 二进制字符串（字节字符串）\n        tinyblob, blob, mediumblob, longblob\n    text 非二进制字符串（字符字符串）\n        tinytext, text, mediumtext, longtext\n    text 在定义时，不需要定义长度，也不会计算总长度。\n    text 类型在定义时，不可给default值\n    \n-- c. binary, varbinary ----------\n    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。\n    char, varchar, text 对应 binary, varbinary, blob.\n    \n3. 日期时间类型\n    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。\n    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59\n    date        3字节    日期         1000-01-01 到 9999-12-31\n    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07\n    time        3字节    时间         -838:59:59 到 838:59:59\n    year        1字节    年份         1901 - 2155\n    \n    datetime    YYYY-MM-DD hh:mm:ss\n    timestamp   YY-MM-DD hh:mm:ss\n                YYYYMMDDhhmmss\n                YYMMDDhhmmss\n                YYYYMMDDhhmmss\n                YYMMDDhhmmss\n    date        YYYY-MM-DD\n                YY-MM-DD\n                YYYYMMDD\n                YYMMDD\n                YYYYMMDD\n                YYMMDD\n    time        hh:mm:ss\n                hhmmss\n                hhmmss\n    year        YYYY\n                YY\n                YYYY\n                YY\n4. 枚举和集合\n-- 枚举(enum) ----------\nenum(val1, val2, val3...)\n    在已知的值中进行单选。最大数量为65535.\n    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。\n    表现为字符串类型，存储却是整型。\n    NULL值的索引是NULL。\n    空字符串错误值的索引值是0。\n    \n-- 集合（set） ----------\nset(val1, val2, val3...)\n    create table tab ( gender set('男', '女', '无') );\n    insert into tab values ('男, 女');\n    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。\n    当创建表时，SET成员值的尾部空格将自动被删除。</code></pre>\n<h3 id=\"列属性-列约束\"><a href=\"#列属性-列约束\" class=\"headerlink\" title=\"列属性(列约束)\"></a>列属性(列约束)</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 列属性（列约束） */</span> <span class=\"hljs-comment\">------------------</span>\n1. PRIMARY 主键\n    - 能唯一标识记录的字段，可以作为主键。\n    - 一个表只能有一个主键。\n    - 主键具有唯一性。\n    - 声明字段时，用 primary key 标识。\n        也可以在字段列表之后声明\n            例：<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> tab ( <span class=\"hljs-keyword\">id</span> <span class=\"hljs-built_in\">int</span>, stu <span class=\"hljs-built_in\">varchar</span>(<span class=\"hljs-number\">10</span>), primary <span class=\"hljs-keyword\">key</span> (<span class=\"hljs-keyword\">id</span>));\n    - 主键字段的值不能为null。\n    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。\n        例：<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> tab ( <span class=\"hljs-keyword\">id</span> <span class=\"hljs-built_in\">int</span>, stu <span class=\"hljs-built_in\">varchar</span>(<span class=\"hljs-number\">10</span>), age <span class=\"hljs-built_in\">int</span>, primary <span class=\"hljs-keyword\">key</span> (stu, age));\n        \n2. UNIQUE 唯一索引（唯一约束）\n    使得某字段的值也不能重复。\n    \n3. NULL 约束\n    null不是数据类型，是列的一个属性。\n    表示当前列是否可以为null，表示什么都没有。\n    null, 允许为空。默认。\n    not null, 不允许为空。\n    <span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> tab <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">'val'</span>);\n        <span class=\"hljs-comment\">-- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span>\n        \n4. DEFAULT 默认值属性\n    当前字段的默认值。\n    <span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> tab <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-keyword\">default</span>, <span class=\"hljs-string\">'val'</span>);    <span class=\"hljs-comment\">-- 此时表示强制使用默认值。</span>\n    <span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> tab ( add_time <span class=\"hljs-built_in\">timestamp</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">current_timestamp</span> );\n        <span class=\"hljs-comment\">-- 表示将当前时间的时间戳设为默认值。</span>\n        current_date, current_time\n        \n5. AUTO_INCREMENT 自动增长约束\n    自动增长必须为索引（主键或unique）\n    只能存在一个字段为自动增长。\n    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 <span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">table</span> tbl auto_increment = x;\n    \n6. <span class=\"hljs-keyword\">COMMENT</span> 注释\n    例：<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> tab ( <span class=\"hljs-keyword\">id</span> <span class=\"hljs-built_in\">int</span> ) <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">'注释内容'</span>;\n    \n7. FOREIGN KEY 外键约束\n    用于限制主表与从表数据完整性。\n    <span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">table</span> t1 <span class=\"hljs-keyword\">add</span> <span class=\"hljs-keyword\">constraint</span> <span class=\"hljs-string\">`t1_t2_fk`</span> <span class=\"hljs-keyword\">foreign</span> <span class=\"hljs-keyword\">key</span> (t1_id) <span class=\"hljs-keyword\">references</span> t2(<span class=\"hljs-keyword\">id</span>);\n        <span class=\"hljs-comment\">-- 将表t1的t1_id外键关联到表t2的id字段。</span>\n        <span class=\"hljs-comment\">-- 每个外键都有一个名字，可以通过 constraint 指定</span>\n    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。\n    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。\n    MySQL中，可以对InnoDB引擎使用外键约束：\n    语法：\n    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]\n    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。\n    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。\n    如果指定了 on <span class=\"hljs-keyword\">update</span> 或 <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">delete</span>：在删除或更新时，有如下几个操作可以选择：\n    <span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">cascade</span>，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。\n    <span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">set</span> <span class=\"hljs-literal\">null</span>，设置为<span class=\"hljs-literal\">null</span>。主表数据被更新（主键值更新），从表的外键被设置为<span class=\"hljs-literal\">null</span>。主表记录被删除，从表相关记录外键被设置成<span class=\"hljs-literal\">null</span>。但注意，要求该外键列，没有<span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">null</span>属性约束。\n    <span class=\"hljs-number\">3.</span> restrict，拒绝父表删除和更新。\n    注意，外键只被<span class=\"hljs-keyword\">InnoDB</span>存储引擎所支持。其他引擎是不支持的。</code></pre>\n<h3 id=\"建表规范\"><a href=\"#建表规范\" class=\"headerlink\" title=\"建表规范\"></a>建表规范</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 建表规范 */</span> <span class=\"hljs-comment\">------------------</span>\n    <span class=\"hljs-comment\">-- Normal Format, NF</span>\n        - 每个表保存一个实体信息\n        - 每个具有一个ID字段作为主键\n        - ID主键 + 原子表\n        \n    <span class=\"hljs-comment\">-- 1NF, 第一范式</span>\n        字段不能再分，就满足第一范式。\n        \n    <span class=\"hljs-comment\">-- 2NF, 第二范式</span>\n        满足第一范式的前提下，不能出现部分依赖。\n        消除符合主键就可以避免部分依赖。增加单列关键字。\n        \n    <span class=\"hljs-comment\">-- 3NF, 第三范式</span>\n        满足第二范式的前提下，不能出现传递依赖。\n        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。\n        将一个实体信息的数据放在一个表内实现。</code></pre>\n<h3 id=\"UNION\"><a href=\"#UNION\" class=\"headerlink\" title=\"UNION\"></a>UNION</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* UNION */</span> <span class=\"hljs-comment\">------------------</span>\n    将多个<span class=\"hljs-keyword\">select</span>查询的结果组合成一个结果集合。\n    <span class=\"hljs-keyword\">SELECT</span> ... <span class=\"hljs-keyword\">UNION</span> [<span class=\"hljs-keyword\">ALL</span>|<span class=\"hljs-keyword\">DISTINCT</span>] <span class=\"hljs-keyword\">SELECT</span> ...\n    默认 <span class=\"hljs-keyword\">DISTINCT</span> 方式，即所有返回的行都是唯一的\n    建议，对每个<span class=\"hljs-keyword\">SELECT</span>查询加上小括号包裹。\n    <span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> 排序时，需加上 <span class=\"hljs-keyword\">LIMIT</span> 进行结合。\n    需要各<span class=\"hljs-keyword\">select</span>查询的字段数量一样。\n    每个<span class=\"hljs-keyword\">select</span>查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条<span class=\"hljs-keyword\">select</span>语句为准。</code></pre>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 子查询 */</span> <span class=\"hljs-comment\">------------------</span>\n    - 子查询需用括号包裹。\n    \n<span class=\"hljs-comment\">-- from型</span>\n    from后要求是一个表，必须给子查询结果取个别名。\n    - 简化每个查询内的条件。\n    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。\n    - 子查询返回一个表，表型子查询。\n    <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> (<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> tb <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">id</span>&gt;<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">as</span> subfrom <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">id</span>&gt;<span class=\"hljs-number\">1</span>;\n    \n<span class=\"hljs-comment\">-- where型</span>\n    - 子查询返回一个值，标量子查询。\n    - 不需要给子查询取别名。\n    - where子查询内的表，不能直接用以更新。\n    <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> tb <span class=\"hljs-keyword\">where</span> money = (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">max</span>(money) <span class=\"hljs-keyword\">from</span> tb);\n    \n    <span class=\"hljs-comment\">-- 列子查询</span>\n        如果子查询结果返回的是一列。\n        使用 in 或 not in 完成查询\n        exists 和 not exists 条件\n            如果子查询返回数据，则返回1或0。常用于判断条件。\n            <span class=\"hljs-keyword\">select</span> column1 <span class=\"hljs-keyword\">from</span> t1 <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">exists</span> (<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> t2);\n            \n    <span class=\"hljs-comment\">-- 行子查询</span>\n        查询条件是一个行。\n        <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> t1 <span class=\"hljs-keyword\">where</span> (<span class=\"hljs-keyword\">id</span>, gender) <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">id</span>, gender <span class=\"hljs-keyword\">from</span> t2);\n        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)\n        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。\n        \n    <span class=\"hljs-comment\">-- 特殊运算符</span>\n    != all()    相当于 not in\n    = some()    相当于 in。any 是 some 的别名\n    != some()   不等同于 not in，不等于其中某一个。\n    all, some 可以配合其他运算符一起使用。</code></pre>\n<h3 id=\"连接查询-join\"><a href=\"#连接查询-join\" class=\"headerlink\" title=\"连接查询(join)\"></a>连接查询(join)</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 连接查询(join) */</span> <span class=\"hljs-comment\">------------------</span>\n    将多个表的字段进行连接，可以指定连接条件。\n    \n<span class=\"hljs-comment\">-- 内连接(inner join)</span>\n    - 默认就是内连接，可省略inner。\n    - 只有数据存在时才能发送连接。即连接结果不能出现空行。\n    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）\n    也可用where表示连接条件。\n    还有 using, 但需字段名相同。 using(字段名)\n    <span class=\"hljs-comment\">-- 交叉连接 cross join</span>\n        即，没有条件的内连接。\n        <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> tb1 <span class=\"hljs-keyword\">cross</span> <span class=\"hljs-keyword\">join</span> tb2;\n        \n<span class=\"hljs-comment\">-- 外连接(outer join)</span>\n    - 如果数据不存在，也会出现在连接结果中。\n    <span class=\"hljs-comment\">-- 左外连接 left join</span>\n        如果数据不存在，左表记录会出现，而右表为null填充\n    <span class=\"hljs-comment\">-- 右外连接 right join</span>\n        如果数据不存在，右表记录会出现，而左表为null填充\n        \n<span class=\"hljs-comment\">-- 自然连接(natural join)</span>\n    自动判断连接条件完成连接。\n    相当于省略了using，会自动查找相同字段名。\n    natural join\n    natural left join\n    natural right join\n<span class=\"hljs-keyword\">select</span> info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex <span class=\"hljs-keyword\">from</span> info, extra_info <span class=\"hljs-keyword\">where</span> info.stu_num = extra_info.stu_id;</code></pre>\n<h3 id=\"TRUNCATE\"><a href=\"#TRUNCATE\" class=\"headerlink\" title=\"TRUNCATE\"></a>TRUNCATE</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* TRUNCATE */</span> <span class=\"hljs-comment\">------------------</span>\n<span class=\"hljs-keyword\">TRUNCATE</span> [<span class=\"hljs-keyword\">TABLE</span>] tbl_name\n清空数据\n删除重建表\n区别：\n<span class=\"hljs-number\">1</span>，<span class=\"hljs-keyword\">truncate</span> 是删除表再创建，<span class=\"hljs-keyword\">delete</span> 是逐条删除\n<span class=\"hljs-number\">2</span>，<span class=\"hljs-keyword\">truncate</span> 重置auto_increment的值。而<span class=\"hljs-keyword\">delete</span>不会\n<span class=\"hljs-number\">3</span>，<span class=\"hljs-keyword\">truncate</span> 不知道删除了几条，而<span class=\"hljs-keyword\">delete</span>知道。\n<span class=\"hljs-number\">4</span>，当被用于带分区的表时，<span class=\"hljs-keyword\">truncate</span> 会保留分区</code></pre>\n<h3 id=\"备份与还原\"><a href=\"#备份与还原\" class=\"headerlink\" title=\"备份与还原\"></a>备份与还原</h3><pre><code class=\"hljs sql\">/* 备份与还原 */ ------------------\n备份，将数据的结构与表内数据保存起来。\n利用 mysqldump 指令完成。\n\n-- 导出\nmysqldump [options] db_name [tables]\nmysqldump [options] ---database DB1 [DB2 DB3...]\nmysqldump [options] --all--database\n1. 导出一张表\n　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)\n2. 导出多张表\n　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)\n3. 导出所有表\n　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)\n4. 导出一个库\n　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)\n可以-w携带WHERE条件\n\n-- 导入\n1. 在登录mysql的情况下：\n　　source  备份文件\n2. 在不登录的情况下\n　　mysql -u用户名 -p密码 库名 &lt; 备份文件</code></pre>\n<h3 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h3><pre><code class=\"hljs sql\">什么是视图：\n    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。\n    视图具有表结构文件，但不存在数据文件。\n    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。\n    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。\n\n<span class=\"hljs-comment\">-- 创建视图</span>\n<span class=\"hljs-keyword\">CREATE</span> [<span class=\"hljs-keyword\">OR</span> <span class=\"hljs-keyword\">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class=\"hljs-keyword\">MERGE</span> | TEMPTABLE&#125;] <span class=\"hljs-keyword\">VIEW</span> view_name [(column_list)] <span class=\"hljs-keyword\">AS</span> select_statement\n    - 视图名必须唯一，同时不能与表重名。\n    - 视图可以使用<span class=\"hljs-keyword\">select</span>语句查询到的列名，也可以自己指定相应的列名。\n    - 可以指定视图执行的算法，通过ALGORITHM指定。\n    - column_list如果存在，则数目必须等于<span class=\"hljs-keyword\">SELECT</span>语句检索的列数\n    \n<span class=\"hljs-comment\">-- 查看结构</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> view_name\n    \n<span class=\"hljs-comment\">-- 删除视图</span>\n    - 删除视图后，数据依然存在。\n    - 可同时删除多个视图。\n    <span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">VIEW</span> [<span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">EXISTS</span>] view_name ...\n    \n<span class=\"hljs-comment\">-- 修改视图结构</span>\n    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。\n    <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">VIEW</span> view_name [(column_list)] <span class=\"hljs-keyword\">AS</span> select_statement\n    \n<span class=\"hljs-comment\">-- 视图作用</span>\n    <span class=\"hljs-number\">1.</span> 简化业务逻辑\n    <span class=\"hljs-number\">2.</span> 对客户端隐藏真实的表结构\n    \n<span class=\"hljs-comment\">-- 视图算法(ALGORITHM)</span>\n    <span class=\"hljs-keyword\">MERGE</span>       合并\n        将视图的查询语句，与外部查询需要先合并再执行！\n    TEMPTABLE   临时表\n        将视图执行完毕后，形成临时表，再做外层查询！\n    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</code></pre>\n<h3 id=\"事务-transaction\"><a href=\"#事务-transaction\" class=\"headerlink\" title=\"事务(transaction)\"></a>事务(transaction)</h3><pre><code class=\"hljs sql\">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。\n    - 支持连续SQL的集体成功或集体撤销。\n    - 事务是数据库在数据晚自习方面的一个功能。\n    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。\n    - InnoDB被称为事务安全型引擎。\n    \n<span class=\"hljs-comment\">-- 事务开启</span>\n    <span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>; 或者 <span class=\"hljs-keyword\">BEGIN</span>;\n    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。\n    \n<span class=\"hljs-comment\">-- 事务提交</span>\n    <span class=\"hljs-keyword\">COMMIT</span>;\n    \n<span class=\"hljs-comment\">-- 事务回滚</span>\n    <span class=\"hljs-keyword\">ROLLBACK</span>;\n    如果部分操作发生问题，映射到事务开启前。\n    \n<span class=\"hljs-comment\">-- 事务的特性</span>\n    1. 原子性（Atomicity）\n        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n    2. 一致性（Consistency）\n        事务前后数据的完整性必须保持一致。\n        - 事务开始和结束时，外部数据一致\n        - 在整个事务过程中，操作是连续的\n    3. 隔离性（Isolation）\n        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。\n    4. 持久性（Durability）\n        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。\n        \n<span class=\"hljs-comment\">-- 事务的实现</span>\n    1. 要求是事务支持的表类型\n    2. 执行一组相关的操作前开启事务\n    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。\n    \n<span class=\"hljs-comment\">-- 事务的原理</span>\n    利用InnoDB的自动提交(autocommit)特性完成。\n    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。\n    而事务是暂时关闭“自动提交”机制，需要<span class=\"hljs-keyword\">commit</span>提交持久化数据操作。\n    \n<span class=\"hljs-comment\">-- 注意</span>\n    <span class=\"hljs-number\">1.</span> 数据定义语言（<span class=\"hljs-keyword\">DDL</span>）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。\n    <span class=\"hljs-number\">2.</span> 事务不能被嵌套\n    \n<span class=\"hljs-comment\">-- 保存点</span>\n    <span class=\"hljs-keyword\">SAVEPOINT</span> 保存点名称 <span class=\"hljs-comment\">-- 设置一个事务保存点</span>\n    <span class=\"hljs-keyword\">ROLLBACK</span> <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-keyword\">SAVEPOINT</span> 保存点名称 <span class=\"hljs-comment\">-- 回滚到保存点</span>\n    <span class=\"hljs-keyword\">RELEASE</span> <span class=\"hljs-keyword\">SAVEPOINT</span> 保存点名称 <span class=\"hljs-comment\">-- 删除保存点</span>\n    \n<span class=\"hljs-comment\">-- InnoDB自动提交特性设置</span>\n    <span class=\"hljs-keyword\">SET</span> autocommit = <span class=\"hljs-number\">0</span>|<span class=\"hljs-number\">1</span>;   0表示关闭自动提交，1表示开启自动提交。\n    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要<span class=\"hljs-keyword\">commit</span>提交后才能持久化数据操作。\n    - 也可以关闭自动提交来开启事务。但与<span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>不同的是，\n        <span class=\"hljs-keyword\">SET</span> autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)\n        而<span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</code></pre>\n<h3 id=\"锁表\"><a href=\"#锁表\" class=\"headerlink\" title=\"锁表\"></a>锁表</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 锁表 */</span>\n表锁定只用于防止其它客户端进行不正当地读取和写入\nMyISAM 支持表锁，InnoDB 支持行锁\n<span class=\"hljs-comment\">-- 锁定</span>\n    <span class=\"hljs-keyword\">LOCK</span> <span class=\"hljs-keyword\">TABLES</span> tbl_name [<span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">alias</span>]\n<span class=\"hljs-comment\">-- 解锁</span>\n    <span class=\"hljs-keyword\">UNLOCK</span> <span class=\"hljs-keyword\">TABLES</span></code></pre>\n<h3 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 触发器 */</span> <span class=\"hljs-comment\">------------------</span>\n    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象\n    监听：记录的增加、修改、删除。\n    \n<span class=\"hljs-comment\">-- 创建触发器</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TRIGGER</span> trigger_name trigger_time trigger_event <span class=\"hljs-keyword\">ON</span> tbl_name <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-keyword\">EACH</span> <span class=\"hljs-keyword\">ROW</span> trigger_stmt\n    参数：\n    trigger_time是触发程序的动作时间。它可以是 <span class=\"hljs-keyword\">before</span> 或 <span class=\"hljs-keyword\">after</span>，以指明触发程序是在激活它的语句之前或之后触发。\n    trigger_event指明了激活触发程序的语句的类型\n        <span class=\"hljs-keyword\">INSERT</span>：将新行插入表时激活触发程序\n        <span class=\"hljs-keyword\">UPDATE</span>：更改某一行时激活触发程序\n        <span class=\"hljs-keyword\">DELETE</span>：从表中删除某一行时激活触发程序\n    tbl_name：监听的表，必须是永久性的表，不能将触发程序与<span class=\"hljs-keyword\">TEMPORARY</span>表或视图关联起来。\n    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构\n    \n<span class=\"hljs-comment\">-- 删除</span>\n<span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TRIGGER</span> [schema_name.]trigger_name\n可以使用<span class=\"hljs-keyword\">old</span>和<span class=\"hljs-keyword\">new</span>代替旧的和新的数据\n    更新操作，更新前是<span class=\"hljs-keyword\">old</span>，更新后是new.\n    删除操作，只有old.\n    增加操作，只有new.\n<span class=\"hljs-comment\">-- 注意</span>\n    <span class=\"hljs-number\">1.</span> 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。\n    \n<span class=\"hljs-comment\">-- 字符连接函数</span>\n<span class=\"hljs-keyword\">concat</span>(str1,str2,...])\n<span class=\"hljs-keyword\">concat_ws</span>(separator,str1,str2,...)\n<span class=\"hljs-comment\">-- 分支语句</span>\n<span class=\"hljs-keyword\">if</span> 条件 <span class=\"hljs-keyword\">then</span>\n    执行语句\nelseif 条件 <span class=\"hljs-keyword\">then</span>\n    执行语句\n<span class=\"hljs-keyword\">else</span>\n    执行语句\n<span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">if</span>;\n<span class=\"hljs-comment\">-- 修改最外层语句结束符</span>\ndelimiter 自定义结束符号\n    SQL语句\n自定义结束符号\ndelimiter ;     <span class=\"hljs-comment\">-- 修改回原来的分号</span>\n<span class=\"hljs-comment\">-- 语句块包裹</span>\n<span class=\"hljs-keyword\">begin</span>\n    语句块\n<span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-comment\">-- 特殊的执行</span>\n<span class=\"hljs-number\">1.</span> 只要添加记录，就会触发程序。\n<span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">Insert</span> <span class=\"hljs-keyword\">into</span> <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">duplicate</span> <span class=\"hljs-keyword\">key</span> <span class=\"hljs-keyword\">update</span> 语法会触发：\n    如果没有重复记录，会触发 <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">insert</span>, <span class=\"hljs-keyword\">after</span> <span class=\"hljs-keyword\">insert</span>;\n    如果有重复记录并更新，会触发 before <span class=\"hljs-keyword\">insert</span>, <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">update</span>, <span class=\"hljs-keyword\">after</span> <span class=\"hljs-keyword\">update</span>;\n    如果有重复记录但是没有发生更新，则触发 before <span class=\"hljs-keyword\">insert</span>, <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">update</span>\n<span class=\"hljs-number\">3.</span> <span class=\"hljs-keyword\">Replace</span> 语法 如果有记录，则执行 <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">insert</span>, <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">delete</span>, <span class=\"hljs-keyword\">after</span> <span class=\"hljs-keyword\">delete</span>, <span class=\"hljs-keyword\">after</span> <span class=\"hljs-keyword\">insert</span></code></pre>\n<h3 id=\"SQL编程\"><a href=\"#SQL编程\" class=\"headerlink\" title=\"SQL编程\"></a>SQL编程</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* SQL编程 */</span> <span class=\"hljs-comment\">------------------</span>\n<span class=\"hljs-comment\">--// 局部变量 ----------</span>\n<span class=\"hljs-comment\">-- 变量声明</span>\n    <span class=\"hljs-keyword\">declare</span> var_name[,...] <span class=\"hljs-keyword\">type</span> [<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">value</span>]\n    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个<span class=\"hljs-keyword\">default</span>子句。值可以被指定为一个表达式，不需要为一个常数。如果没有<span class=\"hljs-keyword\">default</span>子句，初始值为<span class=\"hljs-literal\">null</span>。\n<span class=\"hljs-comment\">-- 赋值</span>\n    使用 <span class=\"hljs-keyword\">set</span> 和 <span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">into</span> 语句为变量赋值。\n    - 注意：在函数内是可以使用全局变量（用户自定义的变量）\n<span class=\"hljs-comment\">--// 全局变量 ----------</span>\n<span class=\"hljs-comment\">-- 定义、赋值</span>\n<span class=\"hljs-keyword\">set</span> 语句可以定义并为变量赋值。\n<span class=\"hljs-keyword\">set</span> @<span class=\"hljs-keyword\">var</span> = <span class=\"hljs-keyword\">value</span>;\n也可以使用<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">into</span>语句为变量初始化并赋值。这样要求<span class=\"hljs-keyword\">select</span>语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。\n还可以把赋值语句看作一个表达式，通过<span class=\"hljs-keyword\">select</span>执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（<span class=\"hljs-keyword\">set</span>语句可以使用= 和 :=）。\n<span class=\"hljs-keyword\">select</span> @<span class=\"hljs-keyword\">var</span>:=<span class=\"hljs-number\">20</span>;\n<span class=\"hljs-keyword\">select</span> @v1:=<span class=\"hljs-keyword\">id</span>, @v2=<span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">from</span> t1 <span class=\"hljs-keyword\">limit</span> <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> tbl_name <span class=\"hljs-keyword\">where</span> @<span class=\"hljs-keyword\">var</span>:=<span class=\"hljs-number\">30</span>;\n<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">into</span> 可以将表中查询获得的数据赋给变量。\n    -| <span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">max</span>(height) <span class=\"hljs-keyword\">into</span> @max_height <span class=\"hljs-keyword\">from</span> tb;\n<span class=\"hljs-comment\">-- 自定义变量名</span>\n为了避免<span class=\"hljs-keyword\">select</span>语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。\n@<span class=\"hljs-keyword\">var</span>=<span class=\"hljs-number\">10</span>;\n    - 变量被定义后，在整个会话周期都有效（登录到退出）\n<span class=\"hljs-comment\">--// 控制结构 ----------</span>\n<span class=\"hljs-comment\">-- if语句</span>\nif search_condition then\n    statement_list   \n[elseif search_condition then\n    statement_list]\n...\n[else\n    statement_list]\n<span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">if</span>;\n<span class=\"hljs-comment\">-- case语句</span>\nCASE value WHEN [compare-value] THEN result\n[WHEN [compare-value] THEN result ...]\n[ELSE result]\n<span class=\"hljs-keyword\">END</span>\n<span class=\"hljs-comment\">-- while循环</span>\n[begin_label:] <span class=\"hljs-keyword\">while</span> search_condition <span class=\"hljs-keyword\">do</span>\n    statement_list\n<span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">while</span> [end_label];\n- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。\n    <span class=\"hljs-comment\">-- 退出循环</span>\n        退出整个循环 leave\n        退出当前循环 iterate\n        通过退出的标签决定退出哪个循环\n<span class=\"hljs-comment\">--// 内置函数 ----------</span>\n<span class=\"hljs-comment\">-- 数值函数</span>\nabs(x)          <span class=\"hljs-comment\">-- 绝对值 abs(-10.9) = 10</span>\nformat(x, d)    <span class=\"hljs-comment\">-- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46</span>\nceil(x)         <span class=\"hljs-comment\">-- 向上取整 ceil(10.1) = 11</span>\nfloor(x)        <span class=\"hljs-comment\">-- 向下取整 floor (10.1) = 10</span>\nround(x)        <span class=\"hljs-comment\">-- 四舍五入去整</span>\nmod(m, n)       <span class=\"hljs-comment\">-- m%n m mod n 求余 10%3=1</span>\npi()            <span class=\"hljs-comment\">-- 获得圆周率</span>\npow(m, n)       <span class=\"hljs-comment\">-- m^n</span>\nsqrt(x)         <span class=\"hljs-comment\">-- 算术平方根</span>\nrand()          <span class=\"hljs-comment\">-- 随机数</span>\n<span class=\"hljs-keyword\">truncate</span>(x, d)  <span class=\"hljs-comment\">-- 截取d位小数</span>\n<span class=\"hljs-comment\">-- 时间日期函数</span>\n<span class=\"hljs-keyword\">now</span>(), <span class=\"hljs-keyword\">current_timestamp</span>();     <span class=\"hljs-comment\">-- 当前日期时间</span>\ncurrent_date();                 <span class=\"hljs-comment\">-- 当前日期</span>\ncurrent_time();                 <span class=\"hljs-comment\">-- 当前时间</span>\ndate('yyyy-mm-dd hh:ii:ss');    <span class=\"hljs-comment\">-- 获取日期部分</span>\ntime('yyyy-mm-dd hh:ii:ss');    <span class=\"hljs-comment\">-- 获取时间部分</span>\ndate_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); <span class=\"hljs-comment\">-- 格式化时间</span>\nunix_timestamp();               <span class=\"hljs-comment\">-- 获得unix时间戳</span>\nfrom_unixtime();                <span class=\"hljs-comment\">-- 从时间戳获得时间</span>\n<span class=\"hljs-comment\">-- 字符串函数</span>\nlength(string)          <span class=\"hljs-comment\">-- string长度，字节</span>\nchar_length(string)     <span class=\"hljs-comment\">-- string的字符个数</span>\nsubstring(str, position [,length])      <span class=\"hljs-comment\">-- 从str的position开始,取length个字符</span>\n<span class=\"hljs-keyword\">replace</span>(<span class=\"hljs-keyword\">str</span> ,search_str ,replace_str)   <span class=\"hljs-comment\">-- 在str中用replace_str替换search_str</span>\n<span class=\"hljs-keyword\">instr</span>(<span class=\"hljs-keyword\">string</span> ,<span class=\"hljs-keyword\">substring</span>)    <span class=\"hljs-comment\">-- 返回substring首次在string中出现的位置</span>\n<span class=\"hljs-keyword\">concat</span>(<span class=\"hljs-keyword\">string</span> [,...])   <span class=\"hljs-comment\">-- 连接字串</span>\n<span class=\"hljs-keyword\">charset</span>(<span class=\"hljs-keyword\">str</span>)            <span class=\"hljs-comment\">-- 返回字串字符集</span>\n<span class=\"hljs-keyword\">lcase</span>(<span class=\"hljs-keyword\">string</span>)           <span class=\"hljs-comment\">-- 转换成小写</span>\n<span class=\"hljs-keyword\">left</span>(<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">length</span>)    <span class=\"hljs-comment\">-- 从string2中的左边起取length个字符</span>\n<span class=\"hljs-keyword\">load_file</span>(file_name)    <span class=\"hljs-comment\">-- 从文件读取内容</span>\n<span class=\"hljs-keyword\">locate</span>(<span class=\"hljs-keyword\">substring</span>, <span class=\"hljs-keyword\">string</span> [,start_position]) <span class=\"hljs-comment\">-- 同instr,但可指定开始位置</span>\n<span class=\"hljs-keyword\">lpad</span>(<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">length</span>, <span class=\"hljs-keyword\">pad</span>)   <span class=\"hljs-comment\">-- 重复用pad加在string开头,直到字串长度为length</span>\n<span class=\"hljs-keyword\">ltrim</span>(<span class=\"hljs-keyword\">string</span>)           <span class=\"hljs-comment\">-- 去除前端空格</span>\n<span class=\"hljs-keyword\">repeat</span>(<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">count</span>)   <span class=\"hljs-comment\">-- 重复count次</span>\nrpad(<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">length</span>, <span class=\"hljs-keyword\">pad</span>)   <span class=\"hljs-comment\">--在str后用pad补充,直到长度为length</span>\n<span class=\"hljs-keyword\">rtrim</span>(<span class=\"hljs-keyword\">string</span>)           <span class=\"hljs-comment\">-- 去除后端空格</span>\n<span class=\"hljs-keyword\">strcmp</span>(string1 ,string2)    <span class=\"hljs-comment\">-- 逐字符比较两字串大小</span>\n<span class=\"hljs-comment\">-- 流程函数</span>\n<span class=\"hljs-keyword\">case</span> <span class=\"hljs-keyword\">when</span> [condition] <span class=\"hljs-keyword\">then</span> <span class=\"hljs-keyword\">result</span> [<span class=\"hljs-keyword\">when</span> [condition] <span class=\"hljs-keyword\">then</span> <span class=\"hljs-keyword\">result</span> ...] [<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">result</span>] <span class=\"hljs-keyword\">end</span>   多分支\n<span class=\"hljs-keyword\">if</span>(expr1,expr2,expr3)  双分支。\n<span class=\"hljs-comment\">-- 聚合函数</span>\n<span class=\"hljs-keyword\">count</span>()\n<span class=\"hljs-keyword\">sum</span>();\nmax();\nmin();\navg();\ngroup_concat()\n<span class=\"hljs-comment\">-- 其他常用函数</span>\nmd5();\ndefault();\n<span class=\"hljs-comment\">--// 存储函数，自定义函数 ----------</span>\n<span class=\"hljs-comment\">-- 新建</span>\n    <span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">FUNCTION</span> function_name (参数列表) <span class=\"hljs-keyword\">RETURNS</span> 返回值类型\n        函数体\n    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。\n    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。\n    - 参数部分，由<span class=\"hljs-string\">\"参数名\"</span>和<span class=\"hljs-string\">\"参数类型\"</span>组成。多个参数用逗号隔开。\n    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。\n    - 多条语句应该使用 begin...end 语句块包含。\n    - 一定要有 <span class=\"hljs-keyword\">return</span> 返回值语句。\n<span class=\"hljs-comment\">-- 删除</span>\n    <span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">FUNCTION</span> [<span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">EXISTS</span>] function_name;\n<span class=\"hljs-comment\">-- 查看</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">FUNCTION</span> <span class=\"hljs-keyword\">STATUS</span> <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'partten'</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">FUNCTION</span> function_name;\n<span class=\"hljs-comment\">-- 修改</span>\n    <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">FUNCTION</span> function_name 函数选项\n<span class=\"hljs-comment\">--// 存储过程，自定义功能 ----------</span>\n<span class=\"hljs-comment\">-- 定义</span>\n存储存储过程 是一段代码（过程），存储在数据库中的<span class=\"hljs-keyword\">sql</span>组成。\n一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。\n而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过<span class=\"hljs-keyword\">call</span>执行。\n<span class=\"hljs-comment\">-- 创建</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">PROCEDURE</span> sp_name (参数列表)\n    过程体\n参数列表：不同于函数的参数列表，需要指明参数类型\n<span class=\"hljs-keyword\">IN</span>，表示输入型\n<span class=\"hljs-keyword\">OUT</span>，表示输出型\nINOUT，表示混合型\n注意，没有返回值。</code></pre>\n<h3 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 存储过程 */</span> <span class=\"hljs-comment\">------------------</span>\n存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。\n调用：<span class=\"hljs-keyword\">CALL</span> 过程名\n<span class=\"hljs-comment\">-- 注意</span>\n- 没有返回值。\n- 只能单独调用，不可夹杂在其他语句中\n<span class=\"hljs-comment\">-- 参数</span>\n<span class=\"hljs-keyword\">IN</span>|<span class=\"hljs-keyword\">OUT</span>|INOUT 参数名 数据类型\n<span class=\"hljs-keyword\">IN</span>      输入：在调用过程中，将数据输入到过程体内部的参数\n<span class=\"hljs-keyword\">OUT</span>     输出：在调用过程中，将过程体处理完的结果返回到客户端\nINOUT   输入输出：既可输入，也可输出\n<span class=\"hljs-comment\">-- 语法</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">PROCEDURE</span> 过程名 (参数列表)\n<span class=\"hljs-keyword\">BEGIN</span>\n    过程体\n<span class=\"hljs-keyword\">END</span></code></pre>\n<h3 id=\"用户和权限管理\"><a href=\"#用户和权限管理\" class=\"headerlink\" title=\"用户和权限管理\"></a>用户和权限管理</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 用户和权限管理 */</span> <span class=\"hljs-comment\">------------------</span>\n<span class=\"hljs-comment\">-- root密码重置</span>\n1. 停止MySQL服务\n2.  [Linux] /usr/local/mysql/bin/safe_mysqld <span class=\"hljs-comment\">--skip-grant-tables &amp;</span>\n    [Windows] mysqld <span class=\"hljs-comment\">--skip-grant-tables</span>\n3. <span class=\"hljs-keyword\">use</span> mysql;\n4. <span class=\"hljs-keyword\">UPDATE</span> <span class=\"hljs-string\">`user`</span> <span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">PASSWORD</span>=<span class=\"hljs-keyword\">PASSWORD</span>(<span class=\"hljs-string\">\"密码\"</span>) <span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-string\">`user`</span> = <span class=\"hljs-string\">\"root\"</span>;\n5. <span class=\"hljs-keyword\">FLUSH</span> <span class=\"hljs-keyword\">PRIVILEGES</span>;\n用户信息表：mysql.user\n<span class=\"hljs-comment\">-- 刷新权限</span>\n<span class=\"hljs-keyword\">FLUSH</span> <span class=\"hljs-keyword\">PRIVILEGES</span>;\n<span class=\"hljs-comment\">-- 增加用户</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span> 用户名 <span class=\"hljs-keyword\">IDENTIFIED</span> <span class=\"hljs-keyword\">BY</span> [<span class=\"hljs-keyword\">PASSWORD</span>] 密码(字符串)\n    - 必须拥有mysql数据库的全局<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span>权限，或拥有<span class=\"hljs-keyword\">INSERT</span>权限。\n    - 只能创建用户，不能赋予权限。\n    - 用户名，注意引号：如 <span class=\"hljs-string\">'user_name'</span>@<span class=\"hljs-string\">'192.168.1.1'</span>\n    - 密码也需引号，纯数字密码也要加引号\n    - 要在纯文本中指定密码，需忽略<span class=\"hljs-keyword\">PASSWORD</span>关键词。要把密码指定为由<span class=\"hljs-keyword\">PASSWORD</span>()函数返回的混编值，需包含关键字<span class=\"hljs-keyword\">PASSWORD</span>\n<span class=\"hljs-comment\">-- 重命名用户</span>\n<span class=\"hljs-keyword\">RENAME</span> <span class=\"hljs-keyword\">USER</span> old_user <span class=\"hljs-keyword\">TO</span> new_user\n<span class=\"hljs-comment\">-- 设置密码</span>\n<span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">PASSWORD</span> = <span class=\"hljs-keyword\">PASSWORD</span>(<span class=\"hljs-string\">'密码'</span>)  <span class=\"hljs-comment\">-- 为当前用户设置密码</span>\n<span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">PASSWORD</span> <span class=\"hljs-keyword\">FOR</span> 用户名 = <span class=\"hljs-keyword\">PASSWORD</span>(<span class=\"hljs-string\">'密码'</span>) <span class=\"hljs-comment\">-- 为指定用户设置密码</span>\n<span class=\"hljs-comment\">-- 删除用户</span>\n<span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">USER</span> 用户名\n<span class=\"hljs-comment\">-- 分配权限/添加用户</span>\n<span class=\"hljs-keyword\">GRANT</span> 权限列表 <span class=\"hljs-keyword\">ON</span> 表名 <span class=\"hljs-keyword\">TO</span> 用户名 [<span class=\"hljs-keyword\">IDENTIFIED</span> <span class=\"hljs-keyword\">BY</span> [<span class=\"hljs-keyword\">PASSWORD</span>] <span class=\"hljs-string\">'password'</span>]\n    - <span class=\"hljs-keyword\">all</span> <span class=\"hljs-keyword\">privileges</span> 表示所有权限\n    - *.* 表示所有库的所有表\n    - 库名.表名 表示某库下面的某表\n    <span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">PRIVILEGES</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-string\">`pms`</span>.* <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-string\">'pms'</span>@<span class=\"hljs-string\">'%'</span> <span class=\"hljs-keyword\">IDENTIFIED</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">'pms0817'</span>;\n<span class=\"hljs-comment\">-- 查看权限</span>\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">GRANTS</span> <span class=\"hljs-keyword\">FOR</span> 用户名\n    <span class=\"hljs-comment\">-- 查看当前用户权限</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">GRANTS</span>; 或 <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">GRANTS</span> <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-keyword\">CURRENT_USER</span>; 或 <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">GRANTS</span> <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-keyword\">CURRENT_USER</span>();\n<span class=\"hljs-comment\">-- 撤消权限</span>\n<span class=\"hljs-keyword\">REVOKE</span> 权限列表 <span class=\"hljs-keyword\">ON</span> 表名 <span class=\"hljs-keyword\">FROM</span> 用户名\n<span class=\"hljs-keyword\">REVOKE</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">PRIVILEGES</span>, <span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">OPTION</span> <span class=\"hljs-keyword\">FROM</span> 用户名   <span class=\"hljs-comment\">-- 撤销所有权限</span>\n<span class=\"hljs-comment\">-- 权限层级</span>\n<span class=\"hljs-comment\">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span>\n全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user\n    <span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> *.*和 <span class=\"hljs-keyword\">REVOKE</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> *.*只授予和撤销全局权限。\n数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host\n    <span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> db_name.*和<span class=\"hljs-keyword\">REVOKE</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> db_name.*只授予和撤销数据库权限。\n表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv\n    <span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> db_name.tbl_name和<span class=\"hljs-keyword\">REVOKE</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> db_name.tbl_name只授予和撤销表权限。\n列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv\n    当使用<span class=\"hljs-keyword\">REVOKE</span>时，您必须指定与被授权列相同的列。\n<span class=\"hljs-comment\">-- 权限列表</span>\n<span class=\"hljs-keyword\">ALL</span> [<span class=\"hljs-keyword\">PRIVILEGES</span>]    <span class=\"hljs-comment\">-- 设置除GRANT OPTION之外的所有简单权限</span>\n<span class=\"hljs-keyword\">ALTER</span>   <span class=\"hljs-comment\">-- 允许使用ALTER TABLE</span>\n<span class=\"hljs-keyword\">ALTER</span> ROUTINE   <span class=\"hljs-comment\">-- 更改或取消已存储的子程序</span>\n<span class=\"hljs-keyword\">CREATE</span>  <span class=\"hljs-comment\">-- 允许使用CREATE TABLE</span>\n<span class=\"hljs-keyword\">CREATE</span> ROUTINE  <span class=\"hljs-comment\">-- 创建已存储的子程序</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TEMPORARY</span> <span class=\"hljs-keyword\">TABLES</span>     <span class=\"hljs-comment\">-- 允许使用CREATE TEMPORARY TABLE</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span>     <span class=\"hljs-comment\">-- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span>     <span class=\"hljs-comment\">-- 允许使用CREATE VIEW</span>\n<span class=\"hljs-keyword\">DELETE</span>  <span class=\"hljs-comment\">-- 允许使用DELETE</span>\n<span class=\"hljs-keyword\">DROP</span>    <span class=\"hljs-comment\">-- 允许使用DROP TABLE</span>\n<span class=\"hljs-keyword\">EXECUTE</span>     <span class=\"hljs-comment\">-- 允许用户运行已存储的子程序</span>\n<span class=\"hljs-keyword\">FILE</span>    <span class=\"hljs-comment\">-- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span>\n<span class=\"hljs-keyword\">INDEX</span>   <span class=\"hljs-comment\">-- 允许使用CREATE INDEX和DROP INDEX</span>\n<span class=\"hljs-keyword\">INSERT</span>  <span class=\"hljs-comment\">-- 允许使用INSERT</span>\n<span class=\"hljs-keyword\">LOCK</span> <span class=\"hljs-keyword\">TABLES</span>     <span class=\"hljs-comment\">-- 允许对您拥有SELECT权限的表使用LOCK TABLES</span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/MySQL.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>转载 <a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide</a> 项目中收集的各类 MySQL 指令</p>\n</blockquote>\n<!-- TOC -->\n<ul>\n<li><a href=\"#基本操作\">基本操作</a></li>\n<li><a href=\"#数据库操作\">数据库操作</a></li>\n<li><a href=\"#表的操作\">表的操作</a></li>\n<li><a href=\"#字符集编码\">字符集编码</a></li>\n<li><a href=\"#数据类型列类型\">数据类型(列类型)</a></li>\n<li><a href=\"#列属性列约束\">列属性(列约束)</a></li>\n<li><a href=\"#建表规范\">建表规范</a></li>\n<li><a href=\"#UNION\">UNION</a></li>\n<li><a href=\"#子查询\">子查询</a></li>\n<li><a href=\"#连接查询join\">连接查询(join)</a></li>\n<li><a href=\"#TRUNCATE\">TRUNCATE</a></li>\n<li><a href=\"#备份与还原\">备份与还原</a></li>\n<li><a href=\"#视图\">视图</a></li>\n<li><a href=\"#事务transaction\">事务(transaction)</a></li>\n<li><a href=\"#锁表\">锁表</a></li>\n<li><a href=\"#触发器\">触发器</a></li>\n<li><a href=\"#sql编程\">SQL编程</a></li>\n<li><a href=\"#存储过程\">存储过程</a></li>\n<li><a href=\"#用户和权限管理\">用户和权限管理</a></li>\n<li><a href=\"#表维护\">表维护</a></li>\n<li><a href=\"#杂项\">杂项</a></li>\n</ul>\n<!-- /TOC -->\n<h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* Windows服务 */</span>\n<span class=\"hljs-comment\">-- 启动MySQL</span>\nnet <span class=\"hljs-keyword\">start</span> mysql\n<span class=\"hljs-comment\">-- 创建Windows服务</span>\nsc <span class=\"hljs-keyword\">create</span> mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)\n<span class=\"hljs-comment\">/* 连接与断开服务器 */</span>\nmysql -h 地址 -P 端口 -u 用户名 -p 密码\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">PROCESSLIST</span> <span class=\"hljs-comment\">-- 显示哪些线程正在运行</span>\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">VARIABLES</span> <span class=\"hljs-comment\">-- 显示系统变量信息</span></code></pre>\n<h3 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 数据库操作 */</span> <span class=\"hljs-comment\">------------------</span>\n<span class=\"hljs-comment\">-- 查看当前数据库</span>\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DATABASE</span>();\n<span class=\"hljs-comment\">-- 显示当前时间、用户名、数据库版本</span>\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">now</span>(), <span class=\"hljs-keyword\">user</span>(), <span class=\"hljs-keyword\">version</span>();\n<span class=\"hljs-comment\">-- 创建库</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">DATABASE</span>[ <span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">EXISTS</span>] 数据库名 数据库选项\n<span class=\"hljs-comment\"># 数据库选项：</span>\n    <span class=\"hljs-built_in\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> charset_name\n    <span class=\"hljs-keyword\">COLLATE</span> collation_name\n<span class=\"hljs-comment\">-- 查看已有库</span>\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">DATABASES</span>[ <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'PATTERN'</span>]\n<span class=\"hljs-comment\">-- 查看当前库信息</span>\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">DATABASE</span> 数据库名\n<span class=\"hljs-comment\">-- 修改库的选项信息</span>\n<span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">DATABASE</span> 库名 选项信息\n<span class=\"hljs-comment\">-- 删除库</span>\n<span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">DATABASE</span>[ <span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">EXISTS</span>] 数据库名\n<span class=\"hljs-comment\"># 同时删除该数据库相关的目录及其目录内容</span></code></pre>\n<h3 id=\"表的操作\"><a href=\"#表的操作\" class=\"headerlink\" title=\"表的操作\"></a>表的操作</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 创建表</span>\n<span class=\"hljs-keyword\">CREATE</span> [<span class=\"hljs-keyword\">TEMPORARY</span>] <span class=\"hljs-keyword\">TABLE</span>[ <span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">EXISTS</span>] [库名.]表名 ( 表的结构定义 )[ 表选项]\n    每个字段必须有数据类型\n    最后一个字段后不能有逗号\n    <span class=\"hljs-keyword\">TEMPORARY</span> 临时表，会话结束时表自动消失\n    对于字段的定义：\n        字段名 数据类型 [<span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> | <span class=\"hljs-literal\">NULL</span>] [<span class=\"hljs-keyword\">DEFAULT</span> default_value] [AUTO_INCREMENT] [<span class=\"hljs-keyword\">UNIQUE</span> [<span class=\"hljs-keyword\">KEY</span>] | [PRIMARY] <span class=\"hljs-keyword\">KEY</span>] [<span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">'string'</span>]\n            \n<span class=\"hljs-comment\">-- 表选项</span>\n    <span class=\"hljs-comment\">-- 字符集</span>\n        <span class=\"hljs-keyword\">CHARSET</span> = charset_name\n        如果表没有设定，则使用数据库字符集\n    <span class=\"hljs-comment\">-- 存储引擎</span>\n        <span class=\"hljs-keyword\">ENGINE</span> = engine_name\n        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同\n        常见的引擎：<span class=\"hljs-keyword\">InnoDB</span> MyISAM <span class=\"hljs-keyword\">Memory</span>/<span class=\"hljs-keyword\">Heap</span> BDB <span class=\"hljs-keyword\">Merge</span> Example CSV MaxDB <span class=\"hljs-keyword\">Archive</span>\n        不同的引擎在保存表的结构和数据时采用不同的方式\n        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引\n        <span class=\"hljs-keyword\">InnoDB</span>表文件含义：.frm表定义，表空间数据和日志文件\n        <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">ENGINES</span> <span class=\"hljs-comment\">-- 显示存储引擎的状态信息</span>\n        <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">ENGINE</span> 引擎名 &#123;<span class=\"hljs-keyword\">LOGS</span>|<span class=\"hljs-keyword\">STATUS</span>&#125; <span class=\"hljs-comment\">-- 显示存储引擎的日志或状态信息</span>\n    <span class=\"hljs-comment\">-- 自增起始数</span>\n    \tAUTO_INCREMENT = 行数\n    <span class=\"hljs-comment\">-- 数据文件目录</span>\n        <span class=\"hljs-keyword\">DATA</span> <span class=\"hljs-keyword\">DIRECTORY</span> = <span class=\"hljs-string\">'目录'</span>\n    <span class=\"hljs-comment\">-- 索引文件目录</span>\n        <span class=\"hljs-keyword\">INDEX</span> <span class=\"hljs-keyword\">DIRECTORY</span> = <span class=\"hljs-string\">'目录'</span>\n    <span class=\"hljs-comment\">-- 表注释</span>\n        <span class=\"hljs-keyword\">COMMENT</span> = <span class=\"hljs-string\">'string'</span>\n    <span class=\"hljs-comment\">-- 分区选项</span>\n        <span class=\"hljs-keyword\">PARTITION</span> <span class=\"hljs-keyword\">BY</span> ... (详细见手册)\n<span class=\"hljs-comment\">-- 查看所有表</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">TABLES</span>[ <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'pattern'</span>]\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">TABLES</span> <span class=\"hljs-keyword\">FROM</span>  库名\n<span class=\"hljs-comment\">-- 查看表机构</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> 表名 （信息更详细）\n    <span class=\"hljs-keyword\">DESC</span> 表名 / <span class=\"hljs-keyword\">DESCRIBE</span> 表名 / <span class=\"hljs-keyword\">EXPLAIN</span> 表名 / <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">COLUMNS</span> <span class=\"hljs-keyword\">FROM</span> 表名 [<span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'PATTERN'</span>]\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">TABLE</span> <span class=\"hljs-keyword\">STATUS</span> [<span class=\"hljs-keyword\">FROM</span> db_name] [<span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'pattern'</span>]\n<span class=\"hljs-comment\">-- 修改表</span>\n    <span class=\"hljs-comment\">-- 修改表本身的选项</span>\n        <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> 表名 表的选项\n        eg: <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> 表名 <span class=\"hljs-keyword\">ENGINE</span>=MYISAM;\n    <span class=\"hljs-comment\">-- 对表进行重命名</span>\n        <span class=\"hljs-keyword\">RENAME</span> <span class=\"hljs-keyword\">TABLE</span> 原表名 <span class=\"hljs-keyword\">TO</span> 新表名\n        <span class=\"hljs-keyword\">RENAME</span> <span class=\"hljs-keyword\">TABLE</span> 原表名 <span class=\"hljs-keyword\">TO</span> 库名.表名 （可将表移动到另一个数据库）\n        <span class=\"hljs-comment\">-- RENAME可以交换两个表名</span>\n    <span class=\"hljs-comment\">-- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span>\n        <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> 表名 操作名\n        <span class=\"hljs-comment\">-- 操作名</span>\n            <span class=\"hljs-keyword\">ADD</span>[ <span class=\"hljs-keyword\">COLUMN</span>] 字段定义       <span class=\"hljs-comment\">-- 增加字段</span>\n                <span class=\"hljs-keyword\">AFTER</span> 字段名          <span class=\"hljs-comment\">-- 表示增加在该字段名后面</span>\n                <span class=\"hljs-keyword\">FIRST</span>               <span class=\"hljs-comment\">-- 表示增加在第一个</span>\n            <span class=\"hljs-keyword\">ADD</span> PRIMARY <span class=\"hljs-keyword\">KEY</span>(字段名)   <span class=\"hljs-comment\">-- 创建主键</span>\n            <span class=\"hljs-keyword\">ADD</span> <span class=\"hljs-keyword\">UNIQUE</span> [索引名] (字段名)<span class=\"hljs-comment\">-- 创建唯一索引</span>\n            <span class=\"hljs-keyword\">ADD</span> <span class=\"hljs-keyword\">INDEX</span> [索引名] (字段名) <span class=\"hljs-comment\">-- 创建普通索引</span>\n            <span class=\"hljs-keyword\">DROP</span>[ <span class=\"hljs-keyword\">COLUMN</span>] 字段名      <span class=\"hljs-comment\">-- 删除字段</span>\n            <span class=\"hljs-keyword\">MODIFY</span>[ <span class=\"hljs-keyword\">COLUMN</span>] 字段名 字段属性     <span class=\"hljs-comment\">-- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span>\n            <span class=\"hljs-keyword\">CHANGE</span>[ <span class=\"hljs-keyword\">COLUMN</span>] 原字段名 新字段名 字段属性      <span class=\"hljs-comment\">-- 支持对字段名修改</span>\n            <span class=\"hljs-keyword\">DROP</span> PRIMARY <span class=\"hljs-keyword\">KEY</span>    <span class=\"hljs-comment\">-- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span>\n            <span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">INDEX</span> 索引名 <span class=\"hljs-comment\">-- 删除索引</span>\n            <span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">FOREIGN</span> <span class=\"hljs-keyword\">KEY</span> 外键    <span class=\"hljs-comment\">-- 删除外键</span>\n<span class=\"hljs-comment\">-- 删除表</span>\n<span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TABLE</span>[ <span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">EXISTS</span>] 表名 ...\n<span class=\"hljs-comment\">-- 清空表数据</span>\n<span class=\"hljs-keyword\">TRUNCATE</span> [<span class=\"hljs-keyword\">TABLE</span>] 表名\n<span class=\"hljs-comment\">-- 复制表结构</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> 表名 <span class=\"hljs-keyword\">LIKE</span> 要复制的表名\n<span class=\"hljs-comment\">-- 复制表结构和数据</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> 表名 [<span class=\"hljs-keyword\">AS</span>] <span class=\"hljs-keyword\">SELECT</span> * <span class=\"hljs-keyword\">FROM</span> 要复制的表名\n<span class=\"hljs-comment\">-- 检查表是否有错误</span>\n<span class=\"hljs-keyword\">CHECK</span> <span class=\"hljs-keyword\">TABLE</span> tbl_name [, tbl_name] ... [<span class=\"hljs-keyword\">option</span>] ...\n<span class=\"hljs-comment\">-- 优化表</span>\n<span class=\"hljs-keyword\">OPTIMIZE</span> [<span class=\"hljs-keyword\">LOCAL</span> | <span class=\"hljs-keyword\">NO_WRITE_TO_BINLOG</span>] <span class=\"hljs-keyword\">TABLE</span> tbl_name [, tbl_name] ...\n<span class=\"hljs-comment\">-- 修复表</span>\n<span class=\"hljs-keyword\">REPAIR</span> [<span class=\"hljs-keyword\">LOCAL</span> | <span class=\"hljs-keyword\">NO_WRITE_TO_BINLOG</span>] <span class=\"hljs-keyword\">TABLE</span> tbl_name [, tbl_name] ... [<span class=\"hljs-keyword\">QUICK</span>] [<span class=\"hljs-keyword\">EXTENDED</span>] [USE_FRM]\n<span class=\"hljs-comment\">-- 分析表</span>\n<span class=\"hljs-keyword\">ANALYZE</span> [<span class=\"hljs-keyword\">LOCAL</span> | <span class=\"hljs-keyword\">NO_WRITE_TO_BINLOG</span>] <span class=\"hljs-keyword\">TABLE</span> tbl_name [, tbl_name] ...</code></pre>\n<h3 id=\"字符集编码\"><a href=\"#字符集编码\" class=\"headerlink\" title=\"字符集编码\"></a>字符集编码</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 字符集编码 */</span> <span class=\"hljs-comment\">------------------</span>\n<span class=\"hljs-comment\">-- MySQL、数据库、表、字段均可设置编码</span>\n<span class=\"hljs-comment\">-- 数据编码与客户端编码不需一致</span>\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">VARIABLES</span> <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'character_set_%'</span>   <span class=\"hljs-comment\">-- 查看所有字符集编码项</span>\n    character_set_client        客户端向服务器发送数据时使用的编码\n    character_set_results       服务器端将结果返回给客户端所使用的编码\n    character_set_connection    连接层编码\n    \n<span class=\"hljs-keyword\">SET</span> 变量名 = 变量值\n    <span class=\"hljs-keyword\">SET</span> character_set_client = gbk;\n    <span class=\"hljs-keyword\">SET</span> character_set_results = gbk;\n    <span class=\"hljs-keyword\">SET</span> character_set_connection = gbk;\n<span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">NAMES</span> GBK;  <span class=\"hljs-comment\">-- 相当于完成以上三个设置</span>\n\n<span class=\"hljs-comment\">-- 校对集</span>\n    校对集用以排序\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-built_in\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> [<span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'pattern'</span>]/<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">CHARSET</span> [<span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'pattern'</span>]   查看所有字符集\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">COLLATION</span> [<span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'pattern'</span>]     查看所有校对集\n    <span class=\"hljs-keyword\">CHARSET</span> 字符集编码     设置字符集编码\n    <span class=\"hljs-keyword\">COLLATE</span> 校对集编码     设置校对集编码</code></pre>\n<h3 id=\"数据类型-列类型\"><a href=\"#数据类型-列类型\" class=\"headerlink\" title=\"数据类型(列类型)\"></a>数据类型(列类型)</h3><pre><code class=\"hljs sql\">/* 数据类型（列类型） */ ------------------\n1. 数值类型\n-- a. 整型 ----------\n    类型         字节     范围（有符号位）\n    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255\n    smallint    2字节    -32768 ~ 32767\n    mediumint   3字节    -8388608 ~ 8388607\n    int         4字节\n    bigint      8字节\n    int(M)  M表示总位数\n    - 默认存在符号位，unsigned 属性修改\n    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改\n        例：int(5)   插入一个数'123'，补填后为'00123'\n    - 在满足要求的情况下，越小越好。\n    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。\n    \n-- b. 浮点型 ----------\n    类型             字节     范围\n    float(单精度)     4字节\n    double(双精度)    8字节\n    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。\n        不同于整型，前后均会补填0.\n    定义浮点型时，需指定总位数和小数位数。\n        float(M, D)     double(M, D)\n        M表示总位数，D表示小数位数。\n        M和D的大小会决定浮点数的范围。不同于整型的固定范围。\n        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。\n        支持科学计数法表示。\n        浮点数表示近似值。\n        \n-- c. 定点数 ----------\n    decimal -- 可变长度\n    decimal(M, D)   M也表示总位数，D表示小数位数。\n    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。\n    将浮点数转换为字符串来保存，每9位数字保存为4个字节。\n    \n2. 字符串类型\n-- a. char, varchar ----------\n    char    定长字符串，速度快，但浪费空间\n    varchar 变长字符串，速度慢，但节省空间\n    M表示能存储的最大长度，此长度是字符数，非字节数。\n    不同的编码，所占用的空间不同。\n    char,最多255个字符，与编码无关。\n    varchar,最多65535字符，与编码有关。\n    一条有效记录最大不能超过65535个字节。\n        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符\n    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。\n    varchar 的最大有效长度由最大行大小和使用的字符集确定。\n    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。\n    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3\n    \n-- b. blob, text ----------\n    blob 二进制字符串（字节字符串）\n        tinyblob, blob, mediumblob, longblob\n    text 非二进制字符串（字符字符串）\n        tinytext, text, mediumtext, longtext\n    text 在定义时，不需要定义长度，也不会计算总长度。\n    text 类型在定义时，不可给default值\n    \n-- c. binary, varbinary ----------\n    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。\n    char, varchar, text 对应 binary, varbinary, blob.\n    \n3. 日期时间类型\n    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。\n    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59\n    date        3字节    日期         1000-01-01 到 9999-12-31\n    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07\n    time        3字节    时间         -838:59:59 到 838:59:59\n    year        1字节    年份         1901 - 2155\n    \n    datetime    YYYY-MM-DD hh:mm:ss\n    timestamp   YY-MM-DD hh:mm:ss\n                YYYYMMDDhhmmss\n                YYMMDDhhmmss\n                YYYYMMDDhhmmss\n                YYMMDDhhmmss\n    date        YYYY-MM-DD\n                YY-MM-DD\n                YYYYMMDD\n                YYMMDD\n                YYYYMMDD\n                YYMMDD\n    time        hh:mm:ss\n                hhmmss\n                hhmmss\n    year        YYYY\n                YY\n                YYYY\n                YY\n4. 枚举和集合\n-- 枚举(enum) ----------\nenum(val1, val2, val3...)\n    在已知的值中进行单选。最大数量为65535.\n    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。\n    表现为字符串类型，存储却是整型。\n    NULL值的索引是NULL。\n    空字符串错误值的索引值是0。\n    \n-- 集合（set） ----------\nset(val1, val2, val3...)\n    create table tab ( gender set('男', '女', '无') );\n    insert into tab values ('男, 女');\n    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。\n    当创建表时，SET成员值的尾部空格将自动被删除。</code></pre>\n<h3 id=\"列属性-列约束\"><a href=\"#列属性-列约束\" class=\"headerlink\" title=\"列属性(列约束)\"></a>列属性(列约束)</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 列属性（列约束） */</span> <span class=\"hljs-comment\">------------------</span>\n1. PRIMARY 主键\n    - 能唯一标识记录的字段，可以作为主键。\n    - 一个表只能有一个主键。\n    - 主键具有唯一性。\n    - 声明字段时，用 primary key 标识。\n        也可以在字段列表之后声明\n            例：<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> tab ( <span class=\"hljs-keyword\">id</span> <span class=\"hljs-built_in\">int</span>, stu <span class=\"hljs-built_in\">varchar</span>(<span class=\"hljs-number\">10</span>), primary <span class=\"hljs-keyword\">key</span> (<span class=\"hljs-keyword\">id</span>));\n    - 主键字段的值不能为null。\n    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。\n        例：<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> tab ( <span class=\"hljs-keyword\">id</span> <span class=\"hljs-built_in\">int</span>, stu <span class=\"hljs-built_in\">varchar</span>(<span class=\"hljs-number\">10</span>), age <span class=\"hljs-built_in\">int</span>, primary <span class=\"hljs-keyword\">key</span> (stu, age));\n        \n2. UNIQUE 唯一索引（唯一约束）\n    使得某字段的值也不能重复。\n    \n3. NULL 约束\n    null不是数据类型，是列的一个属性。\n    表示当前列是否可以为null，表示什么都没有。\n    null, 允许为空。默认。\n    not null, 不允许为空。\n    <span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> tab <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">'val'</span>);\n        <span class=\"hljs-comment\">-- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span>\n        \n4. DEFAULT 默认值属性\n    当前字段的默认值。\n    <span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> tab <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-keyword\">default</span>, <span class=\"hljs-string\">'val'</span>);    <span class=\"hljs-comment\">-- 此时表示强制使用默认值。</span>\n    <span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> tab ( add_time <span class=\"hljs-built_in\">timestamp</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">current_timestamp</span> );\n        <span class=\"hljs-comment\">-- 表示将当前时间的时间戳设为默认值。</span>\n        current_date, current_time\n        \n5. AUTO_INCREMENT 自动增长约束\n    自动增长必须为索引（主键或unique）\n    只能存在一个字段为自动增长。\n    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 <span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">table</span> tbl auto_increment = x;\n    \n6. <span class=\"hljs-keyword\">COMMENT</span> 注释\n    例：<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> tab ( <span class=\"hljs-keyword\">id</span> <span class=\"hljs-built_in\">int</span> ) <span class=\"hljs-keyword\">comment</span> <span class=\"hljs-string\">'注释内容'</span>;\n    \n7. FOREIGN KEY 外键约束\n    用于限制主表与从表数据完整性。\n    <span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">table</span> t1 <span class=\"hljs-keyword\">add</span> <span class=\"hljs-keyword\">constraint</span> <span class=\"hljs-string\">`t1_t2_fk`</span> <span class=\"hljs-keyword\">foreign</span> <span class=\"hljs-keyword\">key</span> (t1_id) <span class=\"hljs-keyword\">references</span> t2(<span class=\"hljs-keyword\">id</span>);\n        <span class=\"hljs-comment\">-- 将表t1的t1_id外键关联到表t2的id字段。</span>\n        <span class=\"hljs-comment\">-- 每个外键都有一个名字，可以通过 constraint 指定</span>\n    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。\n    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。\n    MySQL中，可以对InnoDB引擎使用外键约束：\n    语法：\n    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]\n    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。\n    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。\n    如果指定了 on <span class=\"hljs-keyword\">update</span> 或 <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">delete</span>：在删除或更新时，有如下几个操作可以选择：\n    <span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">cascade</span>，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。\n    <span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">set</span> <span class=\"hljs-literal\">null</span>，设置为<span class=\"hljs-literal\">null</span>。主表数据被更新（主键值更新），从表的外键被设置为<span class=\"hljs-literal\">null</span>。主表记录被删除，从表相关记录外键被设置成<span class=\"hljs-literal\">null</span>。但注意，要求该外键列，没有<span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">null</span>属性约束。\n    <span class=\"hljs-number\">3.</span> restrict，拒绝父表删除和更新。\n    注意，外键只被<span class=\"hljs-keyword\">InnoDB</span>存储引擎所支持。其他引擎是不支持的。</code></pre>\n<h3 id=\"建表规范\"><a href=\"#建表规范\" class=\"headerlink\" title=\"建表规范\"></a>建表规范</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 建表规范 */</span> <span class=\"hljs-comment\">------------------</span>\n    <span class=\"hljs-comment\">-- Normal Format, NF</span>\n        - 每个表保存一个实体信息\n        - 每个具有一个ID字段作为主键\n        - ID主键 + 原子表\n        \n    <span class=\"hljs-comment\">-- 1NF, 第一范式</span>\n        字段不能再分，就满足第一范式。\n        \n    <span class=\"hljs-comment\">-- 2NF, 第二范式</span>\n        满足第一范式的前提下，不能出现部分依赖。\n        消除符合主键就可以避免部分依赖。增加单列关键字。\n        \n    <span class=\"hljs-comment\">-- 3NF, 第三范式</span>\n        满足第二范式的前提下，不能出现传递依赖。\n        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。\n        将一个实体信息的数据放在一个表内实现。</code></pre>\n<h3 id=\"UNION\"><a href=\"#UNION\" class=\"headerlink\" title=\"UNION\"></a>UNION</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* UNION */</span> <span class=\"hljs-comment\">------------------</span>\n    将多个<span class=\"hljs-keyword\">select</span>查询的结果组合成一个结果集合。\n    <span class=\"hljs-keyword\">SELECT</span> ... <span class=\"hljs-keyword\">UNION</span> [<span class=\"hljs-keyword\">ALL</span>|<span class=\"hljs-keyword\">DISTINCT</span>] <span class=\"hljs-keyword\">SELECT</span> ...\n    默认 <span class=\"hljs-keyword\">DISTINCT</span> 方式，即所有返回的行都是唯一的\n    建议，对每个<span class=\"hljs-keyword\">SELECT</span>查询加上小括号包裹。\n    <span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> 排序时，需加上 <span class=\"hljs-keyword\">LIMIT</span> 进行结合。\n    需要各<span class=\"hljs-keyword\">select</span>查询的字段数量一样。\n    每个<span class=\"hljs-keyword\">select</span>查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条<span class=\"hljs-keyword\">select</span>语句为准。</code></pre>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 子查询 */</span> <span class=\"hljs-comment\">------------------</span>\n    - 子查询需用括号包裹。\n    \n<span class=\"hljs-comment\">-- from型</span>\n    from后要求是一个表，必须给子查询结果取个别名。\n    - 简化每个查询内的条件。\n    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。\n    - 子查询返回一个表，表型子查询。\n    <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> (<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> tb <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">id</span>&gt;<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">as</span> subfrom <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">id</span>&gt;<span class=\"hljs-number\">1</span>;\n    \n<span class=\"hljs-comment\">-- where型</span>\n    - 子查询返回一个值，标量子查询。\n    - 不需要给子查询取别名。\n    - where子查询内的表，不能直接用以更新。\n    <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> tb <span class=\"hljs-keyword\">where</span> money = (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">max</span>(money) <span class=\"hljs-keyword\">from</span> tb);\n    \n    <span class=\"hljs-comment\">-- 列子查询</span>\n        如果子查询结果返回的是一列。\n        使用 in 或 not in 完成查询\n        exists 和 not exists 条件\n            如果子查询返回数据，则返回1或0。常用于判断条件。\n            <span class=\"hljs-keyword\">select</span> column1 <span class=\"hljs-keyword\">from</span> t1 <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">exists</span> (<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> t2);\n            \n    <span class=\"hljs-comment\">-- 行子查询</span>\n        查询条件是一个行。\n        <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> t1 <span class=\"hljs-keyword\">where</span> (<span class=\"hljs-keyword\">id</span>, gender) <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">id</span>, gender <span class=\"hljs-keyword\">from</span> t2);\n        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)\n        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。\n        \n    <span class=\"hljs-comment\">-- 特殊运算符</span>\n    != all()    相当于 not in\n    = some()    相当于 in。any 是 some 的别名\n    != some()   不等同于 not in，不等于其中某一个。\n    all, some 可以配合其他运算符一起使用。</code></pre>\n<h3 id=\"连接查询-join\"><a href=\"#连接查询-join\" class=\"headerlink\" title=\"连接查询(join)\"></a>连接查询(join)</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 连接查询(join) */</span> <span class=\"hljs-comment\">------------------</span>\n    将多个表的字段进行连接，可以指定连接条件。\n    \n<span class=\"hljs-comment\">-- 内连接(inner join)</span>\n    - 默认就是内连接，可省略inner。\n    - 只有数据存在时才能发送连接。即连接结果不能出现空行。\n    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）\n    也可用where表示连接条件。\n    还有 using, 但需字段名相同。 using(字段名)\n    <span class=\"hljs-comment\">-- 交叉连接 cross join</span>\n        即，没有条件的内连接。\n        <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> tb1 <span class=\"hljs-keyword\">cross</span> <span class=\"hljs-keyword\">join</span> tb2;\n        \n<span class=\"hljs-comment\">-- 外连接(outer join)</span>\n    - 如果数据不存在，也会出现在连接结果中。\n    <span class=\"hljs-comment\">-- 左外连接 left join</span>\n        如果数据不存在，左表记录会出现，而右表为null填充\n    <span class=\"hljs-comment\">-- 右外连接 right join</span>\n        如果数据不存在，右表记录会出现，而左表为null填充\n        \n<span class=\"hljs-comment\">-- 自然连接(natural join)</span>\n    自动判断连接条件完成连接。\n    相当于省略了using，会自动查找相同字段名。\n    natural join\n    natural left join\n    natural right join\n<span class=\"hljs-keyword\">select</span> info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex <span class=\"hljs-keyword\">from</span> info, extra_info <span class=\"hljs-keyword\">where</span> info.stu_num = extra_info.stu_id;</code></pre>\n<h3 id=\"TRUNCATE\"><a href=\"#TRUNCATE\" class=\"headerlink\" title=\"TRUNCATE\"></a>TRUNCATE</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* TRUNCATE */</span> <span class=\"hljs-comment\">------------------</span>\n<span class=\"hljs-keyword\">TRUNCATE</span> [<span class=\"hljs-keyword\">TABLE</span>] tbl_name\n清空数据\n删除重建表\n区别：\n<span class=\"hljs-number\">1</span>，<span class=\"hljs-keyword\">truncate</span> 是删除表再创建，<span class=\"hljs-keyword\">delete</span> 是逐条删除\n<span class=\"hljs-number\">2</span>，<span class=\"hljs-keyword\">truncate</span> 重置auto_increment的值。而<span class=\"hljs-keyword\">delete</span>不会\n<span class=\"hljs-number\">3</span>，<span class=\"hljs-keyword\">truncate</span> 不知道删除了几条，而<span class=\"hljs-keyword\">delete</span>知道。\n<span class=\"hljs-number\">4</span>，当被用于带分区的表时，<span class=\"hljs-keyword\">truncate</span> 会保留分区</code></pre>\n<h3 id=\"备份与还原\"><a href=\"#备份与还原\" class=\"headerlink\" title=\"备份与还原\"></a>备份与还原</h3><pre><code class=\"hljs sql\">/* 备份与还原 */ ------------------\n备份，将数据的结构与表内数据保存起来。\n利用 mysqldump 指令完成。\n\n-- 导出\nmysqldump [options] db_name [tables]\nmysqldump [options] ---database DB1 [DB2 DB3...]\nmysqldump [options] --all--database\n1. 导出一张表\n　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)\n2. 导出多张表\n　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)\n3. 导出所有表\n　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)\n4. 导出一个库\n　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)\n可以-w携带WHERE条件\n\n-- 导入\n1. 在登录mysql的情况下：\n　　source  备份文件\n2. 在不登录的情况下\n　　mysql -u用户名 -p密码 库名 &lt; 备份文件</code></pre>\n<h3 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h3><pre><code class=\"hljs sql\">什么是视图：\n    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。\n    视图具有表结构文件，但不存在数据文件。\n    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。\n    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。\n\n<span class=\"hljs-comment\">-- 创建视图</span>\n<span class=\"hljs-keyword\">CREATE</span> [<span class=\"hljs-keyword\">OR</span> <span class=\"hljs-keyword\">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class=\"hljs-keyword\">MERGE</span> | TEMPTABLE&#125;] <span class=\"hljs-keyword\">VIEW</span> view_name [(column_list)] <span class=\"hljs-keyword\">AS</span> select_statement\n    - 视图名必须唯一，同时不能与表重名。\n    - 视图可以使用<span class=\"hljs-keyword\">select</span>语句查询到的列名，也可以自己指定相应的列名。\n    - 可以指定视图执行的算法，通过ALGORITHM指定。\n    - column_list如果存在，则数目必须等于<span class=\"hljs-keyword\">SELECT</span>语句检索的列数\n    \n<span class=\"hljs-comment\">-- 查看结构</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> view_name\n    \n<span class=\"hljs-comment\">-- 删除视图</span>\n    - 删除视图后，数据依然存在。\n    - 可同时删除多个视图。\n    <span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">VIEW</span> [<span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">EXISTS</span>] view_name ...\n    \n<span class=\"hljs-comment\">-- 修改视图结构</span>\n    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。\n    <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">VIEW</span> view_name [(column_list)] <span class=\"hljs-keyword\">AS</span> select_statement\n    \n<span class=\"hljs-comment\">-- 视图作用</span>\n    <span class=\"hljs-number\">1.</span> 简化业务逻辑\n    <span class=\"hljs-number\">2.</span> 对客户端隐藏真实的表结构\n    \n<span class=\"hljs-comment\">-- 视图算法(ALGORITHM)</span>\n    <span class=\"hljs-keyword\">MERGE</span>       合并\n        将视图的查询语句，与外部查询需要先合并再执行！\n    TEMPTABLE   临时表\n        将视图执行完毕后，形成临时表，再做外层查询！\n    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</code></pre>\n<h3 id=\"事务-transaction\"><a href=\"#事务-transaction\" class=\"headerlink\" title=\"事务(transaction)\"></a>事务(transaction)</h3><pre><code class=\"hljs sql\">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。\n    - 支持连续SQL的集体成功或集体撤销。\n    - 事务是数据库在数据晚自习方面的一个功能。\n    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。\n    - InnoDB被称为事务安全型引擎。\n    \n<span class=\"hljs-comment\">-- 事务开启</span>\n    <span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>; 或者 <span class=\"hljs-keyword\">BEGIN</span>;\n    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。\n    \n<span class=\"hljs-comment\">-- 事务提交</span>\n    <span class=\"hljs-keyword\">COMMIT</span>;\n    \n<span class=\"hljs-comment\">-- 事务回滚</span>\n    <span class=\"hljs-keyword\">ROLLBACK</span>;\n    如果部分操作发生问题，映射到事务开启前。\n    \n<span class=\"hljs-comment\">-- 事务的特性</span>\n    1. 原子性（Atomicity）\n        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n    2. 一致性（Consistency）\n        事务前后数据的完整性必须保持一致。\n        - 事务开始和结束时，外部数据一致\n        - 在整个事务过程中，操作是连续的\n    3. 隔离性（Isolation）\n        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。\n    4. 持久性（Durability）\n        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。\n        \n<span class=\"hljs-comment\">-- 事务的实现</span>\n    1. 要求是事务支持的表类型\n    2. 执行一组相关的操作前开启事务\n    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。\n    \n<span class=\"hljs-comment\">-- 事务的原理</span>\n    利用InnoDB的自动提交(autocommit)特性完成。\n    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。\n    而事务是暂时关闭“自动提交”机制，需要<span class=\"hljs-keyword\">commit</span>提交持久化数据操作。\n    \n<span class=\"hljs-comment\">-- 注意</span>\n    <span class=\"hljs-number\">1.</span> 数据定义语言（<span class=\"hljs-keyword\">DDL</span>）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。\n    <span class=\"hljs-number\">2.</span> 事务不能被嵌套\n    \n<span class=\"hljs-comment\">-- 保存点</span>\n    <span class=\"hljs-keyword\">SAVEPOINT</span> 保存点名称 <span class=\"hljs-comment\">-- 设置一个事务保存点</span>\n    <span class=\"hljs-keyword\">ROLLBACK</span> <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-keyword\">SAVEPOINT</span> 保存点名称 <span class=\"hljs-comment\">-- 回滚到保存点</span>\n    <span class=\"hljs-keyword\">RELEASE</span> <span class=\"hljs-keyword\">SAVEPOINT</span> 保存点名称 <span class=\"hljs-comment\">-- 删除保存点</span>\n    \n<span class=\"hljs-comment\">-- InnoDB自动提交特性设置</span>\n    <span class=\"hljs-keyword\">SET</span> autocommit = <span class=\"hljs-number\">0</span>|<span class=\"hljs-number\">1</span>;   0表示关闭自动提交，1表示开启自动提交。\n    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要<span class=\"hljs-keyword\">commit</span>提交后才能持久化数据操作。\n    - 也可以关闭自动提交来开启事务。但与<span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>不同的是，\n        <span class=\"hljs-keyword\">SET</span> autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)\n        而<span class=\"hljs-keyword\">START</span> <span class=\"hljs-keyword\">TRANSACTION</span>记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</code></pre>\n<h3 id=\"锁表\"><a href=\"#锁表\" class=\"headerlink\" title=\"锁表\"></a>锁表</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 锁表 */</span>\n表锁定只用于防止其它客户端进行不正当地读取和写入\nMyISAM 支持表锁，InnoDB 支持行锁\n<span class=\"hljs-comment\">-- 锁定</span>\n    <span class=\"hljs-keyword\">LOCK</span> <span class=\"hljs-keyword\">TABLES</span> tbl_name [<span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">alias</span>]\n<span class=\"hljs-comment\">-- 解锁</span>\n    <span class=\"hljs-keyword\">UNLOCK</span> <span class=\"hljs-keyword\">TABLES</span></code></pre>\n<h3 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 触发器 */</span> <span class=\"hljs-comment\">------------------</span>\n    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象\n    监听：记录的增加、修改、删除。\n    \n<span class=\"hljs-comment\">-- 创建触发器</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TRIGGER</span> trigger_name trigger_time trigger_event <span class=\"hljs-keyword\">ON</span> tbl_name <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-keyword\">EACH</span> <span class=\"hljs-keyword\">ROW</span> trigger_stmt\n    参数：\n    trigger_time是触发程序的动作时间。它可以是 <span class=\"hljs-keyword\">before</span> 或 <span class=\"hljs-keyword\">after</span>，以指明触发程序是在激活它的语句之前或之后触发。\n    trigger_event指明了激活触发程序的语句的类型\n        <span class=\"hljs-keyword\">INSERT</span>：将新行插入表时激活触发程序\n        <span class=\"hljs-keyword\">UPDATE</span>：更改某一行时激活触发程序\n        <span class=\"hljs-keyword\">DELETE</span>：从表中删除某一行时激活触发程序\n    tbl_name：监听的表，必须是永久性的表，不能将触发程序与<span class=\"hljs-keyword\">TEMPORARY</span>表或视图关联起来。\n    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构\n    \n<span class=\"hljs-comment\">-- 删除</span>\n<span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TRIGGER</span> [schema_name.]trigger_name\n可以使用<span class=\"hljs-keyword\">old</span>和<span class=\"hljs-keyword\">new</span>代替旧的和新的数据\n    更新操作，更新前是<span class=\"hljs-keyword\">old</span>，更新后是new.\n    删除操作，只有old.\n    增加操作，只有new.\n<span class=\"hljs-comment\">-- 注意</span>\n    <span class=\"hljs-number\">1.</span> 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。\n    \n<span class=\"hljs-comment\">-- 字符连接函数</span>\n<span class=\"hljs-keyword\">concat</span>(str1,str2,...])\n<span class=\"hljs-keyword\">concat_ws</span>(separator,str1,str2,...)\n<span class=\"hljs-comment\">-- 分支语句</span>\n<span class=\"hljs-keyword\">if</span> 条件 <span class=\"hljs-keyword\">then</span>\n    执行语句\nelseif 条件 <span class=\"hljs-keyword\">then</span>\n    执行语句\n<span class=\"hljs-keyword\">else</span>\n    执行语句\n<span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">if</span>;\n<span class=\"hljs-comment\">-- 修改最外层语句结束符</span>\ndelimiter 自定义结束符号\n    SQL语句\n自定义结束符号\ndelimiter ;     <span class=\"hljs-comment\">-- 修改回原来的分号</span>\n<span class=\"hljs-comment\">-- 语句块包裹</span>\n<span class=\"hljs-keyword\">begin</span>\n    语句块\n<span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-comment\">-- 特殊的执行</span>\n<span class=\"hljs-number\">1.</span> 只要添加记录，就会触发程序。\n<span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">Insert</span> <span class=\"hljs-keyword\">into</span> <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">duplicate</span> <span class=\"hljs-keyword\">key</span> <span class=\"hljs-keyword\">update</span> 语法会触发：\n    如果没有重复记录，会触发 <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">insert</span>, <span class=\"hljs-keyword\">after</span> <span class=\"hljs-keyword\">insert</span>;\n    如果有重复记录并更新，会触发 before <span class=\"hljs-keyword\">insert</span>, <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">update</span>, <span class=\"hljs-keyword\">after</span> <span class=\"hljs-keyword\">update</span>;\n    如果有重复记录但是没有发生更新，则触发 before <span class=\"hljs-keyword\">insert</span>, <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">update</span>\n<span class=\"hljs-number\">3.</span> <span class=\"hljs-keyword\">Replace</span> 语法 如果有记录，则执行 <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">insert</span>, <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">delete</span>, <span class=\"hljs-keyword\">after</span> <span class=\"hljs-keyword\">delete</span>, <span class=\"hljs-keyword\">after</span> <span class=\"hljs-keyword\">insert</span></code></pre>\n<h3 id=\"SQL编程\"><a href=\"#SQL编程\" class=\"headerlink\" title=\"SQL编程\"></a>SQL编程</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* SQL编程 */</span> <span class=\"hljs-comment\">------------------</span>\n<span class=\"hljs-comment\">--// 局部变量 ----------</span>\n<span class=\"hljs-comment\">-- 变量声明</span>\n    <span class=\"hljs-keyword\">declare</span> var_name[,...] <span class=\"hljs-keyword\">type</span> [<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">value</span>]\n    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个<span class=\"hljs-keyword\">default</span>子句。值可以被指定为一个表达式，不需要为一个常数。如果没有<span class=\"hljs-keyword\">default</span>子句，初始值为<span class=\"hljs-literal\">null</span>。\n<span class=\"hljs-comment\">-- 赋值</span>\n    使用 <span class=\"hljs-keyword\">set</span> 和 <span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">into</span> 语句为变量赋值。\n    - 注意：在函数内是可以使用全局变量（用户自定义的变量）\n<span class=\"hljs-comment\">--// 全局变量 ----------</span>\n<span class=\"hljs-comment\">-- 定义、赋值</span>\n<span class=\"hljs-keyword\">set</span> 语句可以定义并为变量赋值。\n<span class=\"hljs-keyword\">set</span> @<span class=\"hljs-keyword\">var</span> = <span class=\"hljs-keyword\">value</span>;\n也可以使用<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">into</span>语句为变量初始化并赋值。这样要求<span class=\"hljs-keyword\">select</span>语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。\n还可以把赋值语句看作一个表达式，通过<span class=\"hljs-keyword\">select</span>执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（<span class=\"hljs-keyword\">set</span>语句可以使用= 和 :=）。\n<span class=\"hljs-keyword\">select</span> @<span class=\"hljs-keyword\">var</span>:=<span class=\"hljs-number\">20</span>;\n<span class=\"hljs-keyword\">select</span> @v1:=<span class=\"hljs-keyword\">id</span>, @v2=<span class=\"hljs-keyword\">name</span> <span class=\"hljs-keyword\">from</span> t1 <span class=\"hljs-keyword\">limit</span> <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> tbl_name <span class=\"hljs-keyword\">where</span> @<span class=\"hljs-keyword\">var</span>:=<span class=\"hljs-number\">30</span>;\n<span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">into</span> 可以将表中查询获得的数据赋给变量。\n    -| <span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">max</span>(height) <span class=\"hljs-keyword\">into</span> @max_height <span class=\"hljs-keyword\">from</span> tb;\n<span class=\"hljs-comment\">-- 自定义变量名</span>\n为了避免<span class=\"hljs-keyword\">select</span>语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。\n@<span class=\"hljs-keyword\">var</span>=<span class=\"hljs-number\">10</span>;\n    - 变量被定义后，在整个会话周期都有效（登录到退出）\n<span class=\"hljs-comment\">--// 控制结构 ----------</span>\n<span class=\"hljs-comment\">-- if语句</span>\nif search_condition then\n    statement_list   \n[elseif search_condition then\n    statement_list]\n...\n[else\n    statement_list]\n<span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">if</span>;\n<span class=\"hljs-comment\">-- case语句</span>\nCASE value WHEN [compare-value] THEN result\n[WHEN [compare-value] THEN result ...]\n[ELSE result]\n<span class=\"hljs-keyword\">END</span>\n<span class=\"hljs-comment\">-- while循环</span>\n[begin_label:] <span class=\"hljs-keyword\">while</span> search_condition <span class=\"hljs-keyword\">do</span>\n    statement_list\n<span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">while</span> [end_label];\n- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。\n    <span class=\"hljs-comment\">-- 退出循环</span>\n        退出整个循环 leave\n        退出当前循环 iterate\n        通过退出的标签决定退出哪个循环\n<span class=\"hljs-comment\">--// 内置函数 ----------</span>\n<span class=\"hljs-comment\">-- 数值函数</span>\nabs(x)          <span class=\"hljs-comment\">-- 绝对值 abs(-10.9) = 10</span>\nformat(x, d)    <span class=\"hljs-comment\">-- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46</span>\nceil(x)         <span class=\"hljs-comment\">-- 向上取整 ceil(10.1) = 11</span>\nfloor(x)        <span class=\"hljs-comment\">-- 向下取整 floor (10.1) = 10</span>\nround(x)        <span class=\"hljs-comment\">-- 四舍五入去整</span>\nmod(m, n)       <span class=\"hljs-comment\">-- m%n m mod n 求余 10%3=1</span>\npi()            <span class=\"hljs-comment\">-- 获得圆周率</span>\npow(m, n)       <span class=\"hljs-comment\">-- m^n</span>\nsqrt(x)         <span class=\"hljs-comment\">-- 算术平方根</span>\nrand()          <span class=\"hljs-comment\">-- 随机数</span>\n<span class=\"hljs-keyword\">truncate</span>(x, d)  <span class=\"hljs-comment\">-- 截取d位小数</span>\n<span class=\"hljs-comment\">-- 时间日期函数</span>\n<span class=\"hljs-keyword\">now</span>(), <span class=\"hljs-keyword\">current_timestamp</span>();     <span class=\"hljs-comment\">-- 当前日期时间</span>\ncurrent_date();                 <span class=\"hljs-comment\">-- 当前日期</span>\ncurrent_time();                 <span class=\"hljs-comment\">-- 当前时间</span>\ndate('yyyy-mm-dd hh:ii:ss');    <span class=\"hljs-comment\">-- 获取日期部分</span>\ntime('yyyy-mm-dd hh:ii:ss');    <span class=\"hljs-comment\">-- 获取时间部分</span>\ndate_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); <span class=\"hljs-comment\">-- 格式化时间</span>\nunix_timestamp();               <span class=\"hljs-comment\">-- 获得unix时间戳</span>\nfrom_unixtime();                <span class=\"hljs-comment\">-- 从时间戳获得时间</span>\n<span class=\"hljs-comment\">-- 字符串函数</span>\nlength(string)          <span class=\"hljs-comment\">-- string长度，字节</span>\nchar_length(string)     <span class=\"hljs-comment\">-- string的字符个数</span>\nsubstring(str, position [,length])      <span class=\"hljs-comment\">-- 从str的position开始,取length个字符</span>\n<span class=\"hljs-keyword\">replace</span>(<span class=\"hljs-keyword\">str</span> ,search_str ,replace_str)   <span class=\"hljs-comment\">-- 在str中用replace_str替换search_str</span>\n<span class=\"hljs-keyword\">instr</span>(<span class=\"hljs-keyword\">string</span> ,<span class=\"hljs-keyword\">substring</span>)    <span class=\"hljs-comment\">-- 返回substring首次在string中出现的位置</span>\n<span class=\"hljs-keyword\">concat</span>(<span class=\"hljs-keyword\">string</span> [,...])   <span class=\"hljs-comment\">-- 连接字串</span>\n<span class=\"hljs-keyword\">charset</span>(<span class=\"hljs-keyword\">str</span>)            <span class=\"hljs-comment\">-- 返回字串字符集</span>\n<span class=\"hljs-keyword\">lcase</span>(<span class=\"hljs-keyword\">string</span>)           <span class=\"hljs-comment\">-- 转换成小写</span>\n<span class=\"hljs-keyword\">left</span>(<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">length</span>)    <span class=\"hljs-comment\">-- 从string2中的左边起取length个字符</span>\n<span class=\"hljs-keyword\">load_file</span>(file_name)    <span class=\"hljs-comment\">-- 从文件读取内容</span>\n<span class=\"hljs-keyword\">locate</span>(<span class=\"hljs-keyword\">substring</span>, <span class=\"hljs-keyword\">string</span> [,start_position]) <span class=\"hljs-comment\">-- 同instr,但可指定开始位置</span>\n<span class=\"hljs-keyword\">lpad</span>(<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">length</span>, <span class=\"hljs-keyword\">pad</span>)   <span class=\"hljs-comment\">-- 重复用pad加在string开头,直到字串长度为length</span>\n<span class=\"hljs-keyword\">ltrim</span>(<span class=\"hljs-keyword\">string</span>)           <span class=\"hljs-comment\">-- 去除前端空格</span>\n<span class=\"hljs-keyword\">repeat</span>(<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">count</span>)   <span class=\"hljs-comment\">-- 重复count次</span>\nrpad(<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">length</span>, <span class=\"hljs-keyword\">pad</span>)   <span class=\"hljs-comment\">--在str后用pad补充,直到长度为length</span>\n<span class=\"hljs-keyword\">rtrim</span>(<span class=\"hljs-keyword\">string</span>)           <span class=\"hljs-comment\">-- 去除后端空格</span>\n<span class=\"hljs-keyword\">strcmp</span>(string1 ,string2)    <span class=\"hljs-comment\">-- 逐字符比较两字串大小</span>\n<span class=\"hljs-comment\">-- 流程函数</span>\n<span class=\"hljs-keyword\">case</span> <span class=\"hljs-keyword\">when</span> [condition] <span class=\"hljs-keyword\">then</span> <span class=\"hljs-keyword\">result</span> [<span class=\"hljs-keyword\">when</span> [condition] <span class=\"hljs-keyword\">then</span> <span class=\"hljs-keyword\">result</span> ...] [<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">result</span>] <span class=\"hljs-keyword\">end</span>   多分支\n<span class=\"hljs-keyword\">if</span>(expr1,expr2,expr3)  双分支。\n<span class=\"hljs-comment\">-- 聚合函数</span>\n<span class=\"hljs-keyword\">count</span>()\n<span class=\"hljs-keyword\">sum</span>();\nmax();\nmin();\navg();\ngroup_concat()\n<span class=\"hljs-comment\">-- 其他常用函数</span>\nmd5();\ndefault();\n<span class=\"hljs-comment\">--// 存储函数，自定义函数 ----------</span>\n<span class=\"hljs-comment\">-- 新建</span>\n    <span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">FUNCTION</span> function_name (参数列表) <span class=\"hljs-keyword\">RETURNS</span> 返回值类型\n        函数体\n    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。\n    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。\n    - 参数部分，由<span class=\"hljs-string\">\"参数名\"</span>和<span class=\"hljs-string\">\"参数类型\"</span>组成。多个参数用逗号隔开。\n    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。\n    - 多条语句应该使用 begin...end 语句块包含。\n    - 一定要有 <span class=\"hljs-keyword\">return</span> 返回值语句。\n<span class=\"hljs-comment\">-- 删除</span>\n    <span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">FUNCTION</span> [<span class=\"hljs-keyword\">IF</span> <span class=\"hljs-keyword\">EXISTS</span>] function_name;\n<span class=\"hljs-comment\">-- 查看</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">FUNCTION</span> <span class=\"hljs-keyword\">STATUS</span> <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">'partten'</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">FUNCTION</span> function_name;\n<span class=\"hljs-comment\">-- 修改</span>\n    <span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">FUNCTION</span> function_name 函数选项\n<span class=\"hljs-comment\">--// 存储过程，自定义功能 ----------</span>\n<span class=\"hljs-comment\">-- 定义</span>\n存储存储过程 是一段代码（过程），存储在数据库中的<span class=\"hljs-keyword\">sql</span>组成。\n一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。\n而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过<span class=\"hljs-keyword\">call</span>执行。\n<span class=\"hljs-comment\">-- 创建</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">PROCEDURE</span> sp_name (参数列表)\n    过程体\n参数列表：不同于函数的参数列表，需要指明参数类型\n<span class=\"hljs-keyword\">IN</span>，表示输入型\n<span class=\"hljs-keyword\">OUT</span>，表示输出型\nINOUT，表示混合型\n注意，没有返回值。</code></pre>\n<h3 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 存储过程 */</span> <span class=\"hljs-comment\">------------------</span>\n存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。\n调用：<span class=\"hljs-keyword\">CALL</span> 过程名\n<span class=\"hljs-comment\">-- 注意</span>\n- 没有返回值。\n- 只能单独调用，不可夹杂在其他语句中\n<span class=\"hljs-comment\">-- 参数</span>\n<span class=\"hljs-keyword\">IN</span>|<span class=\"hljs-keyword\">OUT</span>|INOUT 参数名 数据类型\n<span class=\"hljs-keyword\">IN</span>      输入：在调用过程中，将数据输入到过程体内部的参数\n<span class=\"hljs-keyword\">OUT</span>     输出：在调用过程中，将过程体处理完的结果返回到客户端\nINOUT   输入输出：既可输入，也可输出\n<span class=\"hljs-comment\">-- 语法</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">PROCEDURE</span> 过程名 (参数列表)\n<span class=\"hljs-keyword\">BEGIN</span>\n    过程体\n<span class=\"hljs-keyword\">END</span></code></pre>\n<h3 id=\"用户和权限管理\"><a href=\"#用户和权限管理\" class=\"headerlink\" title=\"用户和权限管理\"></a>用户和权限管理</h3><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">/* 用户和权限管理 */</span> <span class=\"hljs-comment\">------------------</span>\n<span class=\"hljs-comment\">-- root密码重置</span>\n1. 停止MySQL服务\n2.  [Linux] /usr/local/mysql/bin/safe_mysqld <span class=\"hljs-comment\">--skip-grant-tables &amp;</span>\n    [Windows] mysqld <span class=\"hljs-comment\">--skip-grant-tables</span>\n3. <span class=\"hljs-keyword\">use</span> mysql;\n4. <span class=\"hljs-keyword\">UPDATE</span> <span class=\"hljs-string\">`user`</span> <span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">PASSWORD</span>=<span class=\"hljs-keyword\">PASSWORD</span>(<span class=\"hljs-string\">\"密码\"</span>) <span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-string\">`user`</span> = <span class=\"hljs-string\">\"root\"</span>;\n5. <span class=\"hljs-keyword\">FLUSH</span> <span class=\"hljs-keyword\">PRIVILEGES</span>;\n用户信息表：mysql.user\n<span class=\"hljs-comment\">-- 刷新权限</span>\n<span class=\"hljs-keyword\">FLUSH</span> <span class=\"hljs-keyword\">PRIVILEGES</span>;\n<span class=\"hljs-comment\">-- 增加用户</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span> 用户名 <span class=\"hljs-keyword\">IDENTIFIED</span> <span class=\"hljs-keyword\">BY</span> [<span class=\"hljs-keyword\">PASSWORD</span>] 密码(字符串)\n    - 必须拥有mysql数据库的全局<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span>权限，或拥有<span class=\"hljs-keyword\">INSERT</span>权限。\n    - 只能创建用户，不能赋予权限。\n    - 用户名，注意引号：如 <span class=\"hljs-string\">'user_name'</span>@<span class=\"hljs-string\">'192.168.1.1'</span>\n    - 密码也需引号，纯数字密码也要加引号\n    - 要在纯文本中指定密码，需忽略<span class=\"hljs-keyword\">PASSWORD</span>关键词。要把密码指定为由<span class=\"hljs-keyword\">PASSWORD</span>()函数返回的混编值，需包含关键字<span class=\"hljs-keyword\">PASSWORD</span>\n<span class=\"hljs-comment\">-- 重命名用户</span>\n<span class=\"hljs-keyword\">RENAME</span> <span class=\"hljs-keyword\">USER</span> old_user <span class=\"hljs-keyword\">TO</span> new_user\n<span class=\"hljs-comment\">-- 设置密码</span>\n<span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">PASSWORD</span> = <span class=\"hljs-keyword\">PASSWORD</span>(<span class=\"hljs-string\">'密码'</span>)  <span class=\"hljs-comment\">-- 为当前用户设置密码</span>\n<span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">PASSWORD</span> <span class=\"hljs-keyword\">FOR</span> 用户名 = <span class=\"hljs-keyword\">PASSWORD</span>(<span class=\"hljs-string\">'密码'</span>) <span class=\"hljs-comment\">-- 为指定用户设置密码</span>\n<span class=\"hljs-comment\">-- 删除用户</span>\n<span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">USER</span> 用户名\n<span class=\"hljs-comment\">-- 分配权限/添加用户</span>\n<span class=\"hljs-keyword\">GRANT</span> 权限列表 <span class=\"hljs-keyword\">ON</span> 表名 <span class=\"hljs-keyword\">TO</span> 用户名 [<span class=\"hljs-keyword\">IDENTIFIED</span> <span class=\"hljs-keyword\">BY</span> [<span class=\"hljs-keyword\">PASSWORD</span>] <span class=\"hljs-string\">'password'</span>]\n    - <span class=\"hljs-keyword\">all</span> <span class=\"hljs-keyword\">privileges</span> 表示所有权限\n    - *.* 表示所有库的所有表\n    - 库名.表名 表示某库下面的某表\n    <span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">PRIVILEGES</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-string\">`pms`</span>.* <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-string\">'pms'</span>@<span class=\"hljs-string\">'%'</span> <span class=\"hljs-keyword\">IDENTIFIED</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">'pms0817'</span>;\n<span class=\"hljs-comment\">-- 查看权限</span>\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">GRANTS</span> <span class=\"hljs-keyword\">FOR</span> 用户名\n    <span class=\"hljs-comment\">-- 查看当前用户权限</span>\n    <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">GRANTS</span>; 或 <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">GRANTS</span> <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-keyword\">CURRENT_USER</span>; 或 <span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">GRANTS</span> <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-keyword\">CURRENT_USER</span>();\n<span class=\"hljs-comment\">-- 撤消权限</span>\n<span class=\"hljs-keyword\">REVOKE</span> 权限列表 <span class=\"hljs-keyword\">ON</span> 表名 <span class=\"hljs-keyword\">FROM</span> 用户名\n<span class=\"hljs-keyword\">REVOKE</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">PRIVILEGES</span>, <span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">OPTION</span> <span class=\"hljs-keyword\">FROM</span> 用户名   <span class=\"hljs-comment\">-- 撤销所有权限</span>\n<span class=\"hljs-comment\">-- 权限层级</span>\n<span class=\"hljs-comment\">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span>\n全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user\n    <span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> *.*和 <span class=\"hljs-keyword\">REVOKE</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> *.*只授予和撤销全局权限。\n数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host\n    <span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> db_name.*和<span class=\"hljs-keyword\">REVOKE</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> db_name.*只授予和撤销数据库权限。\n表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv\n    <span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> db_name.tbl_name和<span class=\"hljs-keyword\">REVOKE</span> <span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-keyword\">ON</span> db_name.tbl_name只授予和撤销表权限。\n列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv\n    当使用<span class=\"hljs-keyword\">REVOKE</span>时，您必须指定与被授权列相同的列。\n<span class=\"hljs-comment\">-- 权限列表</span>\n<span class=\"hljs-keyword\">ALL</span> [<span class=\"hljs-keyword\">PRIVILEGES</span>]    <span class=\"hljs-comment\">-- 设置除GRANT OPTION之外的所有简单权限</span>\n<span class=\"hljs-keyword\">ALTER</span>   <span class=\"hljs-comment\">-- 允许使用ALTER TABLE</span>\n<span class=\"hljs-keyword\">ALTER</span> ROUTINE   <span class=\"hljs-comment\">-- 更改或取消已存储的子程序</span>\n<span class=\"hljs-keyword\">CREATE</span>  <span class=\"hljs-comment\">-- 允许使用CREATE TABLE</span>\n<span class=\"hljs-keyword\">CREATE</span> ROUTINE  <span class=\"hljs-comment\">-- 创建已存储的子程序</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TEMPORARY</span> <span class=\"hljs-keyword\">TABLES</span>     <span class=\"hljs-comment\">-- 允许使用CREATE TEMPORARY TABLE</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span>     <span class=\"hljs-comment\">-- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span>     <span class=\"hljs-comment\">-- 允许使用CREATE VIEW</span>\n<span class=\"hljs-keyword\">DELETE</span>  <span class=\"hljs-comment\">-- 允许使用DELETE</span>\n<span class=\"hljs-keyword\">DROP</span>    <span class=\"hljs-comment\">-- 允许使用DROP TABLE</span>\n<span class=\"hljs-keyword\">EXECUTE</span>     <span class=\"hljs-comment\">-- 允许用户运行已存储的子程序</span>\n<span class=\"hljs-keyword\">FILE</span>    <span class=\"hljs-comment\">-- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span>\n<span class=\"hljs-keyword\">INDEX</span>   <span class=\"hljs-comment\">-- 允许使用CREATE INDEX和DROP INDEX</span>\n<span class=\"hljs-keyword\">INSERT</span>  <span class=\"hljs-comment\">-- 允许使用INSERT</span>\n<span class=\"hljs-keyword\">LOCK</span> <span class=\"hljs-keyword\">TABLES</span>     <span class=\"hljs-comment\">-- 允许对您拥有SELECT权限的表使用LOCK TABLES</span></code></pre>\n"},{"layout":"post","title":"MySql 主从集群配置","date":"2019-03-25T01:07:05.000Z","_content":"\n![](/images/MySQL.jpg)\n>记录安装MySql 过程，并搭建主从模式集群。主从模式在项目中的运用例如读写分离，提高吞吐量在大量需要读操作时可以把压力分散到各个从库不影响主库写操作，如发生主库异常宕机也可以通过从库的数据进行恢复或者顶替主库。\n## MySQL 安装\n官方网站下载最靠谱，不要在奇奇怪怪的网站下可能会有乱七八糟的插件之类的，唯一指定网站 https://www.mysql.com/ ，本人下载的ZIP包解压，进入文件夹进行数据库配置，默认配置为dafult.ini如果没有则创建`my.ini`配置文件。\n\n\n## MySQL 同步原理\n![](/images/MySqlReplication.jpg)\n+ `Master`端需要开启`bin.log`，在每次数据发生改变会往`bin.log`增量写入数据并更新`Pos`，以备下一次增量写入标记`Pos`。\n+ `Slave`端的`I/O`读取`master.info`文件，获取`binlog`文件名和位置点并向`Master`端的`I/O`线程发起读取请求。\n+ `Master`端的`I/O`线程会根据`Slave`端的`I/O线`程请求信息来读取`binlog`日志信息与及读取到最新的`binlog`文件名和`Pos`一同返回给`Slave`的`I/O`线程。\n+ `Slave`端的`I/O`线程会把获取到的`binlog`日志写入`relay`日志（中继日志）文件中，并且更新`master.info`文件信息(包含最后一次读取`Pos`用于下次同步更新的位置点)。\n+ `Slave`端的`SQL`线程会定期读取`relay`日志，把二进制的日志解析成`SQL`语句并执行同步数据到从库。\n\n## Master 节点配置\n``` ini\n[mysql]\n# 设置mysql客户端默认字符集UTF8\ndefault-character-set=utf8 \n[mysqld]\n#设置3306端口\nport = 3306 \n# 设置mysql的安装目录\nbasedir=D:\\\\Program Files (x86)\\\\mysql-8.0.15-winx64-master\n# 设置mysql数据库的数据的存放目录\ndatadir=D:\\\\Program Files (x86)\\\\mysql-8.0.15-winx64-master\\\\data\n# 允许最大连接数\nmax_connections=200\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 服务唯一ID\nserver-id=1\n# 开启Log二进制日志\nlog-bin=master-bin\n# 二进制日志记录方式 混合模式\nbinlog_format=mixed\n```\n\n配置完毕进入`bin`文件夹下打开控制台进行安装初始化\n``` cmd\n# 初始化\nmysqld --initialize --console\n# 注册服务\nmysqld --install [服务名]\n# 启动服务\nnet start [服务名]\n```\n __特别注意 `mysqld --initialize --console` 执行会给你初始化密码，使用命令 `mysql -uroot -p` 登录MySQL__\n\n在`master`库中执行以下脚本\n``` sql\n# 创建用于同步数据的用户\nCREATE USER 'slave3307'@'127.0.0.1' IDENTIFIED  BY '123123';\n# 赋予权限\nGRANT REPLICATION SLAVE,FILE ON *.* TO 'slave3307'@'127.0.0.1';\n# 刷新权限\nFLUSH PRIVILEGES;\n```\n\n## SLAVE 节点配置\n``` ini\n[mysql]\n# 设置mysql客户端默认字符集UTF8\ndefault-character-set=utf8 \n[mysqld]\n#设置3307端口\nport = 3307 \n# 设置mysql的安装目录\nbasedir=D:\\\\Program Files (x86)\\\\mysql-8.0.15-winx64-slave\n# 设置mysql数据库的数据的存放目录\ndatadir=D:\\\\Program Files (x86)\\\\mysql-8.0.15-winx64-slave\\\\data\n# 允许最大连接数\nmax_connections=200\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 服务唯一ID\nserver-id=2\n# 只读设置\nread_only=1\n# 需要同步的数据库名称，如有多个需配置多条\nreplicate-do-db=mastersql\n```\n\n> `read_only` 这里设置为只读模式，不会影响到`slave`的同步复制功能，可以限制普通用户写入操作防止修改数据导致主从数据不一致，但是无法限制`super`用户的修改数据权限，所以同步复制需要新建一个普通用户用于链接同步。\n\n#### 同步配置\n在`5.7`版本之前需要在`my.ini`配置文件`[mysqld]`下添加\n``` ini\n# 主节点地址\nmaster-host=127.0.0.1\n# 主节点端口\nmaster-port=3306\n# 主节点复制账号\nmaster-user= slave3307\n# 主节点复制密码\nmaster-password= 123123\n# 重连时间\nmaster-connect-retry=60\n```\n`5.7`版本之后的主从配置直接通过动态配置无需修改`ini`\n``` sql\n# 改变同步配置\nchange master to master_host='127.0.0.1',master_port=3306, master_user='slave3307', master_password='123123',master_log_file='binlog.000003',master_log_pos=7676;\n# 开启同步\nstart slave;\n# 查看同步状态\nshow slave status;\n```\n执行`show slave status`语句可以查看当前同步状态，`Slave_IO_Running`和`Slave_SQL_Running`是否为`Yes`，证明同步是否开启成功。`Seconds_Behind_Master`为从库与主库同步位置差异一般为0。执行`stop slave`可停止同步进行修改同步设置然后使用`start slave`重新开启。\n\n\n##### 语句解释\n- `master_host`和`master_port` 为主库地址信息\n- `master_port`和`master_password` 同步的账号密码，我们已配置用户为`slave3307`密码为`123`。\n- 在`master`库中执行`show master status;`获取`master_log_file` 主库日志和`master_log_pos`当前日志位置，这里可以根据实际情况来设置`master_log_pos`的起始位置。\n![主库日志](/images/masterStatus.png)\n\n同步开启后可以尝试在主库下创建一个新数据库`mastersql`,然后新建一张表`mytest`。切换到从库你会发现从库也会自动创建`mastersql`数据库并有一张同名的表`mytest`，说明同步成功。\n\n","source":"_posts/Mysql 主从配置.md","raw":"---\nlayout: post\ntitle: MySql 主从集群配置\ndate: 2019-03-25 09:07:05\ncategories: [数据库]\ntags:\n\t- 数据库\n---\n\n![](/images/MySQL.jpg)\n>记录安装MySql 过程，并搭建主从模式集群。主从模式在项目中的运用例如读写分离，提高吞吐量在大量需要读操作时可以把压力分散到各个从库不影响主库写操作，如发生主库异常宕机也可以通过从库的数据进行恢复或者顶替主库。\n## MySQL 安装\n官方网站下载最靠谱，不要在奇奇怪怪的网站下可能会有乱七八糟的插件之类的，唯一指定网站 https://www.mysql.com/ ，本人下载的ZIP包解压，进入文件夹进行数据库配置，默认配置为dafult.ini如果没有则创建`my.ini`配置文件。\n\n\n## MySQL 同步原理\n![](/images/MySqlReplication.jpg)\n+ `Master`端需要开启`bin.log`，在每次数据发生改变会往`bin.log`增量写入数据并更新`Pos`，以备下一次增量写入标记`Pos`。\n+ `Slave`端的`I/O`读取`master.info`文件，获取`binlog`文件名和位置点并向`Master`端的`I/O`线程发起读取请求。\n+ `Master`端的`I/O`线程会根据`Slave`端的`I/O线`程请求信息来读取`binlog`日志信息与及读取到最新的`binlog`文件名和`Pos`一同返回给`Slave`的`I/O`线程。\n+ `Slave`端的`I/O`线程会把获取到的`binlog`日志写入`relay`日志（中继日志）文件中，并且更新`master.info`文件信息(包含最后一次读取`Pos`用于下次同步更新的位置点)。\n+ `Slave`端的`SQL`线程会定期读取`relay`日志，把二进制的日志解析成`SQL`语句并执行同步数据到从库。\n\n## Master 节点配置\n``` ini\n[mysql]\n# 设置mysql客户端默认字符集UTF8\ndefault-character-set=utf8 \n[mysqld]\n#设置3306端口\nport = 3306 \n# 设置mysql的安装目录\nbasedir=D:\\\\Program Files (x86)\\\\mysql-8.0.15-winx64-master\n# 设置mysql数据库的数据的存放目录\ndatadir=D:\\\\Program Files (x86)\\\\mysql-8.0.15-winx64-master\\\\data\n# 允许最大连接数\nmax_connections=200\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 服务唯一ID\nserver-id=1\n# 开启Log二进制日志\nlog-bin=master-bin\n# 二进制日志记录方式 混合模式\nbinlog_format=mixed\n```\n\n配置完毕进入`bin`文件夹下打开控制台进行安装初始化\n``` cmd\n# 初始化\nmysqld --initialize --console\n# 注册服务\nmysqld --install [服务名]\n# 启动服务\nnet start [服务名]\n```\n __特别注意 `mysqld --initialize --console` 执行会给你初始化密码，使用命令 `mysql -uroot -p` 登录MySQL__\n\n在`master`库中执行以下脚本\n``` sql\n# 创建用于同步数据的用户\nCREATE USER 'slave3307'@'127.0.0.1' IDENTIFIED  BY '123123';\n# 赋予权限\nGRANT REPLICATION SLAVE,FILE ON *.* TO 'slave3307'@'127.0.0.1';\n# 刷新权限\nFLUSH PRIVILEGES;\n```\n\n## SLAVE 节点配置\n``` ini\n[mysql]\n# 设置mysql客户端默认字符集UTF8\ndefault-character-set=utf8 \n[mysqld]\n#设置3307端口\nport = 3307 \n# 设置mysql的安装目录\nbasedir=D:\\\\Program Files (x86)\\\\mysql-8.0.15-winx64-slave\n# 设置mysql数据库的数据的存放目录\ndatadir=D:\\\\Program Files (x86)\\\\mysql-8.0.15-winx64-slave\\\\data\n# 允许最大连接数\nmax_connections=200\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 服务唯一ID\nserver-id=2\n# 只读设置\nread_only=1\n# 需要同步的数据库名称，如有多个需配置多条\nreplicate-do-db=mastersql\n```\n\n> `read_only` 这里设置为只读模式，不会影响到`slave`的同步复制功能，可以限制普通用户写入操作防止修改数据导致主从数据不一致，但是无法限制`super`用户的修改数据权限，所以同步复制需要新建一个普通用户用于链接同步。\n\n#### 同步配置\n在`5.7`版本之前需要在`my.ini`配置文件`[mysqld]`下添加\n``` ini\n# 主节点地址\nmaster-host=127.0.0.1\n# 主节点端口\nmaster-port=3306\n# 主节点复制账号\nmaster-user= slave3307\n# 主节点复制密码\nmaster-password= 123123\n# 重连时间\nmaster-connect-retry=60\n```\n`5.7`版本之后的主从配置直接通过动态配置无需修改`ini`\n``` sql\n# 改变同步配置\nchange master to master_host='127.0.0.1',master_port=3306, master_user='slave3307', master_password='123123',master_log_file='binlog.000003',master_log_pos=7676;\n# 开启同步\nstart slave;\n# 查看同步状态\nshow slave status;\n```\n执行`show slave status`语句可以查看当前同步状态，`Slave_IO_Running`和`Slave_SQL_Running`是否为`Yes`，证明同步是否开启成功。`Seconds_Behind_Master`为从库与主库同步位置差异一般为0。执行`stop slave`可停止同步进行修改同步设置然后使用`start slave`重新开启。\n\n\n##### 语句解释\n- `master_host`和`master_port` 为主库地址信息\n- `master_port`和`master_password` 同步的账号密码，我们已配置用户为`slave3307`密码为`123`。\n- 在`master`库中执行`show master status;`获取`master_log_file` 主库日志和`master_log_pos`当前日志位置，这里可以根据实际情况来设置`master_log_pos`的起始位置。\n![主库日志](/images/masterStatus.png)\n\n同步开启后可以尝试在主库下创建一个新数据库`mastersql`,然后新建一张表`mytest`。切换到从库你会发现从库也会自动创建`mastersql`数据库并有一张同名的表`mytest`，说明同步成功。\n\n","slug":"Mysql 主从配置","published":1,"updated":"2020-08-10T01:48:44.733Z","comments":1,"photos":[],"link":"","_id":"ckhmyc98b0023jsudq39jov04","content":"<p><img src=\"/images/MySQL.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录安装MySql 过程，并搭建主从模式集群。主从模式在项目中的运用例如读写分离，提高吞吐量在大量需要读操作时可以把压力分散到各个从库不影响主库写操作，如发生主库异常宕机也可以通过从库的数据进行恢复或者顶替主库。</p>\n</blockquote>\n<h2 id=\"MySQL-安装\"><a href=\"#MySQL-安装\" class=\"headerlink\" title=\"MySQL 安装\"></a>MySQL 安装</h2><p>官方网站下载最靠谱，不要在奇奇怪怪的网站下可能会有乱七八糟的插件之类的，唯一指定网站 <a href=\"https://www.mysql.com/\" target=\"_blank\" rel=\"noopener\">https://www.mysql.com/</a> ，本人下载的ZIP包解压，进入文件夹进行数据库配置，默认配置为dafult.ini如果没有则创建<code>my.ini</code>配置文件。</p>\n<h2 id=\"MySQL-同步原理\"><a href=\"#MySQL-同步原理\" class=\"headerlink\" title=\"MySQL 同步原理\"></a>MySQL 同步原理</h2><p><img src=\"/images/MySqlReplication.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<ul>\n<li><code>Master</code>端需要开启<code>bin.log</code>，在每次数据发生改变会往<code>bin.log</code>增量写入数据并更新<code>Pos</code>，以备下一次增量写入标记<code>Pos</code>。</li>\n<li><code>Slave</code>端的<code>I/O</code>读取<code>master.info</code>文件，获取<code>binlog</code>文件名和位置点并向<code>Master</code>端的<code>I/O</code>线程发起读取请求。</li>\n<li><code>Master</code>端的<code>I/O</code>线程会根据<code>Slave</code>端的<code>I/O线</code>程请求信息来读取<code>binlog</code>日志信息与及读取到最新的<code>binlog</code>文件名和<code>Pos</code>一同返回给<code>Slave</code>的<code>I/O</code>线程。</li>\n<li><code>Slave</code>端的<code>I/O</code>线程会把获取到的<code>binlog</code>日志写入<code>relay</code>日志（中继日志）文件中，并且更新<code>master.info</code>文件信息(包含最后一次读取<code>Pos</code>用于下次同步更新的位置点)。</li>\n<li><code>Slave</code>端的<code>SQL</code>线程会定期读取<code>relay</code>日志，把二进制的日志解析成<code>SQL</code>语句并执行同步数据到从库。</li>\n</ul>\n<h2 id=\"Master-节点配置\"><a href=\"#Master-节点配置\" class=\"headerlink\" title=\"Master 节点配置\"></a>Master 节点配置</h2><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[mysql]</span>\n<span class=\"hljs-comment\"># 设置mysql客户端默认字符集UTF8</span>\n<span class=\"hljs-attr\">default-character-set</span>=utf8 \n<span class=\"hljs-section\">[mysqld]</span>\n<span class=\"hljs-comment\">#设置3306端口</span>\n<span class=\"hljs-attr\">port</span> = <span class=\"hljs-number\">3306</span> \n<span class=\"hljs-comment\"># 设置mysql的安装目录</span>\n<span class=\"hljs-attr\">basedir</span>=D:\\\\Program Files (x86)\\\\mysql-<span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">15</span>-winx64-master\n<span class=\"hljs-comment\"># 设置mysql数据库的数据的存放目录</span>\n<span class=\"hljs-attr\">datadir</span>=D:\\\\Program Files (x86)\\\\mysql-<span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">15</span>-winx64-master\\\\data\n<span class=\"hljs-comment\"># 允许最大连接数</span>\n<span class=\"hljs-attr\">max_connections</span>=<span class=\"hljs-number\">200</span>\n<span class=\"hljs-comment\"># 服务端使用的字符集默认为UTF8</span>\n<span class=\"hljs-attr\">character-set-server</span>=utf8\n<span class=\"hljs-comment\"># 创建新表时将使用的默认存储引擎</span>\n<span class=\"hljs-attr\">default-storage-engine</span>=INNODB\n<span class=\"hljs-comment\"># 服务唯一ID</span>\n<span class=\"hljs-attr\">server-id</span>=<span class=\"hljs-number\">1</span>\n<span class=\"hljs-comment\"># 开启Log二进制日志</span>\n<span class=\"hljs-attr\">log-bin</span>=master-bin\n<span class=\"hljs-comment\"># 二进制日志记录方式 混合模式</span>\n<span class=\"hljs-attr\">binlog_format</span>=mixed</code></pre>\n<p>配置完毕进入<code>bin</code>文件夹下打开控制台进行安装初始化<br><pre><code class=\"hljs cmd\"># 初始化\nmysqld --initialize --console\n# 注册服务\nmysqld --install [服务名]\n# 启动服务\n<span class=\"hljs-built_in\">net</span> <span class=\"hljs-built_in\">start</span> [服务名]</code></pre></p>\n<p> <strong>特别注意 <code>mysqld --initialize --console</code> 执行会给你初始化密码，使用命令 <code>mysql -uroot -p</code> 登录MySQL</strong></p>\n<p>在<code>master</code>库中执行以下脚本<br><pre><code class=\"hljs sql\"><span class=\"hljs-comment\"># 创建用于同步数据的用户</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span> <span class=\"hljs-string\">'slave3307'</span>@<span class=\"hljs-string\">'127.0.0.1'</span> <span class=\"hljs-keyword\">IDENTIFIED</span>  <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">'123123'</span>;\n<span class=\"hljs-comment\"># 赋予权限</span>\n<span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">REPLICATION</span> <span class=\"hljs-keyword\">SLAVE</span>,<span class=\"hljs-keyword\">FILE</span> <span class=\"hljs-keyword\">ON</span> *.* <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-string\">'slave3307'</span>@<span class=\"hljs-string\">'127.0.0.1'</span>;\n<span class=\"hljs-comment\"># 刷新权限</span>\n<span class=\"hljs-keyword\">FLUSH</span> <span class=\"hljs-keyword\">PRIVILEGES</span>;</code></pre></p>\n<h2 id=\"SLAVE-节点配置\"><a href=\"#SLAVE-节点配置\" class=\"headerlink\" title=\"SLAVE 节点配置\"></a>SLAVE 节点配置</h2><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[mysql]</span>\n<span class=\"hljs-comment\"># 设置mysql客户端默认字符集UTF8</span>\n<span class=\"hljs-attr\">default-character-set</span>=utf8 \n<span class=\"hljs-section\">[mysqld]</span>\n<span class=\"hljs-comment\">#设置3307端口</span>\n<span class=\"hljs-attr\">port</span> = <span class=\"hljs-number\">3307</span> \n<span class=\"hljs-comment\"># 设置mysql的安装目录</span>\n<span class=\"hljs-attr\">basedir</span>=D:\\\\Program Files (x86)\\\\mysql-<span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">15</span>-winx64-slave\n<span class=\"hljs-comment\"># 设置mysql数据库的数据的存放目录</span>\n<span class=\"hljs-attr\">datadir</span>=D:\\\\Program Files (x86)\\\\mysql-<span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">15</span>-winx64-slave\\\\data\n<span class=\"hljs-comment\"># 允许最大连接数</span>\n<span class=\"hljs-attr\">max_connections</span>=<span class=\"hljs-number\">200</span>\n<span class=\"hljs-comment\"># 服务端使用的字符集默认为UTF8</span>\n<span class=\"hljs-attr\">character-set-server</span>=utf8\n<span class=\"hljs-comment\"># 创建新表时将使用的默认存储引擎</span>\n<span class=\"hljs-attr\">default-storage-engine</span>=INNODB\n<span class=\"hljs-comment\"># 服务唯一ID</span>\n<span class=\"hljs-attr\">server-id</span>=<span class=\"hljs-number\">2</span>\n<span class=\"hljs-comment\"># 只读设置</span>\n<span class=\"hljs-attr\">read_only</span>=<span class=\"hljs-number\">1</span>\n<span class=\"hljs-comment\"># 需要同步的数据库名称，如有多个需配置多条</span>\n<span class=\"hljs-attr\">replicate-do-db</span>=mastersql</code></pre>\n<blockquote>\n<p><code>read_only</code> 这里设置为只读模式，不会影响到<code>slave</code>的同步复制功能，可以限制普通用户写入操作防止修改数据导致主从数据不一致，但是无法限制<code>super</code>用户的修改数据权限，所以同步复制需要新建一个普通用户用于链接同步。</p>\n</blockquote>\n<h4 id=\"同步配置\"><a href=\"#同步配置\" class=\"headerlink\" title=\"同步配置\"></a>同步配置</h4><p>在<code>5.7</code>版本之前需要在<code>my.ini</code>配置文件<code>[mysqld]</code>下添加<br><pre><code class=\"hljs ini\"><span class=\"hljs-comment\"># 主节点地址</span>\n<span class=\"hljs-attr\">master-host</span>=<span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>\n<span class=\"hljs-comment\"># 主节点端口</span>\n<span class=\"hljs-attr\">master-port</span>=<span class=\"hljs-number\">3306</span>\n<span class=\"hljs-comment\"># 主节点复制账号</span>\n<span class=\"hljs-attr\">master-user</span>= slave3307\n<span class=\"hljs-comment\"># 主节点复制密码</span>\n<span class=\"hljs-attr\">master-password</span>= <span class=\"hljs-number\">123123</span>\n<span class=\"hljs-comment\"># 重连时间</span>\n<span class=\"hljs-attr\">master-connect-retry</span>=<span class=\"hljs-number\">60</span></code></pre></p>\n<p><code>5.7</code>版本之后的主从配置直接通过动态配置无需修改<code>ini</code><br><pre><code class=\"hljs sql\"><span class=\"hljs-comment\"># 改变同步配置</span>\n<span class=\"hljs-keyword\">change</span> <span class=\"hljs-keyword\">master</span> <span class=\"hljs-keyword\">to</span> master_host=<span class=\"hljs-string\">'127.0.0.1'</span>,master_port=<span class=\"hljs-number\">3306</span>, master_user=<span class=\"hljs-string\">'slave3307'</span>, master_password=<span class=\"hljs-string\">'123123'</span>,master_log_file=<span class=\"hljs-string\">'binlog.000003'</span>,master_log_pos=<span class=\"hljs-number\">7676</span>;\n<span class=\"hljs-comment\"># 开启同步</span>\n<span class=\"hljs-keyword\">start</span> <span class=\"hljs-keyword\">slave</span>;\n<span class=\"hljs-comment\"># 查看同步状态</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">slave</span> <span class=\"hljs-keyword\">status</span>;</code></pre></p>\n<p>执行<code>show slave status</code>语句可以查看当前同步状态，<code>Slave_IO_Running</code>和<code>Slave_SQL_Running</code>是否为<code>Yes</code>，证明同步是否开启成功。<code>Seconds_Behind_Master</code>为从库与主库同步位置差异一般为0。执行<code>stop slave</code>可停止同步进行修改同步设置然后使用<code>start slave</code>重新开启。</p>\n<h5 id=\"语句解释\"><a href=\"#语句解释\" class=\"headerlink\" title=\"语句解释\"></a>语句解释</h5><ul>\n<li><code>master_host</code>和<code>master_port</code> 为主库地址信息</li>\n<li><code>master_port</code>和<code>master_password</code> 同步的账号密码，我们已配置用户为<code>slave3307</code>密码为<code>123</code>。</li>\n<li>在<code>master</code>库中执行<code>show master status;</code>获取<code>master_log_file</code> 主库日志和<code>master_log_pos</code>当前日志位置，这里可以根据实际情况来设置<code>master_log_pos</code>的起始位置。<br><img src=\"/images/masterStatus.png\" srcset=\"/img/loading.gif\" alt=\"主库日志\"></li>\n</ul>\n<p>同步开启后可以尝试在主库下创建一个新数据库<code>mastersql</code>,然后新建一张表<code>mytest</code>。切换到从库你会发现从库也会自动创建<code>mastersql</code>数据库并有一张同名的表<code>mytest</code>，说明同步成功。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/MySQL.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录安装MySql 过程，并搭建主从模式集群。主从模式在项目中的运用例如读写分离，提高吞吐量在大量需要读操作时可以把压力分散到各个从库不影响主库写操作，如发生主库异常宕机也可以通过从库的数据进行恢复或者顶替主库。</p>\n</blockquote>\n<h2 id=\"MySQL-安装\"><a href=\"#MySQL-安装\" class=\"headerlink\" title=\"MySQL 安装\"></a>MySQL 安装</h2><p>官方网站下载最靠谱，不要在奇奇怪怪的网站下可能会有乱七八糟的插件之类的，唯一指定网站 <a href=\"https://www.mysql.com/\" target=\"_blank\" rel=\"noopener\">https://www.mysql.com/</a> ，本人下载的ZIP包解压，进入文件夹进行数据库配置，默认配置为dafult.ini如果没有则创建<code>my.ini</code>配置文件。</p>\n<h2 id=\"MySQL-同步原理\"><a href=\"#MySQL-同步原理\" class=\"headerlink\" title=\"MySQL 同步原理\"></a>MySQL 同步原理</h2><p><img src=\"/images/MySqlReplication.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<ul>\n<li><code>Master</code>端需要开启<code>bin.log</code>，在每次数据发生改变会往<code>bin.log</code>增量写入数据并更新<code>Pos</code>，以备下一次增量写入标记<code>Pos</code>。</li>\n<li><code>Slave</code>端的<code>I/O</code>读取<code>master.info</code>文件，获取<code>binlog</code>文件名和位置点并向<code>Master</code>端的<code>I/O</code>线程发起读取请求。</li>\n<li><code>Master</code>端的<code>I/O</code>线程会根据<code>Slave</code>端的<code>I/O线</code>程请求信息来读取<code>binlog</code>日志信息与及读取到最新的<code>binlog</code>文件名和<code>Pos</code>一同返回给<code>Slave</code>的<code>I/O</code>线程。</li>\n<li><code>Slave</code>端的<code>I/O</code>线程会把获取到的<code>binlog</code>日志写入<code>relay</code>日志（中继日志）文件中，并且更新<code>master.info</code>文件信息(包含最后一次读取<code>Pos</code>用于下次同步更新的位置点)。</li>\n<li><code>Slave</code>端的<code>SQL</code>线程会定期读取<code>relay</code>日志，把二进制的日志解析成<code>SQL</code>语句并执行同步数据到从库。</li>\n</ul>\n<h2 id=\"Master-节点配置\"><a href=\"#Master-节点配置\" class=\"headerlink\" title=\"Master 节点配置\"></a>Master 节点配置</h2><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[mysql]</span>\n<span class=\"hljs-comment\"># 设置mysql客户端默认字符集UTF8</span>\n<span class=\"hljs-attr\">default-character-set</span>=utf8 \n<span class=\"hljs-section\">[mysqld]</span>\n<span class=\"hljs-comment\">#设置3306端口</span>\n<span class=\"hljs-attr\">port</span> = <span class=\"hljs-number\">3306</span> \n<span class=\"hljs-comment\"># 设置mysql的安装目录</span>\n<span class=\"hljs-attr\">basedir</span>=D:\\\\Program Files (x86)\\\\mysql-<span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">15</span>-winx64-master\n<span class=\"hljs-comment\"># 设置mysql数据库的数据的存放目录</span>\n<span class=\"hljs-attr\">datadir</span>=D:\\\\Program Files (x86)\\\\mysql-<span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">15</span>-winx64-master\\\\data\n<span class=\"hljs-comment\"># 允许最大连接数</span>\n<span class=\"hljs-attr\">max_connections</span>=<span class=\"hljs-number\">200</span>\n<span class=\"hljs-comment\"># 服务端使用的字符集默认为UTF8</span>\n<span class=\"hljs-attr\">character-set-server</span>=utf8\n<span class=\"hljs-comment\"># 创建新表时将使用的默认存储引擎</span>\n<span class=\"hljs-attr\">default-storage-engine</span>=INNODB\n<span class=\"hljs-comment\"># 服务唯一ID</span>\n<span class=\"hljs-attr\">server-id</span>=<span class=\"hljs-number\">1</span>\n<span class=\"hljs-comment\"># 开启Log二进制日志</span>\n<span class=\"hljs-attr\">log-bin</span>=master-bin\n<span class=\"hljs-comment\"># 二进制日志记录方式 混合模式</span>\n<span class=\"hljs-attr\">binlog_format</span>=mixed</code></pre>\n<p>配置完毕进入<code>bin</code>文件夹下打开控制台进行安装初始化<br><pre><code class=\"hljs cmd\"># 初始化\nmysqld --initialize --console\n# 注册服务\nmysqld --install [服务名]\n# 启动服务\n<span class=\"hljs-built_in\">net</span> <span class=\"hljs-built_in\">start</span> [服务名]</code></pre></p>\n<p> <strong>特别注意 <code>mysqld --initialize --console</code> 执行会给你初始化密码，使用命令 <code>mysql -uroot -p</code> 登录MySQL</strong></p>\n<p>在<code>master</code>库中执行以下脚本<br><pre><code class=\"hljs sql\"><span class=\"hljs-comment\"># 创建用于同步数据的用户</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span> <span class=\"hljs-string\">'slave3307'</span>@<span class=\"hljs-string\">'127.0.0.1'</span> <span class=\"hljs-keyword\">IDENTIFIED</span>  <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">'123123'</span>;\n<span class=\"hljs-comment\"># 赋予权限</span>\n<span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">REPLICATION</span> <span class=\"hljs-keyword\">SLAVE</span>,<span class=\"hljs-keyword\">FILE</span> <span class=\"hljs-keyword\">ON</span> *.* <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-string\">'slave3307'</span>@<span class=\"hljs-string\">'127.0.0.1'</span>;\n<span class=\"hljs-comment\"># 刷新权限</span>\n<span class=\"hljs-keyword\">FLUSH</span> <span class=\"hljs-keyword\">PRIVILEGES</span>;</code></pre></p>\n<h2 id=\"SLAVE-节点配置\"><a href=\"#SLAVE-节点配置\" class=\"headerlink\" title=\"SLAVE 节点配置\"></a>SLAVE 节点配置</h2><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[mysql]</span>\n<span class=\"hljs-comment\"># 设置mysql客户端默认字符集UTF8</span>\n<span class=\"hljs-attr\">default-character-set</span>=utf8 \n<span class=\"hljs-section\">[mysqld]</span>\n<span class=\"hljs-comment\">#设置3307端口</span>\n<span class=\"hljs-attr\">port</span> = <span class=\"hljs-number\">3307</span> \n<span class=\"hljs-comment\"># 设置mysql的安装目录</span>\n<span class=\"hljs-attr\">basedir</span>=D:\\\\Program Files (x86)\\\\mysql-<span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">15</span>-winx64-slave\n<span class=\"hljs-comment\"># 设置mysql数据库的数据的存放目录</span>\n<span class=\"hljs-attr\">datadir</span>=D:\\\\Program Files (x86)\\\\mysql-<span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">15</span>-winx64-slave\\\\data\n<span class=\"hljs-comment\"># 允许最大连接数</span>\n<span class=\"hljs-attr\">max_connections</span>=<span class=\"hljs-number\">200</span>\n<span class=\"hljs-comment\"># 服务端使用的字符集默认为UTF8</span>\n<span class=\"hljs-attr\">character-set-server</span>=utf8\n<span class=\"hljs-comment\"># 创建新表时将使用的默认存储引擎</span>\n<span class=\"hljs-attr\">default-storage-engine</span>=INNODB\n<span class=\"hljs-comment\"># 服务唯一ID</span>\n<span class=\"hljs-attr\">server-id</span>=<span class=\"hljs-number\">2</span>\n<span class=\"hljs-comment\"># 只读设置</span>\n<span class=\"hljs-attr\">read_only</span>=<span class=\"hljs-number\">1</span>\n<span class=\"hljs-comment\"># 需要同步的数据库名称，如有多个需配置多条</span>\n<span class=\"hljs-attr\">replicate-do-db</span>=mastersql</code></pre>\n<blockquote>\n<p><code>read_only</code> 这里设置为只读模式，不会影响到<code>slave</code>的同步复制功能，可以限制普通用户写入操作防止修改数据导致主从数据不一致，但是无法限制<code>super</code>用户的修改数据权限，所以同步复制需要新建一个普通用户用于链接同步。</p>\n</blockquote>\n<h4 id=\"同步配置\"><a href=\"#同步配置\" class=\"headerlink\" title=\"同步配置\"></a>同步配置</h4><p>在<code>5.7</code>版本之前需要在<code>my.ini</code>配置文件<code>[mysqld]</code>下添加<br><pre><code class=\"hljs ini\"><span class=\"hljs-comment\"># 主节点地址</span>\n<span class=\"hljs-attr\">master-host</span>=<span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>\n<span class=\"hljs-comment\"># 主节点端口</span>\n<span class=\"hljs-attr\">master-port</span>=<span class=\"hljs-number\">3306</span>\n<span class=\"hljs-comment\"># 主节点复制账号</span>\n<span class=\"hljs-attr\">master-user</span>= slave3307\n<span class=\"hljs-comment\"># 主节点复制密码</span>\n<span class=\"hljs-attr\">master-password</span>= <span class=\"hljs-number\">123123</span>\n<span class=\"hljs-comment\"># 重连时间</span>\n<span class=\"hljs-attr\">master-connect-retry</span>=<span class=\"hljs-number\">60</span></code></pre></p>\n<p><code>5.7</code>版本之后的主从配置直接通过动态配置无需修改<code>ini</code><br><pre><code class=\"hljs sql\"><span class=\"hljs-comment\"># 改变同步配置</span>\n<span class=\"hljs-keyword\">change</span> <span class=\"hljs-keyword\">master</span> <span class=\"hljs-keyword\">to</span> master_host=<span class=\"hljs-string\">'127.0.0.1'</span>,master_port=<span class=\"hljs-number\">3306</span>, master_user=<span class=\"hljs-string\">'slave3307'</span>, master_password=<span class=\"hljs-string\">'123123'</span>,master_log_file=<span class=\"hljs-string\">'binlog.000003'</span>,master_log_pos=<span class=\"hljs-number\">7676</span>;\n<span class=\"hljs-comment\"># 开启同步</span>\n<span class=\"hljs-keyword\">start</span> <span class=\"hljs-keyword\">slave</span>;\n<span class=\"hljs-comment\"># 查看同步状态</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">slave</span> <span class=\"hljs-keyword\">status</span>;</code></pre></p>\n<p>执行<code>show slave status</code>语句可以查看当前同步状态，<code>Slave_IO_Running</code>和<code>Slave_SQL_Running</code>是否为<code>Yes</code>，证明同步是否开启成功。<code>Seconds_Behind_Master</code>为从库与主库同步位置差异一般为0。执行<code>stop slave</code>可停止同步进行修改同步设置然后使用<code>start slave</code>重新开启。</p>\n<h5 id=\"语句解释\"><a href=\"#语句解释\" class=\"headerlink\" title=\"语句解释\"></a>语句解释</h5><ul>\n<li><code>master_host</code>和<code>master_port</code> 为主库地址信息</li>\n<li><code>master_port</code>和<code>master_password</code> 同步的账号密码，我们已配置用户为<code>slave3307</code>密码为<code>123</code>。</li>\n<li>在<code>master</code>库中执行<code>show master status;</code>获取<code>master_log_file</code> 主库日志和<code>master_log_pos</code>当前日志位置，这里可以根据实际情况来设置<code>master_log_pos</code>的起始位置。<br><img src=\"/images/masterStatus.png\" srcset=\"/img/loading.gif\" alt=\"主库日志\"></li>\n</ul>\n<p>同步开启后可以尝试在主库下创建一个新数据库<code>mastersql</code>,然后新建一张表<code>mytest</code>。切换到从库你会发现从库也会自动创建<code>mastersql</code>数据库并有一张同名的表<code>mytest</code>，说明同步成功。</p>\n"},{"title":"Nginx 配置详解","toc":false,"date":"2019-08-09T08:33:35.000Z","_content":"\n![](/images/nginxconf.png)\n\n> 学习 Nginx的配置文件用于以后回来查询回顾\n\n### Core 模块\n- 配置运行Nginx服务器用户（组）\n- worker process数\n- Nginx进程PID存放路径\n- 错误日志的存放路径\n- 配置文件的引入\n``` bash\nuser nobody nobody;\nworker_processes 2;\nerror_log logs/error.log notice;\npid logs/nginx.pid;\nworker_rlimit_nofile 65535;\n```\n##### 基本参数\n\n|参数|描述|\n|-|-|\n|user|指定 Nginx Woker 进程运行用户以及用户组，默认值 nobby nobby|\n|worker_processes|配置工作进程数，建议于CPU核心数量一致，auto为自动检测|\n|error_log|日志文件的地址和日志级别，debug、info、notice、warn、error、crit|\n|pid|pid进程标识符存放地址|\n|worker_rlimit_nofile worker|进程可以打开最大文件限制数|\n\n\n### Events 模块\n- 该部分配置主要影响Nginx服务器与用户的网络连接，主要包括：\n- 设置网络连接的序列化\n- 是否允许同时接收多个网络连接\n- 事件驱动模型的选择\n- 进程连接数的配置\n\n``` bash\nevents {\n    worker_connections 2048;\n    multi_accept on;\n    use epoll;\n    keepalive_timeout 60;\n    accept_mutex on;\n}\n```\n|参数|描述|\n|-|-|\n|worker_connections |每个进程的最大连接数，客户端连接数 MaxClient = worker_processes * worker_connections，Linux 系统下进程最大连接数受最大文件句柄数所限制，通过`ulimit -n 连接数`来改变其最大打开文件数|\n|use |事件驱动模式 kqueue、rtsig、epoll、/dev/poll、select、poll 、eventport|\n|multi_accept|是否允许同时接受多个连接|\n|keepalive_timeout | 连接超时时间单位（秒）|\n|accept_mutex |网路连接序列化，防止__惊群现象__发生，默认为on|\n\n##### 惊群现象\n![](/images/thundering-herd.png)\n当`CreateSocket`发生连接事件时，所有的`fork`进程都被唤醒，而最终只有一个进程能处理事件响应，其余进程无法获取事件则只能重新睡眠或其他操作，这样现象我们称之为__惊群现象__\n\n### Http 模块\n- 定义MIMI-Type\n- 自定义服务日志\n- 允许sendfile方式传输文件\n- 连接超时时间\n- 单连接请求数上限\n``` bash\nhttp {\n    include mine.types;\n    server_tokens off;\n    default_type application/octet-stream\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    keepalive_timeout 65；\n    ...\n}\n```\n##### 基本参数\n\n|参数|描述|\n|-|-|\n|include|将其他的Nginx配置或者第三方模块的配置引用到当前的主配置文件中|\n|keepalive_timeout|客户端连接保持活动的超时时间|\n|sendfile on |开启高效文件传输模式|\n|default_type |默认类型为二进制流|\n\n#### Upstream 负载均衡模块\n负载均衡目前支持4种方法：\n\n|方法|描述|\n|-|-|\n|poll 轮询|默认方法按照请求时间依次分发到配置的服务|\n|weight 权重|根据服务配置的权重来进行分配请求|\n|ip_hash|根据请求 ip 的 hash 值来固定访问服务，解决了服务 session 不一致问题|\n|fair|根据请求的响应时间智能分配服务|\n|url_hash|根据请求的 url 的 hash 地址分配服务|\n\n##### 基本参数\n\n|参数|描述|\n|-|-|\n|fail_timeout|失败时间周期|\n|max_fails|在 fail_timeout 周期内之内所有请求（最大失败次数）均失败则认为服务停机，等待 fail_timeout 周期后再请求|\n|backup\t|服务标记为热备状态，当其他服务为停机状态下请求才会被分配热备服务|\n|down|服务被标记为停机状态|\n|max_conns|最大连接数|\n\n``` bash\nupstream mysvr {   \n      server 127.0.0.1:7878;\n      server 192.168.10.121:3333 backup;  #热备\n}\n```\n\n#### Server 配置\n- 配置网络监听\n- 基于名称的虚拟主机配置\n- 基于IP的虚拟主机配置\n\n``` bash\nserver {\n        keepalive_requests 120; #单连接请求上限次数。\n        listen       4545;   #监听端口\n\t    acccess_log /var/access.log;\n        server_name  127.0.0.1;   #监听地址      \n\t    root /var/www;\n\n        location  ~*^.+$ {      \n           proxy_pass  http://mysvr;\n           deny 127.0.0.1;  #拒绝的ip\n           allow 172.18.5.54; #允许的ip           \n        } \n}\n```\n##### 基本参数\n|参数|描述|\n|-|-|\n|listen|监听配置格式`[ip:port]`、`[ip]`、`[port]`|\n|server_name|监听域名可用正则进行通配|\n|access_log|访问记录日志地址|\n|keepalive_requests|单连接请求上线次数|\n|root|作为根目录用于文件的检索|\n\n##### Location 配置\n通过指定模式来与客户端请求的URI相匹配，基本语法如下：`location [=|~|~*|^~|@] pattern{……}`\n\n|配置|匹配|\n|-|-|\n|/|模糊匹配|\n|=|精确匹配|\n|^~|标示 uri 以指定字符串开头|\n|~|正则匹配需要区别大小写|\n|~*|正则匹配不需要区别大小写|\n|@|指定区段无法访问|\n\n##### 优先级： = 高于 ^~ 高 ~* 等于 ~ 高于 /\n\n##### 基本参数\n\n|参数|描述|\n|-|-|\n|proxy_pass|代理转发 proxy_pass后面的url加`/`，表示`绝对根路径`；如果没有`/`，表示`相对路径`|\n|alias|访问文件路径别名|\n\n###### 例子\n``` bash\nlocation /mytest/ {\n\tproxy_pass http://127.0.0.1:8080/abc;\n}\n\n# 访问 http://127.0.0.1/mytest/test1 代理转发 http://127.0.0.1:8080/abctest1\n\nlocation /mytest/{\n\tproxy_pass http://127.0.0.1/8080/abc/;\n}\n\n#访问 http://127.0.0.1/mytest/test1 代理转发 http://127.0.0.1:8080/abc/test1\n```\n\n> 推荐使用 https://nginxconfig.io/ 可自定义配置","source":"_posts/Nginx-配置详解.md","raw":"---\ntitle: Nginx 配置详解\ntags:\n  - 技术\ncategories:\n  - 技术\ntoc: false\ndate: 2019-08-09 16:33:35\n---\n\n![](/images/nginxconf.png)\n\n> 学习 Nginx的配置文件用于以后回来查询回顾\n\n### Core 模块\n- 配置运行Nginx服务器用户（组）\n- worker process数\n- Nginx进程PID存放路径\n- 错误日志的存放路径\n- 配置文件的引入\n``` bash\nuser nobody nobody;\nworker_processes 2;\nerror_log logs/error.log notice;\npid logs/nginx.pid;\nworker_rlimit_nofile 65535;\n```\n##### 基本参数\n\n|参数|描述|\n|-|-|\n|user|指定 Nginx Woker 进程运行用户以及用户组，默认值 nobby nobby|\n|worker_processes|配置工作进程数，建议于CPU核心数量一致，auto为自动检测|\n|error_log|日志文件的地址和日志级别，debug、info、notice、warn、error、crit|\n|pid|pid进程标识符存放地址|\n|worker_rlimit_nofile worker|进程可以打开最大文件限制数|\n\n\n### Events 模块\n- 该部分配置主要影响Nginx服务器与用户的网络连接，主要包括：\n- 设置网络连接的序列化\n- 是否允许同时接收多个网络连接\n- 事件驱动模型的选择\n- 进程连接数的配置\n\n``` bash\nevents {\n    worker_connections 2048;\n    multi_accept on;\n    use epoll;\n    keepalive_timeout 60;\n    accept_mutex on;\n}\n```\n|参数|描述|\n|-|-|\n|worker_connections |每个进程的最大连接数，客户端连接数 MaxClient = worker_processes * worker_connections，Linux 系统下进程最大连接数受最大文件句柄数所限制，通过`ulimit -n 连接数`来改变其最大打开文件数|\n|use |事件驱动模式 kqueue、rtsig、epoll、/dev/poll、select、poll 、eventport|\n|multi_accept|是否允许同时接受多个连接|\n|keepalive_timeout | 连接超时时间单位（秒）|\n|accept_mutex |网路连接序列化，防止__惊群现象__发生，默认为on|\n\n##### 惊群现象\n![](/images/thundering-herd.png)\n当`CreateSocket`发生连接事件时，所有的`fork`进程都被唤醒，而最终只有一个进程能处理事件响应，其余进程无法获取事件则只能重新睡眠或其他操作，这样现象我们称之为__惊群现象__\n\n### Http 模块\n- 定义MIMI-Type\n- 自定义服务日志\n- 允许sendfile方式传输文件\n- 连接超时时间\n- 单连接请求数上限\n``` bash\nhttp {\n    include mine.types;\n    server_tokens off;\n    default_type application/octet-stream\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    keepalive_timeout 65；\n    ...\n}\n```\n##### 基本参数\n\n|参数|描述|\n|-|-|\n|include|将其他的Nginx配置或者第三方模块的配置引用到当前的主配置文件中|\n|keepalive_timeout|客户端连接保持活动的超时时间|\n|sendfile on |开启高效文件传输模式|\n|default_type |默认类型为二进制流|\n\n#### Upstream 负载均衡模块\n负载均衡目前支持4种方法：\n\n|方法|描述|\n|-|-|\n|poll 轮询|默认方法按照请求时间依次分发到配置的服务|\n|weight 权重|根据服务配置的权重来进行分配请求|\n|ip_hash|根据请求 ip 的 hash 值来固定访问服务，解决了服务 session 不一致问题|\n|fair|根据请求的响应时间智能分配服务|\n|url_hash|根据请求的 url 的 hash 地址分配服务|\n\n##### 基本参数\n\n|参数|描述|\n|-|-|\n|fail_timeout|失败时间周期|\n|max_fails|在 fail_timeout 周期内之内所有请求（最大失败次数）均失败则认为服务停机，等待 fail_timeout 周期后再请求|\n|backup\t|服务标记为热备状态，当其他服务为停机状态下请求才会被分配热备服务|\n|down|服务被标记为停机状态|\n|max_conns|最大连接数|\n\n``` bash\nupstream mysvr {   \n      server 127.0.0.1:7878;\n      server 192.168.10.121:3333 backup;  #热备\n}\n```\n\n#### Server 配置\n- 配置网络监听\n- 基于名称的虚拟主机配置\n- 基于IP的虚拟主机配置\n\n``` bash\nserver {\n        keepalive_requests 120; #单连接请求上限次数。\n        listen       4545;   #监听端口\n\t    acccess_log /var/access.log;\n        server_name  127.0.0.1;   #监听地址      \n\t    root /var/www;\n\n        location  ~*^.+$ {      \n           proxy_pass  http://mysvr;\n           deny 127.0.0.1;  #拒绝的ip\n           allow 172.18.5.54; #允许的ip           \n        } \n}\n```\n##### 基本参数\n|参数|描述|\n|-|-|\n|listen|监听配置格式`[ip:port]`、`[ip]`、`[port]`|\n|server_name|监听域名可用正则进行通配|\n|access_log|访问记录日志地址|\n|keepalive_requests|单连接请求上线次数|\n|root|作为根目录用于文件的检索|\n\n##### Location 配置\n通过指定模式来与客户端请求的URI相匹配，基本语法如下：`location [=|~|~*|^~|@] pattern{……}`\n\n|配置|匹配|\n|-|-|\n|/|模糊匹配|\n|=|精确匹配|\n|^~|标示 uri 以指定字符串开头|\n|~|正则匹配需要区别大小写|\n|~*|正则匹配不需要区别大小写|\n|@|指定区段无法访问|\n\n##### 优先级： = 高于 ^~ 高 ~* 等于 ~ 高于 /\n\n##### 基本参数\n\n|参数|描述|\n|-|-|\n|proxy_pass|代理转发 proxy_pass后面的url加`/`，表示`绝对根路径`；如果没有`/`，表示`相对路径`|\n|alias|访问文件路径别名|\n\n###### 例子\n``` bash\nlocation /mytest/ {\n\tproxy_pass http://127.0.0.1:8080/abc;\n}\n\n# 访问 http://127.0.0.1/mytest/test1 代理转发 http://127.0.0.1:8080/abctest1\n\nlocation /mytest/{\n\tproxy_pass http://127.0.0.1/8080/abc/;\n}\n\n#访问 http://127.0.0.1/mytest/test1 代理转发 http://127.0.0.1:8080/abc/test1\n```\n\n> 推荐使用 https://nginxconfig.io/ 可自定义配置","slug":"Nginx-配置详解","published":1,"updated":"2020-11-19T01:23:23.151Z","_id":"ckhmyc98c0027jsudvvtakgi1","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/images/nginxconf.png\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>学习 Nginx的配置文件用于以后回来查询回顾</p>\n</blockquote>\n<h3 id=\"Core-模块\"><a href=\"#Core-模块\" class=\"headerlink\" title=\"Core 模块\"></a>Core 模块</h3><ul>\n<li>配置运行Nginx服务器用户（组）</li>\n<li>worker process数</li>\n<li>Nginx进程PID存放路径</li>\n<li>错误日志的存放路径</li>\n<li>配置文件的引入<pre><code class=\"hljs bash\">user nobody nobody;\nworker_processes 2;\nerror_log logs/error.log notice;\npid logs/nginx.pid;\nworker_rlimit_nofile 65535;</code></pre>\n</li>\n</ul>\n<h5 id=\"基本参数\"><a href=\"#基本参数\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>user</td>\n<td>指定 Nginx Woker 进程运行用户以及用户组，默认值 nobby nobby</td>\n</tr>\n<tr>\n<td>worker_processes</td>\n<td>配置工作进程数，建议于CPU核心数量一致，auto为自动检测</td>\n</tr>\n<tr>\n<td>error_log</td>\n<td>日志文件的地址和日志级别，debug、info、notice、warn、error、crit</td>\n</tr>\n<tr>\n<td>pid</td>\n<td>pid进程标识符存放地址</td>\n</tr>\n<tr>\n<td>worker_rlimit_nofile worker</td>\n<td>进程可以打开最大文件限制数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Events-模块\"><a href=\"#Events-模块\" class=\"headerlink\" title=\"Events 模块\"></a>Events 模块</h3><ul>\n<li>该部分配置主要影响Nginx服务器与用户的网络连接，主要包括：</li>\n<li>设置网络连接的序列化</li>\n<li>是否允许同时接收多个网络连接</li>\n<li>事件驱动模型的选择</li>\n<li>进程连接数的配置</li>\n</ul>\n<pre><code class=\"hljs bash\">events &#123;\n    worker_connections 2048;\n    multi_accept on;\n    use epoll;\n    keepalive_timeout 60;\n    accept_mutex on;\n&#125;</code></pre>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>worker_connections</td>\n<td>每个进程的最大连接数，客户端连接数 MaxClient = worker_processes * worker_connections，Linux 系统下进程最大连接数受最大文件句柄数所限制，通过<code>ulimit -n 连接数</code>来改变其最大打开文件数</td>\n</tr>\n<tr>\n<td>use</td>\n<td>事件驱动模式 kqueue、rtsig、epoll、/dev/poll、select、poll 、eventport</td>\n</tr>\n<tr>\n<td>multi_accept</td>\n<td>是否允许同时接受多个连接</td>\n</tr>\n<tr>\n<td>keepalive_timeout</td>\n<td>连接超时时间单位（秒）</td>\n</tr>\n<tr>\n<td>accept_mutex</td>\n<td>网路连接序列化，防止<strong>惊群现象</strong>发生，默认为on</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"惊群现象\"><a href=\"#惊群现象\" class=\"headerlink\" title=\"惊群现象\"></a>惊群现象</h5><p><img src=\"/images/thundering-herd.png\" srcset=\"/img/loading.gif\" alt><br>当<code>CreateSocket</code>发生连接事件时，所有的<code>fork</code>进程都被唤醒，而最终只有一个进程能处理事件响应，其余进程无法获取事件则只能重新睡眠或其他操作，这样现象我们称之为<strong>惊群现象</strong></p>\n<h3 id=\"Http-模块\"><a href=\"#Http-模块\" class=\"headerlink\" title=\"Http 模块\"></a>Http 模块</h3><ul>\n<li>定义MIMI-Type</li>\n<li>自定义服务日志</li>\n<li>允许sendfile方式传输文件</li>\n<li>连接超时时间</li>\n<li>单连接请求数上限<pre><code class=\"hljs bash\">http &#123;\n    include mine.types;\n    server_tokens off;\n    default_type application/octet-stream\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    keepalive_timeout 65；\n    ...\n&#125;</code></pre>\n</li>\n</ul>\n<h5 id=\"基本参数-1\"><a href=\"#基本参数-1\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>include</td>\n<td>将其他的Nginx配置或者第三方模块的配置引用到当前的主配置文件中</td>\n</tr>\n<tr>\n<td>keepalive_timeout</td>\n<td>客户端连接保持活动的超时时间</td>\n</tr>\n<tr>\n<td>sendfile on</td>\n<td>开启高效文件传输模式</td>\n</tr>\n<tr>\n<td>default_type</td>\n<td>默认类型为二进制流</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Upstream-负载均衡模块\"><a href=\"#Upstream-负载均衡模块\" class=\"headerlink\" title=\"Upstream 负载均衡模块\"></a>Upstream 负载均衡模块</h4><p>负载均衡目前支持4种方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>poll 轮询</td>\n<td>默认方法按照请求时间依次分发到配置的服务</td>\n</tr>\n<tr>\n<td>weight 权重</td>\n<td>根据服务配置的权重来进行分配请求</td>\n</tr>\n<tr>\n<td>ip_hash</td>\n<td>根据请求 ip 的 hash 值来固定访问服务，解决了服务 session 不一致问题</td>\n</tr>\n<tr>\n<td>fair</td>\n<td>根据请求的响应时间智能分配服务</td>\n</tr>\n<tr>\n<td>url_hash</td>\n<td>根据请求的 url 的 hash 地址分配服务</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"基本参数-2\"><a href=\"#基本参数-2\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fail_timeout</td>\n<td>失败时间周期</td>\n</tr>\n<tr>\n<td>max_fails</td>\n<td>在 fail_timeout 周期内之内所有请求（最大失败次数）均失败则认为服务停机，等待 fail_timeout 周期后再请求</td>\n</tr>\n<tr>\n<td>backup</td>\n<td>服务标记为热备状态，当其他服务为停机状态下请求才会被分配热备服务</td>\n</tr>\n<tr>\n<td>down</td>\n<td>服务被标记为停机状态</td>\n</tr>\n<tr>\n<td>max_conns</td>\n<td>最大连接数</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"hljs bash\">upstream mysvr &#123;   \n      server 127.0.0.1:7878;\n      server 192.168.10.121:3333 backup;  <span class=\"hljs-comment\">#热备</span>\n&#125;</code></pre>\n<h4 id=\"Server-配置\"><a href=\"#Server-配置\" class=\"headerlink\" title=\"Server 配置\"></a>Server 配置</h4><ul>\n<li>配置网络监听</li>\n<li>基于名称的虚拟主机配置</li>\n<li>基于IP的虚拟主机配置</li>\n</ul>\n<pre><code class=\"hljs bash\">server &#123;\n        keepalive_requests 120; <span class=\"hljs-comment\">#单连接请求上限次数。</span>\n        listen       4545;   <span class=\"hljs-comment\">#监听端口</span>\n\t    acccess_log /var/access.log;\n        server_name  127.0.0.1;   <span class=\"hljs-comment\">#监听地址      </span>\n\t    root /var/www;\n\n        location  ~*^.+$ &#123;      \n           proxy_pass  http://mysvr;\n           deny 127.0.0.1;  <span class=\"hljs-comment\">#拒绝的ip</span>\n           allow 172.18.5.54; <span class=\"hljs-comment\">#允许的ip           </span>\n        &#125; \n&#125;</code></pre>\n<h5 id=\"基本参数-3\"><a href=\"#基本参数-3\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>listen</td>\n<td>监听配置格式<code>[ip:port]</code>、<code>[ip]</code>、<code>[port]</code></td>\n</tr>\n<tr>\n<td>server_name</td>\n<td>监听域名可用正则进行通配</td>\n</tr>\n<tr>\n<td>access_log</td>\n<td>访问记录日志地址</td>\n</tr>\n<tr>\n<td>keepalive_requests</td>\n<td>单连接请求上线次数</td>\n</tr>\n<tr>\n<td>root</td>\n<td>作为根目录用于文件的检索</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Location-配置\"><a href=\"#Location-配置\" class=\"headerlink\" title=\"Location 配置\"></a>Location 配置</h5><p>通过指定模式来与客户端请求的URI相匹配，基本语法如下：<code>location [=|~|~*|^~|@] pattern{……}</code></p>\n<table>\n<thead>\n<tr>\n<th>配置</th>\n<th>匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/</td>\n<td>模糊匹配</td>\n</tr>\n<tr>\n<td>=</td>\n<td>精确匹配</td>\n</tr>\n<tr>\n<td>^~</td>\n<td>标示 uri 以指定字符串开头</td>\n</tr>\n<tr>\n<td>~</td>\n<td>正则匹配需要区别大小写</td>\n</tr>\n<tr>\n<td>~*</td>\n<td>正则匹配不需要区别大小写</td>\n</tr>\n<tr>\n<td>@</td>\n<td>指定区段无法访问</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"优先级：-高于-高-等于-高于\"><a href=\"#优先级：-高于-高-等于-高于\" class=\"headerlink\" title=\"优先级： = 高于 ^~ 高 ~* 等于 ~ 高于 /\"></a>优先级： = 高于 ^~ 高 ~* 等于 ~ 高于 /</h5><h5 id=\"基本参数-4\"><a href=\"#基本参数-4\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>proxy_pass</td>\n<td>代理转发 proxy_pass后面的url加<code>/</code>，表示<code>绝对根路径</code>；如果没有<code>/</code>，表示<code>相对路径</code></td>\n</tr>\n<tr>\n<td>alias</td>\n<td>访问文件路径别名</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h6><pre><code class=\"hljs bash\">location /mytest/ &#123;\n\tproxy_pass http://127.0.0.1:8080/abc;\n&#125;\n\n<span class=\"hljs-comment\"># 访问 http://127.0.0.1/mytest/test1 代理转发 http://127.0.0.1:8080/abctest1</span>\n\nlocation /mytest/&#123;\n\tproxy_pass http://127.0.0.1/8080/abc/;\n&#125;\n\n<span class=\"hljs-comment\">#访问 http://127.0.0.1/mytest/test1 代理转发 http://127.0.0.1:8080/abc/test1</span></code></pre>\n<blockquote>\n<p>推荐使用 <a href=\"https://nginxconfig.io/\" target=\"_blank\" rel=\"noopener\">https://nginxconfig.io/</a> 可自定义配置</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/nginxconf.png\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>学习 Nginx的配置文件用于以后回来查询回顾</p>\n</blockquote>\n<h3 id=\"Core-模块\"><a href=\"#Core-模块\" class=\"headerlink\" title=\"Core 模块\"></a>Core 模块</h3><ul>\n<li>配置运行Nginx服务器用户（组）</li>\n<li>worker process数</li>\n<li>Nginx进程PID存放路径</li>\n<li>错误日志的存放路径</li>\n<li>配置文件的引入<pre><code class=\"hljs bash\">user nobody nobody;\nworker_processes 2;\nerror_log logs/error.log notice;\npid logs/nginx.pid;\nworker_rlimit_nofile 65535;</code></pre>\n</li>\n</ul>\n<h5 id=\"基本参数\"><a href=\"#基本参数\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>user</td>\n<td>指定 Nginx Woker 进程运行用户以及用户组，默认值 nobby nobby</td>\n</tr>\n<tr>\n<td>worker_processes</td>\n<td>配置工作进程数，建议于CPU核心数量一致，auto为自动检测</td>\n</tr>\n<tr>\n<td>error_log</td>\n<td>日志文件的地址和日志级别，debug、info、notice、warn、error、crit</td>\n</tr>\n<tr>\n<td>pid</td>\n<td>pid进程标识符存放地址</td>\n</tr>\n<tr>\n<td>worker_rlimit_nofile worker</td>\n<td>进程可以打开最大文件限制数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Events-模块\"><a href=\"#Events-模块\" class=\"headerlink\" title=\"Events 模块\"></a>Events 模块</h3><ul>\n<li>该部分配置主要影响Nginx服务器与用户的网络连接，主要包括：</li>\n<li>设置网络连接的序列化</li>\n<li>是否允许同时接收多个网络连接</li>\n<li>事件驱动模型的选择</li>\n<li>进程连接数的配置</li>\n</ul>\n<pre><code class=\"hljs bash\">events &#123;\n    worker_connections 2048;\n    multi_accept on;\n    use epoll;\n    keepalive_timeout 60;\n    accept_mutex on;\n&#125;</code></pre>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>worker_connections</td>\n<td>每个进程的最大连接数，客户端连接数 MaxClient = worker_processes * worker_connections，Linux 系统下进程最大连接数受最大文件句柄数所限制，通过<code>ulimit -n 连接数</code>来改变其最大打开文件数</td>\n</tr>\n<tr>\n<td>use</td>\n<td>事件驱动模式 kqueue、rtsig、epoll、/dev/poll、select、poll 、eventport</td>\n</tr>\n<tr>\n<td>multi_accept</td>\n<td>是否允许同时接受多个连接</td>\n</tr>\n<tr>\n<td>keepalive_timeout</td>\n<td>连接超时时间单位（秒）</td>\n</tr>\n<tr>\n<td>accept_mutex</td>\n<td>网路连接序列化，防止<strong>惊群现象</strong>发生，默认为on</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"惊群现象\"><a href=\"#惊群现象\" class=\"headerlink\" title=\"惊群现象\"></a>惊群现象</h5><p><img src=\"/images/thundering-herd.png\" srcset=\"/img/loading.gif\" alt><br>当<code>CreateSocket</code>发生连接事件时，所有的<code>fork</code>进程都被唤醒，而最终只有一个进程能处理事件响应，其余进程无法获取事件则只能重新睡眠或其他操作，这样现象我们称之为<strong>惊群现象</strong></p>\n<h3 id=\"Http-模块\"><a href=\"#Http-模块\" class=\"headerlink\" title=\"Http 模块\"></a>Http 模块</h3><ul>\n<li>定义MIMI-Type</li>\n<li>自定义服务日志</li>\n<li>允许sendfile方式传输文件</li>\n<li>连接超时时间</li>\n<li>单连接请求数上限<pre><code class=\"hljs bash\">http &#123;\n    include mine.types;\n    server_tokens off;\n    default_type application/octet-stream\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    keepalive_timeout 65；\n    ...\n&#125;</code></pre>\n</li>\n</ul>\n<h5 id=\"基本参数-1\"><a href=\"#基本参数-1\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>include</td>\n<td>将其他的Nginx配置或者第三方模块的配置引用到当前的主配置文件中</td>\n</tr>\n<tr>\n<td>keepalive_timeout</td>\n<td>客户端连接保持活动的超时时间</td>\n</tr>\n<tr>\n<td>sendfile on</td>\n<td>开启高效文件传输模式</td>\n</tr>\n<tr>\n<td>default_type</td>\n<td>默认类型为二进制流</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Upstream-负载均衡模块\"><a href=\"#Upstream-负载均衡模块\" class=\"headerlink\" title=\"Upstream 负载均衡模块\"></a>Upstream 负载均衡模块</h4><p>负载均衡目前支持4种方法：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>poll 轮询</td>\n<td>默认方法按照请求时间依次分发到配置的服务</td>\n</tr>\n<tr>\n<td>weight 权重</td>\n<td>根据服务配置的权重来进行分配请求</td>\n</tr>\n<tr>\n<td>ip_hash</td>\n<td>根据请求 ip 的 hash 值来固定访问服务，解决了服务 session 不一致问题</td>\n</tr>\n<tr>\n<td>fair</td>\n<td>根据请求的响应时间智能分配服务</td>\n</tr>\n<tr>\n<td>url_hash</td>\n<td>根据请求的 url 的 hash 地址分配服务</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"基本参数-2\"><a href=\"#基本参数-2\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fail_timeout</td>\n<td>失败时间周期</td>\n</tr>\n<tr>\n<td>max_fails</td>\n<td>在 fail_timeout 周期内之内所有请求（最大失败次数）均失败则认为服务停机，等待 fail_timeout 周期后再请求</td>\n</tr>\n<tr>\n<td>backup</td>\n<td>服务标记为热备状态，当其他服务为停机状态下请求才会被分配热备服务</td>\n</tr>\n<tr>\n<td>down</td>\n<td>服务被标记为停机状态</td>\n</tr>\n<tr>\n<td>max_conns</td>\n<td>最大连接数</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"hljs bash\">upstream mysvr &#123;   \n      server 127.0.0.1:7878;\n      server 192.168.10.121:3333 backup;  <span class=\"hljs-comment\">#热备</span>\n&#125;</code></pre>\n<h4 id=\"Server-配置\"><a href=\"#Server-配置\" class=\"headerlink\" title=\"Server 配置\"></a>Server 配置</h4><ul>\n<li>配置网络监听</li>\n<li>基于名称的虚拟主机配置</li>\n<li>基于IP的虚拟主机配置</li>\n</ul>\n<pre><code class=\"hljs bash\">server &#123;\n        keepalive_requests 120; <span class=\"hljs-comment\">#单连接请求上限次数。</span>\n        listen       4545;   <span class=\"hljs-comment\">#监听端口</span>\n\t    acccess_log /var/access.log;\n        server_name  127.0.0.1;   <span class=\"hljs-comment\">#监听地址      </span>\n\t    root /var/www;\n\n        location  ~*^.+$ &#123;      \n           proxy_pass  http://mysvr;\n           deny 127.0.0.1;  <span class=\"hljs-comment\">#拒绝的ip</span>\n           allow 172.18.5.54; <span class=\"hljs-comment\">#允许的ip           </span>\n        &#125; \n&#125;</code></pre>\n<h5 id=\"基本参数-3\"><a href=\"#基本参数-3\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>listen</td>\n<td>监听配置格式<code>[ip:port]</code>、<code>[ip]</code>、<code>[port]</code></td>\n</tr>\n<tr>\n<td>server_name</td>\n<td>监听域名可用正则进行通配</td>\n</tr>\n<tr>\n<td>access_log</td>\n<td>访问记录日志地址</td>\n</tr>\n<tr>\n<td>keepalive_requests</td>\n<td>单连接请求上线次数</td>\n</tr>\n<tr>\n<td>root</td>\n<td>作为根目录用于文件的检索</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Location-配置\"><a href=\"#Location-配置\" class=\"headerlink\" title=\"Location 配置\"></a>Location 配置</h5><p>通过指定模式来与客户端请求的URI相匹配，基本语法如下：<code>location [=|~|~*|^~|@] pattern{……}</code></p>\n<table>\n<thead>\n<tr>\n<th>配置</th>\n<th>匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/</td>\n<td>模糊匹配</td>\n</tr>\n<tr>\n<td>=</td>\n<td>精确匹配</td>\n</tr>\n<tr>\n<td>^~</td>\n<td>标示 uri 以指定字符串开头</td>\n</tr>\n<tr>\n<td>~</td>\n<td>正则匹配需要区别大小写</td>\n</tr>\n<tr>\n<td>~*</td>\n<td>正则匹配不需要区别大小写</td>\n</tr>\n<tr>\n<td>@</td>\n<td>指定区段无法访问</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"优先级：-高于-高-等于-高于\"><a href=\"#优先级：-高于-高-等于-高于\" class=\"headerlink\" title=\"优先级： = 高于 ^~ 高 ~* 等于 ~ 高于 /\"></a>优先级： = 高于 ^~ 高 ~* 等于 ~ 高于 /</h5><h5 id=\"基本参数-4\"><a href=\"#基本参数-4\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>proxy_pass</td>\n<td>代理转发 proxy_pass后面的url加<code>/</code>，表示<code>绝对根路径</code>；如果没有<code>/</code>，表示<code>相对路径</code></td>\n</tr>\n<tr>\n<td>alias</td>\n<td>访问文件路径别名</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h6><pre><code class=\"hljs bash\">location /mytest/ &#123;\n\tproxy_pass http://127.0.0.1:8080/abc;\n&#125;\n\n<span class=\"hljs-comment\"># 访问 http://127.0.0.1/mytest/test1 代理转发 http://127.0.0.1:8080/abctest1</span>\n\nlocation /mytest/&#123;\n\tproxy_pass http://127.0.0.1/8080/abc/;\n&#125;\n\n<span class=\"hljs-comment\">#访问 http://127.0.0.1/mytest/test1 代理转发 http://127.0.0.1:8080/abc/test1</span></code></pre>\n<blockquote>\n<p>推荐使用 <a href=\"https://nginxconfig.io/\" target=\"_blank\" rel=\"noopener\">https://nginxconfig.io/</a> 可自定义配置</p>\n</blockquote>\n"},{"title":"Oracle数据库驱动","toc":false,"date":"2019-10-17T06:40:59.000Z","_content":"\n> 记录下 Ｏracle 版本和 jdbc 一些对应知识\n\n#### 查询数据库版本\n``` sql\n# 版本信息\nselect* from v$version;\n# 产品信息\nselect * from product_component_version;\n``` \n\n#### 项目引入\n一般项目使用maven 来管理项目jar 在引入 ojdbc 时会无法加载下载必须要去官方自行下载然后注册到 `C:\\Users\\Administrator\\.m2\\repository\\com\\oracle\\数据库版本 ` (ps:此地址为默认的maven库地址)，下\n载地址为 https://www.oracle.com/database/technologies/jdbcdriver-ucp-downloads.html 自行根据情况下载相应的 ojdbc.jar\n\n``` bash\nmvn install:install-file -Dfile=D:\\Downloads\\ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0.3 -Dpackaging=jar -DgeneratePom=true\n```\n\n##### 参数详解 \n- install:可以将项目本身编译并打包到本地仓库\n- install-file:安装文件\n- -Dfile=D:\\Downloads\\ojdbc6.jar : 指定要打的包的文件位置\n- -DgroupId=com.oracle : 指定当前包的groupId为com.oracle\n- -DartifactId=ojdbc6 : 指定当前的artifactfactId为ojdbc6\n- -Dversion=11.2.0.3 : 指定当前包的版本为11.2.0.3\n- -DgeneratePom=true:是否生成pom文件\n\n```\n# maven 引入\n<dependency>\n   <groupId>com.oracle</groupId>\n   <artifactId>ojdbc6</artifactId>\n   <version>11.2.0.3</version>\n</dependency>\n```\n\n#### 版本对应的 jdbc\n![](/images/oralce_jdbc.png)","source":"_posts/Oracle数据库驱动.md","raw":"---\ntitle: Oracle数据库驱动\ntags:\n  - Java\ncategories:\n  - 数据库\ntoc: false\ndate: 2019-10-17 14:40:59\n---\n\n> 记录下 Ｏracle 版本和 jdbc 一些对应知识\n\n#### 查询数据库版本\n``` sql\n# 版本信息\nselect* from v$version;\n# 产品信息\nselect * from product_component_version;\n``` \n\n#### 项目引入\n一般项目使用maven 来管理项目jar 在引入 ojdbc 时会无法加载下载必须要去官方自行下载然后注册到 `C:\\Users\\Administrator\\.m2\\repository\\com\\oracle\\数据库版本 ` (ps:此地址为默认的maven库地址)，下\n载地址为 https://www.oracle.com/database/technologies/jdbcdriver-ucp-downloads.html 自行根据情况下载相应的 ojdbc.jar\n\n``` bash\nmvn install:install-file -Dfile=D:\\Downloads\\ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0.3 -Dpackaging=jar -DgeneratePom=true\n```\n\n##### 参数详解 \n- install:可以将项目本身编译并打包到本地仓库\n- install-file:安装文件\n- -Dfile=D:\\Downloads\\ojdbc6.jar : 指定要打的包的文件位置\n- -DgroupId=com.oracle : 指定当前包的groupId为com.oracle\n- -DartifactId=ojdbc6 : 指定当前的artifactfactId为ojdbc6\n- -Dversion=11.2.0.3 : 指定当前包的版本为11.2.0.3\n- -DgeneratePom=true:是否生成pom文件\n\n```\n# maven 引入\n<dependency>\n   <groupId>com.oracle</groupId>\n   <artifactId>ojdbc6</artifactId>\n   <version>11.2.0.3</version>\n</dependency>\n```\n\n#### 版本对应的 jdbc\n![](/images/oralce_jdbc.png)","slug":"Oracle数据库驱动","published":1,"updated":"2020-08-10T01:48:44.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc98f002bjsud1egyqpn1","content":"<blockquote>\n<p>记录下 Ｏracle 版本和 jdbc 一些对应知识</p>\n</blockquote>\n<h4 id=\"查询数据库版本\"><a href=\"#查询数据库版本\" class=\"headerlink\" title=\"查询数据库版本\"></a>查询数据库版本</h4><pre><code class=\"hljs sql\"><span class=\"hljs-comment\"># 版本信息</span>\n<span class=\"hljs-keyword\">select</span>* <span class=\"hljs-keyword\">from</span> v$<span class=\"hljs-keyword\">version</span>;\n<span class=\"hljs-comment\"># 产品信息</span>\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> product_component_version;\n``` \n\n<span class=\"hljs-comment\">#### 项目引入</span>\n一般项目使用maven 来管理项目jar 在引入 ojdbc 时会无法加载下载必须要去官方自行下载然后注册到 `C:\\Users\\Administrator\\.m2\\repository\\com\\oracle\\数据库版本 ` (ps:此地址为默认的maven库地址)，下\n载地址为 https://www.oracle.com/database/technologies/jdbcdriver-ucp-downloads.html 自行根据情况下载相应的 ojdbc.jar\n\n``` bash\nmvn <span class=\"hljs-keyword\">install</span>:<span class=\"hljs-keyword\">install</span>-<span class=\"hljs-keyword\">file</span> -Dfile=D:\\Downloads\\ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=<span class=\"hljs-number\">11.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.3</span> -Dpackaging=jar -DgeneratePom=<span class=\"hljs-literal\">true</span></code></pre>\n<h5 id=\"参数详解\"><a href=\"#参数详解\" class=\"headerlink\" title=\"参数详解\"></a>参数详解</h5><ul>\n<li>install:可以将项目本身编译并打包到本地仓库</li>\n<li>install-file:安装文件</li>\n<li>-Dfile=D:\\Downloads\\ojdbc6.jar : 指定要打的包的文件位置</li>\n<li>-DgroupId=com.oracle : 指定当前包的groupId为com.oracle</li>\n<li>-DartifactId=ojdbc6 : 指定当前的artifactfactId为ojdbc6</li>\n<li>-Dversion=11.2.0.3 : 指定当前包的版本为11.2.0.3</li>\n<li>-DgeneratePom=true:是否生成pom文件</li>\n</ul>\n<pre><code class=\"hljs undefined\"><span class=\"hljs-meta\"># maven 引入</span>\n<span class=\"hljs-params\">&lt;dependency&gt;</span>\n   <span class=\"hljs-params\">&lt;groupId&gt;</span>com.oracle<span class=\"hljs-params\">&lt;/groupId&gt;</span>\n   <span class=\"hljs-params\">&lt;artifactId&gt;</span>ojdbc6<span class=\"hljs-params\">&lt;/artifactId&gt;</span>\n   <span class=\"hljs-params\">&lt;version&gt;</span><span class=\"hljs-number\">11.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.3</span><span class=\"hljs-params\">&lt;/version&gt;</span>\n<span class=\"hljs-params\">&lt;/dependency&gt;</span></code></pre>\n<h4 id=\"版本对应的-jdbc\"><a href=\"#版本对应的-jdbc\" class=\"headerlink\" title=\"版本对应的 jdbc\"></a>版本对应的 jdbc</h4><p><img src=\"/images/oralce_jdbc.png\" srcset=\"/img/loading.gif\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>记录下 Ｏracle 版本和 jdbc 一些对应知识</p>\n</blockquote>\n<h4 id=\"查询数据库版本\"><a href=\"#查询数据库版本\" class=\"headerlink\" title=\"查询数据库版本\"></a>查询数据库版本</h4><pre><code class=\"hljs sql\"><span class=\"hljs-comment\"># 版本信息</span>\n<span class=\"hljs-keyword\">select</span>* <span class=\"hljs-keyword\">from</span> v$<span class=\"hljs-keyword\">version</span>;\n<span class=\"hljs-comment\"># 产品信息</span>\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> product_component_version;\n``` \n\n<span class=\"hljs-comment\">#### 项目引入</span>\n一般项目使用maven 来管理项目jar 在引入 ojdbc 时会无法加载下载必须要去官方自行下载然后注册到 `C:\\Users\\Administrator\\.m2\\repository\\com\\oracle\\数据库版本 ` (ps:此地址为默认的maven库地址)，下\n载地址为 https://www.oracle.com/database/technologies/jdbcdriver-ucp-downloads.html 自行根据情况下载相应的 ojdbc.jar\n\n``` bash\nmvn <span class=\"hljs-keyword\">install</span>:<span class=\"hljs-keyword\">install</span>-<span class=\"hljs-keyword\">file</span> -Dfile=D:\\Downloads\\ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=<span class=\"hljs-number\">11.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.3</span> -Dpackaging=jar -DgeneratePom=<span class=\"hljs-literal\">true</span></code></pre>\n<h5 id=\"参数详解\"><a href=\"#参数详解\" class=\"headerlink\" title=\"参数详解\"></a>参数详解</h5><ul>\n<li>install:可以将项目本身编译并打包到本地仓库</li>\n<li>install-file:安装文件</li>\n<li>-Dfile=D:\\Downloads\\ojdbc6.jar : 指定要打的包的文件位置</li>\n<li>-DgroupId=com.oracle : 指定当前包的groupId为com.oracle</li>\n<li>-DartifactId=ojdbc6 : 指定当前的artifactfactId为ojdbc6</li>\n<li>-Dversion=11.2.0.3 : 指定当前包的版本为11.2.0.3</li>\n<li>-DgeneratePom=true:是否生成pom文件</li>\n</ul>\n<pre><code class=\"hljs undefined\"><span class=\"hljs-meta\"># maven 引入</span>\n<span class=\"hljs-params\">&lt;dependency&gt;</span>\n   <span class=\"hljs-params\">&lt;groupId&gt;</span>com.oracle<span class=\"hljs-params\">&lt;/groupId&gt;</span>\n   <span class=\"hljs-params\">&lt;artifactId&gt;</span>ojdbc6<span class=\"hljs-params\">&lt;/artifactId&gt;</span>\n   <span class=\"hljs-params\">&lt;version&gt;</span><span class=\"hljs-number\">11.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.3</span><span class=\"hljs-params\">&lt;/version&gt;</span>\n<span class=\"hljs-params\">&lt;/dependency&gt;</span></code></pre>\n<h4 id=\"版本对应的-jdbc\"><a href=\"#版本对应的-jdbc\" class=\"headerlink\" title=\"版本对应的 jdbc\"></a>版本对应的 jdbc</h4><p><img src=\"/images/oralce_jdbc.png\" srcset=\"/img/loading.gif\" alt></p>\n"},{"title":"Python验证码识别","date":"2018-05-25T08:27:08.000Z","_content":"\n>Python 第三方库 PIL Pytesseract tesseract-ocr  进行爬虫验证码识别\n\n## 1.Python 第三方库依赖\n   通过cmd控制台进入python pip目录执行pip install requests 进行安装\n   其他的第三方库都可以通过这种形式进行安装\n```bash\n#进入Python脚本文件夹\ncd C:\\Users\\serwer\\AppData\\Local\\Programs\\Python\\Python36-32\\Scripts\n#安装 requests 请求http库\npip install requests \n#安装 pytesseract 基础识别库\npip install pytesseract\n#安装 Image图片处理 为更好识别验证码\npip install Image\n#显示requests相关信息\npip show requests\n```\n   可以通过配置pip环境变量达到在任意文件夹目录进行pip脚本执行\n\n## 2.OCR图形识别软件 （Google维护的开源的OCR）\nTesseract-ocr [github地址](https://github.com/tesseract-ocr/tesseract) window 可选择[Tesseract-ocr-setup-3.05.01.exe](https://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe)\n\n``` pthyon\n    import requests\n    import pytesseract\n    from PIL import Image\n    \n    imagePath = \"D:\\\\1.gif\"\n    imageUrl = \"http://112.112.9.205:88/ValiateNum.ashx\"\n    \n    def getAuthCodeImage():\n        r = requests.get(imageUrl， stream=True)\n        with open(imagePath， 'wb') as fd:\n    \t    for chunk in r.iter_content(1024):\n            \tfd.write(chunk)\n    \t        fd.close\n    \n    def disposeImage():\n    \timage = Image.open(imagePath)\n    \ttable = []    \n    \tfor i in range(256):    \n    \t    if i < 140:    \n    \t        table.append(0)    \n    \t    else:    \n    \t        table.append(1)  \n    \timage = image.convert('L')\n    \timage = image.resize((300，100)，Image.BILINEAR)\n    \timage = image.point(table，'1')  \n    \timage.save(\"D:\\\\1.png\"，\"png\")\n    \n    \n    def discernCode():\n    \tim=Image.open(\"D:\\\\1.png\")\n    \tcode = pytesseract.image_to_string(im)\n    \tprint(code)\n    \n    #获取验证码并保存\n    getAuthCodeImage()\n    #验证码图片处理 灰阶处理\n    disposeImage()\n    #识别验证码\n    discernCode()\n```\n\n\n","source":"_posts/Python 第三方库 PIL.md","raw":"---\ntitle: Python验证码识别\ndate: 2018-05-25 16:27:08\ncategories: [Python]\ntags:\n    - Python\n---\n\n>Python 第三方库 PIL Pytesseract tesseract-ocr  进行爬虫验证码识别\n\n## 1.Python 第三方库依赖\n   通过cmd控制台进入python pip目录执行pip install requests 进行安装\n   其他的第三方库都可以通过这种形式进行安装\n```bash\n#进入Python脚本文件夹\ncd C:\\Users\\serwer\\AppData\\Local\\Programs\\Python\\Python36-32\\Scripts\n#安装 requests 请求http库\npip install requests \n#安装 pytesseract 基础识别库\npip install pytesseract\n#安装 Image图片处理 为更好识别验证码\npip install Image\n#显示requests相关信息\npip show requests\n```\n   可以通过配置pip环境变量达到在任意文件夹目录进行pip脚本执行\n\n## 2.OCR图形识别软件 （Google维护的开源的OCR）\nTesseract-ocr [github地址](https://github.com/tesseract-ocr/tesseract) window 可选择[Tesseract-ocr-setup-3.05.01.exe](https://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe)\n\n``` pthyon\n    import requests\n    import pytesseract\n    from PIL import Image\n    \n    imagePath = \"D:\\\\1.gif\"\n    imageUrl = \"http://112.112.9.205:88/ValiateNum.ashx\"\n    \n    def getAuthCodeImage():\n        r = requests.get(imageUrl， stream=True)\n        with open(imagePath， 'wb') as fd:\n    \t    for chunk in r.iter_content(1024):\n            \tfd.write(chunk)\n    \t        fd.close\n    \n    def disposeImage():\n    \timage = Image.open(imagePath)\n    \ttable = []    \n    \tfor i in range(256):    \n    \t    if i < 140:    \n    \t        table.append(0)    \n    \t    else:    \n    \t        table.append(1)  \n    \timage = image.convert('L')\n    \timage = image.resize((300，100)，Image.BILINEAR)\n    \timage = image.point(table，'1')  \n    \timage.save(\"D:\\\\1.png\"，\"png\")\n    \n    \n    def discernCode():\n    \tim=Image.open(\"D:\\\\1.png\")\n    \tcode = pytesseract.image_to_string(im)\n    \tprint(code)\n    \n    #获取验证码并保存\n    getAuthCodeImage()\n    #验证码图片处理 灰阶处理\n    disposeImage()\n    #识别验证码\n    discernCode()\n```\n\n\n","slug":"Python 第三方库 PIL","published":1,"updated":"2020-08-10T01:48:44.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc98h002fjsudkauiq8w6","content":"<blockquote>\n<p>Python 第三方库 PIL Pytesseract tesseract-ocr  进行爬虫验证码识别</p>\n</blockquote>\n<h2 id=\"1-Python-第三方库依赖\"><a href=\"#1-Python-第三方库依赖\" class=\"headerlink\" title=\"1.Python 第三方库依赖\"></a>1.Python 第三方库依赖</h2><p>   通过cmd控制台进入python pip目录执行pip install requests 进行安装<br>   其他的第三方库都可以通过这种形式进行安装<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#进入Python脚本文件夹</span>\n<span class=\"hljs-built_in\">cd</span> C:\\Users\\serwer\\AppData\\Local\\Programs\\Python\\Python36-32\\Scripts\n<span class=\"hljs-comment\">#安装 requests 请求http库</span>\npip install requests \n<span class=\"hljs-comment\">#安装 pytesseract 基础识别库</span>\npip install pytesseract\n<span class=\"hljs-comment\">#安装 Image图片处理 为更好识别验证码</span>\npip install Image\n<span class=\"hljs-comment\">#显示requests相关信息</span>\npip show requests</code></pre></p>\n<p>   可以通过配置pip环境变量达到在任意文件夹目录进行pip脚本执行</p>\n<h2 id=\"2-OCR图形识别软件-（Google维护的开源的OCR）\"><a href=\"#2-OCR图形识别软件-（Google维护的开源的OCR）\" class=\"headerlink\" title=\"2.OCR图形识别软件 （Google维护的开源的OCR）\"></a>2.OCR图形识别软件 （Google维护的开源的OCR）</h2><p>Tesseract-ocr <a href=\"https://github.com/tesseract-ocr/tesseract\" target=\"_blank\" rel=\"noopener\">github地址</a> window 可选择<a href=\"https://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe\" target=\"_blank\" rel=\"noopener\">Tesseract-ocr-setup-3.05.01.exe</a></p>\n<pre><code class=\"hljs pthyon\">import requests\nimport pytesseract\nfrom PIL import Image\n\nimagePath = &quot;D:\\\\1.gif&quot;\nimageUrl = &quot;http://112.112.9.205:88/ValiateNum.ashx&quot;\n\ndef getAuthCodeImage():\n    r = requests.get(imageUrl， stream=True)\n    with open(imagePath， &apos;wb&apos;) as fd:\n\t    for chunk in r.iter_content(1024):\n        \tfd.write(chunk)\n\t        fd.close\n\ndef disposeImage():\n\timage = Image.open(imagePath)\n\ttable = []    \n\tfor i in range(256):    \n\t    if i &lt; 140:    \n\t        table.append(0)    \n\t    else:    \n\t        table.append(1)  \n\timage = image.convert(&apos;L&apos;)\n\timage = image.resize((300，100)，Image.BILINEAR)\n\timage = image.point(table，&apos;1&apos;)  \n\timage.save(&quot;D:\\\\1.png&quot;，&quot;png&quot;)\n\n\ndef discernCode():\n\tim=Image.open(&quot;D:\\\\1.png&quot;)\n\tcode = pytesseract.image_to_string(im)\n\tprint(code)\n\n#获取验证码并保存\ngetAuthCodeImage()\n#验证码图片处理 灰阶处理\ndisposeImage()\n#识别验证码\ndiscernCode()</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Python 第三方库 PIL Pytesseract tesseract-ocr  进行爬虫验证码识别</p>\n</blockquote>\n<h2 id=\"1-Python-第三方库依赖\"><a href=\"#1-Python-第三方库依赖\" class=\"headerlink\" title=\"1.Python 第三方库依赖\"></a>1.Python 第三方库依赖</h2><p>   通过cmd控制台进入python pip目录执行pip install requests 进行安装<br>   其他的第三方库都可以通过这种形式进行安装<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#进入Python脚本文件夹</span>\n<span class=\"hljs-built_in\">cd</span> C:\\Users\\serwer\\AppData\\Local\\Programs\\Python\\Python36-32\\Scripts\n<span class=\"hljs-comment\">#安装 requests 请求http库</span>\npip install requests \n<span class=\"hljs-comment\">#安装 pytesseract 基础识别库</span>\npip install pytesseract\n<span class=\"hljs-comment\">#安装 Image图片处理 为更好识别验证码</span>\npip install Image\n<span class=\"hljs-comment\">#显示requests相关信息</span>\npip show requests</code></pre></p>\n<p>   可以通过配置pip环境变量达到在任意文件夹目录进行pip脚本执行</p>\n<h2 id=\"2-OCR图形识别软件-（Google维护的开源的OCR）\"><a href=\"#2-OCR图形识别软件-（Google维护的开源的OCR）\" class=\"headerlink\" title=\"2.OCR图形识别软件 （Google维护的开源的OCR）\"></a>2.OCR图形识别软件 （Google维护的开源的OCR）</h2><p>Tesseract-ocr <a href=\"https://github.com/tesseract-ocr/tesseract\" target=\"_blank\" rel=\"noopener\">github地址</a> window 可选择<a href=\"https://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe\" target=\"_blank\" rel=\"noopener\">Tesseract-ocr-setup-3.05.01.exe</a></p>\n<pre><code class=\"hljs pthyon\">import requests\nimport pytesseract\nfrom PIL import Image\n\nimagePath = &quot;D:\\\\1.gif&quot;\nimageUrl = &quot;http://112.112.9.205:88/ValiateNum.ashx&quot;\n\ndef getAuthCodeImage():\n    r = requests.get(imageUrl， stream=True)\n    with open(imagePath， &apos;wb&apos;) as fd:\n\t    for chunk in r.iter_content(1024):\n        \tfd.write(chunk)\n\t        fd.close\n\ndef disposeImage():\n\timage = Image.open(imagePath)\n\ttable = []    \n\tfor i in range(256):    \n\t    if i &lt; 140:    \n\t        table.append(0)    \n\t    else:    \n\t        table.append(1)  \n\timage = image.convert(&apos;L&apos;)\n\timage = image.resize((300，100)，Image.BILINEAR)\n\timage = image.point(table，&apos;1&apos;)  \n\timage.save(&quot;D:\\\\1.png&quot;，&quot;png&quot;)\n\n\ndef discernCode():\n\tim=Image.open(&quot;D:\\\\1.png&quot;)\n\tcode = pytesseract.image_to_string(im)\n\tprint(code)\n\n#获取验证码并保存\ngetAuthCodeImage()\n#验证码图片处理 灰阶处理\ndisposeImage()\n#识别验证码\ndiscernCode()</code></pre>\n"},{"title":"RabbitMQ 消息队列中间件","toc":false,"date":"2019-03-20T06:35:19.000Z","_content":"\n![](/images/RabbitMQ.jpg)\n\n> RabbitMq消息队列中间件记录一些基本的概念和实际项目运用，消息队列常常会作为解决项目之间解耦的方案之一，特点异步消息可持久化不丢失高可用。实际项目中有各类场景可使用消息队列，例如发送邮件模块、业务消息通知、异步回调结果、日志信息的收集聚合等。\n\n### RabbitMQ\nRabbitMq 是一款由`erlang`开发实现 AMQP（Advanced Message Queueing Protocal）的开源消息中间件，消息中间件主要运用于组件之间解耦，消息发送者不需关心消息消费者的存在，AMQP 的主要特征是面向消息、队列、路由（点对点和发布/订阅）、可靠性、安全。\n\n#### Rabbit 基本概念\n- __Message__ \n由消息头和消息体组成，消息头里包含了`routeKey`用于标记消息需要发送到那个队列，`priority`消息优先权，`delivery-mode`消息可能需要持久性存储。\n- __Channel__\n信道，多路复用连接中的一条独立的双向数据流通道，是建立在`TCP`连接内的虚拟连接，发布消息、订阅队列、接受消息等都是通过信道完成，当你的项目连接上RabbitMq你可以在控制台`Channel`中发现一条新的记录包含了信道的各类信息，当项目停止后该条信道就会销毁。\n![Channel信息](/images/RabbitMq-Channel.png)\n- __Exchanges__\n交换器，消息发送到交换器根据配置的规则再转发到相应队列，转发的规则有4中分别为`direct`、`topic`、`fonout`、`headers`。\n\n#### Exchanges 路由规则\n- __direct__\n属于最常见的一种转发规则，单播模式根据`routeKey`匹配唯一的队列进行发送。\n![Direct](/images/Exchanges-direct.jpg)\n- __topic__\n主题模式通过`#`（匹配0个或多个单词）和`*`（匹配一个单词）来绑定队列，如果不使用通配符可作为普通的`direct`队列，根据实际情况灵活配置。\n![Topic](/images/Exchanges-topic.jpg)\n- __fanout__ \n广播模式，每个发送到交换器上的信息都会被转发到绑定到该交换器上的所有队列，`fanout`类型的转发消息是最快的。\n![fanout](/images/Exchanges-fanout.jpg)\n\n\n#### 安装\n[Rabbit官方网站](http://www.rabbitmq.com/)进行下载，由于 RabbitMQ 由 [ERLANG](http://www.erlang.org/downloads) 开发需要安装相关环境,具体版本查看官方文档。安装完毕可以通过http://127.0.0.1:15672 查看 RabbitMQ 管理中心，包含了 RabbitMQ 配置主题、队列、运行情况、连接等。\n\n初始登陆账号：admin 密码：admin\n![RabbitMQ管理中心](/images/RabbitMQ-Admin.png)\n\n### SpringBoot 集成\nSpringBoot 微服务项目集成 RabbitMQ 特别方便，`Maven`项目依赖添加`spring-boot-starter-amqp`依赖然后进行基本配置，添加`@EnableRabbit`开启 RabbitMQ 自动配置，自动装配的源码可以查看`RabbitAutoConfiguration`类。\n#### Maven 依赖\n``` xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n#### yml 配置\n``` yml\nspring:\n  rabbitmq:\n  host: ip地址\n  port: 端口号默认5672\n  username: 用户名\n  password: 密码\n  publisher-confirms: 是否启动推送自动确认 true or false\n  listener:\n     direct:\n       acknowledge-mode: ack消息确认方式：auto 自动 manual 手动 none 不确认\n     simple\n       acknowledge-mode: ack消息确认方式：auto 自动 manual 手动 none 不确认\n\n```\n\n`ACK`机制就是为了保证数据一定被消费确认，默认配置为`auto`自动,在实际项目中如果消费者出现程序异常或者意外服务宕机会导致消息未消费但是`ACK`自动确认后，提供者并不知道消费者消费失败导致业务数据不一致。`ACK` 可以设置为手动 `manual`只有当消费者告诉中间件已经消费中间件才会把这条消息从队列中删除,否者这条消息会一直在队列中存在直到消费者重新消息掉。\n\n#### 提供者\n``` java\npackage com.example.rabbitmq.rabbitProvider;\n\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\n\n@Component\npublic class RabbitMqProvider {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    public void provider(){\n        rabbitTemplate.convertAndSend(\"myTestQueue\",\"测试测试123\");\n    }\n\n}\n```\n这里使用`RabbitTemplete`进行发送消息，已封装了各类常用的推送消息方法，`myTestQueue`为队列名称。\n\n#### 消费者 Ack 确认\n``` java \npackage com.example.rabbitmq.mytest;\n\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\nimport java.io.IOException;\n\n@Component\n@RabbitListener(queues = \"myTestQueue\")\npublic class RabbitMqConsumer {\n\n@RabbitHandler()\npublic void consumer(String msg, Channel channel, Message message) {\n    try {\n        System.out.println(\"接受消息\" + msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n上述代码使用了`Channel`进行`Ack`确认，队列中有无数条信息为了确认唯一性，调用`basicAck`方法进行确认，`message.getMessageProperties().getDeliveryTag()`获取消息的唯一`tag`值。   \n\n@RabbitListener(queues = ) 当队列不存在时候需要配合 @Bean 注册 Queue 进行创建队列或通过管理平台创建，@RabbitListener(queuesToDeclare = @Queue())这种方式会自动创建队列\n\n\n","source":"_posts/RabbitMq 消息队列中间件.md","raw":"---\ntitle: RabbitMQ 消息队列中间件\ntags:\n  - 中间件\ncategories:\n  - Java\ntoc: false\ndate: 2019-03-20 14:35:19\n---\n\n![](/images/RabbitMQ.jpg)\n\n> RabbitMq消息队列中间件记录一些基本的概念和实际项目运用，消息队列常常会作为解决项目之间解耦的方案之一，特点异步消息可持久化不丢失高可用。实际项目中有各类场景可使用消息队列，例如发送邮件模块、业务消息通知、异步回调结果、日志信息的收集聚合等。\n\n### RabbitMQ\nRabbitMq 是一款由`erlang`开发实现 AMQP（Advanced Message Queueing Protocal）的开源消息中间件，消息中间件主要运用于组件之间解耦，消息发送者不需关心消息消费者的存在，AMQP 的主要特征是面向消息、队列、路由（点对点和发布/订阅）、可靠性、安全。\n\n#### Rabbit 基本概念\n- __Message__ \n由消息头和消息体组成，消息头里包含了`routeKey`用于标记消息需要发送到那个队列，`priority`消息优先权，`delivery-mode`消息可能需要持久性存储。\n- __Channel__\n信道，多路复用连接中的一条独立的双向数据流通道，是建立在`TCP`连接内的虚拟连接，发布消息、订阅队列、接受消息等都是通过信道完成，当你的项目连接上RabbitMq你可以在控制台`Channel`中发现一条新的记录包含了信道的各类信息，当项目停止后该条信道就会销毁。\n![Channel信息](/images/RabbitMq-Channel.png)\n- __Exchanges__\n交换器，消息发送到交换器根据配置的规则再转发到相应队列，转发的规则有4中分别为`direct`、`topic`、`fonout`、`headers`。\n\n#### Exchanges 路由规则\n- __direct__\n属于最常见的一种转发规则，单播模式根据`routeKey`匹配唯一的队列进行发送。\n![Direct](/images/Exchanges-direct.jpg)\n- __topic__\n主题模式通过`#`（匹配0个或多个单词）和`*`（匹配一个单词）来绑定队列，如果不使用通配符可作为普通的`direct`队列，根据实际情况灵活配置。\n![Topic](/images/Exchanges-topic.jpg)\n- __fanout__ \n广播模式，每个发送到交换器上的信息都会被转发到绑定到该交换器上的所有队列，`fanout`类型的转发消息是最快的。\n![fanout](/images/Exchanges-fanout.jpg)\n\n\n#### 安装\n[Rabbit官方网站](http://www.rabbitmq.com/)进行下载，由于 RabbitMQ 由 [ERLANG](http://www.erlang.org/downloads) 开发需要安装相关环境,具体版本查看官方文档。安装完毕可以通过http://127.0.0.1:15672 查看 RabbitMQ 管理中心，包含了 RabbitMQ 配置主题、队列、运行情况、连接等。\n\n初始登陆账号：admin 密码：admin\n![RabbitMQ管理中心](/images/RabbitMQ-Admin.png)\n\n### SpringBoot 集成\nSpringBoot 微服务项目集成 RabbitMQ 特别方便，`Maven`项目依赖添加`spring-boot-starter-amqp`依赖然后进行基本配置，添加`@EnableRabbit`开启 RabbitMQ 自动配置，自动装配的源码可以查看`RabbitAutoConfiguration`类。\n#### Maven 依赖\n``` xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n#### yml 配置\n``` yml\nspring:\n  rabbitmq:\n  host: ip地址\n  port: 端口号默认5672\n  username: 用户名\n  password: 密码\n  publisher-confirms: 是否启动推送自动确认 true or false\n  listener:\n     direct:\n       acknowledge-mode: ack消息确认方式：auto 自动 manual 手动 none 不确认\n     simple\n       acknowledge-mode: ack消息确认方式：auto 自动 manual 手动 none 不确认\n\n```\n\n`ACK`机制就是为了保证数据一定被消费确认，默认配置为`auto`自动,在实际项目中如果消费者出现程序异常或者意外服务宕机会导致消息未消费但是`ACK`自动确认后，提供者并不知道消费者消费失败导致业务数据不一致。`ACK` 可以设置为手动 `manual`只有当消费者告诉中间件已经消费中间件才会把这条消息从队列中删除,否者这条消息会一直在队列中存在直到消费者重新消息掉。\n\n#### 提供者\n``` java\npackage com.example.rabbitmq.rabbitProvider;\n\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\n\n@Component\npublic class RabbitMqProvider {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    public void provider(){\n        rabbitTemplate.convertAndSend(\"myTestQueue\",\"测试测试123\");\n    }\n\n}\n```\n这里使用`RabbitTemplete`进行发送消息，已封装了各类常用的推送消息方法，`myTestQueue`为队列名称。\n\n#### 消费者 Ack 确认\n``` java \npackage com.example.rabbitmq.mytest;\n\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\nimport java.io.IOException;\n\n@Component\n@RabbitListener(queues = \"myTestQueue\")\npublic class RabbitMqConsumer {\n\n@RabbitHandler()\npublic void consumer(String msg, Channel channel, Message message) {\n    try {\n        System.out.println(\"接受消息\" + msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n上述代码使用了`Channel`进行`Ack`确认，队列中有无数条信息为了确认唯一性，调用`basicAck`方法进行确认，`message.getMessageProperties().getDeliveryTag()`获取消息的唯一`tag`值。   \n\n@RabbitListener(queues = ) 当队列不存在时候需要配合 @Bean 注册 Queue 进行创建队列或通过管理平台创建，@RabbitListener(queuesToDeclare = @Queue())这种方式会自动创建队列\n\n\n","slug":"RabbitMq 消息队列中间件","published":1,"updated":"2020-08-10T01:48:44.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc98k002jjsudhhalaprc","content":"<p><img src=\"/images/RabbitMQ.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>RabbitMq消息队列中间件记录一些基本的概念和实际项目运用，消息队列常常会作为解决项目之间解耦的方案之一，特点异步消息可持久化不丢失高可用。实际项目中有各类场景可使用消息队列，例如发送邮件模块、业务消息通知、异步回调结果、日志信息的收集聚合等。</p>\n</blockquote>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><p>RabbitMq 是一款由<code>erlang</code>开发实现 AMQP（Advanced Message Queueing Protocal）的开源消息中间件，消息中间件主要运用于组件之间解耦，消息发送者不需关心消息消费者的存在，AMQP 的主要特征是面向消息、队列、路由（点对点和发布/订阅）、可靠性、安全。</p>\n<h4 id=\"Rabbit-基本概念\"><a href=\"#Rabbit-基本概念\" class=\"headerlink\" title=\"Rabbit 基本概念\"></a>Rabbit 基本概念</h4><ul>\n<li><strong>Message</strong><br>由消息头和消息体组成，消息头里包含了<code>routeKey</code>用于标记消息需要发送到那个队列，<code>priority</code>消息优先权，<code>delivery-mode</code>消息可能需要持久性存储。</li>\n<li><strong>Channel</strong><br>信道，多路复用连接中的一条独立的双向数据流通道，是建立在<code>TCP</code>连接内的虚拟连接，发布消息、订阅队列、接受消息等都是通过信道完成，当你的项目连接上RabbitMq你可以在控制台<code>Channel</code>中发现一条新的记录包含了信道的各类信息，当项目停止后该条信道就会销毁。<br><img src=\"/images/RabbitMq-Channel.png\" srcset=\"/img/loading.gif\" alt=\"Channel信息\"></li>\n<li><strong>Exchanges</strong><br>交换器，消息发送到交换器根据配置的规则再转发到相应队列，转发的规则有4中分别为<code>direct</code>、<code>topic</code>、<code>fonout</code>、<code>headers</code>。</li>\n</ul>\n<h4 id=\"Exchanges-路由规则\"><a href=\"#Exchanges-路由规则\" class=\"headerlink\" title=\"Exchanges 路由规则\"></a>Exchanges 路由规则</h4><ul>\n<li><strong>direct</strong><br>属于最常见的一种转发规则，单播模式根据<code>routeKey</code>匹配唯一的队列进行发送。<br><img src=\"/images/Exchanges-direct.jpg\" srcset=\"/img/loading.gif\" alt=\"Direct\"></li>\n<li><strong>topic</strong><br>主题模式通过<code>#</code>（匹配0个或多个单词）和<code>*</code>（匹配一个单词）来绑定队列，如果不使用通配符可作为普通的<code>direct</code>队列，根据实际情况灵活配置。<br><img src=\"/images/Exchanges-topic.jpg\" srcset=\"/img/loading.gif\" alt=\"Topic\"></li>\n<li><strong>fanout</strong><br>广播模式，每个发送到交换器上的信息都会被转发到绑定到该交换器上的所有队列，<code>fanout</code>类型的转发消息是最快的。<br><img src=\"/images/Exchanges-fanout.jpg\" srcset=\"/img/loading.gif\" alt=\"fanout\"></li>\n</ul>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><a href=\"http://www.rabbitmq.com/\" target=\"_blank\" rel=\"noopener\">Rabbit官方网站</a>进行下载，由于 RabbitMQ 由 <a href=\"http://www.erlang.org/downloads\" target=\"_blank\" rel=\"noopener\">ERLANG</a> 开发需要安装相关环境,具体版本查看官方文档。安装完毕可以通过<a href=\"http://127.0.0.1:15672\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:15672</a> 查看 RabbitMQ 管理中心，包含了 RabbitMQ 配置主题、队列、运行情况、连接等。</p>\n<p>初始登陆账号：admin 密码：admin<br><img src=\"/images/RabbitMQ-Admin.png\" srcset=\"/img/loading.gif\" alt=\"RabbitMQ管理中心\"></p>\n<h3 id=\"SpringBoot-集成\"><a href=\"#SpringBoot-集成\" class=\"headerlink\" title=\"SpringBoot 集成\"></a>SpringBoot 集成</h3><p>SpringBoot 微服务项目集成 RabbitMQ 特别方便，<code>Maven</code>项目依赖添加<code>spring-boot-starter-amqp</code>依赖然后进行基本配置，添加<code>@EnableRabbit</code>开启 RabbitMQ 自动配置，自动装配的源码可以查看<code>RabbitAutoConfiguration</code>类。</p>\n<h4 id=\"Maven-依赖\"><a href=\"#Maven-依赖\" class=\"headerlink\" title=\"Maven 依赖\"></a>Maven 依赖</h4><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n<h4 id=\"yml-配置\"><a href=\"#yml-配置\" class=\"headerlink\" title=\"yml 配置\"></a>yml 配置</h4><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">rabbitmq:</span>\n  <span class=\"hljs-attr\">host:</span> <span class=\"hljs-string\">ip地址</span>\n  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-string\">端口号默认5672</span>\n  <span class=\"hljs-attr\">username:</span> <span class=\"hljs-string\">用户名</span>\n  <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">密码</span>\n  <span class=\"hljs-attr\">publisher-confirms:</span> <span class=\"hljs-string\">是否启动推送自动确认</span> <span class=\"hljs-literal\">true</span> <span class=\"hljs-string\">or</span> <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-attr\">listener:</span>\n     <span class=\"hljs-attr\">direct:</span>\n       <span class=\"hljs-attr\">acknowledge-mode:</span> <span class=\"hljs-string\">ack消息确认方式：auto</span> <span class=\"hljs-string\">自动</span> <span class=\"hljs-string\">manual</span> <span class=\"hljs-string\">手动</span> <span class=\"hljs-string\">none</span> <span class=\"hljs-string\">不确认</span>\n     <span class=\"hljs-string\">simple</span>\n       <span class=\"hljs-attr\">acknowledge-mode:</span> <span class=\"hljs-string\">ack消息确认方式：auto</span> <span class=\"hljs-string\">自动</span> <span class=\"hljs-string\">manual</span> <span class=\"hljs-string\">手动</span> <span class=\"hljs-string\">none</span> <span class=\"hljs-string\">不确认</span></code></pre>\n<p><code>ACK</code>机制就是为了保证数据一定被消费确认，默认配置为<code>auto</code>自动,在实际项目中如果消费者出现程序异常或者意外服务宕机会导致消息未消费但是<code>ACK</code>自动确认后，提供者并不知道消费者消费失败导致业务数据不一致。<code>ACK</code> 可以设置为手动 <code>manual</code>只有当消费者告诉中间件已经消费中间件才会把这条消息从队列中删除,否者这条消息会一直在队列中存在直到消费者重新消息掉。</p>\n<h4 id=\"提供者\"><a href=\"#提供者\" class=\"headerlink\" title=\"提供者\"></a>提供者</h4><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.example.rabbitmq.rabbitProvider;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-keyword\">import</span> javax.annotation.Resource;\n\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RabbitMqProvider</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Resource</span>\n    <span class=\"hljs-keyword\">private</span> RabbitTemplate rabbitTemplate;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">provider</span><span class=\"hljs-params\">()</span></span>&#123;\n        rabbitTemplate.convertAndSend(<span class=\"hljs-string\">\"myTestQueue\"</span>,<span class=\"hljs-string\">\"测试测试123\"</span>);\n    &#125;\n\n&#125;</code></pre>\n<p>这里使用<code>RabbitTemplete</code>进行发送消息，已封装了各类常用的推送消息方法，<code>myTestQueue</code>为队列名称。</p>\n<h4 id=\"消费者-Ack-确认\"><a href=\"#消费者-Ack-确认\" class=\"headerlink\" title=\"消费者 Ack 确认\"></a>消费者 Ack 确认</h4><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.example.rabbitmq.mytest;\n\n<span class=\"hljs-keyword\">import</span> com.rabbitmq.client.Channel;\n<span class=\"hljs-keyword\">import</span> org.springframework.amqp.core.Message;\n<span class=\"hljs-keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;\n<span class=\"hljs-keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n<span class=\"hljs-keyword\">import</span> java.io.IOException;\n\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-meta\">@RabbitListener</span>(queues = <span class=\"hljs-string\">\"myTestQueue\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RabbitMqConsumer</span> </span>&#123;\n\n<span class=\"hljs-meta\">@RabbitHandler</span>()\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">consumer</span><span class=\"hljs-params\">(String msg, Channel channel, Message message)</span> </span>&#123;\n    <span class=\"hljs-keyword\">try</span> &#123;\n        System.out.println(<span class=\"hljs-string\">\"接受消息\"</span> + msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"hljs-keyword\">false</span>);\n    &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n<p>上述代码使用了<code>Channel</code>进行<code>Ack</code>确认，队列中有无数条信息为了确认唯一性，调用<code>basicAck</code>方法进行确认，<code>message.getMessageProperties().getDeliveryTag()</code>获取消息的唯一<code>tag</code>值。   </p>\n<p>@RabbitListener(queues = ) 当队列不存在时候需要配合 @Bean 注册 Queue 进行创建队列或通过管理平台创建，@RabbitListener(queuesToDeclare = @Queue())这种方式会自动创建队列</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/RabbitMQ.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>RabbitMq消息队列中间件记录一些基本的概念和实际项目运用，消息队列常常会作为解决项目之间解耦的方案之一，特点异步消息可持久化不丢失高可用。实际项目中有各类场景可使用消息队列，例如发送邮件模块、业务消息通知、异步回调结果、日志信息的收集聚合等。</p>\n</blockquote>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><p>RabbitMq 是一款由<code>erlang</code>开发实现 AMQP（Advanced Message Queueing Protocal）的开源消息中间件，消息中间件主要运用于组件之间解耦，消息发送者不需关心消息消费者的存在，AMQP 的主要特征是面向消息、队列、路由（点对点和发布/订阅）、可靠性、安全。</p>\n<h4 id=\"Rabbit-基本概念\"><a href=\"#Rabbit-基本概念\" class=\"headerlink\" title=\"Rabbit 基本概念\"></a>Rabbit 基本概念</h4><ul>\n<li><strong>Message</strong><br>由消息头和消息体组成，消息头里包含了<code>routeKey</code>用于标记消息需要发送到那个队列，<code>priority</code>消息优先权，<code>delivery-mode</code>消息可能需要持久性存储。</li>\n<li><strong>Channel</strong><br>信道，多路复用连接中的一条独立的双向数据流通道，是建立在<code>TCP</code>连接内的虚拟连接，发布消息、订阅队列、接受消息等都是通过信道完成，当你的项目连接上RabbitMq你可以在控制台<code>Channel</code>中发现一条新的记录包含了信道的各类信息，当项目停止后该条信道就会销毁。<br><img src=\"/images/RabbitMq-Channel.png\" srcset=\"/img/loading.gif\" alt=\"Channel信息\"></li>\n<li><strong>Exchanges</strong><br>交换器，消息发送到交换器根据配置的规则再转发到相应队列，转发的规则有4中分别为<code>direct</code>、<code>topic</code>、<code>fonout</code>、<code>headers</code>。</li>\n</ul>\n<h4 id=\"Exchanges-路由规则\"><a href=\"#Exchanges-路由规则\" class=\"headerlink\" title=\"Exchanges 路由规则\"></a>Exchanges 路由规则</h4><ul>\n<li><strong>direct</strong><br>属于最常见的一种转发规则，单播模式根据<code>routeKey</code>匹配唯一的队列进行发送。<br><img src=\"/images/Exchanges-direct.jpg\" srcset=\"/img/loading.gif\" alt=\"Direct\"></li>\n<li><strong>topic</strong><br>主题模式通过<code>#</code>（匹配0个或多个单词）和<code>*</code>（匹配一个单词）来绑定队列，如果不使用通配符可作为普通的<code>direct</code>队列，根据实际情况灵活配置。<br><img src=\"/images/Exchanges-topic.jpg\" srcset=\"/img/loading.gif\" alt=\"Topic\"></li>\n<li><strong>fanout</strong><br>广播模式，每个发送到交换器上的信息都会被转发到绑定到该交换器上的所有队列，<code>fanout</code>类型的转发消息是最快的。<br><img src=\"/images/Exchanges-fanout.jpg\" srcset=\"/img/loading.gif\" alt=\"fanout\"></li>\n</ul>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><a href=\"http://www.rabbitmq.com/\" target=\"_blank\" rel=\"noopener\">Rabbit官方网站</a>进行下载，由于 RabbitMQ 由 <a href=\"http://www.erlang.org/downloads\" target=\"_blank\" rel=\"noopener\">ERLANG</a> 开发需要安装相关环境,具体版本查看官方文档。安装完毕可以通过<a href=\"http://127.0.0.1:15672\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:15672</a> 查看 RabbitMQ 管理中心，包含了 RabbitMQ 配置主题、队列、运行情况、连接等。</p>\n<p>初始登陆账号：admin 密码：admin<br><img src=\"/images/RabbitMQ-Admin.png\" srcset=\"/img/loading.gif\" alt=\"RabbitMQ管理中心\"></p>\n<h3 id=\"SpringBoot-集成\"><a href=\"#SpringBoot-集成\" class=\"headerlink\" title=\"SpringBoot 集成\"></a>SpringBoot 集成</h3><p>SpringBoot 微服务项目集成 RabbitMQ 特别方便，<code>Maven</code>项目依赖添加<code>spring-boot-starter-amqp</code>依赖然后进行基本配置，添加<code>@EnableRabbit</code>开启 RabbitMQ 自动配置，自动装配的源码可以查看<code>RabbitAutoConfiguration</code>类。</p>\n<h4 id=\"Maven-依赖\"><a href=\"#Maven-依赖\" class=\"headerlink\" title=\"Maven 依赖\"></a>Maven 依赖</h4><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n<h4 id=\"yml-配置\"><a href=\"#yml-配置\" class=\"headerlink\" title=\"yml 配置\"></a>yml 配置</h4><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">rabbitmq:</span>\n  <span class=\"hljs-attr\">host:</span> <span class=\"hljs-string\">ip地址</span>\n  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-string\">端口号默认5672</span>\n  <span class=\"hljs-attr\">username:</span> <span class=\"hljs-string\">用户名</span>\n  <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">密码</span>\n  <span class=\"hljs-attr\">publisher-confirms:</span> <span class=\"hljs-string\">是否启动推送自动确认</span> <span class=\"hljs-literal\">true</span> <span class=\"hljs-string\">or</span> <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-attr\">listener:</span>\n     <span class=\"hljs-attr\">direct:</span>\n       <span class=\"hljs-attr\">acknowledge-mode:</span> <span class=\"hljs-string\">ack消息确认方式：auto</span> <span class=\"hljs-string\">自动</span> <span class=\"hljs-string\">manual</span> <span class=\"hljs-string\">手动</span> <span class=\"hljs-string\">none</span> <span class=\"hljs-string\">不确认</span>\n     <span class=\"hljs-string\">simple</span>\n       <span class=\"hljs-attr\">acknowledge-mode:</span> <span class=\"hljs-string\">ack消息确认方式：auto</span> <span class=\"hljs-string\">自动</span> <span class=\"hljs-string\">manual</span> <span class=\"hljs-string\">手动</span> <span class=\"hljs-string\">none</span> <span class=\"hljs-string\">不确认</span></code></pre>\n<p><code>ACK</code>机制就是为了保证数据一定被消费确认，默认配置为<code>auto</code>自动,在实际项目中如果消费者出现程序异常或者意外服务宕机会导致消息未消费但是<code>ACK</code>自动确认后，提供者并不知道消费者消费失败导致业务数据不一致。<code>ACK</code> 可以设置为手动 <code>manual</code>只有当消费者告诉中间件已经消费中间件才会把这条消息从队列中删除,否者这条消息会一直在队列中存在直到消费者重新消息掉。</p>\n<h4 id=\"提供者\"><a href=\"#提供者\" class=\"headerlink\" title=\"提供者\"></a>提供者</h4><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.example.rabbitmq.rabbitProvider;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-keyword\">import</span> javax.annotation.Resource;\n\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RabbitMqProvider</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Resource</span>\n    <span class=\"hljs-keyword\">private</span> RabbitTemplate rabbitTemplate;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">provider</span><span class=\"hljs-params\">()</span></span>&#123;\n        rabbitTemplate.convertAndSend(<span class=\"hljs-string\">\"myTestQueue\"</span>,<span class=\"hljs-string\">\"测试测试123\"</span>);\n    &#125;\n\n&#125;</code></pre>\n<p>这里使用<code>RabbitTemplete</code>进行发送消息，已封装了各类常用的推送消息方法，<code>myTestQueue</code>为队列名称。</p>\n<h4 id=\"消费者-Ack-确认\"><a href=\"#消费者-Ack-确认\" class=\"headerlink\" title=\"消费者 Ack 确认\"></a>消费者 Ack 确认</h4><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.example.rabbitmq.mytest;\n\n<span class=\"hljs-keyword\">import</span> com.rabbitmq.client.Channel;\n<span class=\"hljs-keyword\">import</span> org.springframework.amqp.core.Message;\n<span class=\"hljs-keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;\n<span class=\"hljs-keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n<span class=\"hljs-keyword\">import</span> java.io.IOException;\n\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-meta\">@RabbitListener</span>(queues = <span class=\"hljs-string\">\"myTestQueue\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RabbitMqConsumer</span> </span>&#123;\n\n<span class=\"hljs-meta\">@RabbitHandler</span>()\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">consumer</span><span class=\"hljs-params\">(String msg, Channel channel, Message message)</span> </span>&#123;\n    <span class=\"hljs-keyword\">try</span> &#123;\n        System.out.println(<span class=\"hljs-string\">\"接受消息\"</span> + msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"hljs-keyword\">false</span>);\n    &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n<p>上述代码使用了<code>Channel</code>进行<code>Ack</code>确认，队列中有无数条信息为了确认唯一性，调用<code>basicAck</code>方法进行确认，<code>message.getMessageProperties().getDeliveryTag()</code>获取消息的唯一<code>tag</code>值。   </p>\n<p>@RabbitListener(queues = ) 当队列不存在时候需要配合 @Bean 注册 Queue 进行创建队列或通过管理平台创建，@RabbitListener(queuesToDeclare = @Queue())这种方式会自动创建队列</p>\n"},{"title":"Redis 集群搭建记录","toc":false,"date":"2020-05-17T06:06:04.000Z","_content":"\n![](/images/redis.jpg)\n> 记录下本地 windows 搭建集群全过程\n\n### Redis 环境准备\n- 安装 [**Redis for window**](https://github.com/MicrosoftArchive/redis/releases) 微软开源，不过比官方的版本落后很多，生产肯定是用`linux`版本\n- Redis 官方提供`Ruby`脚本自动化建立集群，根据自身系统下载 64 或 32 位 [**RubyInstaller**](https://rubyinstaller.org/)\n- 安装好`Ruby`环境后通过命令行`gem install redis` 安装相关脚本依赖\n\t``` bash\n\tC:\\Users\\28563>gem install redis\n\tSuccessfully installed redis-4.1.4\n\tParsing documentation for redis-4.1.4\n\tDone installing documentation for redis after 1 seconds\n\t1 gem installed\n\t```\n\n- 由于`window`版本`reids`无脚本，需要下载相应版本的`redis`提取出 [**redis-trib.rb**](https://github.com/antirez/redis/releases)\n\n### 节点创建\n- 复制默认的配置文件并修改以下参数\n    ``` conf\n    # 端口号\n    port 6380\n    # rdb 存放地址\n    dbfilename dump-6380.rdb\n    # 日志文件\n    logfile \"server_log_6380.txt\"\n    # 开启集群\n    cluster-enabled yes\n    # 集群节点信息保存地址\n    cluster-config-file nodes-6380.conf\n    # 集群节点超时时间\n    cluster-node-timeout 15000\n    # 集群某哈希槽节点失效继续提供服务\n    cluster-require-full-coverage no\n    ```\n- 启动相关节点`redis-server [配置文件.conf]`，由于是集群模式启动后还未分配`hash slot`所以无法使用\n- 启动脚本`ruby redis-trib.rb create [host:port]`**至少3个节点且不能已有数据**才可以创建成功，执行完毕会根据节点数量自动分配`hash slot`\n\n#### 集群信息\n集群搭建完毕后可以通过`redis-cli -c`集群模式进入客户端，配置文件中`cluster-config-file nodes.conf`就是用来保存节点交换的各种信息，通过`cluster nodes`查看整个集群节点数量、状态、负责的哈希槽范围，`cluster info`集群信息\n\n``` bash\n# 集群基本信息\n127.0.0.1:6379> cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:3\ncluster_size:3\ncluster_current_epoch:7\ncluster_my_epoch:5\ncluster_stats_messages_sent:41100\ncluster_stats_messages_received:41061\n\n# 集群节点信息\n127.0.0.1:6379> cluster nodes\nda808f4f9b33566baffd36b78b75c766a61c53c9 127.0.0.1:6380 master - 0 1589784070344\n 6 connected 0-499 5961-10922\n7ba092b079f54886a4bdbfbaae4bbf161f131102 127.0.0.1:6381 master - 0 1589784069344\n 7 connected 500-998 11422-16383\n68448d769184298cb3678415ecec156e0f88c1cc 127.0.0.1:6379 myself,master - 0 0 5 co\nnnected 999-5960 10923-11421\n```\n\n- **cluster_state** 集群状态（**当集群某个节点失效时根据 cluster-require-full-coverage 设置看到的状态可能不一样**）\n- **cluster_slots_assinged** 集群哈希槽数量\n- **cluster_slots_ok** 正常的哈希槽数\n- **cluster_slots_pfail** 主观失败哈希槽数量\n- **cluster_slots_fail** 客观失败哈希槽数量\n- **cluster_knonw_nodes** 集群中节点数\n- **cluster_size** 集群分片数\n\n#### 集群测试\n``` bash\n127.0.0.1:6379> set k1 1\n-> Redirected to slot [12706] located at 127.0.0.1:6381\nOK\n127.0.0.1:6381> set k2 2\n-> Redirected to slot [449] located at 127.0.0.1:6380\nOK\n127.0.0.1:6380> set k3 3\n-> Redirected to slot [4576] located at 127.0.0.1:6379\nOK \n```\n当我们存入或获取`key`时客户端会通过算法得到对应的哈希槽，如果当前节点不负责该哈希槽则会查询哈希槽路由表查找对应负责的节点并重定向保存\n\n### 集群脚本\n#### 集群信息\n- 通过`info`可知每个节点已有`key`数量、哈希槽数、从节点数量\n    ``` bash\n    # 查看集群情况\n    ruby redis-trib.rb info [集群节点 host:port]\n    127.0.0.1:6379 (68448d76...) -> 0 keys | 6460 slots | 0 slaves.\n    127.0.0.1:6380 (da808f4f...) -> 0 keys | 4962 slots | 0 slaves.\n    127.0.0.1:6381 (7ba092b0...) -> 0 keys | 4962 slots | 0 slaves.\n    127.0.0.1:6382 (cd8124ba...) -> 0 keys | 0 slots | 0 slaves.\n    [OK] 0 keys in 4 masters.\n    0.00 keys per slot on average.\n    ```\n- 通过`check`可知每个节点`node-id`、地址、哈希槽分布和数量、额外副本数量，所有哈希槽是否在\n    ``` bash\n    # 检查集群情况\n    ruby redis-trib.rb check [集群节点 host:port]\n    M: 68448d769184298cb3678415ecec156e0f88c1cc 127.0.0.1:6379\n       slots:0-5960,10923-11421 (6460 slots) master\n       0 additional replica(s)\n    M: da808f4f9b33566baffd36b78b75c766a61c53c9 127.0.0.1:6380\n       slots:5961-10922 (4962 slots) master\n       0 additional replica(s)\n    M: 7ba092b079f54886a4bdbfbaae4bbf161f131102 127.0.0.1:6381\n       slots:11422-16383 (4962 slots) master\n       0 additional replica(s)\n    M: cd8124bab703fba65d7ba91330b72c0e89072269 127.0.0.1:6382\n       slots: (0 slots) master\n       0 additional replica(s)\n    [OK] All nodes agree about slots configuration.\n    >>> Check for open slots...\n    >>> Check slots coverage...\n    [OK] All 16384 slots covered.\n    ```\n\n\n#### 新增子节点\n 为保证整个集群高可用，需要给各个哈希槽负责节点分配至少一个从节点用于故障转移，使用脚本给节点添加从节点，注意该节点必须启动状态且无数据和集群信息否则无法添加，新增的主节点默认是没有哈希槽，需要通过迁移命令转移部分哈希槽\n``` bash\n# 添加到主节点为master-id作为子节点\nruby redis-trib.rb add-node --slave --master-id [主节点 node-id] [新增节点 host:port] [集群中任意节点 host:port]  \n```\n\n#### 删除节点\n从节点可直接删除，主节点如果有哈希槽则需要将拥有的哈希槽迁移到其他节点才能删除，删除节点会自动关闭\n``` bash\n# 删除节点\nruby redis-trib.rb del-node [删除节点 host:port] [删除节点 node-id]\n>>> Removing node cd8124bab703fba65d7ba91330b72c0e89072269 from cluster 127.0.0.\n1:6382\n>>> Sending CLUSTER FORGET messages to the cluster...\n>>> SHUTDOWN the node.\n```\n\n#### 迁移哈希槽\n迁移可以对已有节点进行扩容或缩容，从一个或多个源节点指定哈希槽数量迁移到目标节点，\n如果发现有某个哈希槽有问题，使用`redis-trib.rb fix [集群节点 host:port]`进行修复，如果失败则需要登录有问题的节点，使用`cluter setslot [哈希槽号] stable`取消迁移\n``` bash \n# 迁移哈希槽到新节点\nruby redis-trib.rb reshard -- 额外参数 [集群节点 host:port]\n```\n##### 额外参数\n- **from** [源节点 node-id 多个逗号隔开]\n- **to** [目标节点 node-id]\n- **slots** [哈希槽数量]\n- **yes** [迁移无序手动确认]\n- **pipeline** [批量迁移数量]\n- **timeout** [控制每次migrate操作的超时时间，默认为60000毫秒]\n#### 平衡哈希槽\n当节点越来越多时有的哈希槽多有的哈希槽少可以通过命令平衡每个节点哈希槽数量\n``` bash\n# 平衡集群哈希槽\nruby redis-trib.rb rebalance -- 额外参数 [集群节点 host:port]\n```\n##### 额外参数\n- **weight** [集群节点权重 node-id = 权重 多个空格隔开 默认权重1] 每个节点分配的哈希槽计算方法为：**slot数量 * （节点权重 / 总权重）**\n- **threshold** [节点哈希槽阈值大于才参与平衡]\n- **pipeline** [平衡迁移批量数量]\n- **use-empty-masters** [使用空哈希槽的主节点参与平衡]\n- **simulate** [模拟平衡并不会真正执行迁移操作]\n- **timeout** [设置migrate命令的超时时间]\n\n#### 集群执行命令\n当集群节点越来越多时可通过`call`指令在每个集群节点都执行相应在每个节点都执行某命令\n``` bash\n# 集群执行指令\nruby redis-trib.rb call [集群节点 host:port] [redis 指令]\n# 执行 cluster info 得到结果\n>>> Calling CLUSTER info\n127.0.0.1:6379: cluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:3\ncluster_size:3\ncluster_current_epoch:7\ncluster_my_epoch:5\ncluster_stats_messages_sent:40322\ncluster_stats_messages_received:4028\n```","source":"_posts/Redis-集群搭建记录.md","raw":"---\ntitle: Redis 集群搭建记录\ntags:\n  - Redis\ncategories:\n  - 数据库\ntoc: false\ndate: 2020-05-17 14:06:04\n---\n\n![](/images/redis.jpg)\n> 记录下本地 windows 搭建集群全过程\n\n### Redis 环境准备\n- 安装 [**Redis for window**](https://github.com/MicrosoftArchive/redis/releases) 微软开源，不过比官方的版本落后很多，生产肯定是用`linux`版本\n- Redis 官方提供`Ruby`脚本自动化建立集群，根据自身系统下载 64 或 32 位 [**RubyInstaller**](https://rubyinstaller.org/)\n- 安装好`Ruby`环境后通过命令行`gem install redis` 安装相关脚本依赖\n\t``` bash\n\tC:\\Users\\28563>gem install redis\n\tSuccessfully installed redis-4.1.4\n\tParsing documentation for redis-4.1.4\n\tDone installing documentation for redis after 1 seconds\n\t1 gem installed\n\t```\n\n- 由于`window`版本`reids`无脚本，需要下载相应版本的`redis`提取出 [**redis-trib.rb**](https://github.com/antirez/redis/releases)\n\n### 节点创建\n- 复制默认的配置文件并修改以下参数\n    ``` conf\n    # 端口号\n    port 6380\n    # rdb 存放地址\n    dbfilename dump-6380.rdb\n    # 日志文件\n    logfile \"server_log_6380.txt\"\n    # 开启集群\n    cluster-enabled yes\n    # 集群节点信息保存地址\n    cluster-config-file nodes-6380.conf\n    # 集群节点超时时间\n    cluster-node-timeout 15000\n    # 集群某哈希槽节点失效继续提供服务\n    cluster-require-full-coverage no\n    ```\n- 启动相关节点`redis-server [配置文件.conf]`，由于是集群模式启动后还未分配`hash slot`所以无法使用\n- 启动脚本`ruby redis-trib.rb create [host:port]`**至少3个节点且不能已有数据**才可以创建成功，执行完毕会根据节点数量自动分配`hash slot`\n\n#### 集群信息\n集群搭建完毕后可以通过`redis-cli -c`集群模式进入客户端，配置文件中`cluster-config-file nodes.conf`就是用来保存节点交换的各种信息，通过`cluster nodes`查看整个集群节点数量、状态、负责的哈希槽范围，`cluster info`集群信息\n\n``` bash\n# 集群基本信息\n127.0.0.1:6379> cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:3\ncluster_size:3\ncluster_current_epoch:7\ncluster_my_epoch:5\ncluster_stats_messages_sent:41100\ncluster_stats_messages_received:41061\n\n# 集群节点信息\n127.0.0.1:6379> cluster nodes\nda808f4f9b33566baffd36b78b75c766a61c53c9 127.0.0.1:6380 master - 0 1589784070344\n 6 connected 0-499 5961-10922\n7ba092b079f54886a4bdbfbaae4bbf161f131102 127.0.0.1:6381 master - 0 1589784069344\n 7 connected 500-998 11422-16383\n68448d769184298cb3678415ecec156e0f88c1cc 127.0.0.1:6379 myself,master - 0 0 5 co\nnnected 999-5960 10923-11421\n```\n\n- **cluster_state** 集群状态（**当集群某个节点失效时根据 cluster-require-full-coverage 设置看到的状态可能不一样**）\n- **cluster_slots_assinged** 集群哈希槽数量\n- **cluster_slots_ok** 正常的哈希槽数\n- **cluster_slots_pfail** 主观失败哈希槽数量\n- **cluster_slots_fail** 客观失败哈希槽数量\n- **cluster_knonw_nodes** 集群中节点数\n- **cluster_size** 集群分片数\n\n#### 集群测试\n``` bash\n127.0.0.1:6379> set k1 1\n-> Redirected to slot [12706] located at 127.0.0.1:6381\nOK\n127.0.0.1:6381> set k2 2\n-> Redirected to slot [449] located at 127.0.0.1:6380\nOK\n127.0.0.1:6380> set k3 3\n-> Redirected to slot [4576] located at 127.0.0.1:6379\nOK \n```\n当我们存入或获取`key`时客户端会通过算法得到对应的哈希槽，如果当前节点不负责该哈希槽则会查询哈希槽路由表查找对应负责的节点并重定向保存\n\n### 集群脚本\n#### 集群信息\n- 通过`info`可知每个节点已有`key`数量、哈希槽数、从节点数量\n    ``` bash\n    # 查看集群情况\n    ruby redis-trib.rb info [集群节点 host:port]\n    127.0.0.1:6379 (68448d76...) -> 0 keys | 6460 slots | 0 slaves.\n    127.0.0.1:6380 (da808f4f...) -> 0 keys | 4962 slots | 0 slaves.\n    127.0.0.1:6381 (7ba092b0...) -> 0 keys | 4962 slots | 0 slaves.\n    127.0.0.1:6382 (cd8124ba...) -> 0 keys | 0 slots | 0 slaves.\n    [OK] 0 keys in 4 masters.\n    0.00 keys per slot on average.\n    ```\n- 通过`check`可知每个节点`node-id`、地址、哈希槽分布和数量、额外副本数量，所有哈希槽是否在\n    ``` bash\n    # 检查集群情况\n    ruby redis-trib.rb check [集群节点 host:port]\n    M: 68448d769184298cb3678415ecec156e0f88c1cc 127.0.0.1:6379\n       slots:0-5960,10923-11421 (6460 slots) master\n       0 additional replica(s)\n    M: da808f4f9b33566baffd36b78b75c766a61c53c9 127.0.0.1:6380\n       slots:5961-10922 (4962 slots) master\n       0 additional replica(s)\n    M: 7ba092b079f54886a4bdbfbaae4bbf161f131102 127.0.0.1:6381\n       slots:11422-16383 (4962 slots) master\n       0 additional replica(s)\n    M: cd8124bab703fba65d7ba91330b72c0e89072269 127.0.0.1:6382\n       slots: (0 slots) master\n       0 additional replica(s)\n    [OK] All nodes agree about slots configuration.\n    >>> Check for open slots...\n    >>> Check slots coverage...\n    [OK] All 16384 slots covered.\n    ```\n\n\n#### 新增子节点\n 为保证整个集群高可用，需要给各个哈希槽负责节点分配至少一个从节点用于故障转移，使用脚本给节点添加从节点，注意该节点必须启动状态且无数据和集群信息否则无法添加，新增的主节点默认是没有哈希槽，需要通过迁移命令转移部分哈希槽\n``` bash\n# 添加到主节点为master-id作为子节点\nruby redis-trib.rb add-node --slave --master-id [主节点 node-id] [新增节点 host:port] [集群中任意节点 host:port]  \n```\n\n#### 删除节点\n从节点可直接删除，主节点如果有哈希槽则需要将拥有的哈希槽迁移到其他节点才能删除，删除节点会自动关闭\n``` bash\n# 删除节点\nruby redis-trib.rb del-node [删除节点 host:port] [删除节点 node-id]\n>>> Removing node cd8124bab703fba65d7ba91330b72c0e89072269 from cluster 127.0.0.\n1:6382\n>>> Sending CLUSTER FORGET messages to the cluster...\n>>> SHUTDOWN the node.\n```\n\n#### 迁移哈希槽\n迁移可以对已有节点进行扩容或缩容，从一个或多个源节点指定哈希槽数量迁移到目标节点，\n如果发现有某个哈希槽有问题，使用`redis-trib.rb fix [集群节点 host:port]`进行修复，如果失败则需要登录有问题的节点，使用`cluter setslot [哈希槽号] stable`取消迁移\n``` bash \n# 迁移哈希槽到新节点\nruby redis-trib.rb reshard -- 额外参数 [集群节点 host:port]\n```\n##### 额外参数\n- **from** [源节点 node-id 多个逗号隔开]\n- **to** [目标节点 node-id]\n- **slots** [哈希槽数量]\n- **yes** [迁移无序手动确认]\n- **pipeline** [批量迁移数量]\n- **timeout** [控制每次migrate操作的超时时间，默认为60000毫秒]\n#### 平衡哈希槽\n当节点越来越多时有的哈希槽多有的哈希槽少可以通过命令平衡每个节点哈希槽数量\n``` bash\n# 平衡集群哈希槽\nruby redis-trib.rb rebalance -- 额外参数 [集群节点 host:port]\n```\n##### 额外参数\n- **weight** [集群节点权重 node-id = 权重 多个空格隔开 默认权重1] 每个节点分配的哈希槽计算方法为：**slot数量 * （节点权重 / 总权重）**\n- **threshold** [节点哈希槽阈值大于才参与平衡]\n- **pipeline** [平衡迁移批量数量]\n- **use-empty-masters** [使用空哈希槽的主节点参与平衡]\n- **simulate** [模拟平衡并不会真正执行迁移操作]\n- **timeout** [设置migrate命令的超时时间]\n\n#### 集群执行命令\n当集群节点越来越多时可通过`call`指令在每个集群节点都执行相应在每个节点都执行某命令\n``` bash\n# 集群执行指令\nruby redis-trib.rb call [集群节点 host:port] [redis 指令]\n# 执行 cluster info 得到结果\n>>> Calling CLUSTER info\n127.0.0.1:6379: cluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:3\ncluster_size:3\ncluster_current_epoch:7\ncluster_my_epoch:5\ncluster_stats_messages_sent:40322\ncluster_stats_messages_received:4028\n```","slug":"Redis-集群搭建记录","published":1,"updated":"2020-08-10T01:48:44.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc98m002njsudy9smt80x","content":"<p><img src=\"/images/redis.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录下本地 windows 搭建集群全过程</p>\n</blockquote>\n<h3 id=\"Redis-环境准备\"><a href=\"#Redis-环境准备\" class=\"headerlink\" title=\"Redis 环境准备\"></a>Redis 环境准备</h3><ul>\n<li>安装 <a href=\"https://github.com/MicrosoftArchive/redis/releases\" target=\"_blank\" rel=\"noopener\"><strong>Redis for window</strong></a> 微软开源，不过比官方的版本落后很多，生产肯定是用<code>linux</code>版本</li>\n<li>Redis 官方提供<code>Ruby</code>脚本自动化建立集群，根据自身系统下载 64 或 32 位 <a href=\"https://rubyinstaller.org/\" target=\"_blank\" rel=\"noopener\"><strong>RubyInstaller</strong></a></li>\n<li><p>安装好<code>Ruby</code>环境后通过命令行<code>gem install redis</code> 安装相关脚本依赖</p>\n  <pre><code class=\"hljs bash\">C:\\Users\\28563&gt;gem install redis\nSuccessfully installed redis-4.1.4\nParsing documentation <span class=\"hljs-keyword\">for</span> redis-4.1.4\nDone installing documentation <span class=\"hljs-keyword\">for</span> redis after 1 seconds\n1 gem installed</code></pre>\n</li>\n<li><p>由于<code>window</code>版本<code>reids</code>无脚本，需要下载相应版本的<code>redis</code>提取出 <a href=\"https://github.com/antirez/redis/releases\" target=\"_blank\" rel=\"noopener\"><strong>redis-trib.rb</strong></a></p>\n</li>\n</ul>\n<h3 id=\"节点创建\"><a href=\"#节点创建\" class=\"headerlink\" title=\"节点创建\"></a>节点创建</h3><ul>\n<li><p>复制默认的配置文件并修改以下参数</p>\n  <pre><code class=\"hljs conf\"># 端口号\nport 6380\n# rdb 存放地址\ndbfilename dump-6380.rdb\n# 日志文件\nlogfile &quot;server_log_6380.txt&quot;\n# 开启集群\ncluster-enabled yes\n# 集群节点信息保存地址\ncluster-config-file nodes-6380.conf\n# 集群节点超时时间\ncluster-node-timeout 15000\n# 集群某哈希槽节点失效继续提供服务\ncluster-require-full-coverage no</code></pre>\n</li>\n<li><p>启动相关节点<code>redis-server [配置文件.conf]</code>，由于是集群模式启动后还未分配<code>hash slot</code>所以无法使用</p>\n</li>\n<li>启动脚本<code>ruby redis-trib.rb create [host:port]</code><strong>至少3个节点且不能已有数据</strong>才可以创建成功，执行完毕会根据节点数量自动分配<code>hash slot</code></li>\n</ul>\n<h4 id=\"集群信息\"><a href=\"#集群信息\" class=\"headerlink\" title=\"集群信息\"></a>集群信息</h4><p>集群搭建完毕后可以通过<code>redis-cli -c</code>集群模式进入客户端，配置文件中<code>cluster-config-file nodes.conf</code>就是用来保存节点交换的各种信息，通过<code>cluster nodes</code>查看整个集群节点数量、状态、负责的哈希槽范围，<code>cluster info</code>集群信息</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 集群基本信息</span>\n127.0.0.1:6379&gt; cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:3\ncluster_size:3\ncluster_current_epoch:7\ncluster_my_epoch:5\ncluster_stats_messages_sent:41100\ncluster_stats_messages_received:41061\n\n<span class=\"hljs-comment\"># 集群节点信息</span>\n127.0.0.1:6379&gt; cluster nodes\nda808f4f9b33566baffd36b78b75c766a61c53c9 127.0.0.1:6380 master - 0 1589784070344\n 6 connected 0-499 5961-10922\n7ba092b079f54886a4bdbfbaae4bbf161f131102 127.0.0.1:6381 master - 0 1589784069344\n 7 connected 500-998 11422-16383\n68448d769184298cb3678415ecec156e0f88c1cc 127.0.0.1:6379 myself,master - 0 0 5 co\nnnected 999-5960 10923-11421</code></pre>\n<ul>\n<li><strong>cluster_state</strong> 集群状态（<strong>当集群某个节点失效时根据 cluster-require-full-coverage 设置看到的状态可能不一样</strong>）</li>\n<li><strong>cluster_slots_assinged</strong> 集群哈希槽数量</li>\n<li><strong>cluster_slots_ok</strong> 正常的哈希槽数</li>\n<li><strong>cluster_slots_pfail</strong> 主观失败哈希槽数量</li>\n<li><strong>cluster_slots_fail</strong> 客观失败哈希槽数量</li>\n<li><strong>cluster_knonw_nodes</strong> 集群中节点数</li>\n<li><strong>cluster_size</strong> 集群分片数</li>\n</ul>\n<h4 id=\"集群测试\"><a href=\"#集群测试\" class=\"headerlink\" title=\"集群测试\"></a>集群测试</h4><pre><code class=\"hljs bash\">127.0.0.1:6379&gt; <span class=\"hljs-built_in\">set</span> k1 1\n-&gt; Redirected to slot [12706] located at 127.0.0.1:6381\nOK\n127.0.0.1:6381&gt; <span class=\"hljs-built_in\">set</span> k2 2\n-&gt; Redirected to slot [449] located at 127.0.0.1:6380\nOK\n127.0.0.1:6380&gt; <span class=\"hljs-built_in\">set</span> k3 3\n-&gt; Redirected to slot [4576] located at 127.0.0.1:6379\nOK</code></pre>\n<p>当我们存入或获取<code>key</code>时客户端会通过算法得到对应的哈希槽，如果当前节点不负责该哈希槽则会查询哈希槽路由表查找对应负责的节点并重定向保存</p>\n<h3 id=\"集群脚本\"><a href=\"#集群脚本\" class=\"headerlink\" title=\"集群脚本\"></a>集群脚本</h3><h4 id=\"集群信息-1\"><a href=\"#集群信息-1\" class=\"headerlink\" title=\"集群信息\"></a>集群信息</h4><ul>\n<li><p>通过<code>info</code>可知每个节点已有<code>key</code>数量、哈希槽数、从节点数量</p>\n  <pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 查看集群情况</span>\nruby redis-trib.rb info [集群节点 host:port]\n127.0.0.1:6379 (68448d76...) -&gt; 0 keys | 6460 slots | 0 slaves.\n127.0.0.1:6380 (da808f4f...) -&gt; 0 keys | 4962 slots | 0 slaves.\n127.0.0.1:6381 (7ba092b0...) -&gt; 0 keys | 4962 slots | 0 slaves.\n127.0.0.1:6382 (cd8124ba...) -&gt; 0 keys | 0 slots | 0 slaves.\n[OK] 0 keys <span class=\"hljs-keyword\">in</span> 4 masters.\n0.00 keys per slot on average.</code></pre>\n</li>\n<li><p>通过<code>check</code>可知每个节点<code>node-id</code>、地址、哈希槽分布和数量、额外副本数量，所有哈希槽是否在</p>\n  <pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 检查集群情况</span>\nruby redis-trib.rb check [集群节点 host:port]\nM: 68448d769184298cb3678415ecec156e0f88c1cc 127.0.0.1:6379\n   slots:0-5960,10923-11421 (6460 slots) master\n   0 additional replica(s)\nM: da808f4f9b33566baffd36b78b75c766a61c53c9 127.0.0.1:6380\n   slots:5961-10922 (4962 slots) master\n   0 additional replica(s)\nM: 7ba092b079f54886a4bdbfbaae4bbf161f131102 127.0.0.1:6381\n   slots:11422-16383 (4962 slots) master\n   0 additional replica(s)\nM: cd8124bab703fba65d7ba91330b72c0e89072269 127.0.0.1:6382\n   slots: (0 slots) master\n   0 additional replica(s)\n[OK] All nodes agree about slots configuration.\n&gt;&gt;&gt; Check <span class=\"hljs-keyword\">for</span> open slots...\n&gt;&gt;&gt; Check slots coverage...\n[OK] All 16384 slots covered.</code></pre>\n</li>\n</ul>\n<h4 id=\"新增子节点\"><a href=\"#新增子节点\" class=\"headerlink\" title=\"新增子节点\"></a>新增子节点</h4><p> 为保证整个集群高可用，需要给各个哈希槽负责节点分配至少一个从节点用于故障转移，使用脚本给节点添加从节点，注意该节点必须启动状态且无数据和集群信息否则无法添加，新增的主节点默认是没有哈希槽，需要通过迁移命令转移部分哈希槽<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 添加到主节点为master-id作为子节点</span>\nruby redis-trib.rb add-node --slave --master-id [主节点 node-id] [新增节点 host:port] [集群中任意节点 host:port]</code></pre></p>\n<h4 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h4><p>从节点可直接删除，主节点如果有哈希槽则需要将拥有的哈希槽迁移到其他节点才能删除，删除节点会自动关闭<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 删除节点</span>\nruby redis-trib.rb del-node [删除节点 host:port] [删除节点 node-id]\n&gt;&gt;&gt; Removing node cd8124bab703fba65d7ba91330b72c0e89072269 from cluster 127.0.0.\n1:6382\n&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...\n&gt;&gt;&gt; SHUTDOWN the node.</code></pre></p>\n<h4 id=\"迁移哈希槽\"><a href=\"#迁移哈希槽\" class=\"headerlink\" title=\"迁移哈希槽\"></a>迁移哈希槽</h4><p>迁移可以对已有节点进行扩容或缩容，从一个或多个源节点指定哈希槽数量迁移到目标节点，<br>如果发现有某个哈希槽有问题，使用<code>redis-trib.rb fix [集群节点 host:port]</code>进行修复，如果失败则需要登录有问题的节点，使用<code>cluter setslot [哈希槽号] stable</code>取消迁移<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 迁移哈希槽到新节点</span>\nruby redis-trib.rb reshard -- 额外参数 [集群节点 host:port]</code></pre></p>\n<h5 id=\"额外参数\"><a href=\"#额外参数\" class=\"headerlink\" title=\"额外参数\"></a>额外参数</h5><ul>\n<li><strong>from</strong> [源节点 node-id 多个逗号隔开]</li>\n<li><strong>to</strong> [目标节点 node-id]</li>\n<li><strong>slots</strong> [哈希槽数量]</li>\n<li><strong>yes</strong> [迁移无序手动确认]</li>\n<li><strong>pipeline</strong> [批量迁移数量]</li>\n<li><strong>timeout</strong> [控制每次migrate操作的超时时间，默认为60000毫秒]<h4 id=\"平衡哈希槽\"><a href=\"#平衡哈希槽\" class=\"headerlink\" title=\"平衡哈希槽\"></a>平衡哈希槽</h4>当节点越来越多时有的哈希槽多有的哈希槽少可以通过命令平衡每个节点哈希槽数量<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 平衡集群哈希槽</span>\nruby redis-trib.rb rebalance -- 额外参数 [集群节点 host:port]</code></pre>\n</li>\n</ul>\n<h5 id=\"额外参数-1\"><a href=\"#额外参数-1\" class=\"headerlink\" title=\"额外参数\"></a>额外参数</h5><ul>\n<li><strong>weight</strong> [集群节点权重 node-id = 权重 多个空格隔开 默认权重1] 每个节点分配的哈希槽计算方法为：<strong>slot数量 * （节点权重 / 总权重）</strong></li>\n<li><strong>threshold</strong> [节点哈希槽阈值大于才参与平衡]</li>\n<li><strong>pipeline</strong> [平衡迁移批量数量]</li>\n<li><strong>use-empty-masters</strong> [使用空哈希槽的主节点参与平衡]</li>\n<li><strong>simulate</strong> [模拟平衡并不会真正执行迁移操作]</li>\n<li><strong>timeout</strong> [设置migrate命令的超时时间]</li>\n</ul>\n<h4 id=\"集群执行命令\"><a href=\"#集群执行命令\" class=\"headerlink\" title=\"集群执行命令\"></a>集群执行命令</h4><p>当集群节点越来越多时可通过<code>call</code>指令在每个集群节点都执行相应在每个节点都执行某命令<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 集群执行指令</span>\nruby redis-trib.rb call [集群节点 host:port] [redis 指令]\n<span class=\"hljs-comment\"># 执行 cluster info 得到结果</span>\n&gt;&gt;&gt; Calling CLUSTER info\n127.0.0.1:6379: cluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:3\ncluster_size:3\ncluster_current_epoch:7\ncluster_my_epoch:5\ncluster_stats_messages_sent:40322\ncluster_stats_messages_received:4028</code></pre></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/redis.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录下本地 windows 搭建集群全过程</p>\n</blockquote>\n<h3 id=\"Redis-环境准备\"><a href=\"#Redis-环境准备\" class=\"headerlink\" title=\"Redis 环境准备\"></a>Redis 环境准备</h3><ul>\n<li>安装 <a href=\"https://github.com/MicrosoftArchive/redis/releases\" target=\"_blank\" rel=\"noopener\"><strong>Redis for window</strong></a> 微软开源，不过比官方的版本落后很多，生产肯定是用<code>linux</code>版本</li>\n<li>Redis 官方提供<code>Ruby</code>脚本自动化建立集群，根据自身系统下载 64 或 32 位 <a href=\"https://rubyinstaller.org/\" target=\"_blank\" rel=\"noopener\"><strong>RubyInstaller</strong></a></li>\n<li><p>安装好<code>Ruby</code>环境后通过命令行<code>gem install redis</code> 安装相关脚本依赖</p>\n  <pre><code class=\"hljs bash\">C:\\Users\\28563&gt;gem install redis\nSuccessfully installed redis-4.1.4\nParsing documentation <span class=\"hljs-keyword\">for</span> redis-4.1.4\nDone installing documentation <span class=\"hljs-keyword\">for</span> redis after 1 seconds\n1 gem installed</code></pre>\n</li>\n<li><p>由于<code>window</code>版本<code>reids</code>无脚本，需要下载相应版本的<code>redis</code>提取出 <a href=\"https://github.com/antirez/redis/releases\" target=\"_blank\" rel=\"noopener\"><strong>redis-trib.rb</strong></a></p>\n</li>\n</ul>\n<h3 id=\"节点创建\"><a href=\"#节点创建\" class=\"headerlink\" title=\"节点创建\"></a>节点创建</h3><ul>\n<li><p>复制默认的配置文件并修改以下参数</p>\n  <pre><code class=\"hljs conf\"># 端口号\nport 6380\n# rdb 存放地址\ndbfilename dump-6380.rdb\n# 日志文件\nlogfile &quot;server_log_6380.txt&quot;\n# 开启集群\ncluster-enabled yes\n# 集群节点信息保存地址\ncluster-config-file nodes-6380.conf\n# 集群节点超时时间\ncluster-node-timeout 15000\n# 集群某哈希槽节点失效继续提供服务\ncluster-require-full-coverage no</code></pre>\n</li>\n<li><p>启动相关节点<code>redis-server [配置文件.conf]</code>，由于是集群模式启动后还未分配<code>hash slot</code>所以无法使用</p>\n</li>\n<li>启动脚本<code>ruby redis-trib.rb create [host:port]</code><strong>至少3个节点且不能已有数据</strong>才可以创建成功，执行完毕会根据节点数量自动分配<code>hash slot</code></li>\n</ul>\n<h4 id=\"集群信息\"><a href=\"#集群信息\" class=\"headerlink\" title=\"集群信息\"></a>集群信息</h4><p>集群搭建完毕后可以通过<code>redis-cli -c</code>集群模式进入客户端，配置文件中<code>cluster-config-file nodes.conf</code>就是用来保存节点交换的各种信息，通过<code>cluster nodes</code>查看整个集群节点数量、状态、负责的哈希槽范围，<code>cluster info</code>集群信息</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 集群基本信息</span>\n127.0.0.1:6379&gt; cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:3\ncluster_size:3\ncluster_current_epoch:7\ncluster_my_epoch:5\ncluster_stats_messages_sent:41100\ncluster_stats_messages_received:41061\n\n<span class=\"hljs-comment\"># 集群节点信息</span>\n127.0.0.1:6379&gt; cluster nodes\nda808f4f9b33566baffd36b78b75c766a61c53c9 127.0.0.1:6380 master - 0 1589784070344\n 6 connected 0-499 5961-10922\n7ba092b079f54886a4bdbfbaae4bbf161f131102 127.0.0.1:6381 master - 0 1589784069344\n 7 connected 500-998 11422-16383\n68448d769184298cb3678415ecec156e0f88c1cc 127.0.0.1:6379 myself,master - 0 0 5 co\nnnected 999-5960 10923-11421</code></pre>\n<ul>\n<li><strong>cluster_state</strong> 集群状态（<strong>当集群某个节点失效时根据 cluster-require-full-coverage 设置看到的状态可能不一样</strong>）</li>\n<li><strong>cluster_slots_assinged</strong> 集群哈希槽数量</li>\n<li><strong>cluster_slots_ok</strong> 正常的哈希槽数</li>\n<li><strong>cluster_slots_pfail</strong> 主观失败哈希槽数量</li>\n<li><strong>cluster_slots_fail</strong> 客观失败哈希槽数量</li>\n<li><strong>cluster_knonw_nodes</strong> 集群中节点数</li>\n<li><strong>cluster_size</strong> 集群分片数</li>\n</ul>\n<h4 id=\"集群测试\"><a href=\"#集群测试\" class=\"headerlink\" title=\"集群测试\"></a>集群测试</h4><pre><code class=\"hljs bash\">127.0.0.1:6379&gt; <span class=\"hljs-built_in\">set</span> k1 1\n-&gt; Redirected to slot [12706] located at 127.0.0.1:6381\nOK\n127.0.0.1:6381&gt; <span class=\"hljs-built_in\">set</span> k2 2\n-&gt; Redirected to slot [449] located at 127.0.0.1:6380\nOK\n127.0.0.1:6380&gt; <span class=\"hljs-built_in\">set</span> k3 3\n-&gt; Redirected to slot [4576] located at 127.0.0.1:6379\nOK</code></pre>\n<p>当我们存入或获取<code>key</code>时客户端会通过算法得到对应的哈希槽，如果当前节点不负责该哈希槽则会查询哈希槽路由表查找对应负责的节点并重定向保存</p>\n<h3 id=\"集群脚本\"><a href=\"#集群脚本\" class=\"headerlink\" title=\"集群脚本\"></a>集群脚本</h3><h4 id=\"集群信息-1\"><a href=\"#集群信息-1\" class=\"headerlink\" title=\"集群信息\"></a>集群信息</h4><ul>\n<li><p>通过<code>info</code>可知每个节点已有<code>key</code>数量、哈希槽数、从节点数量</p>\n  <pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 查看集群情况</span>\nruby redis-trib.rb info [集群节点 host:port]\n127.0.0.1:6379 (68448d76...) -&gt; 0 keys | 6460 slots | 0 slaves.\n127.0.0.1:6380 (da808f4f...) -&gt; 0 keys | 4962 slots | 0 slaves.\n127.0.0.1:6381 (7ba092b0...) -&gt; 0 keys | 4962 slots | 0 slaves.\n127.0.0.1:6382 (cd8124ba...) -&gt; 0 keys | 0 slots | 0 slaves.\n[OK] 0 keys <span class=\"hljs-keyword\">in</span> 4 masters.\n0.00 keys per slot on average.</code></pre>\n</li>\n<li><p>通过<code>check</code>可知每个节点<code>node-id</code>、地址、哈希槽分布和数量、额外副本数量，所有哈希槽是否在</p>\n  <pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 检查集群情况</span>\nruby redis-trib.rb check [集群节点 host:port]\nM: 68448d769184298cb3678415ecec156e0f88c1cc 127.0.0.1:6379\n   slots:0-5960,10923-11421 (6460 slots) master\n   0 additional replica(s)\nM: da808f4f9b33566baffd36b78b75c766a61c53c9 127.0.0.1:6380\n   slots:5961-10922 (4962 slots) master\n   0 additional replica(s)\nM: 7ba092b079f54886a4bdbfbaae4bbf161f131102 127.0.0.1:6381\n   slots:11422-16383 (4962 slots) master\n   0 additional replica(s)\nM: cd8124bab703fba65d7ba91330b72c0e89072269 127.0.0.1:6382\n   slots: (0 slots) master\n   0 additional replica(s)\n[OK] All nodes agree about slots configuration.\n&gt;&gt;&gt; Check <span class=\"hljs-keyword\">for</span> open slots...\n&gt;&gt;&gt; Check slots coverage...\n[OK] All 16384 slots covered.</code></pre>\n</li>\n</ul>\n<h4 id=\"新增子节点\"><a href=\"#新增子节点\" class=\"headerlink\" title=\"新增子节点\"></a>新增子节点</h4><p> 为保证整个集群高可用，需要给各个哈希槽负责节点分配至少一个从节点用于故障转移，使用脚本给节点添加从节点，注意该节点必须启动状态且无数据和集群信息否则无法添加，新增的主节点默认是没有哈希槽，需要通过迁移命令转移部分哈希槽<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 添加到主节点为master-id作为子节点</span>\nruby redis-trib.rb add-node --slave --master-id [主节点 node-id] [新增节点 host:port] [集群中任意节点 host:port]</code></pre></p>\n<h4 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h4><p>从节点可直接删除，主节点如果有哈希槽则需要将拥有的哈希槽迁移到其他节点才能删除，删除节点会自动关闭<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 删除节点</span>\nruby redis-trib.rb del-node [删除节点 host:port] [删除节点 node-id]\n&gt;&gt;&gt; Removing node cd8124bab703fba65d7ba91330b72c0e89072269 from cluster 127.0.0.\n1:6382\n&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...\n&gt;&gt;&gt; SHUTDOWN the node.</code></pre></p>\n<h4 id=\"迁移哈希槽\"><a href=\"#迁移哈希槽\" class=\"headerlink\" title=\"迁移哈希槽\"></a>迁移哈希槽</h4><p>迁移可以对已有节点进行扩容或缩容，从一个或多个源节点指定哈希槽数量迁移到目标节点，<br>如果发现有某个哈希槽有问题，使用<code>redis-trib.rb fix [集群节点 host:port]</code>进行修复，如果失败则需要登录有问题的节点，使用<code>cluter setslot [哈希槽号] stable</code>取消迁移<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 迁移哈希槽到新节点</span>\nruby redis-trib.rb reshard -- 额外参数 [集群节点 host:port]</code></pre></p>\n<h5 id=\"额外参数\"><a href=\"#额外参数\" class=\"headerlink\" title=\"额外参数\"></a>额外参数</h5><ul>\n<li><strong>from</strong> [源节点 node-id 多个逗号隔开]</li>\n<li><strong>to</strong> [目标节点 node-id]</li>\n<li><strong>slots</strong> [哈希槽数量]</li>\n<li><strong>yes</strong> [迁移无序手动确认]</li>\n<li><strong>pipeline</strong> [批量迁移数量]</li>\n<li><strong>timeout</strong> [控制每次migrate操作的超时时间，默认为60000毫秒]<h4 id=\"平衡哈希槽\"><a href=\"#平衡哈希槽\" class=\"headerlink\" title=\"平衡哈希槽\"></a>平衡哈希槽</h4>当节点越来越多时有的哈希槽多有的哈希槽少可以通过命令平衡每个节点哈希槽数量<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 平衡集群哈希槽</span>\nruby redis-trib.rb rebalance -- 额外参数 [集群节点 host:port]</code></pre>\n</li>\n</ul>\n<h5 id=\"额外参数-1\"><a href=\"#额外参数-1\" class=\"headerlink\" title=\"额外参数\"></a>额外参数</h5><ul>\n<li><strong>weight</strong> [集群节点权重 node-id = 权重 多个空格隔开 默认权重1] 每个节点分配的哈希槽计算方法为：<strong>slot数量 * （节点权重 / 总权重）</strong></li>\n<li><strong>threshold</strong> [节点哈希槽阈值大于才参与平衡]</li>\n<li><strong>pipeline</strong> [平衡迁移批量数量]</li>\n<li><strong>use-empty-masters</strong> [使用空哈希槽的主节点参与平衡]</li>\n<li><strong>simulate</strong> [模拟平衡并不会真正执行迁移操作]</li>\n<li><strong>timeout</strong> [设置migrate命令的超时时间]</li>\n</ul>\n<h4 id=\"集群执行命令\"><a href=\"#集群执行命令\" class=\"headerlink\" title=\"集群执行命令\"></a>集群执行命令</h4><p>当集群节点越来越多时可通过<code>call</code>指令在每个集群节点都执行相应在每个节点都执行某命令<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 集群执行指令</span>\nruby redis-trib.rb call [集群节点 host:port] [redis 指令]\n<span class=\"hljs-comment\"># 执行 cluster info 得到结果</span>\n&gt;&gt;&gt; Calling CLUSTER info\n127.0.0.1:6379: cluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:3\ncluster_size:3\ncluster_current_epoch:7\ncluster_my_epoch:5\ncluster_stats_messages_sent:40322\ncluster_stats_messages_received:4028</code></pre></p>\n"},{"title":"Redis 主从配置","toc":false,"date":"2019-11-12T06:54:18.000Z","_content":"\n![](/images/redis.jpg)\n\n\n### Redis 主从架构\nRedis 当项目规模越来越大承载需求越来越大单机不足以支撑当前业务，则需要`master-slave`主从架构来分担其压力承载更多`QPS`(__我一人无力承受，我需要更多的人来帮我承担，扛不住就摇人__)， 主写从读把压力分散给下面的小弟，更容易水平扩容支持更高并发。\n![master-slave 架构](/images/redis-master-slave.png)\n\n####  Replication 核心机制\n- redis 采用异步方式复制数据，当从库进行复制时不会堵塞查询也不会影响主库，会使用旧数据提供服务，当数据复制完毕需删除旧数据加载最新数时无法提供服务。\n- slave node 可以有其他 slave node 形成级联模式\n- master node 可以有个多个 slave node\n- slave 有且仅能有一个 master 节点\n\n#### 主从复制流程\n![主从复制流程](/images/redis-master-slave-replication.png)\n\n1. slave 向 master 发送`psync`请求，初次连接 master 会触发全量复制`full resynchronization`，并把 master 的 `runid` 和 `offset` 发送给 slave 以便下一次增量复制\n2. master 会 fork 子进程生成 RDB 快照并将后续执行的写命令写入 buffer（复制缓冲区）\n3. master 把 RDB 快照和复制缓冲区发送给 slave，slave 会将 RDB 快照先存入本地磁盘然后再加载到内存中\n4. 当网络波动导致复制失败重新连接会根据 slave 的`offset`与 master 的 `offset`对比看是否在复制缓冲区范围内判断是全量或增量复制\n\n### Redis 主从配置\n``` conf\n################################# REPLICATION #################################\n# 复制选项，slave复制对应的master。\n# slaveof <masterip> <masterport>\n\n# 如 master 设置了requirepass 则需要密码才能进行复制保证数据安全性\n# masterauth <master-password>\n\n# 当从库同主机失去连接或者复制正在进行\n# 1) 如果slave-serve-stale-data设置为yes(默认设置) ：从库会继续响应客户端的请求。\n# 2) 如果slave-serve-stale-data设置为no ：除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。\nslave-serve-stale-data yes\n\n# 是否开启子节点只读，一般开启只读用于主从读写分离\nslave-read-only yes\n\n# 是否开启无盘复制，在主从复制生产的 RDB 文件不在落地到磁盘而是直接通过 socket 传输到子节点适用于磁盘 IO紧张网络宽带充裕情况下使用，默认不开启 no\nrepl-diskless-sync no\n\n# diskless 复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。\nrepl-diskless-sync-delay 5\n\n# slave 根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。\n# repl-ping-slave-period 10\n\n# 复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。\n# repl-timeout 60\n\n#是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。\nrepl-disable-tcp-nodelay no\n\n# 复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。\n# repl-backlog-size 5mb\n\n# master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。\n# repl-backlog-ttl 3600\n\n# 节点优先级，在哨兵模式下当主节点下线状态下会从子节点群众根据优先级选出一个新的主节点，当优先级为0时直接忽略\nslave-priority 100\n\n# redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。\n# min-slaves-to-write 3\n\n# 延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。\n# min-slaves-max-lag 10\n```\n\n通过命令`slaveof no one`可去除主从关系，通过命令行`info replication`可以查询当前节点的复制信息\n ![复制信息](/images/info_replication.png)\n #### 参数讲解\n<escape>\n<table>\n     <tr>\n            <th>角色</th>\n            <th>属性名</th>\n            <th>属性值</th>\n            <th>描述</th>\n     </tr>\n     <tr>\n            <td rowspan=\"5\">通用配置</td>\n            <td>role</td>\n            <td>master|slave</td>\n            <td>节点角色</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_active</td>\n           <td>1|0</td>\n           <td>复制缓冲区状态 1 启动 0 未启动</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_size</td>\n           <td>10465325</td>\n           <td>复制缓冲区大小</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_first_byte_offset</td>\n           <td>10465200</td>\n           <td>复制缓冲区起始偏移量，标识当前缓冲区可用范围</td>\n     </tr>     \n     <tr>\n           <td>repl_backlog_histlen</td>\n           <td>10465200</td>\n           <td>复制缓冲区已有数据长度（字节）</td>\n     </tr>\n     <tr>\n            <td rowspan=\"3\">主节点</td>\n            <td>slave0</td>\n            <td>slave0:127.0.0.1,port=6380,state=online,offset=5572,lag=0</td>\n            <td>子节点基本信息</td>\n     </tr>\n     <tr>\n            <td>connected_slaves</td>\n            <td>1</td>\n            <td>子节点数量</td>\n     </tr>\n     <tr>\n           <td>master_repl_offset</td>\n           <td>330652</td>\n           <td>主节点复制偏移量</td>\n     </tr>     \n     <tr>\n           <td rowspan=\"10\">子节点</td>\n           <td>master_host</td>\n           <td>127.0.0.1</td>\n           <td>主节点地址</td>\n     </tr>     \n     <tr>\n           <td>master_port</td>\n           <td>6379</td>\n           <td>主节点端口号</td>\n     </tr>     \n     <tr>\n           <td>master_link_status</td>\n           <td>up|down</td>\n           <td>主节点状态 up 上线 down 下线</td>\n     </tr>     \n     <tr>\n           <td>master_last_io_seconds_ago</td>\n           <td>-1|其他数字</td>\n           <td>与主节点最后一次 io 通信时间间隔（秒）</td>\n     </tr>     \n     <tr>\n           <td>master_link_down_since_seconds</td>\n           <td>20</td>\n           <td>主节点下线状态已过时间（秒）</td>\n     </tr>     \n     <tr>\n           <td>master_sync_in_progress</td>\n           <td>1|0</td>\n           <td>子节点是否从主节点全量复制 1 是 0 否</td>\n     </tr>     \n     <tr>\n           <td>slave_repl_offset</td>\n           <td>330652</td>\n           <td>子节点复制偏移量</td>\n     </tr>\n     <tr>\n           <td>slave_priority</td>\n           <td>100</td>\n           <td>子节点优先级，在哨兵模式下会根据优先级重新选举主节点</td>\n     </tr>\n     <tr>\n           <td>slave_read_only</td>\n           <td>1|0</td>\n           <td>子节点是否开启只读 1 是 0 否</td>\n     </tr>\n     <tr>\n           <td>master_repl_offset</td>\n           <td>330652</td>\n           <td>主节点复制偏移量</td>\n     </tr>\n </table>\n </escape>\n \n##### 注意事项\n- 合理设置 `repl-backlog-size` 复制缓冲区大小避免触发循环全量复制，当 master 接受新写入新请求速度大于 slave 同步的速度时，buffer 复制缓冲区内容还未被 slave 同步就被新写入数据所覆盖导致丢失部分指令数据，每一次增量复制 offset 偏移量不在缓冲区范围而触发循环全量复制\n- 设置缓冲区超时 `client-output-buffer-limit slave 256mb 64mb 60` 大于256mb或者超过64mb 的状态且超过60s，根据实际情况配合 repl-timeout 同步超时进行调整使用\n- slave 不会处理过期 key，通过 master 同步删除\n- 从节点 `slave-read-only` 设置为 yes 只读状态\n- 启无磁盘复制：`repl-diskless-sync` yes  快照将不落地磁盘直接通过网络复制避免IO性能差\n\n\n### Sentinel 哨兵模式 \n![哨兵模式架构](/images/redis-sentinel.png)\n对于主从架构如果主节点宕机挂掉子节点将无法获取最新数据，对于这样的情况推出了哨兵模式当`master`挂掉后会从子节点重新选举一个新的`master`节点来保证高可用，旧`master`则会转化成新的`slave`节点\n- **监控** ：sentinel 会不断检查`master`、`slave`服务器是否正常工作 \n- **通知** ：当被监控服务出现问题会通过 Api 向管理人员发送通知\n- **自动故障转移** ：当`master`失效无法提供服务时，将从`slaves`子节点群中选举一个新的`master`节点并将其他`slave`指向它\n\n#### 哨兵配置\n``` conf \n# 端口\nport 26379\n\n# 是否后台启动\ndaemonize yes\n\n# pid文件路径\npidfile /var/run/redis-sentinel.pid\n\n# 日志文件路径\nlogfile \"/var/log/sentinel.log\"\n\n# 定义工作目录\ndir /tmp\n\n# 定义Redis主的别名, IP, 端口，2指的是需要至少2个Sentinel 认为主节点主观下线（subjectivly）才标记为客观下线（objectivly）并准备自动故障转移\nsentinel monitor mymaster 127.0.0.1 6379 2\n\n# 判断主观下线（subjectivly）最大超时时间\nsentinel down-after-milliseconds mymaster 30000\n\n# 并发同步新 master 节点数据的 slave 数量，数字越小当节点过多时需要完成 failover 的事件就越长，数字越大由于 replication 机制会有更多的 slave 无法提供服务\nsentinel parallel-syncs mymaster 1\n\n# 故障转移超时时间\nsentinel failover-timeout mymaster 180000\n\n# 不允许使用SENTINEL SET设置notification-script和client-reconfig-script。\nsentinel deny-scripts-reconfig yes\n\n# 故障通知执行相应的脚本，允许执行的最大事件为60秒超时kill，失败重试次数为10\nsentinel notification-script <master-name> <script-path> \n```\n\n启动哨兵后会__自动感知__到主节点下的所有从节点，通过`info`指令可知监控主节点的状况、地址、子节点数、监控哨兵数量\n![哨兵情况](/images/sentinel-info.png)\n\n> 每次故障转移会__重写节点的配置文件__添加或者删除`slaveof`指向新的主节点，重新上线后会从新主节点同步数据 \n\n### Redis Cluster\n当数据量越来越大时生成的快照也越来越大主从之间复制也更加复杂很难去实现快速水平扩展，把鸡蛋放在一个篮子里不如把鸡蛋分开放在不同的篮子里，通过鸡蛋信息根据算法放到相应的篮子里，当数据量越来越大时我只需增加篮子的数量即可完成水平扩展\n\nRedis Cluster 采用数据分片（sharding）而非一致性哈希（consistency hashing）来实现，Redis 集群默认包含**16384**个哈希槽`hash slot`当存入一个新`key`时会根据 __CRC16(key)__ 计算出结果对 **16384** 取余得出的值对应相应的哈希槽`hash slot`，通过**路由算法**得知负责该哈希槽的节点并存入，集群的搭建至少由3个节点组成为了高可用每个节点至少有一个从节点搭用于故障恢复\n\n![image.png](/images/2020/05/15/c490d980-9687-11ea-baff-f5d93153beb4.png)\n\n#### Cluster 配置\n``` conf\n# 开启集群模式\ncluster-enabled yes\n\n# 集群内部配置文件 会在启动后自动创建\ncluster-config-file nodes.conf\n\n# 集群节点超时时间\ncluster-node-timeout 5000\n\n# 当集群中有节点fail是否认为集群可用，yes 集群某个哈希槽节点无法提供服务且没有从节点故障恢复时认为整个集群失效不再提供服务，no 当某个哈希槽节点失效时认为集群可用且继续提供服务\ncluster-require-full-coverage yes\n```\n\n#### Cluster 机制\n- 集群中所有的节点之间会不断的相互通信（**gossip 协议**）保持整个集群数据完整健康\n- 每个节点需要2个端口：自身端口和（自身端口+10000）用于通信\n- 节点之间会交换包含故障信息、节点变化信息、`hash slot`哈希槽信息等\n- 集群已实现高可用，通过节点之间通信发现有节点超时则认为`pfail`，当半数以上的节点都认为`pfail`则标记为`fail`，类似哨兵的`subjectivly`和`objectivly`\n- 集群采用 **P2P** 模式，完全去中心化节点\n\n\n#### Cluster 高可用 扩容\n当某负责哈希槽节点失效导致无法提供服务为保证整个集群高可用，我们需要给每个负责分片节点配置至少一个从节点用于故障转移，当数据量越来越大时我们可以通过新增分片节点并将其余哈希槽部分转移到新分片之中完成动态扩容而不影响整个集群提供服务\n\n#### 注意事项\n- 集群建立完成后新增的`master`节点是没有分配哈希槽需要自行根据情况从其他节点转移\n- 新增的节点必须为空否则失败，需要删除对应快照 rdb 和 node.conf 集群节点信息\n    ``` bash\n    [ERR] Node 127.0.0.1:6383 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.\n    ```\n- cluster-require-full-coverage 集群失效条件仅针对有哈希槽的分片节点对于其他从节点和无哈希槽节点忽略\n- 通过`reids-trib.rb`脚本删除集群节点会自动去关闭该节点\n","source":"_posts/Redis主从配置.md","raw":"---\ntitle: Redis 主从配置\ntags:\n  - Redis\ncategories:\n  - 数据库\ntoc: false\ndate: 2019-11-12 14:54:18\n---\n\n![](/images/redis.jpg)\n\n\n### Redis 主从架构\nRedis 当项目规模越来越大承载需求越来越大单机不足以支撑当前业务，则需要`master-slave`主从架构来分担其压力承载更多`QPS`(__我一人无力承受，我需要更多的人来帮我承担，扛不住就摇人__)， 主写从读把压力分散给下面的小弟，更容易水平扩容支持更高并发。\n![master-slave 架构](/images/redis-master-slave.png)\n\n####  Replication 核心机制\n- redis 采用异步方式复制数据，当从库进行复制时不会堵塞查询也不会影响主库，会使用旧数据提供服务，当数据复制完毕需删除旧数据加载最新数时无法提供服务。\n- slave node 可以有其他 slave node 形成级联模式\n- master node 可以有个多个 slave node\n- slave 有且仅能有一个 master 节点\n\n#### 主从复制流程\n![主从复制流程](/images/redis-master-slave-replication.png)\n\n1. slave 向 master 发送`psync`请求，初次连接 master 会触发全量复制`full resynchronization`，并把 master 的 `runid` 和 `offset` 发送给 slave 以便下一次增量复制\n2. master 会 fork 子进程生成 RDB 快照并将后续执行的写命令写入 buffer（复制缓冲区）\n3. master 把 RDB 快照和复制缓冲区发送给 slave，slave 会将 RDB 快照先存入本地磁盘然后再加载到内存中\n4. 当网络波动导致复制失败重新连接会根据 slave 的`offset`与 master 的 `offset`对比看是否在复制缓冲区范围内判断是全量或增量复制\n\n### Redis 主从配置\n``` conf\n################################# REPLICATION #################################\n# 复制选项，slave复制对应的master。\n# slaveof <masterip> <masterport>\n\n# 如 master 设置了requirepass 则需要密码才能进行复制保证数据安全性\n# masterauth <master-password>\n\n# 当从库同主机失去连接或者复制正在进行\n# 1) 如果slave-serve-stale-data设置为yes(默认设置) ：从库会继续响应客户端的请求。\n# 2) 如果slave-serve-stale-data设置为no ：除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。\nslave-serve-stale-data yes\n\n# 是否开启子节点只读，一般开启只读用于主从读写分离\nslave-read-only yes\n\n# 是否开启无盘复制，在主从复制生产的 RDB 文件不在落地到磁盘而是直接通过 socket 传输到子节点适用于磁盘 IO紧张网络宽带充裕情况下使用，默认不开启 no\nrepl-diskless-sync no\n\n# diskless 复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。\nrepl-diskless-sync-delay 5\n\n# slave 根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。\n# repl-ping-slave-period 10\n\n# 复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。\n# repl-timeout 60\n\n#是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。\nrepl-disable-tcp-nodelay no\n\n# 复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。\n# repl-backlog-size 5mb\n\n# master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。\n# repl-backlog-ttl 3600\n\n# 节点优先级，在哨兵模式下当主节点下线状态下会从子节点群众根据优先级选出一个新的主节点，当优先级为0时直接忽略\nslave-priority 100\n\n# redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。\n# min-slaves-to-write 3\n\n# 延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。\n# min-slaves-max-lag 10\n```\n\n通过命令`slaveof no one`可去除主从关系，通过命令行`info replication`可以查询当前节点的复制信息\n ![复制信息](/images/info_replication.png)\n #### 参数讲解\n<escape>\n<table>\n     <tr>\n            <th>角色</th>\n            <th>属性名</th>\n            <th>属性值</th>\n            <th>描述</th>\n     </tr>\n     <tr>\n            <td rowspan=\"5\">通用配置</td>\n            <td>role</td>\n            <td>master|slave</td>\n            <td>节点角色</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_active</td>\n           <td>1|0</td>\n           <td>复制缓冲区状态 1 启动 0 未启动</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_size</td>\n           <td>10465325</td>\n           <td>复制缓冲区大小</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_first_byte_offset</td>\n           <td>10465200</td>\n           <td>复制缓冲区起始偏移量，标识当前缓冲区可用范围</td>\n     </tr>     \n     <tr>\n           <td>repl_backlog_histlen</td>\n           <td>10465200</td>\n           <td>复制缓冲区已有数据长度（字节）</td>\n     </tr>\n     <tr>\n            <td rowspan=\"3\">主节点</td>\n            <td>slave0</td>\n            <td>slave0:127.0.0.1,port=6380,state=online,offset=5572,lag=0</td>\n            <td>子节点基本信息</td>\n     </tr>\n     <tr>\n            <td>connected_slaves</td>\n            <td>1</td>\n            <td>子节点数量</td>\n     </tr>\n     <tr>\n           <td>master_repl_offset</td>\n           <td>330652</td>\n           <td>主节点复制偏移量</td>\n     </tr>     \n     <tr>\n           <td rowspan=\"10\">子节点</td>\n           <td>master_host</td>\n           <td>127.0.0.1</td>\n           <td>主节点地址</td>\n     </tr>     \n     <tr>\n           <td>master_port</td>\n           <td>6379</td>\n           <td>主节点端口号</td>\n     </tr>     \n     <tr>\n           <td>master_link_status</td>\n           <td>up|down</td>\n           <td>主节点状态 up 上线 down 下线</td>\n     </tr>     \n     <tr>\n           <td>master_last_io_seconds_ago</td>\n           <td>-1|其他数字</td>\n           <td>与主节点最后一次 io 通信时间间隔（秒）</td>\n     </tr>     \n     <tr>\n           <td>master_link_down_since_seconds</td>\n           <td>20</td>\n           <td>主节点下线状态已过时间（秒）</td>\n     </tr>     \n     <tr>\n           <td>master_sync_in_progress</td>\n           <td>1|0</td>\n           <td>子节点是否从主节点全量复制 1 是 0 否</td>\n     </tr>     \n     <tr>\n           <td>slave_repl_offset</td>\n           <td>330652</td>\n           <td>子节点复制偏移量</td>\n     </tr>\n     <tr>\n           <td>slave_priority</td>\n           <td>100</td>\n           <td>子节点优先级，在哨兵模式下会根据优先级重新选举主节点</td>\n     </tr>\n     <tr>\n           <td>slave_read_only</td>\n           <td>1|0</td>\n           <td>子节点是否开启只读 1 是 0 否</td>\n     </tr>\n     <tr>\n           <td>master_repl_offset</td>\n           <td>330652</td>\n           <td>主节点复制偏移量</td>\n     </tr>\n </table>\n </escape>\n \n##### 注意事项\n- 合理设置 `repl-backlog-size` 复制缓冲区大小避免触发循环全量复制，当 master 接受新写入新请求速度大于 slave 同步的速度时，buffer 复制缓冲区内容还未被 slave 同步就被新写入数据所覆盖导致丢失部分指令数据，每一次增量复制 offset 偏移量不在缓冲区范围而触发循环全量复制\n- 设置缓冲区超时 `client-output-buffer-limit slave 256mb 64mb 60` 大于256mb或者超过64mb 的状态且超过60s，根据实际情况配合 repl-timeout 同步超时进行调整使用\n- slave 不会处理过期 key，通过 master 同步删除\n- 从节点 `slave-read-only` 设置为 yes 只读状态\n- 启无磁盘复制：`repl-diskless-sync` yes  快照将不落地磁盘直接通过网络复制避免IO性能差\n\n\n### Sentinel 哨兵模式 \n![哨兵模式架构](/images/redis-sentinel.png)\n对于主从架构如果主节点宕机挂掉子节点将无法获取最新数据，对于这样的情况推出了哨兵模式当`master`挂掉后会从子节点重新选举一个新的`master`节点来保证高可用，旧`master`则会转化成新的`slave`节点\n- **监控** ：sentinel 会不断检查`master`、`slave`服务器是否正常工作 \n- **通知** ：当被监控服务出现问题会通过 Api 向管理人员发送通知\n- **自动故障转移** ：当`master`失效无法提供服务时，将从`slaves`子节点群中选举一个新的`master`节点并将其他`slave`指向它\n\n#### 哨兵配置\n``` conf \n# 端口\nport 26379\n\n# 是否后台启动\ndaemonize yes\n\n# pid文件路径\npidfile /var/run/redis-sentinel.pid\n\n# 日志文件路径\nlogfile \"/var/log/sentinel.log\"\n\n# 定义工作目录\ndir /tmp\n\n# 定义Redis主的别名, IP, 端口，2指的是需要至少2个Sentinel 认为主节点主观下线（subjectivly）才标记为客观下线（objectivly）并准备自动故障转移\nsentinel monitor mymaster 127.0.0.1 6379 2\n\n# 判断主观下线（subjectivly）最大超时时间\nsentinel down-after-milliseconds mymaster 30000\n\n# 并发同步新 master 节点数据的 slave 数量，数字越小当节点过多时需要完成 failover 的事件就越长，数字越大由于 replication 机制会有更多的 slave 无法提供服务\nsentinel parallel-syncs mymaster 1\n\n# 故障转移超时时间\nsentinel failover-timeout mymaster 180000\n\n# 不允许使用SENTINEL SET设置notification-script和client-reconfig-script。\nsentinel deny-scripts-reconfig yes\n\n# 故障通知执行相应的脚本，允许执行的最大事件为60秒超时kill，失败重试次数为10\nsentinel notification-script <master-name> <script-path> \n```\n\n启动哨兵后会__自动感知__到主节点下的所有从节点，通过`info`指令可知监控主节点的状况、地址、子节点数、监控哨兵数量\n![哨兵情况](/images/sentinel-info.png)\n\n> 每次故障转移会__重写节点的配置文件__添加或者删除`slaveof`指向新的主节点，重新上线后会从新主节点同步数据 \n\n### Redis Cluster\n当数据量越来越大时生成的快照也越来越大主从之间复制也更加复杂很难去实现快速水平扩展，把鸡蛋放在一个篮子里不如把鸡蛋分开放在不同的篮子里，通过鸡蛋信息根据算法放到相应的篮子里，当数据量越来越大时我只需增加篮子的数量即可完成水平扩展\n\nRedis Cluster 采用数据分片（sharding）而非一致性哈希（consistency hashing）来实现，Redis 集群默认包含**16384**个哈希槽`hash slot`当存入一个新`key`时会根据 __CRC16(key)__ 计算出结果对 **16384** 取余得出的值对应相应的哈希槽`hash slot`，通过**路由算法**得知负责该哈希槽的节点并存入，集群的搭建至少由3个节点组成为了高可用每个节点至少有一个从节点搭用于故障恢复\n\n![image.png](/images/2020/05/15/c490d980-9687-11ea-baff-f5d93153beb4.png)\n\n#### Cluster 配置\n``` conf\n# 开启集群模式\ncluster-enabled yes\n\n# 集群内部配置文件 会在启动后自动创建\ncluster-config-file nodes.conf\n\n# 集群节点超时时间\ncluster-node-timeout 5000\n\n# 当集群中有节点fail是否认为集群可用，yes 集群某个哈希槽节点无法提供服务且没有从节点故障恢复时认为整个集群失效不再提供服务，no 当某个哈希槽节点失效时认为集群可用且继续提供服务\ncluster-require-full-coverage yes\n```\n\n#### Cluster 机制\n- 集群中所有的节点之间会不断的相互通信（**gossip 协议**）保持整个集群数据完整健康\n- 每个节点需要2个端口：自身端口和（自身端口+10000）用于通信\n- 节点之间会交换包含故障信息、节点变化信息、`hash slot`哈希槽信息等\n- 集群已实现高可用，通过节点之间通信发现有节点超时则认为`pfail`，当半数以上的节点都认为`pfail`则标记为`fail`，类似哨兵的`subjectivly`和`objectivly`\n- 集群采用 **P2P** 模式，完全去中心化节点\n\n\n#### Cluster 高可用 扩容\n当某负责哈希槽节点失效导致无法提供服务为保证整个集群高可用，我们需要给每个负责分片节点配置至少一个从节点用于故障转移，当数据量越来越大时我们可以通过新增分片节点并将其余哈希槽部分转移到新分片之中完成动态扩容而不影响整个集群提供服务\n\n#### 注意事项\n- 集群建立完成后新增的`master`节点是没有分配哈希槽需要自行根据情况从其他节点转移\n- 新增的节点必须为空否则失败，需要删除对应快照 rdb 和 node.conf 集群节点信息\n    ``` bash\n    [ERR] Node 127.0.0.1:6383 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.\n    ```\n- cluster-require-full-coverage 集群失效条件仅针对有哈希槽的分片节点对于其他从节点和无哈希槽节点忽略\n- 通过`reids-trib.rb`脚本删除集群节点会自动去关闭该节点\n","slug":"Redis主从配置","published":1,"updated":"2020-08-10T01:48:44.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc98o002rjsudsz9ez37d","content":"<p><img src=\"/images/redis.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"Redis-主从架构\"><a href=\"#Redis-主从架构\" class=\"headerlink\" title=\"Redis 主从架构\"></a>Redis 主从架构</h3><p>Redis 当项目规模越来越大承载需求越来越大单机不足以支撑当前业务，则需要<code>master-slave</code>主从架构来分担其压力承载更多<code>QPS</code>(<strong>我一人无力承受，我需要更多的人来帮我承担，扛不住就摇人</strong>)， 主写从读把压力分散给下面的小弟，更容易水平扩容支持更高并发。<br><img src=\"/images/redis-master-slave.png\" srcset=\"/img/loading.gif\" alt=\"master-slave 架构\"></p>\n<h4 id=\"Replication-核心机制\"><a href=\"#Replication-核心机制\" class=\"headerlink\" title=\"Replication 核心机制\"></a>Replication 核心机制</h4><ul>\n<li>redis 采用异步方式复制数据，当从库进行复制时不会堵塞查询也不会影响主库，会使用旧数据提供服务，当数据复制完毕需删除旧数据加载最新数时无法提供服务。</li>\n<li>slave node 可以有其他 slave node 形成级联模式</li>\n<li>master node 可以有个多个 slave node</li>\n<li>slave 有且仅能有一个 master 节点</li>\n</ul>\n<h4 id=\"主从复制流程\"><a href=\"#主从复制流程\" class=\"headerlink\" title=\"主从复制流程\"></a>主从复制流程</h4><p><img src=\"/images/redis-master-slave-replication.png\" srcset=\"/img/loading.gif\" alt=\"主从复制流程\"></p>\n<ol>\n<li>slave 向 master 发送<code>psync</code>请求，初次连接 master 会触发全量复制<code>full resynchronization</code>，并把 master 的 <code>runid</code> 和 <code>offset</code> 发送给 slave 以便下一次增量复制</li>\n<li>master 会 fork 子进程生成 RDB 快照并将后续执行的写命令写入 buffer（复制缓冲区）</li>\n<li>master 把 RDB 快照和复制缓冲区发送给 slave，slave 会将 RDB 快照先存入本地磁盘然后再加载到内存中</li>\n<li>当网络波动导致复制失败重新连接会根据 slave 的<code>offset</code>与 master 的 <code>offset</code>对比看是否在复制缓冲区范围内判断是全量或增量复制</li>\n</ol>\n<h3 id=\"Redis-主从配置\"><a href=\"#Redis-主从配置\" class=\"headerlink\" title=\"Redis 主从配置\"></a>Redis 主从配置</h3><pre><code class=\"hljs conf\">################################# REPLICATION #################################\n# 复制选项，slave复制对应的master。\n# slaveof &lt;masterip&gt; &lt;masterport&gt;\n\n# 如 master 设置了requirepass 则需要密码才能进行复制保证数据安全性\n# masterauth &lt;master-password&gt;\n\n# 当从库同主机失去连接或者复制正在进行\n# 1) 如果slave-serve-stale-data设置为yes(默认设置) ：从库会继续响应客户端的请求。\n# 2) 如果slave-serve-stale-data设置为no ：除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。\nslave-serve-stale-data yes\n\n# 是否开启子节点只读，一般开启只读用于主从读写分离\nslave-read-only yes\n\n# 是否开启无盘复制，在主从复制生产的 RDB 文件不在落地到磁盘而是直接通过 socket 传输到子节点适用于磁盘 IO紧张网络宽带充裕情况下使用，默认不开启 no\nrepl-diskless-sync no\n\n# diskless 复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。\nrepl-diskless-sync-delay 5\n\n# slave 根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。\n# repl-ping-slave-period 10\n\n# 复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。\n# repl-timeout 60\n\n#是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。\nrepl-disable-tcp-nodelay no\n\n# 复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。\n# repl-backlog-size 5mb\n\n# master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。\n# repl-backlog-ttl 3600\n\n# 节点优先级，在哨兵模式下当主节点下线状态下会从子节点群众根据优先级选出一个新的主节点，当优先级为0时直接忽略\nslave-priority 100\n\n# redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。\n# min-slaves-to-write 3\n\n# 延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。\n# min-slaves-max-lag 10</code></pre>\n<p>通过命令<code>slaveof no one</code>可去除主从关系，通过命令行<code>info replication</code>可以查询当前节点的复制信息<br> <img src=\"/images/info_replication.png\" srcset=\"/img/loading.gif\" alt=\"复制信息\"></p>\n<h4 id=\"参数讲解\"><a href=\"#参数讲解\" class=\"headerlink\" title=\"参数讲解\"></a>参数讲解</h4>\n<table>\n     <tr>\n            <th>角色</th>\n            <th>属性名</th>\n            <th>属性值</th>\n            <th>描述</th>\n     </tr>\n     <tr>\n            <td rowspan=\"5\">通用配置</td>\n            <td>role</td>\n            <td>master|slave</td>\n            <td>节点角色</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_active</td>\n           <td>1|0</td>\n           <td>复制缓冲区状态 1 启动 0 未启动</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_size</td>\n           <td>10465325</td>\n           <td>复制缓冲区大小</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_first_byte_offset</td>\n           <td>10465200</td>\n           <td>复制缓冲区起始偏移量，标识当前缓冲区可用范围</td>\n     </tr>     \n     <tr>\n           <td>repl_backlog_histlen</td>\n           <td>10465200</td>\n           <td>复制缓冲区已有数据长度（字节）</td>\n     </tr>\n     <tr>\n            <td rowspan=\"3\">主节点</td>\n            <td>slave0</td>\n            <td>slave0:127.0.0.1,port=6380,state=online,offset=5572,lag=0</td>\n            <td>子节点基本信息</td>\n     </tr>\n     <tr>\n            <td>connected_slaves</td>\n            <td>1</td>\n            <td>子节点数量</td>\n     </tr>\n     <tr>\n           <td>master_repl_offset</td>\n           <td>330652</td>\n           <td>主节点复制偏移量</td>\n     </tr>     \n     <tr>\n           <td rowspan=\"10\">子节点</td>\n           <td>master_host</td>\n           <td>127.0.0.1</td>\n           <td>主节点地址</td>\n     </tr>     \n     <tr>\n           <td>master_port</td>\n           <td>6379</td>\n           <td>主节点端口号</td>\n     </tr>     \n     <tr>\n           <td>master_link_status</td>\n           <td>up|down</td>\n           <td>主节点状态 up 上线 down 下线</td>\n     </tr>     \n     <tr>\n           <td>master_last_io_seconds_ago</td>\n           <td>-1|其他数字</td>\n           <td>与主节点最后一次 io 通信时间间隔（秒）</td>\n     </tr>     \n     <tr>\n           <td>master_link_down_since_seconds</td>\n           <td>20</td>\n           <td>主节点下线状态已过时间（秒）</td>\n     </tr>     \n     <tr>\n           <td>master_sync_in_progress</td>\n           <td>1|0</td>\n           <td>子节点是否从主节点全量复制 1 是 0 否</td>\n     </tr>     \n     <tr>\n           <td>slave_repl_offset</td>\n           <td>330652</td>\n           <td>子节点复制偏移量</td>\n     </tr>\n     <tr>\n           <td>slave_priority</td>\n           <td>100</td>\n           <td>子节点优先级，在哨兵模式下会根据优先级重新选举主节点</td>\n     </tr>\n     <tr>\n           <td>slave_read_only</td>\n           <td>1|0</td>\n           <td>子节点是否开启只读 1 是 0 否</td>\n     </tr>\n     <tr>\n           <td>master_repl_offset</td>\n           <td>330652</td>\n           <td>主节点复制偏移量</td>\n     </tr>\n </table>\n \n<h5 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><ul>\n<li>合理设置 <code>repl-backlog-size</code> 复制缓冲区大小避免触发循环全量复制，当 master 接受新写入新请求速度大于 slave 同步的速度时，buffer 复制缓冲区内容还未被 slave 同步就被新写入数据所覆盖导致丢失部分指令数据，每一次增量复制 offset 偏移量不在缓冲区范围而触发循环全量复制</li>\n<li>设置缓冲区超时 <code>client-output-buffer-limit slave 256mb 64mb 60</code> 大于256mb或者超过64mb 的状态且超过60s，根据实际情况配合 repl-timeout 同步超时进行调整使用</li>\n<li>slave 不会处理过期 key，通过 master 同步删除</li>\n<li>从节点 <code>slave-read-only</code> 设置为 yes 只读状态</li>\n<li>启无磁盘复制：<code>repl-diskless-sync</code> yes  快照将不落地磁盘直接通过网络复制避免IO性能差</li>\n</ul>\n<h3 id=\"Sentinel-哨兵模式\"><a href=\"#Sentinel-哨兵模式\" class=\"headerlink\" title=\"Sentinel 哨兵模式\"></a>Sentinel 哨兵模式</h3><p><img src=\"/images/redis-sentinel.png\" srcset=\"/img/loading.gif\" alt=\"哨兵模式架构\"><br>对于主从架构如果主节点宕机挂掉子节点将无法获取最新数据，对于这样的情况推出了哨兵模式当<code>master</code>挂掉后会从子节点重新选举一个新的<code>master</code>节点来保证高可用，旧<code>master</code>则会转化成新的<code>slave</code>节点</p>\n<ul>\n<li><strong>监控</strong> ：sentinel 会不断检查<code>master</code>、<code>slave</code>服务器是否正常工作 </li>\n<li><strong>通知</strong> ：当被监控服务出现问题会通过 Api 向管理人员发送通知</li>\n<li><strong>自动故障转移</strong> ：当<code>master</code>失效无法提供服务时，将从<code>slaves</code>子节点群中选举一个新的<code>master</code>节点并将其他<code>slave</code>指向它</li>\n</ul>\n<h4 id=\"哨兵配置\"><a href=\"#哨兵配置\" class=\"headerlink\" title=\"哨兵配置\"></a>哨兵配置</h4><pre><code class=\"hljs conf\"># 端口\nport 26379\n\n# 是否后台启动\ndaemonize yes\n\n# pid文件路径\npidfile /var/run/redis-sentinel.pid\n\n# 日志文件路径\nlogfile &quot;/var/log/sentinel.log&quot;\n\n# 定义工作目录\ndir /tmp\n\n# 定义Redis主的别名, IP, 端口，2指的是需要至少2个Sentinel 认为主节点主观下线（subjectivly）才标记为客观下线（objectivly）并准备自动故障转移\nsentinel monitor mymaster 127.0.0.1 6379 2\n\n# 判断主观下线（subjectivly）最大超时时间\nsentinel down-after-milliseconds mymaster 30000\n\n# 并发同步新 master 节点数据的 slave 数量，数字越小当节点过多时需要完成 failover 的事件就越长，数字越大由于 replication 机制会有更多的 slave 无法提供服务\nsentinel parallel-syncs mymaster 1\n\n# 故障转移超时时间\nsentinel failover-timeout mymaster 180000\n\n# 不允许使用SENTINEL SET设置notification-script和client-reconfig-script。\nsentinel deny-scripts-reconfig yes\n\n# 故障通知执行相应的脚本，允许执行的最大事件为60秒超时kill，失败重试次数为10\nsentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</code></pre>\n<p>启动哨兵后会<strong>自动感知</strong>到主节点下的所有从节点，通过<code>info</code>指令可知监控主节点的状况、地址、子节点数、监控哨兵数量<br><img src=\"/images/sentinel-info.png\" srcset=\"/img/loading.gif\" alt=\"哨兵情况\"></p>\n<blockquote>\n<p>每次故障转移会<strong>重写节点的配置文件</strong>添加或者删除<code>slaveof</code>指向新的主节点，重新上线后会从新主节点同步数据 </p>\n</blockquote>\n<h3 id=\"Redis-Cluster\"><a href=\"#Redis-Cluster\" class=\"headerlink\" title=\"Redis Cluster\"></a>Redis Cluster</h3><p>当数据量越来越大时生成的快照也越来越大主从之间复制也更加复杂很难去实现快速水平扩展，把鸡蛋放在一个篮子里不如把鸡蛋分开放在不同的篮子里，通过鸡蛋信息根据算法放到相应的篮子里，当数据量越来越大时我只需增加篮子的数量即可完成水平扩展</p>\n<p>Redis Cluster 采用数据分片（sharding）而非一致性哈希（consistency hashing）来实现，Redis 集群默认包含<strong>16384</strong>个哈希槽<code>hash slot</code>当存入一个新<code>key</code>时会根据 <strong>CRC16(key)</strong> 计算出结果对 <strong>16384</strong> 取余得出的值对应相应的哈希槽<code>hash slot</code>，通过<strong>路由算法</strong>得知负责该哈希槽的节点并存入，集群的搭建至少由3个节点组成为了高可用每个节点至少有一个从节点搭用于故障恢复</p>\n<p><img src=\"/images/2020/05/15/c490d980-9687-11ea-baff-f5d93153beb4.png\" srcset=\"/img/loading.gif\" alt=\"image.png\"></p>\n<h4 id=\"Cluster-配置\"><a href=\"#Cluster-配置\" class=\"headerlink\" title=\"Cluster 配置\"></a>Cluster 配置</h4><pre><code class=\"hljs conf\"># 开启集群模式\ncluster-enabled yes\n\n# 集群内部配置文件 会在启动后自动创建\ncluster-config-file nodes.conf\n\n# 集群节点超时时间\ncluster-node-timeout 5000\n\n# 当集群中有节点fail是否认为集群可用，yes 集群某个哈希槽节点无法提供服务且没有从节点故障恢复时认为整个集群失效不再提供服务，no 当某个哈希槽节点失效时认为集群可用且继续提供服务\ncluster-require-full-coverage yes</code></pre>\n<h4 id=\"Cluster-机制\"><a href=\"#Cluster-机制\" class=\"headerlink\" title=\"Cluster 机制\"></a>Cluster 机制</h4><ul>\n<li>集群中所有的节点之间会不断的相互通信（<strong>gossip 协议</strong>）保持整个集群数据完整健康</li>\n<li>每个节点需要2个端口：自身端口和（自身端口+10000）用于通信</li>\n<li>节点之间会交换包含故障信息、节点变化信息、<code>hash slot</code>哈希槽信息等</li>\n<li>集群已实现高可用，通过节点之间通信发现有节点超时则认为<code>pfail</code>，当半数以上的节点都认为<code>pfail</code>则标记为<code>fail</code>，类似哨兵的<code>subjectivly</code>和<code>objectivly</code></li>\n<li>集群采用 <strong>P2P</strong> 模式，完全去中心化节点</li>\n</ul>\n<h4 id=\"Cluster-高可用-扩容\"><a href=\"#Cluster-高可用-扩容\" class=\"headerlink\" title=\"Cluster 高可用 扩容\"></a>Cluster 高可用 扩容</h4><p>当某负责哈希槽节点失效导致无法提供服务为保证整个集群高可用，我们需要给每个负责分片节点配置至少一个从节点用于故障转移，当数据量越来越大时我们可以通过新增分片节点并将其余哈希槽部分转移到新分片之中完成动态扩容而不影响整个集群提供服务</p>\n<h4 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ul>\n<li>集群建立完成后新增的<code>master</code>节点是没有分配哈希槽需要自行根据情况从其他节点转移</li>\n<li><p>新增的节点必须为空否则失败，需要删除对应快照 rdb 和 node.conf 集群节点信息</p>\n  <pre><code class=\"hljs bash\">[ERR] Node 127.0.0.1:6383 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key <span class=\"hljs-keyword\">in</span> database 0.</code></pre>\n</li>\n<li><p>cluster-require-full-coverage 集群失效条件仅针对有哈希槽的分片节点对于其他从节点和无哈希槽节点忽略</p>\n</li>\n<li>通过<code>reids-trib.rb</code>脚本删除集群节点会自动去关闭该节点</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/redis.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"Redis-主从架构\"><a href=\"#Redis-主从架构\" class=\"headerlink\" title=\"Redis 主从架构\"></a>Redis 主从架构</h3><p>Redis 当项目规模越来越大承载需求越来越大单机不足以支撑当前业务，则需要<code>master-slave</code>主从架构来分担其压力承载更多<code>QPS</code>(<strong>我一人无力承受，我需要更多的人来帮我承担，扛不住就摇人</strong>)， 主写从读把压力分散给下面的小弟，更容易水平扩容支持更高并发。<br><img src=\"/images/redis-master-slave.png\" srcset=\"/img/loading.gif\" alt=\"master-slave 架构\"></p>\n<h4 id=\"Replication-核心机制\"><a href=\"#Replication-核心机制\" class=\"headerlink\" title=\"Replication 核心机制\"></a>Replication 核心机制</h4><ul>\n<li>redis 采用异步方式复制数据，当从库进行复制时不会堵塞查询也不会影响主库，会使用旧数据提供服务，当数据复制完毕需删除旧数据加载最新数时无法提供服务。</li>\n<li>slave node 可以有其他 slave node 形成级联模式</li>\n<li>master node 可以有个多个 slave node</li>\n<li>slave 有且仅能有一个 master 节点</li>\n</ul>\n<h4 id=\"主从复制流程\"><a href=\"#主从复制流程\" class=\"headerlink\" title=\"主从复制流程\"></a>主从复制流程</h4><p><img src=\"/images/redis-master-slave-replication.png\" srcset=\"/img/loading.gif\" alt=\"主从复制流程\"></p>\n<ol>\n<li>slave 向 master 发送<code>psync</code>请求，初次连接 master 会触发全量复制<code>full resynchronization</code>，并把 master 的 <code>runid</code> 和 <code>offset</code> 发送给 slave 以便下一次增量复制</li>\n<li>master 会 fork 子进程生成 RDB 快照并将后续执行的写命令写入 buffer（复制缓冲区）</li>\n<li>master 把 RDB 快照和复制缓冲区发送给 slave，slave 会将 RDB 快照先存入本地磁盘然后再加载到内存中</li>\n<li>当网络波动导致复制失败重新连接会根据 slave 的<code>offset</code>与 master 的 <code>offset</code>对比看是否在复制缓冲区范围内判断是全量或增量复制</li>\n</ol>\n<h3 id=\"Redis-主从配置\"><a href=\"#Redis-主从配置\" class=\"headerlink\" title=\"Redis 主从配置\"></a>Redis 主从配置</h3><pre><code class=\"hljs conf\">################################# REPLICATION #################################\n# 复制选项，slave复制对应的master。\n# slaveof &lt;masterip&gt; &lt;masterport&gt;\n\n# 如 master 设置了requirepass 则需要密码才能进行复制保证数据安全性\n# masterauth &lt;master-password&gt;\n\n# 当从库同主机失去连接或者复制正在进行\n# 1) 如果slave-serve-stale-data设置为yes(默认设置) ：从库会继续响应客户端的请求。\n# 2) 如果slave-serve-stale-data设置为no ：除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。\nslave-serve-stale-data yes\n\n# 是否开启子节点只读，一般开启只读用于主从读写分离\nslave-read-only yes\n\n# 是否开启无盘复制，在主从复制生产的 RDB 文件不在落地到磁盘而是直接通过 socket 传输到子节点适用于磁盘 IO紧张网络宽带充裕情况下使用，默认不开启 no\nrepl-diskless-sync no\n\n# diskless 复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。\nrepl-diskless-sync-delay 5\n\n# slave 根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。\n# repl-ping-slave-period 10\n\n# 复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。\n# repl-timeout 60\n\n#是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。\nrepl-disable-tcp-nodelay no\n\n# 复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。\n# repl-backlog-size 5mb\n\n# master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。\n# repl-backlog-ttl 3600\n\n# 节点优先级，在哨兵模式下当主节点下线状态下会从子节点群众根据优先级选出一个新的主节点，当优先级为0时直接忽略\nslave-priority 100\n\n# redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。\n# min-slaves-to-write 3\n\n# 延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。\n# min-slaves-max-lag 10</code></pre>\n<p>通过命令<code>slaveof no one</code>可去除主从关系，通过命令行<code>info replication</code>可以查询当前节点的复制信息<br> <img src=\"/images/info_replication.png\" srcset=\"/img/loading.gif\" alt=\"复制信息\"></p>\n<h4 id=\"参数讲解\"><a href=\"#参数讲解\" class=\"headerlink\" title=\"参数讲解\"></a>参数讲解</h4>\n<table>\n     <tr>\n            <th>角色</th>\n            <th>属性名</th>\n            <th>属性值</th>\n            <th>描述</th>\n     </tr>\n     <tr>\n            <td rowspan=\"5\">通用配置</td>\n            <td>role</td>\n            <td>master|slave</td>\n            <td>节点角色</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_active</td>\n           <td>1|0</td>\n           <td>复制缓冲区状态 1 启动 0 未启动</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_size</td>\n           <td>10465325</td>\n           <td>复制缓冲区大小</td>\n     </tr>\n     <tr>\n           <td>repl_backlog_first_byte_offset</td>\n           <td>10465200</td>\n           <td>复制缓冲区起始偏移量，标识当前缓冲区可用范围</td>\n     </tr>     \n     <tr>\n           <td>repl_backlog_histlen</td>\n           <td>10465200</td>\n           <td>复制缓冲区已有数据长度（字节）</td>\n     </tr>\n     <tr>\n            <td rowspan=\"3\">主节点</td>\n            <td>slave0</td>\n            <td>slave0:127.0.0.1,port=6380,state=online,offset=5572,lag=0</td>\n            <td>子节点基本信息</td>\n     </tr>\n     <tr>\n            <td>connected_slaves</td>\n            <td>1</td>\n            <td>子节点数量</td>\n     </tr>\n     <tr>\n           <td>master_repl_offset</td>\n           <td>330652</td>\n           <td>主节点复制偏移量</td>\n     </tr>     \n     <tr>\n           <td rowspan=\"10\">子节点</td>\n           <td>master_host</td>\n           <td>127.0.0.1</td>\n           <td>主节点地址</td>\n     </tr>     \n     <tr>\n           <td>master_port</td>\n           <td>6379</td>\n           <td>主节点端口号</td>\n     </tr>     \n     <tr>\n           <td>master_link_status</td>\n           <td>up|down</td>\n           <td>主节点状态 up 上线 down 下线</td>\n     </tr>     \n     <tr>\n           <td>master_last_io_seconds_ago</td>\n           <td>-1|其他数字</td>\n           <td>与主节点最后一次 io 通信时间间隔（秒）</td>\n     </tr>     \n     <tr>\n           <td>master_link_down_since_seconds</td>\n           <td>20</td>\n           <td>主节点下线状态已过时间（秒）</td>\n     </tr>     \n     <tr>\n           <td>master_sync_in_progress</td>\n           <td>1|0</td>\n           <td>子节点是否从主节点全量复制 1 是 0 否</td>\n     </tr>     \n     <tr>\n           <td>slave_repl_offset</td>\n           <td>330652</td>\n           <td>子节点复制偏移量</td>\n     </tr>\n     <tr>\n           <td>slave_priority</td>\n           <td>100</td>\n           <td>子节点优先级，在哨兵模式下会根据优先级重新选举主节点</td>\n     </tr>\n     <tr>\n           <td>slave_read_only</td>\n           <td>1|0</td>\n           <td>子节点是否开启只读 1 是 0 否</td>\n     </tr>\n     <tr>\n           <td>master_repl_offset</td>\n           <td>330652</td>\n           <td>主节点复制偏移量</td>\n     </tr>\n </table>\n \n<h5 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><ul>\n<li>合理设置 <code>repl-backlog-size</code> 复制缓冲区大小避免触发循环全量复制，当 master 接受新写入新请求速度大于 slave 同步的速度时，buffer 复制缓冲区内容还未被 slave 同步就被新写入数据所覆盖导致丢失部分指令数据，每一次增量复制 offset 偏移量不在缓冲区范围而触发循环全量复制</li>\n<li>设置缓冲区超时 <code>client-output-buffer-limit slave 256mb 64mb 60</code> 大于256mb或者超过64mb 的状态且超过60s，根据实际情况配合 repl-timeout 同步超时进行调整使用</li>\n<li>slave 不会处理过期 key，通过 master 同步删除</li>\n<li>从节点 <code>slave-read-only</code> 设置为 yes 只读状态</li>\n<li>启无磁盘复制：<code>repl-diskless-sync</code> yes  快照将不落地磁盘直接通过网络复制避免IO性能差</li>\n</ul>\n<h3 id=\"Sentinel-哨兵模式\"><a href=\"#Sentinel-哨兵模式\" class=\"headerlink\" title=\"Sentinel 哨兵模式\"></a>Sentinel 哨兵模式</h3><p><img src=\"/images/redis-sentinel.png\" srcset=\"/img/loading.gif\" alt=\"哨兵模式架构\"><br>对于主从架构如果主节点宕机挂掉子节点将无法获取最新数据，对于这样的情况推出了哨兵模式当<code>master</code>挂掉后会从子节点重新选举一个新的<code>master</code>节点来保证高可用，旧<code>master</code>则会转化成新的<code>slave</code>节点</p>\n<ul>\n<li><strong>监控</strong> ：sentinel 会不断检查<code>master</code>、<code>slave</code>服务器是否正常工作 </li>\n<li><strong>通知</strong> ：当被监控服务出现问题会通过 Api 向管理人员发送通知</li>\n<li><strong>自动故障转移</strong> ：当<code>master</code>失效无法提供服务时，将从<code>slaves</code>子节点群中选举一个新的<code>master</code>节点并将其他<code>slave</code>指向它</li>\n</ul>\n<h4 id=\"哨兵配置\"><a href=\"#哨兵配置\" class=\"headerlink\" title=\"哨兵配置\"></a>哨兵配置</h4><pre><code class=\"hljs conf\"># 端口\nport 26379\n\n# 是否后台启动\ndaemonize yes\n\n# pid文件路径\npidfile /var/run/redis-sentinel.pid\n\n# 日志文件路径\nlogfile &quot;/var/log/sentinel.log&quot;\n\n# 定义工作目录\ndir /tmp\n\n# 定义Redis主的别名, IP, 端口，2指的是需要至少2个Sentinel 认为主节点主观下线（subjectivly）才标记为客观下线（objectivly）并准备自动故障转移\nsentinel monitor mymaster 127.0.0.1 6379 2\n\n# 判断主观下线（subjectivly）最大超时时间\nsentinel down-after-milliseconds mymaster 30000\n\n# 并发同步新 master 节点数据的 slave 数量，数字越小当节点过多时需要完成 failover 的事件就越长，数字越大由于 replication 机制会有更多的 slave 无法提供服务\nsentinel parallel-syncs mymaster 1\n\n# 故障转移超时时间\nsentinel failover-timeout mymaster 180000\n\n# 不允许使用SENTINEL SET设置notification-script和client-reconfig-script。\nsentinel deny-scripts-reconfig yes\n\n# 故障通知执行相应的脚本，允许执行的最大事件为60秒超时kill，失败重试次数为10\nsentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</code></pre>\n<p>启动哨兵后会<strong>自动感知</strong>到主节点下的所有从节点，通过<code>info</code>指令可知监控主节点的状况、地址、子节点数、监控哨兵数量<br><img src=\"/images/sentinel-info.png\" srcset=\"/img/loading.gif\" alt=\"哨兵情况\"></p>\n<blockquote>\n<p>每次故障转移会<strong>重写节点的配置文件</strong>添加或者删除<code>slaveof</code>指向新的主节点，重新上线后会从新主节点同步数据 </p>\n</blockquote>\n<h3 id=\"Redis-Cluster\"><a href=\"#Redis-Cluster\" class=\"headerlink\" title=\"Redis Cluster\"></a>Redis Cluster</h3><p>当数据量越来越大时生成的快照也越来越大主从之间复制也更加复杂很难去实现快速水平扩展，把鸡蛋放在一个篮子里不如把鸡蛋分开放在不同的篮子里，通过鸡蛋信息根据算法放到相应的篮子里，当数据量越来越大时我只需增加篮子的数量即可完成水平扩展</p>\n<p>Redis Cluster 采用数据分片（sharding）而非一致性哈希（consistency hashing）来实现，Redis 集群默认包含<strong>16384</strong>个哈希槽<code>hash slot</code>当存入一个新<code>key</code>时会根据 <strong>CRC16(key)</strong> 计算出结果对 <strong>16384</strong> 取余得出的值对应相应的哈希槽<code>hash slot</code>，通过<strong>路由算法</strong>得知负责该哈希槽的节点并存入，集群的搭建至少由3个节点组成为了高可用每个节点至少有一个从节点搭用于故障恢复</p>\n<p><img src=\"/images/2020/05/15/c490d980-9687-11ea-baff-f5d93153beb4.png\" srcset=\"/img/loading.gif\" alt=\"image.png\"></p>\n<h4 id=\"Cluster-配置\"><a href=\"#Cluster-配置\" class=\"headerlink\" title=\"Cluster 配置\"></a>Cluster 配置</h4><pre><code class=\"hljs conf\"># 开启集群模式\ncluster-enabled yes\n\n# 集群内部配置文件 会在启动后自动创建\ncluster-config-file nodes.conf\n\n# 集群节点超时时间\ncluster-node-timeout 5000\n\n# 当集群中有节点fail是否认为集群可用，yes 集群某个哈希槽节点无法提供服务且没有从节点故障恢复时认为整个集群失效不再提供服务，no 当某个哈希槽节点失效时认为集群可用且继续提供服务\ncluster-require-full-coverage yes</code></pre>\n<h4 id=\"Cluster-机制\"><a href=\"#Cluster-机制\" class=\"headerlink\" title=\"Cluster 机制\"></a>Cluster 机制</h4><ul>\n<li>集群中所有的节点之间会不断的相互通信（<strong>gossip 协议</strong>）保持整个集群数据完整健康</li>\n<li>每个节点需要2个端口：自身端口和（自身端口+10000）用于通信</li>\n<li>节点之间会交换包含故障信息、节点变化信息、<code>hash slot</code>哈希槽信息等</li>\n<li>集群已实现高可用，通过节点之间通信发现有节点超时则认为<code>pfail</code>，当半数以上的节点都认为<code>pfail</code>则标记为<code>fail</code>，类似哨兵的<code>subjectivly</code>和<code>objectivly</code></li>\n<li>集群采用 <strong>P2P</strong> 模式，完全去中心化节点</li>\n</ul>\n<h4 id=\"Cluster-高可用-扩容\"><a href=\"#Cluster-高可用-扩容\" class=\"headerlink\" title=\"Cluster 高可用 扩容\"></a>Cluster 高可用 扩容</h4><p>当某负责哈希槽节点失效导致无法提供服务为保证整个集群高可用，我们需要给每个负责分片节点配置至少一个从节点用于故障转移，当数据量越来越大时我们可以通过新增分片节点并将其余哈希槽部分转移到新分片之中完成动态扩容而不影响整个集群提供服务</p>\n<h4 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ul>\n<li>集群建立完成后新增的<code>master</code>节点是没有分配哈希槽需要自行根据情况从其他节点转移</li>\n<li><p>新增的节点必须为空否则失败，需要删除对应快照 rdb 和 node.conf 集群节点信息</p>\n  <pre><code class=\"hljs bash\">[ERR] Node 127.0.0.1:6383 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key <span class=\"hljs-keyword\">in</span> database 0.</code></pre>\n</li>\n<li><p>cluster-require-full-coverage 集群失效条件仅针对有哈希槽的分片节点对于其他从节点和无哈希槽节点忽略</p>\n</li>\n<li>通过<code>reids-trib.rb</code>脚本删除集群节点会自动去关闭该节点</li>\n</ul>\n"},{"title":"Redis 持久化","toc":false,"date":"2019-02-22T02:27:08.000Z","_content":"\n![](/images/redis.jpg)\n\n>记录学习Redis持久化，Redis为内存数据库当服务器异常关闭或重启会导致内存里的Redis数据丢失，Redis提供持久化方案来保证数据不丢失.\n\n## Redis 持久化\nRedis持久化有多种不同级别的方式\n- `RDB` 持久化可以在指定时间范围内服务器生成数据集的`Snapshot` 时间点快照`point-in-time `(数据库中所有键值对数据)\n- `AOF` 持久化记录服务器执行过的写操作命令，在服务启动通过执行命令来恢复数据集。`AOF`文件中的命令以 Redis 协议的格式保存，新命令会追加到文件末尾。\n- `RDB`和`AOF`同时使用，在Redis重启时优先使用`AOF`进行数据恢复，因为`AOF`的保存的数据通常比`RDB`文件所保存的数据更完整。\n- 关闭持久化，数据仅在服务器运行时存在\n\n## RDB 持久化-配置\n- __save__ `save m n` (m 代表时间范围内 n 修改次数) 例如默认配置文件中的`save 900 1` 900秒内至少有一个 Key 发生变化则保存。\n- __stop-writes-on-bgsave-error__ 默认值 yes，当 Redis 后台保存失败时是否停止接受写操作。如果已经设置一些监控可选择关闭。\n- __rdbcompression__ 默认值 yes，对存储到磁盘的快照文件是否进行压缩(`LZF`算法压缩)，压缩会消耗一定 CPU 性能，具体根据实际情况设置是否压缩。\n- __rdbchecksum__ 默认值 yes，对于存储的快照文件使用`CRC64`算法进行数据校验，校验大概消耗10%的性能，如需大量性能可关闭跳过校验过程。\n- __dbfilename__ 默认值 dump.rbd， 快照文件的名称。\n- __dir__ 默认当前目录，快照文件的存放文件路径\n\n#### RDB 优点\n- Redis 在保存 RDB 会 fork 出子进程进行，几乎不影响 Redis 处理效率。\n- RDB 非常适合灾难恢复（`disaster reconvery`），每次快照会生成完整的快照文件，可根据业务需求进行多备云备份。\n- RDB 在恢复大数据集时比AOF速度更快。 \n\n#### RDB 缺点\n- RDB 快照是定期生成，在时间范围内服务发生宕机可能导致会丢失部分数据\n- RDB 在大数据快照生成上会消耗大量 CPU 性能，如 CPU 性能不足或紧张时会影响 Redis 对外服务。\n\n## AOF 持久化\n__AOF__（`append-only file`）持久化:将 Redis 执行的每一条写请求都记录在一个日志文件里，在 Redis 启动后会执行所有的写操作达来恢复数据。AOF 默认是关闭状态，AOF 提供3种fsync配置\n- __appendfsync no__ 不进行fsync，由OS来决定什么时候进行同步，速度最快\n- __appendfsync always__ 每一次操作都进行fsync，速度较慢\n- __appendfsync everysec__ 折中的做法，交由后台线程每秒fsync一次\n\n#### AOF 优点\n数据更安全，在配置 appendfsync always 或 appendfsync everysec 会及时把每条执行的写操作都记录都追加到 AOF 文件末尾即使是服务出现故障至多损失1s之内的数据。\n\n#### AOF 缺点\n\n##### 参考地址\nhttp://doc.redisfans.com/topic/persistence.html\nhttps://baijiahao.baidu.com/s?id=1611955931705092609&wfr=spider&for=pc","source":"_posts/Redis持久化.md","raw":"---\ntitle: Redis 持久化\ntags:\n  - Redis\ncategories:\n  - 数据库\ntoc: false\ndate: 2019-02-22 10:27:08\n---\n\n![](/images/redis.jpg)\n\n>记录学习Redis持久化，Redis为内存数据库当服务器异常关闭或重启会导致内存里的Redis数据丢失，Redis提供持久化方案来保证数据不丢失.\n\n## Redis 持久化\nRedis持久化有多种不同级别的方式\n- `RDB` 持久化可以在指定时间范围内服务器生成数据集的`Snapshot` 时间点快照`point-in-time `(数据库中所有键值对数据)\n- `AOF` 持久化记录服务器执行过的写操作命令，在服务启动通过执行命令来恢复数据集。`AOF`文件中的命令以 Redis 协议的格式保存，新命令会追加到文件末尾。\n- `RDB`和`AOF`同时使用，在Redis重启时优先使用`AOF`进行数据恢复，因为`AOF`的保存的数据通常比`RDB`文件所保存的数据更完整。\n- 关闭持久化，数据仅在服务器运行时存在\n\n## RDB 持久化-配置\n- __save__ `save m n` (m 代表时间范围内 n 修改次数) 例如默认配置文件中的`save 900 1` 900秒内至少有一个 Key 发生变化则保存。\n- __stop-writes-on-bgsave-error__ 默认值 yes，当 Redis 后台保存失败时是否停止接受写操作。如果已经设置一些监控可选择关闭。\n- __rdbcompression__ 默认值 yes，对存储到磁盘的快照文件是否进行压缩(`LZF`算法压缩)，压缩会消耗一定 CPU 性能，具体根据实际情况设置是否压缩。\n- __rdbchecksum__ 默认值 yes，对于存储的快照文件使用`CRC64`算法进行数据校验，校验大概消耗10%的性能，如需大量性能可关闭跳过校验过程。\n- __dbfilename__ 默认值 dump.rbd， 快照文件的名称。\n- __dir__ 默认当前目录，快照文件的存放文件路径\n\n#### RDB 优点\n- Redis 在保存 RDB 会 fork 出子进程进行，几乎不影响 Redis 处理效率。\n- RDB 非常适合灾难恢复（`disaster reconvery`），每次快照会生成完整的快照文件，可根据业务需求进行多备云备份。\n- RDB 在恢复大数据集时比AOF速度更快。 \n\n#### RDB 缺点\n- RDB 快照是定期生成，在时间范围内服务发生宕机可能导致会丢失部分数据\n- RDB 在大数据快照生成上会消耗大量 CPU 性能，如 CPU 性能不足或紧张时会影响 Redis 对外服务。\n\n## AOF 持久化\n__AOF__（`append-only file`）持久化:将 Redis 执行的每一条写请求都记录在一个日志文件里，在 Redis 启动后会执行所有的写操作达来恢复数据。AOF 默认是关闭状态，AOF 提供3种fsync配置\n- __appendfsync no__ 不进行fsync，由OS来决定什么时候进行同步，速度最快\n- __appendfsync always__ 每一次操作都进行fsync，速度较慢\n- __appendfsync everysec__ 折中的做法，交由后台线程每秒fsync一次\n\n#### AOF 优点\n数据更安全，在配置 appendfsync always 或 appendfsync everysec 会及时把每条执行的写操作都记录都追加到 AOF 文件末尾即使是服务出现故障至多损失1s之内的数据。\n\n#### AOF 缺点\n\n##### 参考地址\nhttp://doc.redisfans.com/topic/persistence.html\nhttps://baijiahao.baidu.com/s?id=1611955931705092609&wfr=spider&for=pc","slug":"Redis持久化","published":1,"updated":"2020-08-10T01:48:44.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc98u002ujsudkxcsuezs","content":"<p><img src=\"/images/redis.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录学习Redis持久化，Redis为内存数据库当服务器异常关闭或重启会导致内存里的Redis数据丢失，Redis提供持久化方案来保证数据不丢失.</p>\n</blockquote>\n<h2 id=\"Redis-持久化\"><a href=\"#Redis-持久化\" class=\"headerlink\" title=\"Redis 持久化\"></a>Redis 持久化</h2><p>Redis持久化有多种不同级别的方式</p>\n<ul>\n<li><code>RDB</code> 持久化可以在指定时间范围内服务器生成数据集的<code>Snapshot</code> 时间点快照<code>point-in-time</code>(数据库中所有键值对数据)</li>\n<li><code>AOF</code> 持久化记录服务器执行过的写操作命令，在服务启动通过执行命令来恢复数据集。<code>AOF</code>文件中的命令以 Redis 协议的格式保存，新命令会追加到文件末尾。</li>\n<li><code>RDB</code>和<code>AOF</code>同时使用，在Redis重启时优先使用<code>AOF</code>进行数据恢复，因为<code>AOF</code>的保存的数据通常比<code>RDB</code>文件所保存的数据更完整。</li>\n<li>关闭持久化，数据仅在服务器运行时存在</li>\n</ul>\n<h2 id=\"RDB-持久化-配置\"><a href=\"#RDB-持久化-配置\" class=\"headerlink\" title=\"RDB 持久化-配置\"></a>RDB 持久化-配置</h2><ul>\n<li><strong>save</strong> <code>save m n</code> (m 代表时间范围内 n 修改次数) 例如默认配置文件中的<code>save 900 1</code> 900秒内至少有一个 Key 发生变化则保存。</li>\n<li><strong>stop-writes-on-bgsave-error</strong> 默认值 yes，当 Redis 后台保存失败时是否停止接受写操作。如果已经设置一些监控可选择关闭。</li>\n<li><strong>rdbcompression</strong> 默认值 yes，对存储到磁盘的快照文件是否进行压缩(<code>LZF</code>算法压缩)，压缩会消耗一定 CPU 性能，具体根据实际情况设置是否压缩。</li>\n<li><strong>rdbchecksum</strong> 默认值 yes，对于存储的快照文件使用<code>CRC64</code>算法进行数据校验，校验大概消耗10%的性能，如需大量性能可关闭跳过校验过程。</li>\n<li><strong>dbfilename</strong> 默认值 dump.rbd， 快照文件的名称。</li>\n<li><strong>dir</strong> 默认当前目录，快照文件的存放文件路径</li>\n</ul>\n<h4 id=\"RDB-优点\"><a href=\"#RDB-优点\" class=\"headerlink\" title=\"RDB 优点\"></a>RDB 优点</h4><ul>\n<li>Redis 在保存 RDB 会 fork 出子进程进行，几乎不影响 Redis 处理效率。</li>\n<li>RDB 非常适合灾难恢复（<code>disaster reconvery</code>），每次快照会生成完整的快照文件，可根据业务需求进行多备云备份。</li>\n<li>RDB 在恢复大数据集时比AOF速度更快。 </li>\n</ul>\n<h4 id=\"RDB-缺点\"><a href=\"#RDB-缺点\" class=\"headerlink\" title=\"RDB 缺点\"></a>RDB 缺点</h4><ul>\n<li>RDB 快照是定期生成，在时间范围内服务发生宕机可能导致会丢失部分数据</li>\n<li>RDB 在大数据快照生成上会消耗大量 CPU 性能，如 CPU 性能不足或紧张时会影响 Redis 对外服务。</li>\n</ul>\n<h2 id=\"AOF-持久化\"><a href=\"#AOF-持久化\" class=\"headerlink\" title=\"AOF 持久化\"></a>AOF 持久化</h2><p><strong>AOF</strong>（<code>append-only file</code>）持久化:将 Redis 执行的每一条写请求都记录在一个日志文件里，在 Redis 启动后会执行所有的写操作达来恢复数据。AOF 默认是关闭状态，AOF 提供3种fsync配置</p>\n<ul>\n<li><strong>appendfsync no</strong> 不进行fsync，由OS来决定什么时候进行同步，速度最快</li>\n<li><strong>appendfsync always</strong> 每一次操作都进行fsync，速度较慢</li>\n<li><strong>appendfsync everysec</strong> 折中的做法，交由后台线程每秒fsync一次</li>\n</ul>\n<h4 id=\"AOF-优点\"><a href=\"#AOF-优点\" class=\"headerlink\" title=\"AOF 优点\"></a>AOF 优点</h4><p>数据更安全，在配置 appendfsync always 或 appendfsync everysec 会及时把每条执行的写操作都记录都追加到 AOF 文件末尾即使是服务出现故障至多损失1s之内的数据。</p>\n<h4 id=\"AOF-缺点\"><a href=\"#AOF-缺点\" class=\"headerlink\" title=\"AOF 缺点\"></a>AOF 缺点</h4><h5 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h5><p><a href=\"http://doc.redisfans.com/topic/persistence.html\" target=\"_blank\" rel=\"noopener\">http://doc.redisfans.com/topic/persistence.html</a><br><a href=\"https://baijiahao.baidu.com/s?id=1611955931705092609&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">https://baijiahao.baidu.com/s?id=1611955931705092609&amp;wfr=spider&amp;for=pc</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/redis.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录学习Redis持久化，Redis为内存数据库当服务器异常关闭或重启会导致内存里的Redis数据丢失，Redis提供持久化方案来保证数据不丢失.</p>\n</blockquote>\n<h2 id=\"Redis-持久化\"><a href=\"#Redis-持久化\" class=\"headerlink\" title=\"Redis 持久化\"></a>Redis 持久化</h2><p>Redis持久化有多种不同级别的方式</p>\n<ul>\n<li><code>RDB</code> 持久化可以在指定时间范围内服务器生成数据集的<code>Snapshot</code> 时间点快照<code>point-in-time</code>(数据库中所有键值对数据)</li>\n<li><code>AOF</code> 持久化记录服务器执行过的写操作命令，在服务启动通过执行命令来恢复数据集。<code>AOF</code>文件中的命令以 Redis 协议的格式保存，新命令会追加到文件末尾。</li>\n<li><code>RDB</code>和<code>AOF</code>同时使用，在Redis重启时优先使用<code>AOF</code>进行数据恢复，因为<code>AOF</code>的保存的数据通常比<code>RDB</code>文件所保存的数据更完整。</li>\n<li>关闭持久化，数据仅在服务器运行时存在</li>\n</ul>\n<h2 id=\"RDB-持久化-配置\"><a href=\"#RDB-持久化-配置\" class=\"headerlink\" title=\"RDB 持久化-配置\"></a>RDB 持久化-配置</h2><ul>\n<li><strong>save</strong> <code>save m n</code> (m 代表时间范围内 n 修改次数) 例如默认配置文件中的<code>save 900 1</code> 900秒内至少有一个 Key 发生变化则保存。</li>\n<li><strong>stop-writes-on-bgsave-error</strong> 默认值 yes，当 Redis 后台保存失败时是否停止接受写操作。如果已经设置一些监控可选择关闭。</li>\n<li><strong>rdbcompression</strong> 默认值 yes，对存储到磁盘的快照文件是否进行压缩(<code>LZF</code>算法压缩)，压缩会消耗一定 CPU 性能，具体根据实际情况设置是否压缩。</li>\n<li><strong>rdbchecksum</strong> 默认值 yes，对于存储的快照文件使用<code>CRC64</code>算法进行数据校验，校验大概消耗10%的性能，如需大量性能可关闭跳过校验过程。</li>\n<li><strong>dbfilename</strong> 默认值 dump.rbd， 快照文件的名称。</li>\n<li><strong>dir</strong> 默认当前目录，快照文件的存放文件路径</li>\n</ul>\n<h4 id=\"RDB-优点\"><a href=\"#RDB-优点\" class=\"headerlink\" title=\"RDB 优点\"></a>RDB 优点</h4><ul>\n<li>Redis 在保存 RDB 会 fork 出子进程进行，几乎不影响 Redis 处理效率。</li>\n<li>RDB 非常适合灾难恢复（<code>disaster reconvery</code>），每次快照会生成完整的快照文件，可根据业务需求进行多备云备份。</li>\n<li>RDB 在恢复大数据集时比AOF速度更快。 </li>\n</ul>\n<h4 id=\"RDB-缺点\"><a href=\"#RDB-缺点\" class=\"headerlink\" title=\"RDB 缺点\"></a>RDB 缺点</h4><ul>\n<li>RDB 快照是定期生成，在时间范围内服务发生宕机可能导致会丢失部分数据</li>\n<li>RDB 在大数据快照生成上会消耗大量 CPU 性能，如 CPU 性能不足或紧张时会影响 Redis 对外服务。</li>\n</ul>\n<h2 id=\"AOF-持久化\"><a href=\"#AOF-持久化\" class=\"headerlink\" title=\"AOF 持久化\"></a>AOF 持久化</h2><p><strong>AOF</strong>（<code>append-only file</code>）持久化:将 Redis 执行的每一条写请求都记录在一个日志文件里，在 Redis 启动后会执行所有的写操作达来恢复数据。AOF 默认是关闭状态，AOF 提供3种fsync配置</p>\n<ul>\n<li><strong>appendfsync no</strong> 不进行fsync，由OS来决定什么时候进行同步，速度最快</li>\n<li><strong>appendfsync always</strong> 每一次操作都进行fsync，速度较慢</li>\n<li><strong>appendfsync everysec</strong> 折中的做法，交由后台线程每秒fsync一次</li>\n</ul>\n<h4 id=\"AOF-优点\"><a href=\"#AOF-优点\" class=\"headerlink\" title=\"AOF 优点\"></a>AOF 优点</h4><p>数据更安全，在配置 appendfsync always 或 appendfsync everysec 会及时把每条执行的写操作都记录都追加到 AOF 文件末尾即使是服务出现故障至多损失1s之内的数据。</p>\n<h4 id=\"AOF-缺点\"><a href=\"#AOF-缺点\" class=\"headerlink\" title=\"AOF 缺点\"></a>AOF 缺点</h4><h5 id=\"参考地址\"><a href=\"#参考地址\" class=\"headerlink\" title=\"参考地址\"></a>参考地址</h5><p><a href=\"http://doc.redisfans.com/topic/persistence.html\" target=\"_blank\" rel=\"noopener\">http://doc.redisfans.com/topic/persistence.html</a><br><a href=\"https://baijiahao.baidu.com/s?id=1611955931705092609&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">https://baijiahao.baidu.com/s?id=1611955931705092609&amp;wfr=spider&amp;for=pc</a></p>\n"},{"title":"Redis 数据类型及应用场景","toc":false,"date":"2019-04-10T08:19:30.000Z","_content":"\n![](/images/redis.jpg)\n\n> 记录学习 Redis 的数据类型以及实际项目中的运用场景\n\n## Redis 存储类型\n`Redis` 面试经常会闻到支持那些存储类型，常用的类型有`String`、`Hash`、`List`、`Set`、`Sorted Set`等。\n\n### String\n`   Strings` 数据类结构是最简单的 `Key-value`类型，`Value` 的值根据执行的命令可为数值或字符串。\n> 常用命令: `set,get,decr,incr,mget` 等。\n\n__应用场景__：例如计数器功能`incr`可以运用于接口调用次数每次调用增加+1，配合`decr`每次减少-1，执行完毕会返回操作之后的值。\n\n\n### Hash\n`Hash` 键值对格式，适合存放对象信息例如用户信息，用户名ID对应的用户信息`value`。有时候我们使用的是序列化对象取出和存在都需要序列化消耗性能。\n> 常用命令： `hget，hset，hgetall，Hash` 实现有2种在数据量较小时会采用类似一维数组紧凑存储,对应的`value`的`redisObject`的`encoding`为`zipmap`，当数据足够大时内部会自动转化成真正`HashMap`结构，`encoding`为`ht`。\n  \n__应用场景__：例如用户信息、后台列表信息、用户的权限信息等。\n\n### List\n`List` 链表，`Redis` 实现为一个双向链表，即可以反向查询和遍历，更方便操作但也带来更多的性能消耗。\n> 常用命令: `lpush，rpush，lpop，rpop，lrange，blpop`等\n\n__应用场景__：例如使用`lrange`可以做分页操作，一些列表信息展示，使用`ltrim`限制长度可限制最新N条数据。`lpsuh`、`rpush`添加数据，`lpop`、`rpop`删除数据。\n\n### Set\n`Set` 类似`List`的功能，主要功能可以去重当你不希望有重复数据可以使用，并且可以判断是否某数据是否在集合内还可以处理2个`Set`交集、并集、差集。\n> 常用命令： `sadd，spop，smembers，sunion`等，实现方式是`value`永远为`null`的`HashMap`，通过计算`Hash`的方式来快速排重。\n\n__应用场景__：例如用户权限公共的权限交集，微博里的共同好友、共同关注等。\n\n### SortedSet\n当你需要没有重复数据且有序则可以使用`SortedSet`，不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。\n> 常用命令: `zadd，zcard，zrem`\n\n### Geo\n用于存放地理坐标\n\n\n### 代码运用\n``` java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class TestControllerTest {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    private final String stringKey = \"stringKey\";\n\n    private final String listKey = \"listKey\";\n\n    private final String hashKey = \"hashKey\";\n\n    private final String geoType = \"geoKey\";\n\n    private final String setType1 = \"setType1\";\n\n    private final String setType2 = \"setType2\";\n\n    private final String sortedType = \"sortedType\";\n\n\n    @Test\n    /**\n     * 常见的string类型数据\n     */\n    public void stringType() {\n        ValueOperations<String, String> valueOperations = stringRedisTemplate.opsForValue();\n        valueOperations.set(stringKey, \"test\");\n        System.out.println(valueOperations.get(stringKey));\n        stringRedisTemplate.delete(stringKey);\n    }\n\n    @Test\n    /**\n     * list数据类型 可分页 可作为简单的队列\n     */\n    public void listType() {\n        List<String> pushList = Arrays.asList(\"push3\", \"push2\", \"push1\");\n        ListOperations<String, String> listOperations = stringRedisTemplate.opsForList();\n        listOperations.leftPushAll(listKey, pushList);\n        System.out.println(listOperations.size(listKey));\n        String str1 = listOperations.rightPop(listKey);\n        String str2 = listOperations.rightPop(listKey, 10, TimeUnit.MILLISECONDS);\n        String str3 = listOperations.rightPop(listKey);\n        System.out.println(str1);\n        System.out.println(str2);\n        System.out.println(str3);\n    }\n\n    @Test\n    /**\n     * hash 键值对类型\n     */\n    public void hashType() {\n        HashOperations<String, String, String> hashOperations = stringRedisTemplate.opsForHash();\n        hashOperations.put(hashKey, \"1\", \"1str\");\n        hashOperations.put(hashKey, \"2\", \"2str\");\n        hashOperations.put(hashKey, \"3\", \"3str\");\n        Map<String,String> objectMap = hashOperations.entries(hashKey);\n        for (String o : objectMap.values()) {\n            System.out.println(o);\n        }\n        System.out.println(hashOperations.keys(hashKey));\n        System.out.println(hashOperations.get(hashKey, \"1\"));\n    }\n\n    @Test\n    /**\n     * Geo常用语地理位置 坐标 地点距离\n     */\n    public void geoType() {\n        GeoOperations<String, String> geoOperations = stringRedisTemplate.opsForGeo();\n        geoOperations.add(geoType, new Point(123.02, 232.0), \"beijing\");\n        geoOperations.add(geoType, new Point(1232.0222, 423.23), \"shanghai\");\n        Distance distance = geoOperations.distance(geoType, \"beijing\", \"shanghai\");\n        System.out.println(distance.getValue());\n    }\n\n    @Test\n    /**\n     * 不可重复set\n     */\n    public void setType() {\n        SetOperations<String, String> setOperations = stringRedisTemplate.opsForSet();\n        setOperations.add(setType1, \"1\",\"3\", \"4\");\n        setOperations.add(setType2, \"2\",\"4\",\"5\");\n        //差集\n        Set<String> differenceStr = setOperations.difference(setType2,setType1);\n        System.out.println(differenceStr);\n        //交集\n        Set<String> intersectStr = setOperations.intersect(setType1, setType2);\n        System.out.println(intersectStr);\n    }\n\n    @Test\n    /**\n     * 不可重复且通过分数进行排序set\n     */\n    public void sortedSetType() {\n        ZSetOperations<String, String> zSetOperations = stringRedisTemplate.opsForZSet();\n        zSetOperations.add(sortedType, \"小于\", 72.2);\n        zSetOperations.add(sortedType, \"小明\", 52.2);\n        zSetOperations.add(sortedType, \"小方\", 22.5);\n        zSetOperations.add(sortedType, \"小球\", 99.2);\n        // 升序分数排名 从0 开始\n        System.out.println(zSetOperations.rank(sortedType,\"小于\"));\n        // 降序分数排名 从0 开始\n        System.out.println(zSetOperations.reverseRank(sortedType,\"小于\"));\n        //50-80 分数 升序 values\n        Set<String> scores=zSetOperations.rangeByScore(sortedType,50,80);\n        System.out.println(scores);\n        //20-80 分数 降序 values\n        Set<String> reverseScores=zSetOperations.reverseRangeByScore(sortedType,20,80);\n        System.out.println(reverseScores);\n    }\n\n}\n```\n\n## 过期策略\n- 定时删除 对于带有`TTL`标示的`key`， Redis 会定时随机抽取检查是否过期并删除\n- 惰性删除 当你去获取一个`key`时如果超时则会直接删除该key且没有返回\n对于以上2种删除并不能覆盖到所有的`key`，当这些数据后续不再使用会浪费大量内存空间属于无效缓存，如果内存不足时想继续存入新数据则会产生与预期不符的结果，`Redis`对于内存不足情况下提供了内存淘汰机制\n\n#### 内存淘汰机制\n- __noeviction__ 内存不足写入操作直接报错返回错信息\n- __allkey-lru__ 所有 key 通用，优先删除最近最少使用(less recently used ,LRU) 的 key\n- __allkey-random__ 所有 key 通用，随机删除一部分 key\n- __volatile-lru__ 只限于设置了 expire 的部分，随机删除一部分 key\n- __volatile-random__ 只限于设置了 expire 的部分，优先删除剩余时间(time to live TTL) 短的key","source":"_posts/Redis数据类型及应用场景.md","raw":"---\ntitle: Redis 数据类型及应用场景\ntags:\n  - Redis\ncategories:\n  - Java\ntoc: false\ndate: 2019-04-10 16:19:30\n---\n\n![](/images/redis.jpg)\n\n> 记录学习 Redis 的数据类型以及实际项目中的运用场景\n\n## Redis 存储类型\n`Redis` 面试经常会闻到支持那些存储类型，常用的类型有`String`、`Hash`、`List`、`Set`、`Sorted Set`等。\n\n### String\n`   Strings` 数据类结构是最简单的 `Key-value`类型，`Value` 的值根据执行的命令可为数值或字符串。\n> 常用命令: `set,get,decr,incr,mget` 等。\n\n__应用场景__：例如计数器功能`incr`可以运用于接口调用次数每次调用增加+1，配合`decr`每次减少-1，执行完毕会返回操作之后的值。\n\n\n### Hash\n`Hash` 键值对格式，适合存放对象信息例如用户信息，用户名ID对应的用户信息`value`。有时候我们使用的是序列化对象取出和存在都需要序列化消耗性能。\n> 常用命令： `hget，hset，hgetall，Hash` 实现有2种在数据量较小时会采用类似一维数组紧凑存储,对应的`value`的`redisObject`的`encoding`为`zipmap`，当数据足够大时内部会自动转化成真正`HashMap`结构，`encoding`为`ht`。\n  \n__应用场景__：例如用户信息、后台列表信息、用户的权限信息等。\n\n### List\n`List` 链表，`Redis` 实现为一个双向链表，即可以反向查询和遍历，更方便操作但也带来更多的性能消耗。\n> 常用命令: `lpush，rpush，lpop，rpop，lrange，blpop`等\n\n__应用场景__：例如使用`lrange`可以做分页操作，一些列表信息展示，使用`ltrim`限制长度可限制最新N条数据。`lpsuh`、`rpush`添加数据，`lpop`、`rpop`删除数据。\n\n### Set\n`Set` 类似`List`的功能，主要功能可以去重当你不希望有重复数据可以使用，并且可以判断是否某数据是否在集合内还可以处理2个`Set`交集、并集、差集。\n> 常用命令： `sadd，spop，smembers，sunion`等，实现方式是`value`永远为`null`的`HashMap`，通过计算`Hash`的方式来快速排重。\n\n__应用场景__：例如用户权限公共的权限交集，微博里的共同好友、共同关注等。\n\n### SortedSet\n当你需要没有重复数据且有序则可以使用`SortedSet`，不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。\n> 常用命令: `zadd，zcard，zrem`\n\n### Geo\n用于存放地理坐标\n\n\n### 代码运用\n``` java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class TestControllerTest {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    private final String stringKey = \"stringKey\";\n\n    private final String listKey = \"listKey\";\n\n    private final String hashKey = \"hashKey\";\n\n    private final String geoType = \"geoKey\";\n\n    private final String setType1 = \"setType1\";\n\n    private final String setType2 = \"setType2\";\n\n    private final String sortedType = \"sortedType\";\n\n\n    @Test\n    /**\n     * 常见的string类型数据\n     */\n    public void stringType() {\n        ValueOperations<String, String> valueOperations = stringRedisTemplate.opsForValue();\n        valueOperations.set(stringKey, \"test\");\n        System.out.println(valueOperations.get(stringKey));\n        stringRedisTemplate.delete(stringKey);\n    }\n\n    @Test\n    /**\n     * list数据类型 可分页 可作为简单的队列\n     */\n    public void listType() {\n        List<String> pushList = Arrays.asList(\"push3\", \"push2\", \"push1\");\n        ListOperations<String, String> listOperations = stringRedisTemplate.opsForList();\n        listOperations.leftPushAll(listKey, pushList);\n        System.out.println(listOperations.size(listKey));\n        String str1 = listOperations.rightPop(listKey);\n        String str2 = listOperations.rightPop(listKey, 10, TimeUnit.MILLISECONDS);\n        String str3 = listOperations.rightPop(listKey);\n        System.out.println(str1);\n        System.out.println(str2);\n        System.out.println(str3);\n    }\n\n    @Test\n    /**\n     * hash 键值对类型\n     */\n    public void hashType() {\n        HashOperations<String, String, String> hashOperations = stringRedisTemplate.opsForHash();\n        hashOperations.put(hashKey, \"1\", \"1str\");\n        hashOperations.put(hashKey, \"2\", \"2str\");\n        hashOperations.put(hashKey, \"3\", \"3str\");\n        Map<String,String> objectMap = hashOperations.entries(hashKey);\n        for (String o : objectMap.values()) {\n            System.out.println(o);\n        }\n        System.out.println(hashOperations.keys(hashKey));\n        System.out.println(hashOperations.get(hashKey, \"1\"));\n    }\n\n    @Test\n    /**\n     * Geo常用语地理位置 坐标 地点距离\n     */\n    public void geoType() {\n        GeoOperations<String, String> geoOperations = stringRedisTemplate.opsForGeo();\n        geoOperations.add(geoType, new Point(123.02, 232.0), \"beijing\");\n        geoOperations.add(geoType, new Point(1232.0222, 423.23), \"shanghai\");\n        Distance distance = geoOperations.distance(geoType, \"beijing\", \"shanghai\");\n        System.out.println(distance.getValue());\n    }\n\n    @Test\n    /**\n     * 不可重复set\n     */\n    public void setType() {\n        SetOperations<String, String> setOperations = stringRedisTemplate.opsForSet();\n        setOperations.add(setType1, \"1\",\"3\", \"4\");\n        setOperations.add(setType2, \"2\",\"4\",\"5\");\n        //差集\n        Set<String> differenceStr = setOperations.difference(setType2,setType1);\n        System.out.println(differenceStr);\n        //交集\n        Set<String> intersectStr = setOperations.intersect(setType1, setType2);\n        System.out.println(intersectStr);\n    }\n\n    @Test\n    /**\n     * 不可重复且通过分数进行排序set\n     */\n    public void sortedSetType() {\n        ZSetOperations<String, String> zSetOperations = stringRedisTemplate.opsForZSet();\n        zSetOperations.add(sortedType, \"小于\", 72.2);\n        zSetOperations.add(sortedType, \"小明\", 52.2);\n        zSetOperations.add(sortedType, \"小方\", 22.5);\n        zSetOperations.add(sortedType, \"小球\", 99.2);\n        // 升序分数排名 从0 开始\n        System.out.println(zSetOperations.rank(sortedType,\"小于\"));\n        // 降序分数排名 从0 开始\n        System.out.println(zSetOperations.reverseRank(sortedType,\"小于\"));\n        //50-80 分数 升序 values\n        Set<String> scores=zSetOperations.rangeByScore(sortedType,50,80);\n        System.out.println(scores);\n        //20-80 分数 降序 values\n        Set<String> reverseScores=zSetOperations.reverseRangeByScore(sortedType,20,80);\n        System.out.println(reverseScores);\n    }\n\n}\n```\n\n## 过期策略\n- 定时删除 对于带有`TTL`标示的`key`， Redis 会定时随机抽取检查是否过期并删除\n- 惰性删除 当你去获取一个`key`时如果超时则会直接删除该key且没有返回\n对于以上2种删除并不能覆盖到所有的`key`，当这些数据后续不再使用会浪费大量内存空间属于无效缓存，如果内存不足时想继续存入新数据则会产生与预期不符的结果，`Redis`对于内存不足情况下提供了内存淘汰机制\n\n#### 内存淘汰机制\n- __noeviction__ 内存不足写入操作直接报错返回错信息\n- __allkey-lru__ 所有 key 通用，优先删除最近最少使用(less recently used ,LRU) 的 key\n- __allkey-random__ 所有 key 通用，随机删除一部分 key\n- __volatile-lru__ 只限于设置了 expire 的部分，随机删除一部分 key\n- __volatile-random__ 只限于设置了 expire 的部分，优先删除剩余时间(time to live TTL) 短的key","slug":"Redis数据类型及应用场景","published":1,"updated":"2020-08-10T01:48:44.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc98y002yjsud9wvxj0zf","content":"<p><img src=\"/images/redis.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录学习 Redis 的数据类型以及实际项目中的运用场景</p>\n</blockquote>\n<h2 id=\"Redis-存储类型\"><a href=\"#Redis-存储类型\" class=\"headerlink\" title=\"Redis 存储类型\"></a>Redis 存储类型</h2><p><code>Redis</code> 面试经常会闻到支持那些存储类型，常用的类型有<code>String</code>、<code>Hash</code>、<code>List</code>、<code>Set</code>、<code>Sorted Set</code>等。</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p><code>Strings</code> 数据类结构是最简单的 <code>Key-value</code>类型，<code>Value</code> 的值根据执行的命令可为数值或字符串。</p>\n<blockquote>\n<p>常用命令: <code>set,get,decr,incr,mget</code> 等。</p>\n</blockquote>\n<p><strong>应用场景</strong>：例如计数器功能<code>incr</code>可以运用于接口调用次数每次调用增加+1，配合<code>decr</code>每次减少-1，执行完毕会返回操作之后的值。</p>\n<h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><p><code>Hash</code> 键值对格式，适合存放对象信息例如用户信息，用户名ID对应的用户信息<code>value</code>。有时候我们使用的是序列化对象取出和存在都需要序列化消耗性能。</p>\n<blockquote>\n<p>常用命令： <code>hget，hset，hgetall，Hash</code> 实现有2种在数据量较小时会采用类似一维数组紧凑存储,对应的<code>value</code>的<code>redisObject</code>的<code>encoding</code>为<code>zipmap</code>，当数据足够大时内部会自动转化成真正<code>HashMap</code>结构，<code>encoding</code>为<code>ht</code>。</p>\n</blockquote>\n<p><strong>应用场景</strong>：例如用户信息、后台列表信息、用户的权限信息等。</p>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p><code>List</code> 链表，<code>Redis</code> 实现为一个双向链表，即可以反向查询和遍历，更方便操作但也带来更多的性能消耗。</p>\n<blockquote>\n<p>常用命令: <code>lpush，rpush，lpop，rpop，lrange，blpop</code>等</p>\n</blockquote>\n<p><strong>应用场景</strong>：例如使用<code>lrange</code>可以做分页操作，一些列表信息展示，使用<code>ltrim</code>限制长度可限制最新N条数据。<code>lpsuh</code>、<code>rpush</code>添加数据，<code>lpop</code>、<code>rpop</code>删除数据。</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p><code>Set</code> 类似<code>List</code>的功能，主要功能可以去重当你不希望有重复数据可以使用，并且可以判断是否某数据是否在集合内还可以处理2个<code>Set</code>交集、并集、差集。</p>\n<blockquote>\n<p>常用命令： <code>sadd，spop，smembers，sunion</code>等，实现方式是<code>value</code>永远为<code>null</code>的<code>HashMap</code>，通过计算<code>Hash</code>的方式来快速排重。</p>\n</blockquote>\n<p><strong>应用场景</strong>：例如用户权限公共的权限交集，微博里的共同好友、共同关注等。</p>\n<h3 id=\"SortedSet\"><a href=\"#SortedSet\" class=\"headerlink\" title=\"SortedSet\"></a>SortedSet</h3><p>当你需要没有重复数据且有序则可以使用<code>SortedSet</code>，不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。</p>\n<blockquote>\n<p>常用命令: <code>zadd，zcard，zrem</code></p>\n</blockquote>\n<h3 id=\"Geo\"><a href=\"#Geo\" class=\"headerlink\" title=\"Geo\"></a>Geo</h3><p>用于存放地理坐标</p>\n<h3 id=\"代码运用\"><a href=\"#代码运用\" class=\"headerlink\" title=\"代码运用\"></a>代码运用</h3><pre><code class=\"hljs java\">\n<span class=\"hljs-meta\">@RunWith</span>(SpringRunner<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n@<span class=\"hljs-title\">SpringBootTest</span>\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">class</span> <span class=\"hljs-title\">TestControllerTest</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Resource</span>\n    <span class=\"hljs-keyword\">private</span> StringRedisTemplate stringRedisTemplate;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String stringKey = <span class=\"hljs-string\">\"stringKey\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String listKey = <span class=\"hljs-string\">\"listKey\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String hashKey = <span class=\"hljs-string\">\"hashKey\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String geoType = <span class=\"hljs-string\">\"geoKey\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String setType1 = <span class=\"hljs-string\">\"setType1\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String setType2 = <span class=\"hljs-string\">\"setType2\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String sortedType = <span class=\"hljs-string\">\"sortedType\"</span>;\n\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * 常见的string类型数据\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">stringType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue();\n        valueOperations.set(stringKey, <span class=\"hljs-string\">\"test\"</span>);\n        System.out.println(valueOperations.get(stringKey));\n        stringRedisTemplate.delete(stringKey);\n    &#125;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * list数据类型 可分页 可作为简单的队列\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">listType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        List&lt;String&gt; pushList = Arrays.asList(<span class=\"hljs-string\">\"push3\"</span>, <span class=\"hljs-string\">\"push2\"</span>, <span class=\"hljs-string\">\"push1\"</span>);\n        ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList();\n        listOperations.leftPushAll(listKey, pushList);\n        System.out.println(listOperations.size(listKey));\n        String str1 = listOperations.rightPop(listKey);\n        String str2 = listOperations.rightPop(listKey, <span class=\"hljs-number\">10</span>, TimeUnit.MILLISECONDS);\n        String str3 = listOperations.rightPop(listKey);\n        System.out.println(str1);\n        System.out.println(str2);\n        System.out.println(str3);\n    &#125;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * hash 键值对类型\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">hashType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        HashOperations&lt;String, String, String&gt; hashOperations = stringRedisTemplate.opsForHash();\n        hashOperations.put(hashKey, <span class=\"hljs-string\">\"1\"</span>, <span class=\"hljs-string\">\"1str\"</span>);\n        hashOperations.put(hashKey, <span class=\"hljs-string\">\"2\"</span>, <span class=\"hljs-string\">\"2str\"</span>);\n        hashOperations.put(hashKey, <span class=\"hljs-string\">\"3\"</span>, <span class=\"hljs-string\">\"3str\"</span>);\n        Map&lt;String,String&gt; objectMap = hashOperations.entries(hashKey);\n        <span class=\"hljs-keyword\">for</span> (String o : objectMap.values()) &#123;\n            System.out.println(o);\n        &#125;\n        System.out.println(hashOperations.keys(hashKey));\n        System.out.println(hashOperations.get(hashKey, <span class=\"hljs-string\">\"1\"</span>));\n    &#125;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * Geo常用语地理位置 坐标 地点距离\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">geoType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        GeoOperations&lt;String, String&gt; geoOperations = stringRedisTemplate.opsForGeo();\n        geoOperations.add(geoType, <span class=\"hljs-keyword\">new</span> Point(<span class=\"hljs-number\">123.02</span>, <span class=\"hljs-number\">232.0</span>), <span class=\"hljs-string\">\"beijing\"</span>);\n        geoOperations.add(geoType, <span class=\"hljs-keyword\">new</span> Point(<span class=\"hljs-number\">1232.0222</span>, <span class=\"hljs-number\">423.23</span>), <span class=\"hljs-string\">\"shanghai\"</span>);\n        Distance distance = geoOperations.distance(geoType, <span class=\"hljs-string\">\"beijing\"</span>, <span class=\"hljs-string\">\"shanghai\"</span>);\n        System.out.println(distance.getValue());\n    &#125;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * 不可重复set\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        SetOperations&lt;String, String&gt; setOperations = stringRedisTemplate.opsForSet();\n        setOperations.add(setType1, <span class=\"hljs-string\">\"1\"</span>,<span class=\"hljs-string\">\"3\"</span>, <span class=\"hljs-string\">\"4\"</span>);\n        setOperations.add(setType2, <span class=\"hljs-string\">\"2\"</span>,<span class=\"hljs-string\">\"4\"</span>,<span class=\"hljs-string\">\"5\"</span>);\n        <span class=\"hljs-comment\">//差集</span>\n        Set&lt;String&gt; differenceStr = setOperations.difference(setType2,setType1);\n        System.out.println(differenceStr);\n        <span class=\"hljs-comment\">//交集</span>\n        Set&lt;String&gt; intersectStr = setOperations.intersect(setType1, setType2);\n        System.out.println(intersectStr);\n    &#125;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * 不可重复且通过分数进行排序set\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sortedSetType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        ZSetOperations&lt;String, String&gt; zSetOperations = stringRedisTemplate.opsForZSet();\n        zSetOperations.add(sortedType, <span class=\"hljs-string\">\"小于\"</span>, <span class=\"hljs-number\">72.2</span>);\n        zSetOperations.add(sortedType, <span class=\"hljs-string\">\"小明\"</span>, <span class=\"hljs-number\">52.2</span>);\n        zSetOperations.add(sortedType, <span class=\"hljs-string\">\"小方\"</span>, <span class=\"hljs-number\">22.5</span>);\n        zSetOperations.add(sortedType, <span class=\"hljs-string\">\"小球\"</span>, <span class=\"hljs-number\">99.2</span>);\n        <span class=\"hljs-comment\">// 升序分数排名 从0 开始</span>\n        System.out.println(zSetOperations.rank(sortedType,<span class=\"hljs-string\">\"小于\"</span>));\n        <span class=\"hljs-comment\">// 降序分数排名 从0 开始</span>\n        System.out.println(zSetOperations.reverseRank(sortedType,<span class=\"hljs-string\">\"小于\"</span>));\n        <span class=\"hljs-comment\">//50-80 分数 升序 values</span>\n        Set&lt;String&gt; scores=zSetOperations.rangeByScore(sortedType,<span class=\"hljs-number\">50</span>,<span class=\"hljs-number\">80</span>);\n        System.out.println(scores);\n        <span class=\"hljs-comment\">//20-80 分数 降序 values</span>\n        Set&lt;String&gt; reverseScores=zSetOperations.reverseRangeByScore(sortedType,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">80</span>);\n        System.out.println(reverseScores);\n    &#125;\n\n&#125;</code></pre>\n<h2 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h2><ul>\n<li>定时删除 对于带有<code>TTL</code>标示的<code>key</code>， Redis 会定时随机抽取检查是否过期并删除</li>\n<li>惰性删除 当你去获取一个<code>key</code>时如果超时则会直接删除该key且没有返回<br>对于以上2种删除并不能覆盖到所有的<code>key</code>，当这些数据后续不再使用会浪费大量内存空间属于无效缓存，如果内存不足时想继续存入新数据则会产生与预期不符的结果，<code>Redis</code>对于内存不足情况下提供了内存淘汰机制</li>\n</ul>\n<h4 id=\"内存淘汰机制\"><a href=\"#内存淘汰机制\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h4><ul>\n<li><strong>noeviction</strong> 内存不足写入操作直接报错返回错信息</li>\n<li><strong>allkey-lru</strong> 所有 key 通用，优先删除最近最少使用(less recently used ,LRU) 的 key</li>\n<li><strong>allkey-random</strong> 所有 key 通用，随机删除一部分 key</li>\n<li><strong>volatile-lru</strong> 只限于设置了 expire 的部分，随机删除一部分 key</li>\n<li><strong>volatile-random</strong> 只限于设置了 expire 的部分，优先删除剩余时间(time to live TTL) 短的key</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/redis.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录学习 Redis 的数据类型以及实际项目中的运用场景</p>\n</blockquote>\n<h2 id=\"Redis-存储类型\"><a href=\"#Redis-存储类型\" class=\"headerlink\" title=\"Redis 存储类型\"></a>Redis 存储类型</h2><p><code>Redis</code> 面试经常会闻到支持那些存储类型，常用的类型有<code>String</code>、<code>Hash</code>、<code>List</code>、<code>Set</code>、<code>Sorted Set</code>等。</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p><code>Strings</code> 数据类结构是最简单的 <code>Key-value</code>类型，<code>Value</code> 的值根据执行的命令可为数值或字符串。</p>\n<blockquote>\n<p>常用命令: <code>set,get,decr,incr,mget</code> 等。</p>\n</blockquote>\n<p><strong>应用场景</strong>：例如计数器功能<code>incr</code>可以运用于接口调用次数每次调用增加+1，配合<code>decr</code>每次减少-1，执行完毕会返回操作之后的值。</p>\n<h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><p><code>Hash</code> 键值对格式，适合存放对象信息例如用户信息，用户名ID对应的用户信息<code>value</code>。有时候我们使用的是序列化对象取出和存在都需要序列化消耗性能。</p>\n<blockquote>\n<p>常用命令： <code>hget，hset，hgetall，Hash</code> 实现有2种在数据量较小时会采用类似一维数组紧凑存储,对应的<code>value</code>的<code>redisObject</code>的<code>encoding</code>为<code>zipmap</code>，当数据足够大时内部会自动转化成真正<code>HashMap</code>结构，<code>encoding</code>为<code>ht</code>。</p>\n</blockquote>\n<p><strong>应用场景</strong>：例如用户信息、后台列表信息、用户的权限信息等。</p>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p><code>List</code> 链表，<code>Redis</code> 实现为一个双向链表，即可以反向查询和遍历，更方便操作但也带来更多的性能消耗。</p>\n<blockquote>\n<p>常用命令: <code>lpush，rpush，lpop，rpop，lrange，blpop</code>等</p>\n</blockquote>\n<p><strong>应用场景</strong>：例如使用<code>lrange</code>可以做分页操作，一些列表信息展示，使用<code>ltrim</code>限制长度可限制最新N条数据。<code>lpsuh</code>、<code>rpush</code>添加数据，<code>lpop</code>、<code>rpop</code>删除数据。</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p><code>Set</code> 类似<code>List</code>的功能，主要功能可以去重当你不希望有重复数据可以使用，并且可以判断是否某数据是否在集合内还可以处理2个<code>Set</code>交集、并集、差集。</p>\n<blockquote>\n<p>常用命令： <code>sadd，spop，smembers，sunion</code>等，实现方式是<code>value</code>永远为<code>null</code>的<code>HashMap</code>，通过计算<code>Hash</code>的方式来快速排重。</p>\n</blockquote>\n<p><strong>应用场景</strong>：例如用户权限公共的权限交集，微博里的共同好友、共同关注等。</p>\n<h3 id=\"SortedSet\"><a href=\"#SortedSet\" class=\"headerlink\" title=\"SortedSet\"></a>SortedSet</h3><p>当你需要没有重复数据且有序则可以使用<code>SortedSet</code>，不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。</p>\n<blockquote>\n<p>常用命令: <code>zadd，zcard，zrem</code></p>\n</blockquote>\n<h3 id=\"Geo\"><a href=\"#Geo\" class=\"headerlink\" title=\"Geo\"></a>Geo</h3><p>用于存放地理坐标</p>\n<h3 id=\"代码运用\"><a href=\"#代码运用\" class=\"headerlink\" title=\"代码运用\"></a>代码运用</h3><pre><code class=\"hljs java\">\n<span class=\"hljs-meta\">@RunWith</span>(SpringRunner<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n@<span class=\"hljs-title\">SpringBootTest</span>\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">class</span> <span class=\"hljs-title\">TestControllerTest</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Resource</span>\n    <span class=\"hljs-keyword\">private</span> StringRedisTemplate stringRedisTemplate;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String stringKey = <span class=\"hljs-string\">\"stringKey\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String listKey = <span class=\"hljs-string\">\"listKey\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String hashKey = <span class=\"hljs-string\">\"hashKey\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String geoType = <span class=\"hljs-string\">\"geoKey\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String setType1 = <span class=\"hljs-string\">\"setType1\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String setType2 = <span class=\"hljs-string\">\"setType2\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String sortedType = <span class=\"hljs-string\">\"sortedType\"</span>;\n\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * 常见的string类型数据\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">stringType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue();\n        valueOperations.set(stringKey, <span class=\"hljs-string\">\"test\"</span>);\n        System.out.println(valueOperations.get(stringKey));\n        stringRedisTemplate.delete(stringKey);\n    &#125;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * list数据类型 可分页 可作为简单的队列\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">listType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        List&lt;String&gt; pushList = Arrays.asList(<span class=\"hljs-string\">\"push3\"</span>, <span class=\"hljs-string\">\"push2\"</span>, <span class=\"hljs-string\">\"push1\"</span>);\n        ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList();\n        listOperations.leftPushAll(listKey, pushList);\n        System.out.println(listOperations.size(listKey));\n        String str1 = listOperations.rightPop(listKey);\n        String str2 = listOperations.rightPop(listKey, <span class=\"hljs-number\">10</span>, TimeUnit.MILLISECONDS);\n        String str3 = listOperations.rightPop(listKey);\n        System.out.println(str1);\n        System.out.println(str2);\n        System.out.println(str3);\n    &#125;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * hash 键值对类型\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">hashType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        HashOperations&lt;String, String, String&gt; hashOperations = stringRedisTemplate.opsForHash();\n        hashOperations.put(hashKey, <span class=\"hljs-string\">\"1\"</span>, <span class=\"hljs-string\">\"1str\"</span>);\n        hashOperations.put(hashKey, <span class=\"hljs-string\">\"2\"</span>, <span class=\"hljs-string\">\"2str\"</span>);\n        hashOperations.put(hashKey, <span class=\"hljs-string\">\"3\"</span>, <span class=\"hljs-string\">\"3str\"</span>);\n        Map&lt;String,String&gt; objectMap = hashOperations.entries(hashKey);\n        <span class=\"hljs-keyword\">for</span> (String o : objectMap.values()) &#123;\n            System.out.println(o);\n        &#125;\n        System.out.println(hashOperations.keys(hashKey));\n        System.out.println(hashOperations.get(hashKey, <span class=\"hljs-string\">\"1\"</span>));\n    &#125;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * Geo常用语地理位置 坐标 地点距离\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">geoType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        GeoOperations&lt;String, String&gt; geoOperations = stringRedisTemplate.opsForGeo();\n        geoOperations.add(geoType, <span class=\"hljs-keyword\">new</span> Point(<span class=\"hljs-number\">123.02</span>, <span class=\"hljs-number\">232.0</span>), <span class=\"hljs-string\">\"beijing\"</span>);\n        geoOperations.add(geoType, <span class=\"hljs-keyword\">new</span> Point(<span class=\"hljs-number\">1232.0222</span>, <span class=\"hljs-number\">423.23</span>), <span class=\"hljs-string\">\"shanghai\"</span>);\n        Distance distance = geoOperations.distance(geoType, <span class=\"hljs-string\">\"beijing\"</span>, <span class=\"hljs-string\">\"shanghai\"</span>);\n        System.out.println(distance.getValue());\n    &#125;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * 不可重复set\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        SetOperations&lt;String, String&gt; setOperations = stringRedisTemplate.opsForSet();\n        setOperations.add(setType1, <span class=\"hljs-string\">\"1\"</span>,<span class=\"hljs-string\">\"3\"</span>, <span class=\"hljs-string\">\"4\"</span>);\n        setOperations.add(setType2, <span class=\"hljs-string\">\"2\"</span>,<span class=\"hljs-string\">\"4\"</span>,<span class=\"hljs-string\">\"5\"</span>);\n        <span class=\"hljs-comment\">//差集</span>\n        Set&lt;String&gt; differenceStr = setOperations.difference(setType2,setType1);\n        System.out.println(differenceStr);\n        <span class=\"hljs-comment\">//交集</span>\n        Set&lt;String&gt; intersectStr = setOperations.intersect(setType1, setType2);\n        System.out.println(intersectStr);\n    &#125;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-comment\">/**\n     * 不可重复且通过分数进行排序set\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sortedSetType</span><span class=\"hljs-params\">()</span> </span>&#123;\n        ZSetOperations&lt;String, String&gt; zSetOperations = stringRedisTemplate.opsForZSet();\n        zSetOperations.add(sortedType, <span class=\"hljs-string\">\"小于\"</span>, <span class=\"hljs-number\">72.2</span>);\n        zSetOperations.add(sortedType, <span class=\"hljs-string\">\"小明\"</span>, <span class=\"hljs-number\">52.2</span>);\n        zSetOperations.add(sortedType, <span class=\"hljs-string\">\"小方\"</span>, <span class=\"hljs-number\">22.5</span>);\n        zSetOperations.add(sortedType, <span class=\"hljs-string\">\"小球\"</span>, <span class=\"hljs-number\">99.2</span>);\n        <span class=\"hljs-comment\">// 升序分数排名 从0 开始</span>\n        System.out.println(zSetOperations.rank(sortedType,<span class=\"hljs-string\">\"小于\"</span>));\n        <span class=\"hljs-comment\">// 降序分数排名 从0 开始</span>\n        System.out.println(zSetOperations.reverseRank(sortedType,<span class=\"hljs-string\">\"小于\"</span>));\n        <span class=\"hljs-comment\">//50-80 分数 升序 values</span>\n        Set&lt;String&gt; scores=zSetOperations.rangeByScore(sortedType,<span class=\"hljs-number\">50</span>,<span class=\"hljs-number\">80</span>);\n        System.out.println(scores);\n        <span class=\"hljs-comment\">//20-80 分数 降序 values</span>\n        Set&lt;String&gt; reverseScores=zSetOperations.reverseRangeByScore(sortedType,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">80</span>);\n        System.out.println(reverseScores);\n    &#125;\n\n&#125;</code></pre>\n<h2 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h2><ul>\n<li>定时删除 对于带有<code>TTL</code>标示的<code>key</code>， Redis 会定时随机抽取检查是否过期并删除</li>\n<li>惰性删除 当你去获取一个<code>key</code>时如果超时则会直接删除该key且没有返回<br>对于以上2种删除并不能覆盖到所有的<code>key</code>，当这些数据后续不再使用会浪费大量内存空间属于无效缓存，如果内存不足时想继续存入新数据则会产生与预期不符的结果，<code>Redis</code>对于内存不足情况下提供了内存淘汰机制</li>\n</ul>\n<h4 id=\"内存淘汰机制\"><a href=\"#内存淘汰机制\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h4><ul>\n<li><strong>noeviction</strong> 内存不足写入操作直接报错返回错信息</li>\n<li><strong>allkey-lru</strong> 所有 key 通用，优先删除最近最少使用(less recently used ,LRU) 的 key</li>\n<li><strong>allkey-random</strong> 所有 key 通用，随机删除一部分 key</li>\n<li><strong>volatile-lru</strong> 只限于设置了 expire 的部分，随机删除一部分 key</li>\n<li><strong>volatile-random</strong> 只限于设置了 expire 的部分，优先删除剩余时间(time to live TTL) 短的key</li>\n</ul>\n"},{"title":"Redis的淘汰机制LRU算法","toc":false,"date":"2020-09-14T06:46:09.000Z","_content":"\n![](/images/java.jpg)\n\n### LRU 算法\nLRU 全程 Least Recently Used（最近最久未使用），设计原则为：如果有一个数在一段时间未被访问，那么将来被访问的可能性就很小，当资源超过限制范围时应淘汰最久未被访问的数据\n\n### LinkerHashMap 实现 LRU\n`LinkerHsahMap`双向链表数据结构，在创建时可以选择`accessOrder`参数，默认`false`是按插入顺序进行排序，当我们设置`true`则按访问的顺序来进行排序，每当调用`get()`方法会执行`afterNodeAccess`方法将被访者置换尾部\n\n``` java\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n        LinkedHashMap.Entry<K,V> last;\n        if (accessOrder && (last = tail) != e) {\n            LinkedHashMap.Entry<K,V> p =\n                (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n            p.after = null;\n            if (b == null)\n                head = a;\n            else\n                b.after = a;\n            if (a != null)\n                a.before = b;\n            else\n                last = b;\n            if (last == null)\n                head = p;\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            tail = p;\n            ++modCount;\n        }\n  }\n```\n\n当插入新的数据会调用`removeEldestEntry`返回的boolean是否删除链表头部元素，重写该方法当缓存的长度大于限制则删除链表头部元素即删除了最久未被访问的元素，因为被访问过的元素会置换到链表的尾部\n\n``` java\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n       LinkedHashMap.Entry<K,V> first;\n        if (evict && (first = head) != null && removeEldestEntry(first)) {\n            K key = first.key;\n            removeNode(hash(key), key, null, false, true);\n        }\n}\n\nprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n        return false;\n}\n```\n\n我们经常用到的`Mybatis`内部也实现了LRUMap，核心就是重写`removeEldestEntry`方法删除链表头部元素\n\n### 代码实现\n``` java\npublic class LRUCache<K,V> extends LinkedHashMap<K,V> {\n    private final Integer cacheSize;\n\n    public LRUCache(Integer cacheSize) {\n        super(cacheSize,0.75f,true);\n        this.cacheSize = cacheSize;\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size()>cacheSize;\n    }\n\n    public static void main(String[] args) {\n        LRUCache c = new LRUCache(3);\n        c.put(\"k1\", 1);\n        c.put(\"k2\", 2);\n        c.put(\"k3\", 3);\n   \t    c.get(\"k2\");\n        c.put(\"k4\", 4);\n     \n        System.out.println(c);\n    }\n}\n```\n\n这里打印出来为 **{k3=3, k2=2, k4=4}**，当`get(\"k2\")`时会将`k2`元素移到链表的末尾，下一步`put(\"k4\")`时`removeEldestEntry`会返回`true`，缓存长度已超出限制范围删除首部元素所以打印出来就是 **{k3=3, k2=2, k4=4}**","source":"_posts/Redis的淘汰机制LRU算法.md","raw":"---\ntitle: Redis的淘汰机制LRU算法\ntags: []\ncategories: [redis]\ntoc: false\ndate: 2020-09-14 14:46:09\n---\n\n![](/images/java.jpg)\n\n### LRU 算法\nLRU 全程 Least Recently Used（最近最久未使用），设计原则为：如果有一个数在一段时间未被访问，那么将来被访问的可能性就很小，当资源超过限制范围时应淘汰最久未被访问的数据\n\n### LinkerHashMap 实现 LRU\n`LinkerHsahMap`双向链表数据结构，在创建时可以选择`accessOrder`参数，默认`false`是按插入顺序进行排序，当我们设置`true`则按访问的顺序来进行排序，每当调用`get()`方法会执行`afterNodeAccess`方法将被访者置换尾部\n\n``` java\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n        LinkedHashMap.Entry<K,V> last;\n        if (accessOrder && (last = tail) != e) {\n            LinkedHashMap.Entry<K,V> p =\n                (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n            p.after = null;\n            if (b == null)\n                head = a;\n            else\n                b.after = a;\n            if (a != null)\n                a.before = b;\n            else\n                last = b;\n            if (last == null)\n                head = p;\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            tail = p;\n            ++modCount;\n        }\n  }\n```\n\n当插入新的数据会调用`removeEldestEntry`返回的boolean是否删除链表头部元素，重写该方法当缓存的长度大于限制则删除链表头部元素即删除了最久未被访问的元素，因为被访问过的元素会置换到链表的尾部\n\n``` java\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n       LinkedHashMap.Entry<K,V> first;\n        if (evict && (first = head) != null && removeEldestEntry(first)) {\n            K key = first.key;\n            removeNode(hash(key), key, null, false, true);\n        }\n}\n\nprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n        return false;\n}\n```\n\n我们经常用到的`Mybatis`内部也实现了LRUMap，核心就是重写`removeEldestEntry`方法删除链表头部元素\n\n### 代码实现\n``` java\npublic class LRUCache<K,V> extends LinkedHashMap<K,V> {\n    private final Integer cacheSize;\n\n    public LRUCache(Integer cacheSize) {\n        super(cacheSize,0.75f,true);\n        this.cacheSize = cacheSize;\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size()>cacheSize;\n    }\n\n    public static void main(String[] args) {\n        LRUCache c = new LRUCache(3);\n        c.put(\"k1\", 1);\n        c.put(\"k2\", 2);\n        c.put(\"k3\", 3);\n   \t    c.get(\"k2\");\n        c.put(\"k4\", 4);\n     \n        System.out.println(c);\n    }\n}\n```\n\n这里打印出来为 **{k3=3, k2=2, k4=4}**，当`get(\"k2\")`时会将`k2`元素移到链表的末尾，下一步`put(\"k4\")`时`removeEldestEntry`会返回`true`，缓存长度已超出限制范围删除首部元素所以打印出来就是 **{k3=3, k2=2, k4=4}**","slug":"Redis的淘汰机制LRU算法","published":1,"updated":"2020-11-18T03:21:21.823Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9910031jsudxji0aof0","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"LRU-算法\"><a href=\"#LRU-算法\" class=\"headerlink\" title=\"LRU 算法\"></a>LRU 算法</h3><p>LRU 全程 Least Recently Used（最近最久未使用），设计原则为：如果有一个数在一段时间未被访问，那么将来被访问的可能性就很小，当资源超过限制范围时应淘汰最久未被访问的数据</p>\n<h3 id=\"LinkerHashMap-实现-LRU\"><a href=\"#LinkerHashMap-实现-LRU\" class=\"headerlink\" title=\"LinkerHashMap 实现 LRU\"></a>LinkerHashMap 实现 LRU</h3><p><code>LinkerHsahMap</code>双向链表数据结构，在创建时可以选择<code>accessOrder</code>参数，默认<code>false</code>是按插入顺序进行排序，当我们设置<code>true</code>则按访问的顺序来进行排序，每当调用<code>get()</code>方法会执行<code>afterNodeAccess</code>方法将被访者置换尾部</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">afterNodeAccess</span><span class=\"hljs-params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"hljs-comment\">// move node to last</span>\n        LinkedHashMap.Entry&lt;K,V&gt; last;\n        <span class=\"hljs-keyword\">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;\n            LinkedHashMap.Entry&lt;K,V&gt; p =\n                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;\n            p.after = <span class=\"hljs-keyword\">null</span>;\n            <span class=\"hljs-keyword\">if</span> (b == <span class=\"hljs-keyword\">null</span>)\n                head = a;\n            <span class=\"hljs-keyword\">else</span>\n                b.after = a;\n            <span class=\"hljs-keyword\">if</span> (a != <span class=\"hljs-keyword\">null</span>)\n                a.before = b;\n            <span class=\"hljs-keyword\">else</span>\n                last = b;\n            <span class=\"hljs-keyword\">if</span> (last == <span class=\"hljs-keyword\">null</span>)\n                head = p;\n            <span class=\"hljs-keyword\">else</span> &#123;\n                p.before = last;\n                last.after = p;\n            &#125;\n            tail = p;\n            ++modCount;\n        &#125;\n  &#125;</code></pre>\n<p>当插入新的数据会调用<code>removeEldestEntry</code>返回的boolean是否删除链表头部元素，重写该方法当缓存的长度大于限制则删除链表头部元素即删除了最久未被访问的元素，因为被访问过的元素会置换到链表的尾部</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">afterNodeInsertion</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> evict)</span> </span>&#123; <span class=\"hljs-comment\">// possibly remove eldest</span>\n       LinkedHashMap.Entry&lt;K,V&gt; first;\n        <span class=\"hljs-keyword\">if</span> (evict &amp;&amp; (first = head) != <span class=\"hljs-keyword\">null</span> &amp;&amp; removeEldestEntry(first)) &#123;\n            K key = first.key;\n            removeNode(hash(key), key, <span class=\"hljs-keyword\">null</span>, <span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">true</span>);\n        &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">removeEldestEntry</span><span class=\"hljs-params\">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n&#125;</code></pre>\n<p>我们经常用到的<code>Mybatis</code>内部也实现了LRUMap，核心就是重写<code>removeEldestEntry</code>方法删除链表头部元素</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LRUCache</span>&lt;<span class=\"hljs-title\">K</span>,<span class=\"hljs-title\">V</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">LinkedHashMap</span>&lt;<span class=\"hljs-title\">K</span>,<span class=\"hljs-title\">V</span>&gt; </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Integer cacheSize;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">LRUCache</span><span class=\"hljs-params\">(Integer cacheSize)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>(cacheSize,<span class=\"hljs-number\">0.75f</span>,<span class=\"hljs-keyword\">true</span>);\n        <span class=\"hljs-keyword\">this</span>.cacheSize = cacheSize;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">removeEldestEntry</span><span class=\"hljs-params\">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> size()&gt;cacheSize;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        LRUCache c = <span class=\"hljs-keyword\">new</span> LRUCache(<span class=\"hljs-number\">3</span>);\n        c.put(<span class=\"hljs-string\">\"k1\"</span>, <span class=\"hljs-number\">1</span>);\n        c.put(<span class=\"hljs-string\">\"k2\"</span>, <span class=\"hljs-number\">2</span>);\n        c.put(<span class=\"hljs-string\">\"k3\"</span>, <span class=\"hljs-number\">3</span>);\n   \t    c.get(<span class=\"hljs-string\">\"k2\"</span>);\n        c.put(<span class=\"hljs-string\">\"k4\"</span>, <span class=\"hljs-number\">4</span>);\n     \n        System.out.println(c);\n    &#125;\n&#125;</code></pre>\n<p>这里打印出来为 <strong>{k3=3, k2=2, k4=4}</strong>，当<code>get(&quot;k2&quot;)</code>时会将<code>k2</code>元素移到链表的末尾，下一步<code>put(&quot;k4&quot;)</code>时<code>removeEldestEntry</code>会返回<code>true</code>，缓存长度已超出限制范围删除首部元素所以打印出来就是 <strong>{k3=3, k2=2, k4=4}</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"LRU-算法\"><a href=\"#LRU-算法\" class=\"headerlink\" title=\"LRU 算法\"></a>LRU 算法</h3><p>LRU 全程 Least Recently Used（最近最久未使用），设计原则为：如果有一个数在一段时间未被访问，那么将来被访问的可能性就很小，当资源超过限制范围时应淘汰最久未被访问的数据</p>\n<h3 id=\"LinkerHashMap-实现-LRU\"><a href=\"#LinkerHashMap-实现-LRU\" class=\"headerlink\" title=\"LinkerHashMap 实现 LRU\"></a>LinkerHashMap 实现 LRU</h3><p><code>LinkerHsahMap</code>双向链表数据结构，在创建时可以选择<code>accessOrder</code>参数，默认<code>false</code>是按插入顺序进行排序，当我们设置<code>true</code>则按访问的顺序来进行排序，每当调用<code>get()</code>方法会执行<code>afterNodeAccess</code>方法将被访者置换尾部</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">afterNodeAccess</span><span class=\"hljs-params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"hljs-comment\">// move node to last</span>\n        LinkedHashMap.Entry&lt;K,V&gt; last;\n        <span class=\"hljs-keyword\">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;\n            LinkedHashMap.Entry&lt;K,V&gt; p =\n                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;\n            p.after = <span class=\"hljs-keyword\">null</span>;\n            <span class=\"hljs-keyword\">if</span> (b == <span class=\"hljs-keyword\">null</span>)\n                head = a;\n            <span class=\"hljs-keyword\">else</span>\n                b.after = a;\n            <span class=\"hljs-keyword\">if</span> (a != <span class=\"hljs-keyword\">null</span>)\n                a.before = b;\n            <span class=\"hljs-keyword\">else</span>\n                last = b;\n            <span class=\"hljs-keyword\">if</span> (last == <span class=\"hljs-keyword\">null</span>)\n                head = p;\n            <span class=\"hljs-keyword\">else</span> &#123;\n                p.before = last;\n                last.after = p;\n            &#125;\n            tail = p;\n            ++modCount;\n        &#125;\n  &#125;</code></pre>\n<p>当插入新的数据会调用<code>removeEldestEntry</code>返回的boolean是否删除链表头部元素，重写该方法当缓存的长度大于限制则删除链表头部元素即删除了最久未被访问的元素，因为被访问过的元素会置换到链表的尾部</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">afterNodeInsertion</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> evict)</span> </span>&#123; <span class=\"hljs-comment\">// possibly remove eldest</span>\n       LinkedHashMap.Entry&lt;K,V&gt; first;\n        <span class=\"hljs-keyword\">if</span> (evict &amp;&amp; (first = head) != <span class=\"hljs-keyword\">null</span> &amp;&amp; removeEldestEntry(first)) &#123;\n            K key = first.key;\n            removeNode(hash(key), key, <span class=\"hljs-keyword\">null</span>, <span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">true</span>);\n        &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">removeEldestEntry</span><span class=\"hljs-params\">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n&#125;</code></pre>\n<p>我们经常用到的<code>Mybatis</code>内部也实现了LRUMap，核心就是重写<code>removeEldestEntry</code>方法删除链表头部元素</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LRUCache</span>&lt;<span class=\"hljs-title\">K</span>,<span class=\"hljs-title\">V</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">LinkedHashMap</span>&lt;<span class=\"hljs-title\">K</span>,<span class=\"hljs-title\">V</span>&gt; </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Integer cacheSize;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">LRUCache</span><span class=\"hljs-params\">(Integer cacheSize)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>(cacheSize,<span class=\"hljs-number\">0.75f</span>,<span class=\"hljs-keyword\">true</span>);\n        <span class=\"hljs-keyword\">this</span>.cacheSize = cacheSize;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">removeEldestEntry</span><span class=\"hljs-params\">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> size()&gt;cacheSize;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        LRUCache c = <span class=\"hljs-keyword\">new</span> LRUCache(<span class=\"hljs-number\">3</span>);\n        c.put(<span class=\"hljs-string\">\"k1\"</span>, <span class=\"hljs-number\">1</span>);\n        c.put(<span class=\"hljs-string\">\"k2\"</span>, <span class=\"hljs-number\">2</span>);\n        c.put(<span class=\"hljs-string\">\"k3\"</span>, <span class=\"hljs-number\">3</span>);\n   \t    c.get(<span class=\"hljs-string\">\"k2\"</span>);\n        c.put(<span class=\"hljs-string\">\"k4\"</span>, <span class=\"hljs-number\">4</span>);\n     \n        System.out.println(c);\n    &#125;\n&#125;</code></pre>\n<p>这里打印出来为 <strong>{k3=3, k2=2, k4=4}</strong>，当<code>get(&quot;k2&quot;)</code>时会将<code>k2</code>元素移到链表的末尾，下一步<code>put(&quot;k4&quot;)</code>时<code>removeEldestEntry</code>会返回<code>true</code>，缓存长度已超出限制范围删除首部元素所以打印出来就是 <strong>{k3=3, k2=2, k4=4}</strong></p>\n"},{"title":"Redis 缓存问题场景","date":"2019-02-22T02:27:08.000Z","_content":"\n![](/images/redis.jpg)\n\n>记录下学习Redis缓存实际项目中会出现的一些场景和解决方案，缓存穿透、缓存击穿、缓存雪崩\n\n## Redis 缓存穿透\n缓存穿透是指缓存和数据库都查询到不到，例如查询UserId=-1的用户，当大量类似访问请求发送到服务端，由于数据库一直无法查找到数据则缓存无法更新和插入，后续大量的请求全部落到了DB上。导致DB数据库压力增大发生崩溃、变慢。\n#### 解决方案\n- 在接口层面或者通过过滤器拦截器过滤掉一些恶意查询条件。\n- 如果有查询不到的大量请求，可以设置`Key-Null`和`TTL`的时间设置30-60秒(具体根据实际业务需求来设定)，避免大量的后续恶意请求落在DB上。\n![缓存穿透](/images/redis-caching-penetration.png)\n\n\n## Redis 缓存雪崩\n缓存雪崩是指缓存中大量的Key同一时间失效或缓存服务直接宕机导致大量的访问请求都落到了DB上，使得数据库压力过大导致连锁反应瘫痪宕机。\n![缓存雪崩](/images/redis-caching-avalanche.png)\n\n#### 失效解决：\n- 热门数据缓存设置`TTL`延长或者永久\n- 数据的缓存设置随机`TTL`防止同一时间失效\n\n#### 服务宕机：\n- Redis 高可用，使用主从+哨兵 `redis cluster`，避免全盘崩溃\n- 本地 `ehcache` 缓存 + `hystrix` 限流/降级，避免DB被打死\n- Redis 持久化，一旦重启立刻恢复数据\n![解决方案](/images/redis-caching-avalanche-solution.png)\n\n## 3.Redis 缓存击穿\n缓存击穿是指同一个热门Key突然失效，大量的并发访问导致直接落在DB上，导致DB数据库压力增大宕机，与雪崩不同的是击穿是单一Key雪崩是大量热门Key。\n- 数据的缓存`TTL`设置永久\n- 使用互斥锁等待第一次请求缓存构建完成后释放锁，让其余所有请求直接通过缓存拿取数据。单机环境`Lock`类型，集群使用`Setnx`(set if not exits)\n\n#### 查考资料 \nhttps://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-caching-avalanche-and-caching-penetration.md\n","source":"_posts/Redis缓存场景.md","raw":"---\ntitle: Redis 缓存问题场景\ndate: 2019-02-22 10:27:08\ncategories: [数据库]\ntags:\n    - Redis\n    - Java\n---\n\n![](/images/redis.jpg)\n\n>记录下学习Redis缓存实际项目中会出现的一些场景和解决方案，缓存穿透、缓存击穿、缓存雪崩\n\n## Redis 缓存穿透\n缓存穿透是指缓存和数据库都查询到不到，例如查询UserId=-1的用户，当大量类似访问请求发送到服务端，由于数据库一直无法查找到数据则缓存无法更新和插入，后续大量的请求全部落到了DB上。导致DB数据库压力增大发生崩溃、变慢。\n#### 解决方案\n- 在接口层面或者通过过滤器拦截器过滤掉一些恶意查询条件。\n- 如果有查询不到的大量请求，可以设置`Key-Null`和`TTL`的时间设置30-60秒(具体根据实际业务需求来设定)，避免大量的后续恶意请求落在DB上。\n![缓存穿透](/images/redis-caching-penetration.png)\n\n\n## Redis 缓存雪崩\n缓存雪崩是指缓存中大量的Key同一时间失效或缓存服务直接宕机导致大量的访问请求都落到了DB上，使得数据库压力过大导致连锁反应瘫痪宕机。\n![缓存雪崩](/images/redis-caching-avalanche.png)\n\n#### 失效解决：\n- 热门数据缓存设置`TTL`延长或者永久\n- 数据的缓存设置随机`TTL`防止同一时间失效\n\n#### 服务宕机：\n- Redis 高可用，使用主从+哨兵 `redis cluster`，避免全盘崩溃\n- 本地 `ehcache` 缓存 + `hystrix` 限流/降级，避免DB被打死\n- Redis 持久化，一旦重启立刻恢复数据\n![解决方案](/images/redis-caching-avalanche-solution.png)\n\n## 3.Redis 缓存击穿\n缓存击穿是指同一个热门Key突然失效，大量的并发访问导致直接落在DB上，导致DB数据库压力增大宕机，与雪崩不同的是击穿是单一Key雪崩是大量热门Key。\n- 数据的缓存`TTL`设置永久\n- 使用互斥锁等待第一次请求缓存构建完成后释放锁，让其余所有请求直接通过缓存拿取数据。单机环境`Lock`类型，集群使用`Setnx`(set if not exits)\n\n#### 查考资料 \nhttps://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-caching-avalanche-and-caching-penetration.md\n","slug":"Redis缓存场景","published":1,"updated":"2020-08-10T01:48:44.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9930033jsud0nfcztbm","content":"<p><img src=\"/images/redis.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录下学习Redis缓存实际项目中会出现的一些场景和解决方案，缓存穿透、缓存击穿、缓存雪崩</p>\n</blockquote>\n<h2 id=\"Redis-缓存穿透\"><a href=\"#Redis-缓存穿透\" class=\"headerlink\" title=\"Redis 缓存穿透\"></a>Redis 缓存穿透</h2><p>缓存穿透是指缓存和数据库都查询到不到，例如查询UserId=-1的用户，当大量类似访问请求发送到服务端，由于数据库一直无法查找到数据则缓存无法更新和插入，后续大量的请求全部落到了DB上。导致DB数据库压力增大发生崩溃、变慢。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ul>\n<li>在接口层面或者通过过滤器拦截器过滤掉一些恶意查询条件。</li>\n<li>如果有查询不到的大量请求，可以设置<code>Key-Null</code>和<code>TTL</code>的时间设置30-60秒(具体根据实际业务需求来设定)，避免大量的后续恶意请求落在DB上。<br><img src=\"/images/redis-caching-penetration.png\" srcset=\"/img/loading.gif\" alt=\"缓存穿透\"></li>\n</ul>\n<h2 id=\"Redis-缓存雪崩\"><a href=\"#Redis-缓存雪崩\" class=\"headerlink\" title=\"Redis 缓存雪崩\"></a>Redis 缓存雪崩</h2><p>缓存雪崩是指缓存中大量的Key同一时间失效或缓存服务直接宕机导致大量的访问请求都落到了DB上，使得数据库压力过大导致连锁反应瘫痪宕机。<br><img src=\"/images/redis-caching-avalanche.png\" srcset=\"/img/loading.gif\" alt=\"缓存雪崩\"></p>\n<h4 id=\"失效解决：\"><a href=\"#失效解决：\" class=\"headerlink\" title=\"失效解决：\"></a>失效解决：</h4><ul>\n<li>热门数据缓存设置<code>TTL</code>延长或者永久</li>\n<li>数据的缓存设置随机<code>TTL</code>防止同一时间失效</li>\n</ul>\n<h4 id=\"服务宕机：\"><a href=\"#服务宕机：\" class=\"headerlink\" title=\"服务宕机：\"></a>服务宕机：</h4><ul>\n<li>Redis 高可用，使用主从+哨兵 <code>redis cluster</code>，避免全盘崩溃</li>\n<li>本地 <code>ehcache</code> 缓存 + <code>hystrix</code> 限流/降级，避免DB被打死</li>\n<li>Redis 持久化，一旦重启立刻恢复数据<br><img src=\"/images/redis-caching-avalanche-solution.png\" srcset=\"/img/loading.gif\" alt=\"解决方案\"></li>\n</ul>\n<h2 id=\"3-Redis-缓存击穿\"><a href=\"#3-Redis-缓存击穿\" class=\"headerlink\" title=\"3.Redis 缓存击穿\"></a>3.Redis 缓存击穿</h2><p>缓存击穿是指同一个热门Key突然失效，大量的并发访问导致直接落在DB上，导致DB数据库压力增大宕机，与雪崩不同的是击穿是单一Key雪崩是大量热门Key。</p>\n<ul>\n<li>数据的缓存<code>TTL</code>设置永久</li>\n<li>使用互斥锁等待第一次请求缓存构建完成后释放锁，让其余所有请求直接通过缓存拿取数据。单机环境<code>Lock</code>类型，集群使用<code>Setnx</code>(set if not exits)</li>\n</ul>\n<h4 id=\"查考资料\"><a href=\"#查考资料\" class=\"headerlink\" title=\"查考资料\"></a>查考资料</h4><p><a href=\"https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-caching-avalanche-and-caching-penetration.md\" target=\"_blank\" rel=\"noopener\">https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-caching-avalanche-and-caching-penetration.md</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/redis.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录下学习Redis缓存实际项目中会出现的一些场景和解决方案，缓存穿透、缓存击穿、缓存雪崩</p>\n</blockquote>\n<h2 id=\"Redis-缓存穿透\"><a href=\"#Redis-缓存穿透\" class=\"headerlink\" title=\"Redis 缓存穿透\"></a>Redis 缓存穿透</h2><p>缓存穿透是指缓存和数据库都查询到不到，例如查询UserId=-1的用户，当大量类似访问请求发送到服务端，由于数据库一直无法查找到数据则缓存无法更新和插入，后续大量的请求全部落到了DB上。导致DB数据库压力增大发生崩溃、变慢。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ul>\n<li>在接口层面或者通过过滤器拦截器过滤掉一些恶意查询条件。</li>\n<li>如果有查询不到的大量请求，可以设置<code>Key-Null</code>和<code>TTL</code>的时间设置30-60秒(具体根据实际业务需求来设定)，避免大量的后续恶意请求落在DB上。<br><img src=\"/images/redis-caching-penetration.png\" srcset=\"/img/loading.gif\" alt=\"缓存穿透\"></li>\n</ul>\n<h2 id=\"Redis-缓存雪崩\"><a href=\"#Redis-缓存雪崩\" class=\"headerlink\" title=\"Redis 缓存雪崩\"></a>Redis 缓存雪崩</h2><p>缓存雪崩是指缓存中大量的Key同一时间失效或缓存服务直接宕机导致大量的访问请求都落到了DB上，使得数据库压力过大导致连锁反应瘫痪宕机。<br><img src=\"/images/redis-caching-avalanche.png\" srcset=\"/img/loading.gif\" alt=\"缓存雪崩\"></p>\n<h4 id=\"失效解决：\"><a href=\"#失效解决：\" class=\"headerlink\" title=\"失效解决：\"></a>失效解决：</h4><ul>\n<li>热门数据缓存设置<code>TTL</code>延长或者永久</li>\n<li>数据的缓存设置随机<code>TTL</code>防止同一时间失效</li>\n</ul>\n<h4 id=\"服务宕机：\"><a href=\"#服务宕机：\" class=\"headerlink\" title=\"服务宕机：\"></a>服务宕机：</h4><ul>\n<li>Redis 高可用，使用主从+哨兵 <code>redis cluster</code>，避免全盘崩溃</li>\n<li>本地 <code>ehcache</code> 缓存 + <code>hystrix</code> 限流/降级，避免DB被打死</li>\n<li>Redis 持久化，一旦重启立刻恢复数据<br><img src=\"/images/redis-caching-avalanche-solution.png\" srcset=\"/img/loading.gif\" alt=\"解决方案\"></li>\n</ul>\n<h2 id=\"3-Redis-缓存击穿\"><a href=\"#3-Redis-缓存击穿\" class=\"headerlink\" title=\"3.Redis 缓存击穿\"></a>3.Redis 缓存击穿</h2><p>缓存击穿是指同一个热门Key突然失效，大量的并发访问导致直接落在DB上，导致DB数据库压力增大宕机，与雪崩不同的是击穿是单一Key雪崩是大量热门Key。</p>\n<ul>\n<li>数据的缓存<code>TTL</code>设置永久</li>\n<li>使用互斥锁等待第一次请求缓存构建完成后释放锁，让其余所有请求直接通过缓存拿取数据。单机环境<code>Lock</code>类型，集群使用<code>Setnx</code>(set if not exits)</li>\n</ul>\n<h4 id=\"查考资料\"><a href=\"#查考资料\" class=\"headerlink\" title=\"查考资料\"></a>查考资料</h4><p><a href=\"https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-caching-avalanche-and-caching-penetration.md\" target=\"_blank\" rel=\"noopener\">https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-caching-avalanche-and-caching-penetration.md</a></p>\n"},{"title":"Sharding-jdbc 数据库中间件集成","toc":false,"date":"2019-10-17T08:42:30.000Z","_content":"\n> 在开发政策推送项目发现我们的控润表越来越大将近千万级查询效率极低，历史垃圾数据删除也比较麻烦后期还需要新增各种航司数据量会更大，才想起来可以将控润按月份进行分表操作，历史数据直接 truncate 查询效率变高，这里使用了sharding-jdbc进行自动分表\n\n\n### Sharding-JDBC\n根据官方的介绍 Sharding-JDBC 属于一款轻量级的 Java 框架，直接通过引入相应的 jar 包和设置配置项达到分库分表、读写分离等功能不需额外的服务支撑，对于现有项目代码零侵入，兼容大多数 Orm 框架 （Hibernate、Spring-JPA、Mybatis）和各类第三方 JDBC 数据库连接池（Druid、DBCP、HikariCP）。\n\n![](/images/sharding-jdbc.png)\n\n> 官方的文档: https://shardingsphere.apache.org/document/current/cn/overview/\n\n### SpringBoot 集成\nmaven 项目通过引入`sharding-jdbc-spring-boot-starter`进行配置\n``` xml\n<dependency>\n  <groupId>org.apache.shardingsphere</groupId>\n  <artifactId>sharding-jdbc-spring-boot-starter</artifactId>\n  <version>4.0.0-RC1</version>\n</dependency>\n```\n\nSharding-JDBC 的配置有3种根据项目情况自行选择，这里采用 `yml`方式集成开发，需要修改原有的`datasource`替换成`sharding.datasource`，配置如下\n\n``` yml\nspring:\n  profiles: dev\n  shardingsphere:\n    datasource: # 数据库相关设置\n      names: ds\n      ds:\n        type: com.alibaba.druid.pool.DruidDataSource\n        driver-class-name: oracle.jdbc.OracleDriver\n        url: jdbc:oracle:thin:@192.168.105.16:1523:TKPO\n        username: ticket_policy\n        password: ticket_policy\n    sharding: # 分片设置\n      tables:\n        filter_control_setting: # 逻辑表\n          actual-data-nodes: ds.filter_control_setting_$->{1..12} # 实际物理表集合\n          table-strategy:\n            standard:\n              sharding-column: departdate # 分片字段\n              range-algorithm-class-name: com.zkxy.data.config.FilterControlRangeShardingAlgorithm\n              precise-algorithm-class-name: com.zkxy.data.config.FilterControlPreciseShardingAlgorithm\n    props:\n      sql.show: true\n```\n\n##### 配置解释\n- `datasource` 数据库相关信息\n- `sql.show` 打印出sql执行情况\n- `filter_control_setting` 逻辑表名，在执行`sql`该逻辑表时会根据分词进行转化成真正的物理表名\n- `actual-data-nodes` 真实的物理表集合，`$->{1..12}`这里指1-12后缀，12张平行表也叫水平分表\n- `sharding-cloumns` 分片列，对应数据库字段多个用逗号隔开\n- `algorithm-class-name` 分片逻辑实现类路径\n- `table-strategy` 分表算法逻辑，官方提供了4种分片算法:\n\t1. 精确分片算法 `PreciseShardingAlgorithm` 使用单一键作为分片键的=与IN进行分片的场景\n\t\n\t2. 范围分片算法 `RangeShardingAlgorithm` 使用单一键作为分片键的BETWEEN AND进行分片的场景\n\t\n\t3. 复合分片算法 `ComplexKeysShardingAlgorithm` 使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度\n\t\n\t4. Hint分片算法 `HintShardingAlgorithm` 用于处理使用Hint行分片的场景\n\n### 自定义算法\n这里我们使用`Complex`复合分片算法，可以通过多个字段进行分片处理\n\n``` java\npackage com.zkxy.data.config;\n\nimport cn.hutool.core.date.DateField;\nimport cn.hutool.core.date.DateTime;\nimport cn.hutool.core.date.DateUtil;\nimport com.google.common.collect.Range;\nimport io.shardingsphere.api.algorithm.sharding.ListShardingValue;\nimport io.shardingsphere.api.algorithm.sharding.RangeShardingValue;\nimport io.shardingsphere.api.algorithm.sharding.ShardingValue;\nimport io.shardingsphere.api.algorithm.sharding.complex.ComplexKeysShardingAlgorithm;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class FilterControlComplexShardingAlgorithm implements ComplexKeysShardingAlgorithm {\n    @Override\n    public Collection<String> doSharding(Collection<String> collection, Collection<ShardingValue> colValues) {\n        for(ShardingValue shardingValue:colValues){\n            String columnName=shardingValue.getColumnName();\n            switch (columnName){\n                case \"yearMonth\":\n                    return shardingByMonth(shardingValue);\n                case \"departDate\":\n                    return shardingByDate(shardingValue);\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * 根据时间范围进行分片\n     * @return\n     */\n    private Collection<String> shardingByDate(ShardingValue shardingValue){\n        List<String> tableNames = new ArrayList<>();\n        /**\n         * 范围 between\n         */\n        if(shardingValue instanceof RangeShardingValue){\n            RangeShardingValue rangeShardingValue = (RangeShardingValue) shardingValue;\n            Range valueRange = rangeShardingValue.getValueRange();\n            Date begin = DateUtil.parse(valueRange.lowerEndpoint().toString());\n            Date end = DateUtil.parse(valueRange.upperEndpoint().toString());\n            for(DateTime dateTime:DateUtil.rangeToList(begin,end, DateField.MONTH)){\n                tableNames.add(createTrueTableName(shardingValue,dateTime.month()+1));\n            }\n        }\n        /**\n         * 等于 in\n         */\n        if(shardingValue instanceof ListShardingValue){\n            ListShardingValue listShardingValue = (ListShardingValue) shardingValue;\n            for(Object value: listShardingValue.getValues()){\n                tableNames.add(createTrueTableName(shardingValue,DateUtil.parse(value.toString()).month()+1));\n            }\n        }\n        return tableNames;\n    }\n\n\n\n\n    /**\n     * 根据月份进行分片\n     * @param shardingValue\n     * @return\n     */\n    private Collection<String> shardingByMonth(ShardingValue shardingValue){\n        ListShardingValue listShardingValue= (ListShardingValue) shardingValue;\n        return (Collection<String>) listShardingValue.getValues().stream()\n                .map(o -> createTrueTableName(shardingValue,DateUtil.parse(o+\"\",\"yyyy-MM\").month()+1))\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * 生成真实物理表名\n     * @param shardingValue\n     * @param suffix\n     * @return\n     */\n    private String createTrueTableName(ShardingValue shardingValue, Object suffix){\n        return shardingValue.getLogicTableName()+\"_\"+suffix;\n    }\n}\n\n```\n\n##### 代码解析\n- Collection<String> collection 执行`sql`中所有的逻辑表名\n- Collection<ShardingValue> colValues 分片列信息\n\n当执行`select`语句中`where`中包含配置的分片列且包含逻辑`beween and`、`in`、`=`3种逻辑时回调用我们自定义算法执行并返回需要查询的真实物理表名，如果没有分片按默认`actual-data-nodes`配置中的所有表执行相应`sql`\n\n``` sql\n# 分片列 yearMonth 对应会查询 filter_control_setting_10\nselect * from filter_control_setting where yearMonth = '2019-10-10';\n\n# 无分片列 则会查询 filter_control_setting_1 .... filter_control_setting_12 一共12张表信息归并返回结果\nselect * from filter_control_setting;\n```\n\n### 遇到的问题\n1. 最新版本 __4.0.0-RC1__ 使用 `ComplexKeysShardingAlgorithm`多字段复杂分片当遇到`between and`会报异常`BetweenRouteValue cannot be cast to ListRouteValue`，查看源码发现直接强转`ListRouteValue`导致报错，上`github`查看官方的`issues`也有同样的问题只有等待版本更新。\n2. 数据库驱动版本过低也会导致集成失败，最好根据当前数据库版本更新较新的驱动`jar`包","source":"_posts/Sharding-jdbc-数据库中间件集成.md","raw":"---\ntitle: Sharding-jdbc 数据库中间件集成\ntags:\n  - 中间件\ncategories:\n  - 技术\ntoc: false\ndate: 2019-10-17 16:42:30\n---\n\n> 在开发政策推送项目发现我们的控润表越来越大将近千万级查询效率极低，历史垃圾数据删除也比较麻烦后期还需要新增各种航司数据量会更大，才想起来可以将控润按月份进行分表操作，历史数据直接 truncate 查询效率变高，这里使用了sharding-jdbc进行自动分表\n\n\n### Sharding-JDBC\n根据官方的介绍 Sharding-JDBC 属于一款轻量级的 Java 框架，直接通过引入相应的 jar 包和设置配置项达到分库分表、读写分离等功能不需额外的服务支撑，对于现有项目代码零侵入，兼容大多数 Orm 框架 （Hibernate、Spring-JPA、Mybatis）和各类第三方 JDBC 数据库连接池（Druid、DBCP、HikariCP）。\n\n![](/images/sharding-jdbc.png)\n\n> 官方的文档: https://shardingsphere.apache.org/document/current/cn/overview/\n\n### SpringBoot 集成\nmaven 项目通过引入`sharding-jdbc-spring-boot-starter`进行配置\n``` xml\n<dependency>\n  <groupId>org.apache.shardingsphere</groupId>\n  <artifactId>sharding-jdbc-spring-boot-starter</artifactId>\n  <version>4.0.0-RC1</version>\n</dependency>\n```\n\nSharding-JDBC 的配置有3种根据项目情况自行选择，这里采用 `yml`方式集成开发，需要修改原有的`datasource`替换成`sharding.datasource`，配置如下\n\n``` yml\nspring:\n  profiles: dev\n  shardingsphere:\n    datasource: # 数据库相关设置\n      names: ds\n      ds:\n        type: com.alibaba.druid.pool.DruidDataSource\n        driver-class-name: oracle.jdbc.OracleDriver\n        url: jdbc:oracle:thin:@192.168.105.16:1523:TKPO\n        username: ticket_policy\n        password: ticket_policy\n    sharding: # 分片设置\n      tables:\n        filter_control_setting: # 逻辑表\n          actual-data-nodes: ds.filter_control_setting_$->{1..12} # 实际物理表集合\n          table-strategy:\n            standard:\n              sharding-column: departdate # 分片字段\n              range-algorithm-class-name: com.zkxy.data.config.FilterControlRangeShardingAlgorithm\n              precise-algorithm-class-name: com.zkxy.data.config.FilterControlPreciseShardingAlgorithm\n    props:\n      sql.show: true\n```\n\n##### 配置解释\n- `datasource` 数据库相关信息\n- `sql.show` 打印出sql执行情况\n- `filter_control_setting` 逻辑表名，在执行`sql`该逻辑表时会根据分词进行转化成真正的物理表名\n- `actual-data-nodes` 真实的物理表集合，`$->{1..12}`这里指1-12后缀，12张平行表也叫水平分表\n- `sharding-cloumns` 分片列，对应数据库字段多个用逗号隔开\n- `algorithm-class-name` 分片逻辑实现类路径\n- `table-strategy` 分表算法逻辑，官方提供了4种分片算法:\n\t1. 精确分片算法 `PreciseShardingAlgorithm` 使用单一键作为分片键的=与IN进行分片的场景\n\t\n\t2. 范围分片算法 `RangeShardingAlgorithm` 使用单一键作为分片键的BETWEEN AND进行分片的场景\n\t\n\t3. 复合分片算法 `ComplexKeysShardingAlgorithm` 使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度\n\t\n\t4. Hint分片算法 `HintShardingAlgorithm` 用于处理使用Hint行分片的场景\n\n### 自定义算法\n这里我们使用`Complex`复合分片算法，可以通过多个字段进行分片处理\n\n``` java\npackage com.zkxy.data.config;\n\nimport cn.hutool.core.date.DateField;\nimport cn.hutool.core.date.DateTime;\nimport cn.hutool.core.date.DateUtil;\nimport com.google.common.collect.Range;\nimport io.shardingsphere.api.algorithm.sharding.ListShardingValue;\nimport io.shardingsphere.api.algorithm.sharding.RangeShardingValue;\nimport io.shardingsphere.api.algorithm.sharding.ShardingValue;\nimport io.shardingsphere.api.algorithm.sharding.complex.ComplexKeysShardingAlgorithm;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class FilterControlComplexShardingAlgorithm implements ComplexKeysShardingAlgorithm {\n    @Override\n    public Collection<String> doSharding(Collection<String> collection, Collection<ShardingValue> colValues) {\n        for(ShardingValue shardingValue:colValues){\n            String columnName=shardingValue.getColumnName();\n            switch (columnName){\n                case \"yearMonth\":\n                    return shardingByMonth(shardingValue);\n                case \"departDate\":\n                    return shardingByDate(shardingValue);\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * 根据时间范围进行分片\n     * @return\n     */\n    private Collection<String> shardingByDate(ShardingValue shardingValue){\n        List<String> tableNames = new ArrayList<>();\n        /**\n         * 范围 between\n         */\n        if(shardingValue instanceof RangeShardingValue){\n            RangeShardingValue rangeShardingValue = (RangeShardingValue) shardingValue;\n            Range valueRange = rangeShardingValue.getValueRange();\n            Date begin = DateUtil.parse(valueRange.lowerEndpoint().toString());\n            Date end = DateUtil.parse(valueRange.upperEndpoint().toString());\n            for(DateTime dateTime:DateUtil.rangeToList(begin,end, DateField.MONTH)){\n                tableNames.add(createTrueTableName(shardingValue,dateTime.month()+1));\n            }\n        }\n        /**\n         * 等于 in\n         */\n        if(shardingValue instanceof ListShardingValue){\n            ListShardingValue listShardingValue = (ListShardingValue) shardingValue;\n            for(Object value: listShardingValue.getValues()){\n                tableNames.add(createTrueTableName(shardingValue,DateUtil.parse(value.toString()).month()+1));\n            }\n        }\n        return tableNames;\n    }\n\n\n\n\n    /**\n     * 根据月份进行分片\n     * @param shardingValue\n     * @return\n     */\n    private Collection<String> shardingByMonth(ShardingValue shardingValue){\n        ListShardingValue listShardingValue= (ListShardingValue) shardingValue;\n        return (Collection<String>) listShardingValue.getValues().stream()\n                .map(o -> createTrueTableName(shardingValue,DateUtil.parse(o+\"\",\"yyyy-MM\").month()+1))\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * 生成真实物理表名\n     * @param shardingValue\n     * @param suffix\n     * @return\n     */\n    private String createTrueTableName(ShardingValue shardingValue, Object suffix){\n        return shardingValue.getLogicTableName()+\"_\"+suffix;\n    }\n}\n\n```\n\n##### 代码解析\n- Collection<String> collection 执行`sql`中所有的逻辑表名\n- Collection<ShardingValue> colValues 分片列信息\n\n当执行`select`语句中`where`中包含配置的分片列且包含逻辑`beween and`、`in`、`=`3种逻辑时回调用我们自定义算法执行并返回需要查询的真实物理表名，如果没有分片按默认`actual-data-nodes`配置中的所有表执行相应`sql`\n\n``` sql\n# 分片列 yearMonth 对应会查询 filter_control_setting_10\nselect * from filter_control_setting where yearMonth = '2019-10-10';\n\n# 无分片列 则会查询 filter_control_setting_1 .... filter_control_setting_12 一共12张表信息归并返回结果\nselect * from filter_control_setting;\n```\n\n### 遇到的问题\n1. 最新版本 __4.0.0-RC1__ 使用 `ComplexKeysShardingAlgorithm`多字段复杂分片当遇到`between and`会报异常`BetweenRouteValue cannot be cast to ListRouteValue`，查看源码发现直接强转`ListRouteValue`导致报错，上`github`查看官方的`issues`也有同样的问题只有等待版本更新。\n2. 数据库驱动版本过低也会导致集成失败，最好根据当前数据库版本更新较新的驱动`jar`包","slug":"Sharding-jdbc-数据库中间件集成","published":1,"updated":"2020-08-10T01:48:44.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9960038jsudbyab06of","content":"<blockquote>\n<p>在开发政策推送项目发现我们的控润表越来越大将近千万级查询效率极低，历史垃圾数据删除也比较麻烦后期还需要新增各种航司数据量会更大，才想起来可以将控润按月份进行分表操作，历史数据直接 truncate 查询效率变高，这里使用了sharding-jdbc进行自动分表</p>\n</blockquote>\n<h3 id=\"Sharding-JDBC\"><a href=\"#Sharding-JDBC\" class=\"headerlink\" title=\"Sharding-JDBC\"></a>Sharding-JDBC</h3><p>根据官方的介绍 Sharding-JDBC 属于一款轻量级的 Java 框架，直接通过引入相应的 jar 包和设置配置项达到分库分表、读写分离等功能不需额外的服务支撑，对于现有项目代码零侵入，兼容大多数 Orm 框架 （Hibernate、Spring-JPA、Mybatis）和各类第三方 JDBC 数据库连接池（Druid、DBCP、HikariCP）。</p>\n<p><img src=\"/images/sharding-jdbc.png\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>官方的文档: <a href=\"https://shardingsphere.apache.org/document/current/cn/overview/\" target=\"_blank\" rel=\"noopener\">https://shardingsphere.apache.org/document/current/cn/overview/</a></p>\n</blockquote>\n<h3 id=\"SpringBoot-集成\"><a href=\"#SpringBoot-集成\" class=\"headerlink\" title=\"SpringBoot 集成\"></a>SpringBoot 集成</h3><p>maven 项目通过引入<code>sharding-jdbc-spring-boot-starter</code>进行配置<br><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.apache.shardingsphere<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0-RC1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre></p>\n<p>Sharding-JDBC 的配置有3种根据项目情况自行选择，这里采用 <code>yml</code>方式集成开发，需要修改原有的<code>datasource</code>替换成<code>sharding.datasource</code>，配置如下</p>\n<pre><code class=\"hljs yml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">profiles:</span> <span class=\"hljs-string\">dev</span>\n  <span class=\"hljs-attr\">shardingsphere:</span>\n    <span class=\"hljs-attr\">datasource:</span> <span class=\"hljs-comment\"># 数据库相关设置</span>\n      <span class=\"hljs-attr\">names:</span> <span class=\"hljs-string\">ds</span>\n      <span class=\"hljs-attr\">ds:</span>\n        <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">com.alibaba.druid.pool.DruidDataSource</span>\n        <span class=\"hljs-attr\">driver-class-name:</span> <span class=\"hljs-string\">oracle.jdbc.OracleDriver</span>\n        <span class=\"hljs-attr\">url:</span> <span class=\"hljs-string\">jdbc:oracle:thin:@192.168.105.16:1523:TKPO</span>\n        <span class=\"hljs-attr\">username:</span> <span class=\"hljs-string\">ticket_policy</span>\n        <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">ticket_policy</span>\n    <span class=\"hljs-attr\">sharding:</span> <span class=\"hljs-comment\"># 分片设置</span>\n      <span class=\"hljs-attr\">tables:</span>\n        <span class=\"hljs-attr\">filter_control_setting:</span> <span class=\"hljs-comment\"># 逻辑表</span>\n          <span class=\"hljs-attr\">actual-data-nodes:</span> <span class=\"hljs-string\">ds.filter_control_setting_$-&gt;&#123;1..12&#125;</span> <span class=\"hljs-comment\"># 实际物理表集合</span>\n          <span class=\"hljs-attr\">table-strategy:</span>\n            <span class=\"hljs-attr\">standard:</span>\n              <span class=\"hljs-attr\">sharding-column:</span> <span class=\"hljs-string\">departdate</span> <span class=\"hljs-comment\"># 分片字段</span>\n              <span class=\"hljs-attr\">range-algorithm-class-name:</span> <span class=\"hljs-string\">com.zkxy.data.config.FilterControlRangeShardingAlgorithm</span>\n              <span class=\"hljs-attr\">precise-algorithm-class-name:</span> <span class=\"hljs-string\">com.zkxy.data.config.FilterControlPreciseShardingAlgorithm</span>\n    <span class=\"hljs-attr\">props:</span>\n      <span class=\"hljs-attr\">sql.show:</span> <span class=\"hljs-literal\">true</span></code></pre>\n<h5 id=\"配置解释\"><a href=\"#配置解释\" class=\"headerlink\" title=\"配置解释\"></a>配置解释</h5><ul>\n<li><code>datasource</code> 数据库相关信息</li>\n<li><code>sql.show</code> 打印出sql执行情况</li>\n<li><code>filter_control_setting</code> 逻辑表名，在执行<code>sql</code>该逻辑表时会根据分词进行转化成真正的物理表名</li>\n<li><code>actual-data-nodes</code> 真实的物理表集合，<code>$-&gt;{1..12}</code>这里指1-12后缀，12张平行表也叫水平分表</li>\n<li><code>sharding-cloumns</code> 分片列，对应数据库字段多个用逗号隔开</li>\n<li><code>algorithm-class-name</code> 分片逻辑实现类路径</li>\n<li><p><code>table-strategy</code> 分表算法逻辑，官方提供了4种分片算法:</p>\n<ol>\n<li><p>精确分片算法 <code>PreciseShardingAlgorithm</code> 使用单一键作为分片键的=与IN进行分片的场景</p>\n</li>\n<li><p>范围分片算法 <code>RangeShardingAlgorithm</code> 使用单一键作为分片键的BETWEEN AND进行分片的场景</p>\n</li>\n<li><p>复合分片算法 <code>ComplexKeysShardingAlgorithm</code> 使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度</p>\n</li>\n<li><p>Hint分片算法 <code>HintShardingAlgorithm</code> 用于处理使用Hint行分片的场景</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"自定义算法\"><a href=\"#自定义算法\" class=\"headerlink\" title=\"自定义算法\"></a>自定义算法</h3><p>这里我们使用<code>Complex</code>复合分片算法，可以通过多个字段进行分片处理</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.zkxy.data.config;\n\n<span class=\"hljs-keyword\">import</span> cn.hutool.core.date.DateField;\n<span class=\"hljs-keyword\">import</span> cn.hutool.core.date.DateTime;\n<span class=\"hljs-keyword\">import</span> cn.hutool.core.date.DateUtil;\n<span class=\"hljs-keyword\">import</span> com.google.common.collect.Range;\n<span class=\"hljs-keyword\">import</span> io.shardingsphere.api.algorithm.sharding.ListShardingValue;\n<span class=\"hljs-keyword\">import</span> io.shardingsphere.api.algorithm.sharding.RangeShardingValue;\n<span class=\"hljs-keyword\">import</span> io.shardingsphere.api.algorithm.sharding.ShardingValue;\n<span class=\"hljs-keyword\">import</span> io.shardingsphere.api.algorithm.sharding.complex.ComplexKeysShardingAlgorithm;\n\n<span class=\"hljs-keyword\">import</span> java.util.*;\n<span class=\"hljs-keyword\">import</span> java.util.stream.Collectors;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FilterControlComplexShardingAlgorithm</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ComplexKeysShardingAlgorithm</span> </span>&#123;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Collection&lt;String&gt; <span class=\"hljs-title\">doSharding</span><span class=\"hljs-params\">(Collection&lt;String&gt; collection, Collection&lt;ShardingValue&gt; colValues)</span> </span>&#123;\n        <span class=\"hljs-keyword\">for</span>(ShardingValue shardingValue:colValues)&#123;\n            String columnName=shardingValue.getColumnName();\n            <span class=\"hljs-keyword\">switch</span> (columnName)&#123;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"yearMonth\"</span>:\n                    <span class=\"hljs-keyword\">return</span> shardingByMonth(shardingValue);\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"departDate\"</span>:\n                    <span class=\"hljs-keyword\">return</span> shardingByDate(shardingValue);\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> collection;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 根据时间范围进行分片\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Collection&lt;String&gt; <span class=\"hljs-title\">shardingByDate</span><span class=\"hljs-params\">(ShardingValue shardingValue)</span></span>&#123;\n        List&lt;String&gt; tableNames = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n        <span class=\"hljs-comment\">/**\n         * 范围 between\n         */</span>\n        <span class=\"hljs-keyword\">if</span>(shardingValue <span class=\"hljs-keyword\">instanceof</span> RangeShardingValue)&#123;\n            RangeShardingValue rangeShardingValue = (RangeShardingValue) shardingValue;\n            Range valueRange = rangeShardingValue.getValueRange();\n            Date begin = DateUtil.parse(valueRange.lowerEndpoint().toString());\n            Date end = DateUtil.parse(valueRange.upperEndpoint().toString());\n            <span class=\"hljs-keyword\">for</span>(DateTime dateTime:DateUtil.rangeToList(begin,end, DateField.MONTH))&#123;\n                tableNames.add(createTrueTableName(shardingValue,dateTime.month()+<span class=\"hljs-number\">1</span>));\n            &#125;\n        &#125;\n        <span class=\"hljs-comment\">/**\n         * 等于 in\n         */</span>\n        <span class=\"hljs-keyword\">if</span>(shardingValue <span class=\"hljs-keyword\">instanceof</span> ListShardingValue)&#123;\n            ListShardingValue listShardingValue = (ListShardingValue) shardingValue;\n            <span class=\"hljs-keyword\">for</span>(Object value: listShardingValue.getValues())&#123;\n                tableNames.add(createTrueTableName(shardingValue,DateUtil.parse(value.toString()).month()+<span class=\"hljs-number\">1</span>));\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> tableNames;\n    &#125;\n\n\n\n\n    <span class=\"hljs-comment\">/**\n     * 根据月份进行分片\n     * <span class=\"hljs-doctag\">@param</span> shardingValue\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Collection&lt;String&gt; <span class=\"hljs-title\">shardingByMonth</span><span class=\"hljs-params\">(ShardingValue shardingValue)</span></span>&#123;\n        ListShardingValue listShardingValue= (ListShardingValue) shardingValue;\n        <span class=\"hljs-keyword\">return</span> (Collection&lt;String&gt;) listShardingValue.getValues().stream()\n                .map(o -&gt; createTrueTableName(shardingValue,DateUtil.parse(o+<span class=\"hljs-string\">\"\"</span>,<span class=\"hljs-string\">\"yyyy-MM\"</span>).month()+<span class=\"hljs-number\">1</span>))\n                .collect(Collectors.toList());\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 生成真实物理表名\n     * <span class=\"hljs-doctag\">@param</span> shardingValue\n     * <span class=\"hljs-doctag\">@param</span> suffix\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title\">createTrueTableName</span><span class=\"hljs-params\">(ShardingValue shardingValue, Object suffix)</span></span>&#123;\n        <span class=\"hljs-keyword\">return</span> shardingValue.getLogicTableName()+<span class=\"hljs-string\">\"_\"</span>+suffix;\n    &#125;\n&#125;</code></pre>\n<h5 id=\"代码解析\"><a href=\"#代码解析\" class=\"headerlink\" title=\"代码解析\"></a>代码解析</h5><ul>\n<li>Collection<string> collection 执行<code>sql</code>中所有的逻辑表名</string></li>\n<li>Collection<shardingvalue> colValues 分片列信息</shardingvalue></li>\n</ul>\n<p>当执行<code>select</code>语句中<code>where</code>中包含配置的分片列且包含逻辑<code>beween and</code>、<code>in</code>、<code>=</code>3种逻辑时回调用我们自定义算法执行并返回需要查询的真实物理表名，如果没有分片按默认<code>actual-data-nodes</code>配置中的所有表执行相应<code>sql</code></p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-comment\"># 分片列 yearMonth 对应会查询 filter_control_setting_10</span>\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> filter_control_setting <span class=\"hljs-keyword\">where</span> yearMonth = <span class=\"hljs-string\">'2019-10-10'</span>;\n\n<span class=\"hljs-comment\"># 无分片列 则会查询 filter_control_setting_1 .... filter_control_setting_12 一共12张表信息归并返回结果</span>\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> filter_control_setting;</code></pre>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><ol>\n<li>最新版本 <strong>4.0.0-RC1</strong> 使用 <code>ComplexKeysShardingAlgorithm</code>多字段复杂分片当遇到<code>between and</code>会报异常<code>BetweenRouteValue cannot be cast to ListRouteValue</code>，查看源码发现直接强转<code>ListRouteValue</code>导致报错，上<code>github</code>查看官方的<code>issues</code>也有同样的问题只有等待版本更新。</li>\n<li>数据库驱动版本过低也会导致集成失败，最好根据当前数据库版本更新较新的驱动<code>jar</code>包</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在开发政策推送项目发现我们的控润表越来越大将近千万级查询效率极低，历史垃圾数据删除也比较麻烦后期还需要新增各种航司数据量会更大，才想起来可以将控润按月份进行分表操作，历史数据直接 truncate 查询效率变高，这里使用了sharding-jdbc进行自动分表</p>\n</blockquote>\n<h3 id=\"Sharding-JDBC\"><a href=\"#Sharding-JDBC\" class=\"headerlink\" title=\"Sharding-JDBC\"></a>Sharding-JDBC</h3><p>根据官方的介绍 Sharding-JDBC 属于一款轻量级的 Java 框架，直接通过引入相应的 jar 包和设置配置项达到分库分表、读写分离等功能不需额外的服务支撑，对于现有项目代码零侵入，兼容大多数 Orm 框架 （Hibernate、Spring-JPA、Mybatis）和各类第三方 JDBC 数据库连接池（Druid、DBCP、HikariCP）。</p>\n<p><img src=\"/images/sharding-jdbc.png\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>官方的文档: <a href=\"https://shardingsphere.apache.org/document/current/cn/overview/\" target=\"_blank\" rel=\"noopener\">https://shardingsphere.apache.org/document/current/cn/overview/</a></p>\n</blockquote>\n<h3 id=\"SpringBoot-集成\"><a href=\"#SpringBoot-集成\" class=\"headerlink\" title=\"SpringBoot 集成\"></a>SpringBoot 集成</h3><p>maven 项目通过引入<code>sharding-jdbc-spring-boot-starter</code>进行配置<br><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.apache.shardingsphere<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.0.0-RC1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre></p>\n<p>Sharding-JDBC 的配置有3种根据项目情况自行选择，这里采用 <code>yml</code>方式集成开发，需要修改原有的<code>datasource</code>替换成<code>sharding.datasource</code>，配置如下</p>\n<pre><code class=\"hljs yml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">profiles:</span> <span class=\"hljs-string\">dev</span>\n  <span class=\"hljs-attr\">shardingsphere:</span>\n    <span class=\"hljs-attr\">datasource:</span> <span class=\"hljs-comment\"># 数据库相关设置</span>\n      <span class=\"hljs-attr\">names:</span> <span class=\"hljs-string\">ds</span>\n      <span class=\"hljs-attr\">ds:</span>\n        <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">com.alibaba.druid.pool.DruidDataSource</span>\n        <span class=\"hljs-attr\">driver-class-name:</span> <span class=\"hljs-string\">oracle.jdbc.OracleDriver</span>\n        <span class=\"hljs-attr\">url:</span> <span class=\"hljs-string\">jdbc:oracle:thin:@192.168.105.16:1523:TKPO</span>\n        <span class=\"hljs-attr\">username:</span> <span class=\"hljs-string\">ticket_policy</span>\n        <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">ticket_policy</span>\n    <span class=\"hljs-attr\">sharding:</span> <span class=\"hljs-comment\"># 分片设置</span>\n      <span class=\"hljs-attr\">tables:</span>\n        <span class=\"hljs-attr\">filter_control_setting:</span> <span class=\"hljs-comment\"># 逻辑表</span>\n          <span class=\"hljs-attr\">actual-data-nodes:</span> <span class=\"hljs-string\">ds.filter_control_setting_$-&gt;&#123;1..12&#125;</span> <span class=\"hljs-comment\"># 实际物理表集合</span>\n          <span class=\"hljs-attr\">table-strategy:</span>\n            <span class=\"hljs-attr\">standard:</span>\n              <span class=\"hljs-attr\">sharding-column:</span> <span class=\"hljs-string\">departdate</span> <span class=\"hljs-comment\"># 分片字段</span>\n              <span class=\"hljs-attr\">range-algorithm-class-name:</span> <span class=\"hljs-string\">com.zkxy.data.config.FilterControlRangeShardingAlgorithm</span>\n              <span class=\"hljs-attr\">precise-algorithm-class-name:</span> <span class=\"hljs-string\">com.zkxy.data.config.FilterControlPreciseShardingAlgorithm</span>\n    <span class=\"hljs-attr\">props:</span>\n      <span class=\"hljs-attr\">sql.show:</span> <span class=\"hljs-literal\">true</span></code></pre>\n<h5 id=\"配置解释\"><a href=\"#配置解释\" class=\"headerlink\" title=\"配置解释\"></a>配置解释</h5><ul>\n<li><code>datasource</code> 数据库相关信息</li>\n<li><code>sql.show</code> 打印出sql执行情况</li>\n<li><code>filter_control_setting</code> 逻辑表名，在执行<code>sql</code>该逻辑表时会根据分词进行转化成真正的物理表名</li>\n<li><code>actual-data-nodes</code> 真实的物理表集合，<code>$-&gt;{1..12}</code>这里指1-12后缀，12张平行表也叫水平分表</li>\n<li><code>sharding-cloumns</code> 分片列，对应数据库字段多个用逗号隔开</li>\n<li><code>algorithm-class-name</code> 分片逻辑实现类路径</li>\n<li><p><code>table-strategy</code> 分表算法逻辑，官方提供了4种分片算法:</p>\n<ol>\n<li><p>精确分片算法 <code>PreciseShardingAlgorithm</code> 使用单一键作为分片键的=与IN进行分片的场景</p>\n</li>\n<li><p>范围分片算法 <code>RangeShardingAlgorithm</code> 使用单一键作为分片键的BETWEEN AND进行分片的场景</p>\n</li>\n<li><p>复合分片算法 <code>ComplexKeysShardingAlgorithm</code> 使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度</p>\n</li>\n<li><p>Hint分片算法 <code>HintShardingAlgorithm</code> 用于处理使用Hint行分片的场景</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"自定义算法\"><a href=\"#自定义算法\" class=\"headerlink\" title=\"自定义算法\"></a>自定义算法</h3><p>这里我们使用<code>Complex</code>复合分片算法，可以通过多个字段进行分片处理</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.zkxy.data.config;\n\n<span class=\"hljs-keyword\">import</span> cn.hutool.core.date.DateField;\n<span class=\"hljs-keyword\">import</span> cn.hutool.core.date.DateTime;\n<span class=\"hljs-keyword\">import</span> cn.hutool.core.date.DateUtil;\n<span class=\"hljs-keyword\">import</span> com.google.common.collect.Range;\n<span class=\"hljs-keyword\">import</span> io.shardingsphere.api.algorithm.sharding.ListShardingValue;\n<span class=\"hljs-keyword\">import</span> io.shardingsphere.api.algorithm.sharding.RangeShardingValue;\n<span class=\"hljs-keyword\">import</span> io.shardingsphere.api.algorithm.sharding.ShardingValue;\n<span class=\"hljs-keyword\">import</span> io.shardingsphere.api.algorithm.sharding.complex.ComplexKeysShardingAlgorithm;\n\n<span class=\"hljs-keyword\">import</span> java.util.*;\n<span class=\"hljs-keyword\">import</span> java.util.stream.Collectors;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FilterControlComplexShardingAlgorithm</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ComplexKeysShardingAlgorithm</span> </span>&#123;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Collection&lt;String&gt; <span class=\"hljs-title\">doSharding</span><span class=\"hljs-params\">(Collection&lt;String&gt; collection, Collection&lt;ShardingValue&gt; colValues)</span> </span>&#123;\n        <span class=\"hljs-keyword\">for</span>(ShardingValue shardingValue:colValues)&#123;\n            String columnName=shardingValue.getColumnName();\n            <span class=\"hljs-keyword\">switch</span> (columnName)&#123;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"yearMonth\"</span>:\n                    <span class=\"hljs-keyword\">return</span> shardingByMonth(shardingValue);\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"departDate\"</span>:\n                    <span class=\"hljs-keyword\">return</span> shardingByDate(shardingValue);\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> collection;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 根据时间范围进行分片\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Collection&lt;String&gt; <span class=\"hljs-title\">shardingByDate</span><span class=\"hljs-params\">(ShardingValue shardingValue)</span></span>&#123;\n        List&lt;String&gt; tableNames = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n        <span class=\"hljs-comment\">/**\n         * 范围 between\n         */</span>\n        <span class=\"hljs-keyword\">if</span>(shardingValue <span class=\"hljs-keyword\">instanceof</span> RangeShardingValue)&#123;\n            RangeShardingValue rangeShardingValue = (RangeShardingValue) shardingValue;\n            Range valueRange = rangeShardingValue.getValueRange();\n            Date begin = DateUtil.parse(valueRange.lowerEndpoint().toString());\n            Date end = DateUtil.parse(valueRange.upperEndpoint().toString());\n            <span class=\"hljs-keyword\">for</span>(DateTime dateTime:DateUtil.rangeToList(begin,end, DateField.MONTH))&#123;\n                tableNames.add(createTrueTableName(shardingValue,dateTime.month()+<span class=\"hljs-number\">1</span>));\n            &#125;\n        &#125;\n        <span class=\"hljs-comment\">/**\n         * 等于 in\n         */</span>\n        <span class=\"hljs-keyword\">if</span>(shardingValue <span class=\"hljs-keyword\">instanceof</span> ListShardingValue)&#123;\n            ListShardingValue listShardingValue = (ListShardingValue) shardingValue;\n            <span class=\"hljs-keyword\">for</span>(Object value: listShardingValue.getValues())&#123;\n                tableNames.add(createTrueTableName(shardingValue,DateUtil.parse(value.toString()).month()+<span class=\"hljs-number\">1</span>));\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> tableNames;\n    &#125;\n\n\n\n\n    <span class=\"hljs-comment\">/**\n     * 根据月份进行分片\n     * <span class=\"hljs-doctag\">@param</span> shardingValue\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Collection&lt;String&gt; <span class=\"hljs-title\">shardingByMonth</span><span class=\"hljs-params\">(ShardingValue shardingValue)</span></span>&#123;\n        ListShardingValue listShardingValue= (ListShardingValue) shardingValue;\n        <span class=\"hljs-keyword\">return</span> (Collection&lt;String&gt;) listShardingValue.getValues().stream()\n                .map(o -&gt; createTrueTableName(shardingValue,DateUtil.parse(o+<span class=\"hljs-string\">\"\"</span>,<span class=\"hljs-string\">\"yyyy-MM\"</span>).month()+<span class=\"hljs-number\">1</span>))\n                .collect(Collectors.toList());\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 生成真实物理表名\n     * <span class=\"hljs-doctag\">@param</span> shardingValue\n     * <span class=\"hljs-doctag\">@param</span> suffix\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title\">createTrueTableName</span><span class=\"hljs-params\">(ShardingValue shardingValue, Object suffix)</span></span>&#123;\n        <span class=\"hljs-keyword\">return</span> shardingValue.getLogicTableName()+<span class=\"hljs-string\">\"_\"</span>+suffix;\n    &#125;\n&#125;</code></pre>\n<h5 id=\"代码解析\"><a href=\"#代码解析\" class=\"headerlink\" title=\"代码解析\"></a>代码解析</h5><ul>\n<li>Collection<string> collection 执行<code>sql</code>中所有的逻辑表名</string></li>\n<li>Collection<shardingvalue> colValues 分片列信息</shardingvalue></li>\n</ul>\n<p>当执行<code>select</code>语句中<code>where</code>中包含配置的分片列且包含逻辑<code>beween and</code>、<code>in</code>、<code>=</code>3种逻辑时回调用我们自定义算法执行并返回需要查询的真实物理表名，如果没有分片按默认<code>actual-data-nodes</code>配置中的所有表执行相应<code>sql</code></p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-comment\"># 分片列 yearMonth 对应会查询 filter_control_setting_10</span>\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> filter_control_setting <span class=\"hljs-keyword\">where</span> yearMonth = <span class=\"hljs-string\">'2019-10-10'</span>;\n\n<span class=\"hljs-comment\"># 无分片列 则会查询 filter_control_setting_1 .... filter_control_setting_12 一共12张表信息归并返回结果</span>\n<span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> filter_control_setting;</code></pre>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><ol>\n<li>最新版本 <strong>4.0.0-RC1</strong> 使用 <code>ComplexKeysShardingAlgorithm</code>多字段复杂分片当遇到<code>between and</code>会报异常<code>BetweenRouteValue cannot be cast to ListRouteValue</code>，查看源码发现直接强转<code>ListRouteValue</code>导致报错，上<code>github</code>查看官方的<code>issues</code>也有同样的问题只有等待版本更新。</li>\n<li>数据库驱动版本过低也会导致集成失败，最好根据当前数据库版本更新较新的驱动<code>jar</code>包</li>\n</ol>\n"},{"title":"SkyWalking 搭建记录","date":"2019-04-02T03:08:24.000Z","_content":"\n![](/images/SkyWalking.jpg)\n\n> 记录搭建Skywalking 6.0过程和详细遇到的问题\n\n## SkyWalking \n`SkyWalking` 是观察性分析平台和应用性能管理系统，提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。它是一款国产开源软件源码在github上，\n官方网站为 http://skywalking.apache.org/zh/ Github https://github.com/apache/incubator-skywalking/\n\n![项目结构](/images/skywalkingFile.png)\n### Agent \n`Agent`探针项目里面包含`skywalking-agent.jar`，使用`JavaAgent`做字节码侵入，对代码无侵入，收集格式化数据然后通过`Http`或`gRpc`方式发送到`SkyWalking Collector`。\n通过`agent.config`配置探针\n- __agent.namespace__： 跨进程链路中的`header`，不同的`namespace`会导致跨进程的链路中断\n- __agent.service_name__：一个服务（项目）的唯一标识，这个字段决定了在sw的UI上的关于`service`的展示名称\n- __agent.sample_n_per_3_secs__：客户端采样率，默认是-1代表全采样\n- __agent.authentication__： 与`collector`进行通信的安全认证，需要同`collector`中配置相同\n- __agent.ignore_suffix__：忽略特定请求后缀的trace\n- __collector.backend_service__：`agent`需要同`collector`进行数据传输的IP和端口\n- __logging.level__：`agent`记录日志级别\n\n##### 集成方式\n常用的`Java`项目运行方式`Jar`方式或者`War`通过容器启动，例如`Tomcat`\n- __Jar__ 配置JVM运行添加探针 `-javaagent:[skywalking-agent.jar绝对路径] -Dskywalking.agent.application_code=[应用名]` 多应用使用同一个`Agent`通过系统变量设置应用名称\n- __Tomcat__ `tomcat`目录`bin`下的`catalina`脚本\n``` shell\nWindow\nCATALINA_OPTS = -javaagent:[skywalking-agent.jar绝对路径]\nLinux\nCATALINA_OPTS=\"$CATALINA_OPTS -javaagent:[skywalking-agent.jar绝对路径]\"; export CATALINA_OPTS\n```\n\n### Config\n`Config`文件夹中包含了`application.yml`配置文件，可以配置收集的数据存储方式，默认是`h2`一般使用`elasticsearch`作为存储方式。\n``` yml\nstorage:\n elasticsearch:\n   nameSpace: es5-cluster\n   clusterNodes: 192.168.105.13:9200\n   indexShardsNumber: 2\n   indexReplicasNumber: 0\n   # Batch process setting, refer to https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/java-docs-bulk-processor.html\n   bulkActions: 2000 # Execute the bulk every 2000 requests\n   bulkSize: 20 # flush the bulk every 20mb\n   flushInterval: 10 # flush the bulk every 10 seconds whatever the number of requests\n   concurrentRequests: 2 # the number of concurrent requests\n```\n\n启动`bin`文件夹中的`startup.bat`或者`start.sh`根据系统来执行，会启动2个项目`Skywalking-Collector`用于收集数据并把数据存储到Es中，`Skywalking-WebApp`用于展示收集的数据，2个项目的日志在`logs`中记录生成，通过http://localhot:8080查看运行情况\n\n![Skywalking-WebApp](/images/skywalking-ui.png)\n\n## 注意事项\n- `Skywalking` __6.0__ 相对 __5.0__简化了配置项，数据落地添加了`MySql`方式，需要注意`Elasticsearch`要求的版本也不一样，从_5.X__到__6.X__\n- `Skywalking UI`默认的登录密码为`admin`，可以在`webapp.yml`中自行配置\n- `Skywalking-WebApp`和`Skywalking-Collector`如果跟探针不在同一机器上，修改`Collector`的配置文件`application.yml`的`host`，以便于探针收集的数据能准确的发送到`Collector`，同时修改探针`agent.config`配置项`collector.servers`地址。\n``` yml\ncore:\n  default:\n    restHost: 192.168.104.162\n    restPort: 12800\n    restContextPath: /\n    gRPCHost: 192.168.104.162\n    gRPCPort: 11800\n    downsampling:\n    - Hour\n    - Day\n    - Month\n    # Set a timeout on metric data. After the timeout has expired, the metric data will automatically be deleted.\n    recordDataTTL: 90 # Unit is minute\n    minuteMetricsDataTTL: 90 # Unit is minute\n    hourMetricsDataTTL: 36 # Unit is hour\n    dayMetricsDataTTL: 45 # Unit is day\n    monthMetricsDataTTL: 18 # Unit is month\n```\n- `naming`中的地址对应了`webapp.yml`中`listOfServers: 127.0.0.1:12800`，`UI`使用`rest http`通信对应配置文件的`restHost`和`restPort`，`agent`在大多数场景下使用`gRpc`方式通信，在语言不支持的情况下会使用`http`通信。\n\n##### 参考资料 http://www.primeton.com/read.php?id=2751","source":"_posts/SkyWalking搭建记录.md","raw":"---\ntitle: SkyWalking 搭建记录\ndate: 2019-04-02 11:08:24\ncategories: [Java]\ntags:\n\t - 中间件 \n---\n\n![](/images/SkyWalking.jpg)\n\n> 记录搭建Skywalking 6.0过程和详细遇到的问题\n\n## SkyWalking \n`SkyWalking` 是观察性分析平台和应用性能管理系统，提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。它是一款国产开源软件源码在github上，\n官方网站为 http://skywalking.apache.org/zh/ Github https://github.com/apache/incubator-skywalking/\n\n![项目结构](/images/skywalkingFile.png)\n### Agent \n`Agent`探针项目里面包含`skywalking-agent.jar`，使用`JavaAgent`做字节码侵入，对代码无侵入，收集格式化数据然后通过`Http`或`gRpc`方式发送到`SkyWalking Collector`。\n通过`agent.config`配置探针\n- __agent.namespace__： 跨进程链路中的`header`，不同的`namespace`会导致跨进程的链路中断\n- __agent.service_name__：一个服务（项目）的唯一标识，这个字段决定了在sw的UI上的关于`service`的展示名称\n- __agent.sample_n_per_3_secs__：客户端采样率，默认是-1代表全采样\n- __agent.authentication__： 与`collector`进行通信的安全认证，需要同`collector`中配置相同\n- __agent.ignore_suffix__：忽略特定请求后缀的trace\n- __collector.backend_service__：`agent`需要同`collector`进行数据传输的IP和端口\n- __logging.level__：`agent`记录日志级别\n\n##### 集成方式\n常用的`Java`项目运行方式`Jar`方式或者`War`通过容器启动，例如`Tomcat`\n- __Jar__ 配置JVM运行添加探针 `-javaagent:[skywalking-agent.jar绝对路径] -Dskywalking.agent.application_code=[应用名]` 多应用使用同一个`Agent`通过系统变量设置应用名称\n- __Tomcat__ `tomcat`目录`bin`下的`catalina`脚本\n``` shell\nWindow\nCATALINA_OPTS = -javaagent:[skywalking-agent.jar绝对路径]\nLinux\nCATALINA_OPTS=\"$CATALINA_OPTS -javaagent:[skywalking-agent.jar绝对路径]\"; export CATALINA_OPTS\n```\n\n### Config\n`Config`文件夹中包含了`application.yml`配置文件，可以配置收集的数据存储方式，默认是`h2`一般使用`elasticsearch`作为存储方式。\n``` yml\nstorage:\n elasticsearch:\n   nameSpace: es5-cluster\n   clusterNodes: 192.168.105.13:9200\n   indexShardsNumber: 2\n   indexReplicasNumber: 0\n   # Batch process setting, refer to https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/java-docs-bulk-processor.html\n   bulkActions: 2000 # Execute the bulk every 2000 requests\n   bulkSize: 20 # flush the bulk every 20mb\n   flushInterval: 10 # flush the bulk every 10 seconds whatever the number of requests\n   concurrentRequests: 2 # the number of concurrent requests\n```\n\n启动`bin`文件夹中的`startup.bat`或者`start.sh`根据系统来执行，会启动2个项目`Skywalking-Collector`用于收集数据并把数据存储到Es中，`Skywalking-WebApp`用于展示收集的数据，2个项目的日志在`logs`中记录生成，通过http://localhot:8080查看运行情况\n\n![Skywalking-WebApp](/images/skywalking-ui.png)\n\n## 注意事项\n- `Skywalking` __6.0__ 相对 __5.0__简化了配置项，数据落地添加了`MySql`方式，需要注意`Elasticsearch`要求的版本也不一样，从_5.X__到__6.X__\n- `Skywalking UI`默认的登录密码为`admin`，可以在`webapp.yml`中自行配置\n- `Skywalking-WebApp`和`Skywalking-Collector`如果跟探针不在同一机器上，修改`Collector`的配置文件`application.yml`的`host`，以便于探针收集的数据能准确的发送到`Collector`，同时修改探针`agent.config`配置项`collector.servers`地址。\n``` yml\ncore:\n  default:\n    restHost: 192.168.104.162\n    restPort: 12800\n    restContextPath: /\n    gRPCHost: 192.168.104.162\n    gRPCPort: 11800\n    downsampling:\n    - Hour\n    - Day\n    - Month\n    # Set a timeout on metric data. After the timeout has expired, the metric data will automatically be deleted.\n    recordDataTTL: 90 # Unit is minute\n    minuteMetricsDataTTL: 90 # Unit is minute\n    hourMetricsDataTTL: 36 # Unit is hour\n    dayMetricsDataTTL: 45 # Unit is day\n    monthMetricsDataTTL: 18 # Unit is month\n```\n- `naming`中的地址对应了`webapp.yml`中`listOfServers: 127.0.0.1:12800`，`UI`使用`rest http`通信对应配置文件的`restHost`和`restPort`，`agent`在大多数场景下使用`gRpc`方式通信，在语言不支持的情况下会使用`http`通信。\n\n##### 参考资料 http://www.primeton.com/read.php?id=2751","slug":"SkyWalking搭建记录","published":1,"updated":"2020-08-13T09:11:29.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc998003bjsudcbobovu4","content":"<p><img src=\"/images/SkyWalking.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录搭建Skywalking 6.0过程和详细遇到的问题</p>\n</blockquote>\n<h2 id=\"SkyWalking\"><a href=\"#SkyWalking\" class=\"headerlink\" title=\"SkyWalking\"></a>SkyWalking</h2><p><code>SkyWalking</code> 是观察性分析平台和应用性能管理系统，提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。它是一款国产开源软件源码在github上，<br>官方网站为 <a href=\"http://skywalking.apache.org/zh/\" target=\"_blank\" rel=\"noopener\">http://skywalking.apache.org/zh/</a> Github <a href=\"https://github.com/apache/incubator-skywalking/\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-skywalking/</a></p>\n<p><img src=\"/images/skywalkingFile.png\" srcset=\"/img/loading.gif\" alt=\"项目结构\"></p>\n<h3 id=\"Agent\"><a href=\"#Agent\" class=\"headerlink\" title=\"Agent\"></a>Agent</h3><p><code>Agent</code>探针项目里面包含<code>skywalking-agent.jar</code>，使用<code>JavaAgent</code>做字节码侵入，对代码无侵入，收集格式化数据然后通过<code>Http</code>或<code>gRpc</code>方式发送到<code>SkyWalking Collector</code>。<br>通过<code>agent.config</code>配置探针</p>\n<ul>\n<li><strong>agent.namespace</strong>： 跨进程链路中的<code>header</code>，不同的<code>namespace</code>会导致跨进程的链路中断</li>\n<li><strong>agent.service_name</strong>：一个服务（项目）的唯一标识，这个字段决定了在sw的UI上的关于<code>service</code>的展示名称</li>\n<li><strong>agent.sample_n_per_3_secs</strong>：客户端采样率，默认是-1代表全采样</li>\n<li><strong>agent.authentication</strong>： 与<code>collector</code>进行通信的安全认证，需要同<code>collector</code>中配置相同</li>\n<li><strong>agent.ignore_suffix</strong>：忽略特定请求后缀的trace</li>\n<li><strong>collector.backend_service</strong>：<code>agent</code>需要同<code>collector</code>进行数据传输的IP和端口</li>\n<li><strong>logging.level</strong>：<code>agent</code>记录日志级别</li>\n</ul>\n<h5 id=\"集成方式\"><a href=\"#集成方式\" class=\"headerlink\" title=\"集成方式\"></a>集成方式</h5><p>常用的<code>Java</code>项目运行方式<code>Jar</code>方式或者<code>War</code>通过容器启动，例如<code>Tomcat</code></p>\n<ul>\n<li><strong>Jar</strong> 配置JVM运行添加探针 <code>-javaagent:[skywalking-agent.jar绝对路径] -Dskywalking.agent.application_code=[应用名]</code> 多应用使用同一个<code>Agent</code>通过系统变量设置应用名称</li>\n<li><strong>Tomcat</strong> <code>tomcat</code>目录<code>bin</code>下的<code>catalina</code>脚本<pre><code class=\"hljs shell\">Window\nCATALINA_OPTS = -javaagent:[skywalking-agent.jar绝对路径]\nLinux\nCATALINA_OPTS=\"$CATALINA_OPTS -javaagent:[skywalking-agent.jar绝对路径]\"; export CATALINA_OPTS</code></pre>\n</li>\n</ul>\n<h3 id=\"Config\"><a href=\"#Config\" class=\"headerlink\" title=\"Config\"></a>Config</h3><p><code>Config</code>文件夹中包含了<code>application.yml</code>配置文件，可以配置收集的数据存储方式，默认是<code>h2</code>一般使用<code>elasticsearch</code>作为存储方式。<br><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">storage:</span>\n <span class=\"hljs-attr\">elasticsearch:</span>\n   <span class=\"hljs-attr\">nameSpace:</span> <span class=\"hljs-string\">es5-cluster</span>\n   <span class=\"hljs-attr\">clusterNodes:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.105</span><span class=\"hljs-number\">.13</span><span class=\"hljs-string\">:9200</span>\n   <span class=\"hljs-attr\">indexShardsNumber:</span> <span class=\"hljs-number\">2</span>\n   <span class=\"hljs-attr\">indexReplicasNumber:</span> <span class=\"hljs-number\">0</span>\n   <span class=\"hljs-comment\"># Batch process setting, refer to https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/java-docs-bulk-processor.html</span>\n   <span class=\"hljs-attr\">bulkActions:</span> <span class=\"hljs-number\">2000</span> <span class=\"hljs-comment\"># Execute the bulk every 2000 requests</span>\n   <span class=\"hljs-attr\">bulkSize:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># flush the bulk every 20mb</span>\n   <span class=\"hljs-attr\">flushInterval:</span> <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\"># flush the bulk every 10 seconds whatever the number of requests</span>\n   <span class=\"hljs-attr\">concurrentRequests:</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\"># the number of concurrent requests</span></code></pre></p>\n<p>启动<code>bin</code>文件夹中的<code>startup.bat</code>或者<code>start.sh</code>根据系统来执行，会启动2个项目<code>Skywalking-Collector</code>用于收集数据并把数据存储到Es中，<code>Skywalking-WebApp</code>用于展示收集的数据，2个项目的日志在<code>logs</code>中记录生成，通过<a href=\"http://localhot:8080查看运行情况\" target=\"_blank\" rel=\"noopener\">http://localhot:8080查看运行情况</a></p>\n<p><img src=\"/images/skywalking-ui.png\" srcset=\"/img/loading.gif\" alt=\"Skywalking-WebApp\"></p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li><code>Skywalking</code> <strong>6.0</strong> 相对 <strong>5.0</strong>简化了配置项，数据落地添加了<code>MySql</code>方式，需要注意<code>Elasticsearch</code>要求的版本也不一样，从_5.X__到<strong>6.X</strong></li>\n<li><code>Skywalking UI</code>默认的登录密码为<code>admin</code>，可以在<code>webapp.yml</code>中自行配置</li>\n<li><p><code>Skywalking-WebApp</code>和<code>Skywalking-Collector</code>如果跟探针不在同一机器上，修改<code>Collector</code>的配置文件<code>application.yml</code>的<code>host</code>，以便于探针收集的数据能准确的发送到<code>Collector</code>，同时修改探针<code>agent.config</code>配置项<code>collector.servers</code>地址。</p>\n<pre><code class=\"hljs yml\"><span class=\"hljs-attr\">core:</span>\n  <span class=\"hljs-attr\">default:</span>\n    <span class=\"hljs-attr\">restHost:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.104</span><span class=\"hljs-number\">.162</span>\n    <span class=\"hljs-attr\">restPort:</span> <span class=\"hljs-number\">12800</span>\n    <span class=\"hljs-attr\">restContextPath:</span> <span class=\"hljs-string\">/</span>\n    <span class=\"hljs-attr\">gRPCHost:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.104</span><span class=\"hljs-number\">.162</span>\n    <span class=\"hljs-attr\">gRPCPort:</span> <span class=\"hljs-number\">11800</span>\n    <span class=\"hljs-attr\">downsampling:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Hour</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Day</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Month</span>\n    <span class=\"hljs-comment\"># Set a timeout on metric data. After the timeout has expired, the metric data will automatically be deleted.</span>\n    <span class=\"hljs-attr\">recordDataTTL:</span> <span class=\"hljs-number\">90</span> <span class=\"hljs-comment\"># Unit is minute</span>\n    <span class=\"hljs-attr\">minuteMetricsDataTTL:</span> <span class=\"hljs-number\">90</span> <span class=\"hljs-comment\"># Unit is minute</span>\n    <span class=\"hljs-attr\">hourMetricsDataTTL:</span> <span class=\"hljs-number\">36</span> <span class=\"hljs-comment\"># Unit is hour</span>\n    <span class=\"hljs-attr\">dayMetricsDataTTL:</span> <span class=\"hljs-number\">45</span> <span class=\"hljs-comment\"># Unit is day</span>\n    <span class=\"hljs-attr\">monthMetricsDataTTL:</span> <span class=\"hljs-number\">18</span> <span class=\"hljs-comment\"># Unit is month</span></code></pre>\n</li>\n<li><p><code>naming</code>中的地址对应了<code>webapp.yml</code>中<code>listOfServers: 127.0.0.1:12800</code>，<code>UI</code>使用<code>rest http</code>通信对应配置文件的<code>restHost</code>和<code>restPort</code>，<code>agent</code>在大多数场景下使用<code>gRpc</code>方式通信，在语言不支持的情况下会使用<code>http</code>通信。</p>\n</li>\n</ul>\n<h5 id=\"参考资料-http-www-primeton-com-read-php-id-2751\"><a href=\"#参考资料-http-www-primeton-com-read-php-id-2751\" class=\"headerlink\" title=\"参考资料 http://www.primeton.com/read.php?id=2751\"></a>参考资料 <a href=\"http://www.primeton.com/read.php?id=2751\" target=\"_blank\" rel=\"noopener\">http://www.primeton.com/read.php?id=2751</a></h5>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/SkyWalking.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录搭建Skywalking 6.0过程和详细遇到的问题</p>\n</blockquote>\n<h2 id=\"SkyWalking\"><a href=\"#SkyWalking\" class=\"headerlink\" title=\"SkyWalking\"></a>SkyWalking</h2><p><code>SkyWalking</code> 是观察性分析平台和应用性能管理系统，提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。它是一款国产开源软件源码在github上，<br>官方网站为 <a href=\"http://skywalking.apache.org/zh/\" target=\"_blank\" rel=\"noopener\">http://skywalking.apache.org/zh/</a> Github <a href=\"https://github.com/apache/incubator-skywalking/\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-skywalking/</a></p>\n<p><img src=\"/images/skywalkingFile.png\" srcset=\"/img/loading.gif\" alt=\"项目结构\"></p>\n<h3 id=\"Agent\"><a href=\"#Agent\" class=\"headerlink\" title=\"Agent\"></a>Agent</h3><p><code>Agent</code>探针项目里面包含<code>skywalking-agent.jar</code>，使用<code>JavaAgent</code>做字节码侵入，对代码无侵入，收集格式化数据然后通过<code>Http</code>或<code>gRpc</code>方式发送到<code>SkyWalking Collector</code>。<br>通过<code>agent.config</code>配置探针</p>\n<ul>\n<li><strong>agent.namespace</strong>： 跨进程链路中的<code>header</code>，不同的<code>namespace</code>会导致跨进程的链路中断</li>\n<li><strong>agent.service_name</strong>：一个服务（项目）的唯一标识，这个字段决定了在sw的UI上的关于<code>service</code>的展示名称</li>\n<li><strong>agent.sample_n_per_3_secs</strong>：客户端采样率，默认是-1代表全采样</li>\n<li><strong>agent.authentication</strong>： 与<code>collector</code>进行通信的安全认证，需要同<code>collector</code>中配置相同</li>\n<li><strong>agent.ignore_suffix</strong>：忽略特定请求后缀的trace</li>\n<li><strong>collector.backend_service</strong>：<code>agent</code>需要同<code>collector</code>进行数据传输的IP和端口</li>\n<li><strong>logging.level</strong>：<code>agent</code>记录日志级别</li>\n</ul>\n<h5 id=\"集成方式\"><a href=\"#集成方式\" class=\"headerlink\" title=\"集成方式\"></a>集成方式</h5><p>常用的<code>Java</code>项目运行方式<code>Jar</code>方式或者<code>War</code>通过容器启动，例如<code>Tomcat</code></p>\n<ul>\n<li><strong>Jar</strong> 配置JVM运行添加探针 <code>-javaagent:[skywalking-agent.jar绝对路径] -Dskywalking.agent.application_code=[应用名]</code> 多应用使用同一个<code>Agent</code>通过系统变量设置应用名称</li>\n<li><strong>Tomcat</strong> <code>tomcat</code>目录<code>bin</code>下的<code>catalina</code>脚本<pre><code class=\"hljs shell\">Window\nCATALINA_OPTS = -javaagent:[skywalking-agent.jar绝对路径]\nLinux\nCATALINA_OPTS=\"$CATALINA_OPTS -javaagent:[skywalking-agent.jar绝对路径]\"; export CATALINA_OPTS</code></pre>\n</li>\n</ul>\n<h3 id=\"Config\"><a href=\"#Config\" class=\"headerlink\" title=\"Config\"></a>Config</h3><p><code>Config</code>文件夹中包含了<code>application.yml</code>配置文件，可以配置收集的数据存储方式，默认是<code>h2</code>一般使用<code>elasticsearch</code>作为存储方式。<br><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">storage:</span>\n <span class=\"hljs-attr\">elasticsearch:</span>\n   <span class=\"hljs-attr\">nameSpace:</span> <span class=\"hljs-string\">es5-cluster</span>\n   <span class=\"hljs-attr\">clusterNodes:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.105</span><span class=\"hljs-number\">.13</span><span class=\"hljs-string\">:9200</span>\n   <span class=\"hljs-attr\">indexShardsNumber:</span> <span class=\"hljs-number\">2</span>\n   <span class=\"hljs-attr\">indexReplicasNumber:</span> <span class=\"hljs-number\">0</span>\n   <span class=\"hljs-comment\"># Batch process setting, refer to https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/java-docs-bulk-processor.html</span>\n   <span class=\"hljs-attr\">bulkActions:</span> <span class=\"hljs-number\">2000</span> <span class=\"hljs-comment\"># Execute the bulk every 2000 requests</span>\n   <span class=\"hljs-attr\">bulkSize:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># flush the bulk every 20mb</span>\n   <span class=\"hljs-attr\">flushInterval:</span> <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\"># flush the bulk every 10 seconds whatever the number of requests</span>\n   <span class=\"hljs-attr\">concurrentRequests:</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\"># the number of concurrent requests</span></code></pre></p>\n<p>启动<code>bin</code>文件夹中的<code>startup.bat</code>或者<code>start.sh</code>根据系统来执行，会启动2个项目<code>Skywalking-Collector</code>用于收集数据并把数据存储到Es中，<code>Skywalking-WebApp</code>用于展示收集的数据，2个项目的日志在<code>logs</code>中记录生成，通过<a href=\"http://localhot:8080查看运行情况\" target=\"_blank\" rel=\"noopener\">http://localhot:8080查看运行情况</a></p>\n<p><img src=\"/images/skywalking-ui.png\" srcset=\"/img/loading.gif\" alt=\"Skywalking-WebApp\"></p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li><code>Skywalking</code> <strong>6.0</strong> 相对 <strong>5.0</strong>简化了配置项，数据落地添加了<code>MySql</code>方式，需要注意<code>Elasticsearch</code>要求的版本也不一样，从_5.X__到<strong>6.X</strong></li>\n<li><code>Skywalking UI</code>默认的登录密码为<code>admin</code>，可以在<code>webapp.yml</code>中自行配置</li>\n<li><p><code>Skywalking-WebApp</code>和<code>Skywalking-Collector</code>如果跟探针不在同一机器上，修改<code>Collector</code>的配置文件<code>application.yml</code>的<code>host</code>，以便于探针收集的数据能准确的发送到<code>Collector</code>，同时修改探针<code>agent.config</code>配置项<code>collector.servers</code>地址。</p>\n<pre><code class=\"hljs yml\"><span class=\"hljs-attr\">core:</span>\n  <span class=\"hljs-attr\">default:</span>\n    <span class=\"hljs-attr\">restHost:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.104</span><span class=\"hljs-number\">.162</span>\n    <span class=\"hljs-attr\">restPort:</span> <span class=\"hljs-number\">12800</span>\n    <span class=\"hljs-attr\">restContextPath:</span> <span class=\"hljs-string\">/</span>\n    <span class=\"hljs-attr\">gRPCHost:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.104</span><span class=\"hljs-number\">.162</span>\n    <span class=\"hljs-attr\">gRPCPort:</span> <span class=\"hljs-number\">11800</span>\n    <span class=\"hljs-attr\">downsampling:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Hour</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Day</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Month</span>\n    <span class=\"hljs-comment\"># Set a timeout on metric data. After the timeout has expired, the metric data will automatically be deleted.</span>\n    <span class=\"hljs-attr\">recordDataTTL:</span> <span class=\"hljs-number\">90</span> <span class=\"hljs-comment\"># Unit is minute</span>\n    <span class=\"hljs-attr\">minuteMetricsDataTTL:</span> <span class=\"hljs-number\">90</span> <span class=\"hljs-comment\"># Unit is minute</span>\n    <span class=\"hljs-attr\">hourMetricsDataTTL:</span> <span class=\"hljs-number\">36</span> <span class=\"hljs-comment\"># Unit is hour</span>\n    <span class=\"hljs-attr\">dayMetricsDataTTL:</span> <span class=\"hljs-number\">45</span> <span class=\"hljs-comment\"># Unit is day</span>\n    <span class=\"hljs-attr\">monthMetricsDataTTL:</span> <span class=\"hljs-number\">18</span> <span class=\"hljs-comment\"># Unit is month</span></code></pre>\n</li>\n<li><p><code>naming</code>中的地址对应了<code>webapp.yml</code>中<code>listOfServers: 127.0.0.1:12800</code>，<code>UI</code>使用<code>rest http</code>通信对应配置文件的<code>restHost</code>和<code>restPort</code>，<code>agent</code>在大多数场景下使用<code>gRpc</code>方式通信，在语言不支持的情况下会使用<code>http</code>通信。</p>\n</li>\n</ul>\n<h5 id=\"参考资料-http-www-primeton-com-read-php-id-2751\"><a href=\"#参考资料-http-www-primeton-com-read-php-id-2751\" class=\"headerlink\" title=\"参考资料 http://www.primeton.com/read.php?id=2751\"></a>参考资料 <a href=\"http://www.primeton.com/read.php?id=2751\" target=\"_blank\" rel=\"noopener\">http://www.primeton.com/read.php?id=2751</a></h5>"},{"title":"SpringBoot 启动源码解析（四）之容器","toc":false,"date":"2020-05-20T02:14:36.000Z","_content":"\n![](/images/spring.jpg)\n> 当配置环境初始化完毕后下一步容器创建、准备、刷新、刷新后处理\n\n### SpringApplicationContext 容器创建\n根据应用类型去实例化相应的容器对象，SpringBoot 使用`AnnotationConfigServletWebServerApplicationContext`，实例化会初始化`AnnotatedBeanDefinitionReader`和`ClassPathBeanDefinitionScanner` \n- AnnotatedBeanDefinitionReader 用于管理`BeanDefinition`，包含 `BeanDefinitionRegistry`注册管理、`BeanNameGenerator` beanName生成规则、`scopeMetadataResolver` Scope注解解析器\n- ClassPathBeanDefinitionScanner 用与类扫描包含了匹配规则`**/*.class/`和过滤条件`@Component`（所以我们项目中常常使用的@Service、@Controller会被注册）、`scopeMetadataResolver` Scope注解解析器、`resourcePatternResolver`资源加载器等\n\n``` java\n// 根据类型对应Class利用反射创建实例 \nprotected ConfigurableApplicationContext createApplicationContext() {\n    Class<?> contextClass = this.applicationContextClass;\n    if (contextClass == null) {\n        try {\n            switch(this.webApplicationType) {\n            case SERVLET:\n                contextClass = Class.forName(\"org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext\");\n                break;\n            case REACTIVE:\n                contextClass = Class.forName(\"org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext\");\n                break;\n            default:\n                contextClass = Class.forName(\"org.springframework.context.annotation.AnnotationConfigApplicationContext\");\n            }\n        } catch (ClassNotFoundException var3) {\n            throw new IllegalStateException(\"Unable create a default ApplicationContext, please specify an ApplicationContextClass\", var3);\n        }\n    }\n\n    return (ConfigurableApplicationContext)BeanUtils.instantiateClass(contextClass);\n}\n\n// AnnotationConfigSelvetWebServerApplicationContext 构造方法 \npublic AnnotationConfigServletWebServerApplicationContext() {\n    this.annotatedClasses = new LinkedHashSet();\n    this.reader = new AnnotatedBeanDefinitionReader(this);\n    this.scanner = new ClassPathBeanDefinitionScanner(this);\n}\n\n```\n\n![ConfigurableApplicationContext 可配置上下文结构](/images/2020/05/19/beb83e10-99b4-11ea-bc19-85fa9aca2a18.png)\n\n### SpringApplicationContext 准备\n1. 上下文加载装配环境包含`AnnotatedBeanDefinitionReader`和`ClassPathBeanDefinitionScanner`\n2. 配置上下文的 bean 生成器及 ResourceLoader 资源加载器，广播上下文准备事件并开启日志\n3. 获取`DefaultListableBeanFactory`并单例注册`springApplicationArguments`、`springBootBanner`\n4. 加载所有资源创建 `BeanDefinitionReader`读取资源根据资源类型分类解析\n5. 广播上下文加载完毕事件\n\n- XmlBeanDefinitionReader xml 配置文件读取加载 bean\n- AnnotatedBeanDefinitionReader 注解方法读取\n- ClassPathBeanDefinitionScanner 类路径扫描器\n- GroovyBeanDefinitionReader groovy 方法加载 bean\n\n``` java\nprivate void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {\n    // 装载可配置环境\n    context.setEnvironment(environment);\n    // 配置上下文的 bean 生成器及资源加载器\n    this.postProcessApplicationContext(context);\n    // 循环遍历所有初始化器\n    this.applyInitializers(context);\n    // 广播上下文准备事件\n    listeners.contextPrepared(context);\n    if (this.logStartupInfo) {\n        this.logStartupInfo(context.getParent() == null);\n        this.logStartupProfileInfo(context);\n    }\n    // 可配置Bean 工厂 单例注册特殊bean\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n    if (printedBanner != null) {\n        beanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n    }\n\n    if (beanFactory instanceof DefaultListableBeanFactory) {\n        ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n    }\n\n    if (this.lazyInitialization) {\n        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n    }\n    // 加载所有资源\n    Set<Object> sources = this.getAllSources();\n    Assert.notEmpty(sources, \"Sources must not be empty\");\n    this.load(context, sources.toArray(new Object[0]));\n    // 广播上下文加载事件\n    listeners.contextLoaded(context);\n}\n```\n\n### SpringApplicationContext 刷新\n``` java\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized(this.startupShutdownMonitor) {\n        # 准备刷新 更新状态、校验必要属性、设置监听器列表\n        this.prepareRefresh();\n        // 设置SerializationId \n        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();\n        // 后置处理器设置注册各类环境配置Bean\n        this.prepareBeanFactory(beanFactory);\n        try {\n            // 后置处理器空方法用于第三方拓展\n            this.postProcessBeanFactory(beanFactory);\n            this.invokeBeanFactoryPostProcessors(beanFactory);\n            this.registerBeanPostProcessors(beanFactory);\n            this.initMessageSource();\n            this.initApplicationEventMulticaster();\n            this.onRefresh();\n            this.registerListeners();\n            this.finishBeanFactoryInitialization(beanFactory);\n            this.finishRefresh();\n        } catch (BeansException var9) {\n            if (this.logger.isWarnEnabled()) {\n                this.logger.warn(\"Exception encountered during context initialization - cancelling refresh attempt: \" + var9);\n            }\n\n            this.destroyBeans();\n            this.cancelRefresh(var9);\n            throw var9;\n        } finally {\n            this.resetCommonCaches();\n        }\n\n    }\n}\n```\n\n#### prepareRefresh 准备刷新上下文\n1. 设置上下文状态记录跟踪日志\n2. 初始化配置资源并校验环境必要属性\n3. 新增监听器列表 `earlyApplicationListeners`\n``` java \nprotected void prepareRefresh() {\n    this.startupDate = System.currentTimeMillis();\n    this.closed.set(false);\n    this.active.set(true);\n    if (this.logger.isDebugEnabled()) {\n    if (this.logger.isTraceEnabled()) {\n        this.logger.trace(\"Refreshing \" + this);\n    } else {\n        this.logger.debug(\"Refreshing \" + this.getDisplayName());\n    }\n    }\n\n    this.initPropertySources();\n    this.getEnvironment().validateRequiredProperties();\n    if (this.earlyApplicationListeners == null) {\n    this.earlyApplicationListeners = new LinkedHashSet(this.applicationListeners);\n    } else {\n    this.applicationListeners.clear();\n    this.applicationListeners.addAll(this.earlyApplicationListeners);\n    }\n\n    this.earlyApplicationEvents = new LinkedHashSet();\n}\n```\n\n#### prepareBeanFactory 准备 BeanFactory\n1. 加载 `ClassLoader`、新增 `StandardBeanExpressionResolver` 标准的`Bean`表达式解析器、`ResourceEditorRegistrar` 属性编辑注册器\n2. 添加 `ApplicationContextAwareProcessor` 后置处理器用于处理 Bean 初始化前后操作，忽略依赖接口列表新增`EnvironmentAware`、`ApplicationEventPushlisherAware`、`ResouceLoaderAware`、`EmbedderValueResolverAware`、`MessageSourceAware`、`ApplicationContextAware`接口，由于`ApplicationContextAwareProcesser`已实现以上功能\n3. 新增`ApplicationListenerDetector` 监听器检测器用于内置 Bean 发布事件\n4. 注册单例 Bean `environment`、`systemProperties`、`systemEnvironment`\n``` java\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    // 设置 ClassLoader 用于加载 Bean \n    beanFactory.setBeanClassLoader(this.getClassLoader());\n    // 设置 StandardBeanExpressionResolver（标准 Bean EL 表达式解析器） 用于解析#{}\n    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n    // 新增 属性编辑注册器 \n    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, this.getEnvironment()));\n    // 新增 Bean 后置处理器\n    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n    // 忽略以下接口类依赖\n    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n    beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n    beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n    if (beanFactory.containsBean(\"loadTimeWeaver\")) {\n        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n    }\n\n    if (!beanFactory.containsLocalBean(\"environment\")) {\n        beanFactory.registerSingleton(\"environment\", this.getEnvironment());\n    }\n\n    if (!beanFactory.containsLocalBean(\"systemProperties\")) {\n        beanFactory.registerSingleton(\"systemProperties\", this.getEnvironment().getSystemProperties());\n    }\n\n    if (!beanFactory.containsLocalBean(\"systemEnvironment\")) {\n        beanFactory.registerSingleton(\"systemEnvironment\", this.getEnvironment().getSystemEnvironment());\n    }\n\n}\n```\n\n#### postProcessBeanFactory 后置处理器\n根据第三方组件拓展新增后置处理器忽略接口依赖\n``` java\n// ServletWebServerApplicationContext 提供的方法 \nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    beanFactory.addBeanPostProcessor(new WebApplicationContextServletContextAwareProcessor(this));\n    beanFactory.ignoreDependencyInterface(ServletContextAware.class);\n    this.registerWebApplicationScopes();\n}\n\n\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    super.postProcessBeanFactory(beanFactory);\n    if (this.basePackages != null && this.basePackages.length > 0) {\n        this.scanner.scan(this.basePackages);\n    }\n\n    if (!this.annotatedClasses.isEmpty()) {\n        this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));\n    }\n}\n```\n\n#### invokeBeanFactoryPostProcessors 调用 Bean 工厂后置处理器\n1. 迭代上下文中`beanFactoryPostProcessors` 后置处理器集合，如果是`BeanDefinitionRegistryPostProcessor` 则调用执行`postProcessBeanDefinitionRegistry`否则仅收集与`regularPostProcessors`\n2. 循环类型为`BeanDefinitionRegistryPostProcessor`的处理器名字集合判断\n``` java\npublic static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n    Set<String> processedBeans = new HashSet();\n    ArrayList regularPostProcessors;\n    ArrayList registryProcessors;\n    int var9;\n    ArrayList currentRegistryProcessors;\n    String[] postProcessorNames;\n    if (beanFactory instanceof BeanDefinitionRegistry) {\n        BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;\n        regularPostProcessors = new ArrayList();\n        registryProcessors = new ArrayList();\n        Iterator var6 = beanFactoryPostProcessors.iterator();\n        // 迭代判断类型分配收集和执行 postProcessBeanDefinitionRegistry\n        while(var6.hasNext()) {\n            BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var6.next();\n            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n                BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor)postProcessor;\n                registryProcessor.postProcessBeanDefinitionRegistry(registry);\n                registryProcessors.add(registryProcessor);\n            } else {\n                regularPostProcessors.add(postProcessor);\n            }\n        }\n\n        currentRegistryProcessors = new ArrayList();\n        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n        String[] var16 = postProcessorNames;\n        var9 = postProcessorNames.length;\n\n        int var10;\n        String ppName;\n        // \n        for(var10 = 0; var10 < var9; ++var10) {\n            ppName = var16[var10];\n            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n                processedBeans.add(ppName);\n            }\n        }\n\n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n        registryProcessors.addAll(currentRegistryProcessors);\n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n        currentRegistryProcessors.clear();\n        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n        var16 = postProcessorNames;\n        var9 = postProcessorNames.length;\n\n        for(var10 = 0; var10 < var9; ++var10) {\n            ppName = var16[var10];\n            if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n                processedBeans.add(ppName);\n            }\n        }\n\n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n        registryProcessors.addAll(currentRegistryProcessors);\n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n        currentRegistryProcessors.clear();\n        boolean reiterate = true;\n\n        while(reiterate) {\n            reiterate = false;\n            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n            String[] var19 = postProcessorNames;\n            var10 = postProcessorNames.length;\n\n            for(int var26 = 0; var26 < var10; ++var26) {\n                String ppName = var19[var26];\n                if (!processedBeans.contains(ppName)) {\n                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n                    processedBeans.add(ppName);\n                    reiterate = true;\n                }\n            }\n\n            sortPostProcessors(currentRegistryProcessors, beanFactory);\n            registryProcessors.addAll(currentRegistryProcessors);\n            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n            currentRegistryProcessors.clear();\n        }\n\n        invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);\n        invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    } else {\n        invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    }\n\n    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n    regularPostProcessors = new ArrayList();\n    registryProcessors = new ArrayList();\n    currentRegistryProcessors = new ArrayList();\n    postProcessorNames = postProcessorNames;\n    int var20 = postProcessorNames.length;\n\n    String ppName;\n    for(var9 = 0; var9 < var20; ++var9) {\n        ppName = postProcessorNames[var9];\n        if (!processedBeans.contains(ppName)) {\n            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n                regularPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n            } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n                registryProcessors.add(ppName);\n            } else {\n                currentRegistryProcessors.add(ppName);\n            }\n        }\n    }\n\n    sortPostProcessors(regularPostProcessors, beanFactory);\n    invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList(registryProcessors.size());\n    Iterator var21 = registryProcessors.iterator();\n\n    while(var21.hasNext()) {\n        String postProcessorName = (String)var21.next();\n        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n    }\n\n    sortPostProcessors(orderedPostProcessors, beanFactory);\n    invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList(currentRegistryProcessors.size());\n    Iterator var24 = currentRegistryProcessors.iterator();\n\n    while(var24.hasNext()) {\n        ppName = (String)var24.next();\n        nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n    }\n\n    invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    beanFactory.clearMetadataCache();\n}\n```\n","source":"_posts/SpringBoot-启动过程（四）.md","raw":"---\ntitle: SpringBoot 启动源码解析（四）之容器\ntags:\n  - Spring\ncategories:\n  - Spring\ntoc: false\ndate: 2020-05-20 10:14:36\n---\n\n![](/images/spring.jpg)\n> 当配置环境初始化完毕后下一步容器创建、准备、刷新、刷新后处理\n\n### SpringApplicationContext 容器创建\n根据应用类型去实例化相应的容器对象，SpringBoot 使用`AnnotationConfigServletWebServerApplicationContext`，实例化会初始化`AnnotatedBeanDefinitionReader`和`ClassPathBeanDefinitionScanner` \n- AnnotatedBeanDefinitionReader 用于管理`BeanDefinition`，包含 `BeanDefinitionRegistry`注册管理、`BeanNameGenerator` beanName生成规则、`scopeMetadataResolver` Scope注解解析器\n- ClassPathBeanDefinitionScanner 用与类扫描包含了匹配规则`**/*.class/`和过滤条件`@Component`（所以我们项目中常常使用的@Service、@Controller会被注册）、`scopeMetadataResolver` Scope注解解析器、`resourcePatternResolver`资源加载器等\n\n``` java\n// 根据类型对应Class利用反射创建实例 \nprotected ConfigurableApplicationContext createApplicationContext() {\n    Class<?> contextClass = this.applicationContextClass;\n    if (contextClass == null) {\n        try {\n            switch(this.webApplicationType) {\n            case SERVLET:\n                contextClass = Class.forName(\"org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext\");\n                break;\n            case REACTIVE:\n                contextClass = Class.forName(\"org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext\");\n                break;\n            default:\n                contextClass = Class.forName(\"org.springframework.context.annotation.AnnotationConfigApplicationContext\");\n            }\n        } catch (ClassNotFoundException var3) {\n            throw new IllegalStateException(\"Unable create a default ApplicationContext, please specify an ApplicationContextClass\", var3);\n        }\n    }\n\n    return (ConfigurableApplicationContext)BeanUtils.instantiateClass(contextClass);\n}\n\n// AnnotationConfigSelvetWebServerApplicationContext 构造方法 \npublic AnnotationConfigServletWebServerApplicationContext() {\n    this.annotatedClasses = new LinkedHashSet();\n    this.reader = new AnnotatedBeanDefinitionReader(this);\n    this.scanner = new ClassPathBeanDefinitionScanner(this);\n}\n\n```\n\n![ConfigurableApplicationContext 可配置上下文结构](/images/2020/05/19/beb83e10-99b4-11ea-bc19-85fa9aca2a18.png)\n\n### SpringApplicationContext 准备\n1. 上下文加载装配环境包含`AnnotatedBeanDefinitionReader`和`ClassPathBeanDefinitionScanner`\n2. 配置上下文的 bean 生成器及 ResourceLoader 资源加载器，广播上下文准备事件并开启日志\n3. 获取`DefaultListableBeanFactory`并单例注册`springApplicationArguments`、`springBootBanner`\n4. 加载所有资源创建 `BeanDefinitionReader`读取资源根据资源类型分类解析\n5. 广播上下文加载完毕事件\n\n- XmlBeanDefinitionReader xml 配置文件读取加载 bean\n- AnnotatedBeanDefinitionReader 注解方法读取\n- ClassPathBeanDefinitionScanner 类路径扫描器\n- GroovyBeanDefinitionReader groovy 方法加载 bean\n\n``` java\nprivate void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {\n    // 装载可配置环境\n    context.setEnvironment(environment);\n    // 配置上下文的 bean 生成器及资源加载器\n    this.postProcessApplicationContext(context);\n    // 循环遍历所有初始化器\n    this.applyInitializers(context);\n    // 广播上下文准备事件\n    listeners.contextPrepared(context);\n    if (this.logStartupInfo) {\n        this.logStartupInfo(context.getParent() == null);\n        this.logStartupProfileInfo(context);\n    }\n    // 可配置Bean 工厂 单例注册特殊bean\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n    if (printedBanner != null) {\n        beanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n    }\n\n    if (beanFactory instanceof DefaultListableBeanFactory) {\n        ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n    }\n\n    if (this.lazyInitialization) {\n        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n    }\n    // 加载所有资源\n    Set<Object> sources = this.getAllSources();\n    Assert.notEmpty(sources, \"Sources must not be empty\");\n    this.load(context, sources.toArray(new Object[0]));\n    // 广播上下文加载事件\n    listeners.contextLoaded(context);\n}\n```\n\n### SpringApplicationContext 刷新\n``` java\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized(this.startupShutdownMonitor) {\n        # 准备刷新 更新状态、校验必要属性、设置监听器列表\n        this.prepareRefresh();\n        // 设置SerializationId \n        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();\n        // 后置处理器设置注册各类环境配置Bean\n        this.prepareBeanFactory(beanFactory);\n        try {\n            // 后置处理器空方法用于第三方拓展\n            this.postProcessBeanFactory(beanFactory);\n            this.invokeBeanFactoryPostProcessors(beanFactory);\n            this.registerBeanPostProcessors(beanFactory);\n            this.initMessageSource();\n            this.initApplicationEventMulticaster();\n            this.onRefresh();\n            this.registerListeners();\n            this.finishBeanFactoryInitialization(beanFactory);\n            this.finishRefresh();\n        } catch (BeansException var9) {\n            if (this.logger.isWarnEnabled()) {\n                this.logger.warn(\"Exception encountered during context initialization - cancelling refresh attempt: \" + var9);\n            }\n\n            this.destroyBeans();\n            this.cancelRefresh(var9);\n            throw var9;\n        } finally {\n            this.resetCommonCaches();\n        }\n\n    }\n}\n```\n\n#### prepareRefresh 准备刷新上下文\n1. 设置上下文状态记录跟踪日志\n2. 初始化配置资源并校验环境必要属性\n3. 新增监听器列表 `earlyApplicationListeners`\n``` java \nprotected void prepareRefresh() {\n    this.startupDate = System.currentTimeMillis();\n    this.closed.set(false);\n    this.active.set(true);\n    if (this.logger.isDebugEnabled()) {\n    if (this.logger.isTraceEnabled()) {\n        this.logger.trace(\"Refreshing \" + this);\n    } else {\n        this.logger.debug(\"Refreshing \" + this.getDisplayName());\n    }\n    }\n\n    this.initPropertySources();\n    this.getEnvironment().validateRequiredProperties();\n    if (this.earlyApplicationListeners == null) {\n    this.earlyApplicationListeners = new LinkedHashSet(this.applicationListeners);\n    } else {\n    this.applicationListeners.clear();\n    this.applicationListeners.addAll(this.earlyApplicationListeners);\n    }\n\n    this.earlyApplicationEvents = new LinkedHashSet();\n}\n```\n\n#### prepareBeanFactory 准备 BeanFactory\n1. 加载 `ClassLoader`、新增 `StandardBeanExpressionResolver` 标准的`Bean`表达式解析器、`ResourceEditorRegistrar` 属性编辑注册器\n2. 添加 `ApplicationContextAwareProcessor` 后置处理器用于处理 Bean 初始化前后操作，忽略依赖接口列表新增`EnvironmentAware`、`ApplicationEventPushlisherAware`、`ResouceLoaderAware`、`EmbedderValueResolverAware`、`MessageSourceAware`、`ApplicationContextAware`接口，由于`ApplicationContextAwareProcesser`已实现以上功能\n3. 新增`ApplicationListenerDetector` 监听器检测器用于内置 Bean 发布事件\n4. 注册单例 Bean `environment`、`systemProperties`、`systemEnvironment`\n``` java\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    // 设置 ClassLoader 用于加载 Bean \n    beanFactory.setBeanClassLoader(this.getClassLoader());\n    // 设置 StandardBeanExpressionResolver（标准 Bean EL 表达式解析器） 用于解析#{}\n    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n    // 新增 属性编辑注册器 \n    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, this.getEnvironment()));\n    // 新增 Bean 后置处理器\n    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n    // 忽略以下接口类依赖\n    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n    beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n    beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n    if (beanFactory.containsBean(\"loadTimeWeaver\")) {\n        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n    }\n\n    if (!beanFactory.containsLocalBean(\"environment\")) {\n        beanFactory.registerSingleton(\"environment\", this.getEnvironment());\n    }\n\n    if (!beanFactory.containsLocalBean(\"systemProperties\")) {\n        beanFactory.registerSingleton(\"systemProperties\", this.getEnvironment().getSystemProperties());\n    }\n\n    if (!beanFactory.containsLocalBean(\"systemEnvironment\")) {\n        beanFactory.registerSingleton(\"systemEnvironment\", this.getEnvironment().getSystemEnvironment());\n    }\n\n}\n```\n\n#### postProcessBeanFactory 后置处理器\n根据第三方组件拓展新增后置处理器忽略接口依赖\n``` java\n// ServletWebServerApplicationContext 提供的方法 \nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    beanFactory.addBeanPostProcessor(new WebApplicationContextServletContextAwareProcessor(this));\n    beanFactory.ignoreDependencyInterface(ServletContextAware.class);\n    this.registerWebApplicationScopes();\n}\n\n\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    super.postProcessBeanFactory(beanFactory);\n    if (this.basePackages != null && this.basePackages.length > 0) {\n        this.scanner.scan(this.basePackages);\n    }\n\n    if (!this.annotatedClasses.isEmpty()) {\n        this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));\n    }\n}\n```\n\n#### invokeBeanFactoryPostProcessors 调用 Bean 工厂后置处理器\n1. 迭代上下文中`beanFactoryPostProcessors` 后置处理器集合，如果是`BeanDefinitionRegistryPostProcessor` 则调用执行`postProcessBeanDefinitionRegistry`否则仅收集与`regularPostProcessors`\n2. 循环类型为`BeanDefinitionRegistryPostProcessor`的处理器名字集合判断\n``` java\npublic static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n    Set<String> processedBeans = new HashSet();\n    ArrayList regularPostProcessors;\n    ArrayList registryProcessors;\n    int var9;\n    ArrayList currentRegistryProcessors;\n    String[] postProcessorNames;\n    if (beanFactory instanceof BeanDefinitionRegistry) {\n        BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;\n        regularPostProcessors = new ArrayList();\n        registryProcessors = new ArrayList();\n        Iterator var6 = beanFactoryPostProcessors.iterator();\n        // 迭代判断类型分配收集和执行 postProcessBeanDefinitionRegistry\n        while(var6.hasNext()) {\n            BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var6.next();\n            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n                BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor)postProcessor;\n                registryProcessor.postProcessBeanDefinitionRegistry(registry);\n                registryProcessors.add(registryProcessor);\n            } else {\n                regularPostProcessors.add(postProcessor);\n            }\n        }\n\n        currentRegistryProcessors = new ArrayList();\n        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n        String[] var16 = postProcessorNames;\n        var9 = postProcessorNames.length;\n\n        int var10;\n        String ppName;\n        // \n        for(var10 = 0; var10 < var9; ++var10) {\n            ppName = var16[var10];\n            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n                processedBeans.add(ppName);\n            }\n        }\n\n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n        registryProcessors.addAll(currentRegistryProcessors);\n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n        currentRegistryProcessors.clear();\n        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n        var16 = postProcessorNames;\n        var9 = postProcessorNames.length;\n\n        for(var10 = 0; var10 < var9; ++var10) {\n            ppName = var16[var10];\n            if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n                processedBeans.add(ppName);\n            }\n        }\n\n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n        registryProcessors.addAll(currentRegistryProcessors);\n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n        currentRegistryProcessors.clear();\n        boolean reiterate = true;\n\n        while(reiterate) {\n            reiterate = false;\n            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n            String[] var19 = postProcessorNames;\n            var10 = postProcessorNames.length;\n\n            for(int var26 = 0; var26 < var10; ++var26) {\n                String ppName = var19[var26];\n                if (!processedBeans.contains(ppName)) {\n                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n                    processedBeans.add(ppName);\n                    reiterate = true;\n                }\n            }\n\n            sortPostProcessors(currentRegistryProcessors, beanFactory);\n            registryProcessors.addAll(currentRegistryProcessors);\n            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n            currentRegistryProcessors.clear();\n        }\n\n        invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);\n        invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    } else {\n        invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    }\n\n    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n    regularPostProcessors = new ArrayList();\n    registryProcessors = new ArrayList();\n    currentRegistryProcessors = new ArrayList();\n    postProcessorNames = postProcessorNames;\n    int var20 = postProcessorNames.length;\n\n    String ppName;\n    for(var9 = 0; var9 < var20; ++var9) {\n        ppName = postProcessorNames[var9];\n        if (!processedBeans.contains(ppName)) {\n            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n                regularPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n            } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n                registryProcessors.add(ppName);\n            } else {\n                currentRegistryProcessors.add(ppName);\n            }\n        }\n    }\n\n    sortPostProcessors(regularPostProcessors, beanFactory);\n    invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList(registryProcessors.size());\n    Iterator var21 = registryProcessors.iterator();\n\n    while(var21.hasNext()) {\n        String postProcessorName = (String)var21.next();\n        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n    }\n\n    sortPostProcessors(orderedPostProcessors, beanFactory);\n    invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList(currentRegistryProcessors.size());\n    Iterator var24 = currentRegistryProcessors.iterator();\n\n    while(var24.hasNext()) {\n        ppName = (String)var24.next();\n        nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n    }\n\n    invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    beanFactory.clearMetadataCache();\n}\n```\n","slug":"SpringBoot-启动过程（四）","published":1,"updated":"2020-08-10T01:48:44.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc99a003fjsudvhly90ra","content":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>当配置环境初始化完毕后下一步容器创建、准备、刷新、刷新后处理</p>\n</blockquote>\n<h3 id=\"SpringApplicationContext-容器创建\"><a href=\"#SpringApplicationContext-容器创建\" class=\"headerlink\" title=\"SpringApplicationContext 容器创建\"></a>SpringApplicationContext 容器创建</h3><p>根据应用类型去实例化相应的容器对象，SpringBoot 使用<code>AnnotationConfigServletWebServerApplicationContext</code>，实例化会初始化<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefinitionScanner</code> </p>\n<ul>\n<li>AnnotatedBeanDefinitionReader 用于管理<code>BeanDefinition</code>，包含 <code>BeanDefinitionRegistry</code>注册管理、<code>BeanNameGenerator</code> beanName生成规则、<code>scopeMetadataResolver</code> Scope注解解析器</li>\n<li>ClassPathBeanDefinitionScanner 用与类扫描包含了匹配规则<code>**/*.class/</code>和过滤条件<code>@Component</code>（所以我们项目中常常使用的@Service、@Controller会被注册）、<code>scopeMetadataResolver</code> Scope注解解析器、<code>resourcePatternResolver</code>资源加载器等</li>\n</ul>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 根据类型对应Class利用反射创建实例 </span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> ConfigurableApplicationContext <span class=\"hljs-title\">createApplicationContext</span><span class=\"hljs-params\">()</span> </span>&#123;\n    Class&lt;?&gt; contextClass = <span class=\"hljs-keyword\">this</span>.applicationContextClass;\n    <span class=\"hljs-keyword\">if</span> (contextClass == <span class=\"hljs-keyword\">null</span>) &#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            <span class=\"hljs-keyword\">switch</span>(<span class=\"hljs-keyword\">this</span>.webApplicationType) &#123;\n            <span class=\"hljs-keyword\">case</span> SERVLET:\n                contextClass = Class.forName(<span class=\"hljs-string\">\"org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext\"</span>);\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> REACTIVE:\n                contextClass = Class.forName(<span class=\"hljs-string\">\"org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext\"</span>);\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">default</span>:\n                contextClass = Class.forName(<span class=\"hljs-string\">\"org.springframework.context.annotation.AnnotationConfigApplicationContext\"</span>);\n            &#125;\n        &#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException var3) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Unable create a default ApplicationContext, please specify an ApplicationContextClass\"</span>, var3);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> (ConfigurableApplicationContext)BeanUtils.instantiateClass(contextClass);\n&#125;\n\n<span class=\"hljs-comment\">// AnnotationConfigSelvetWebServerApplicationContext 构造方法 </span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AnnotationConfigServletWebServerApplicationContext</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.annotatedClasses = <span class=\"hljs-keyword\">new</span> LinkedHashSet();\n    <span class=\"hljs-keyword\">this</span>.reader = <span class=\"hljs-keyword\">new</span> AnnotatedBeanDefinitionReader(<span class=\"hljs-keyword\">this</span>);\n    <span class=\"hljs-keyword\">this</span>.scanner = <span class=\"hljs-keyword\">new</span> ClassPathBeanDefinitionScanner(<span class=\"hljs-keyword\">this</span>);\n&#125;</code></pre>\n<p><img src=\"/images/2020/05/19/beb83e10-99b4-11ea-bc19-85fa9aca2a18.png\" srcset=\"/img/loading.gif\" alt=\"ConfigurableApplicationContext 可配置上下文结构\"></p>\n<h3 id=\"SpringApplicationContext-准备\"><a href=\"#SpringApplicationContext-准备\" class=\"headerlink\" title=\"SpringApplicationContext 准备\"></a>SpringApplicationContext 准备</h3><ol>\n<li>上下文加载装配环境包含<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefinitionScanner</code></li>\n<li>配置上下文的 bean 生成器及 ResourceLoader 资源加载器，广播上下文准备事件并开启日志</li>\n<li>获取<code>DefaultListableBeanFactory</code>并单例注册<code>springApplicationArguments</code>、<code>springBootBanner</code></li>\n<li>加载所有资源创建 <code>BeanDefinitionReader</code>读取资源根据资源类型分类解析</li>\n<li>广播上下文加载完毕事件</li>\n</ol>\n<ul>\n<li>XmlBeanDefinitionReader xml 配置文件读取加载 bean</li>\n<li>AnnotatedBeanDefinitionReader 注解方法读取</li>\n<li>ClassPathBeanDefinitionScanner 类路径扫描器</li>\n<li>GroovyBeanDefinitionReader groovy 方法加载 bean</li>\n</ul>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepareContext</span><span class=\"hljs-params\">(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;\n    <span class=\"hljs-comment\">// 装载可配置环境</span>\n    context.setEnvironment(environment);\n    <span class=\"hljs-comment\">// 配置上下文的 bean 生成器及资源加载器</span>\n    <span class=\"hljs-keyword\">this</span>.postProcessApplicationContext(context);\n    <span class=\"hljs-comment\">// 循环遍历所有初始化器</span>\n    <span class=\"hljs-keyword\">this</span>.applyInitializers(context);\n    <span class=\"hljs-comment\">// 广播上下文准备事件</span>\n    listeners.contextPrepared(context);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.logStartupInfo) &#123;\n        <span class=\"hljs-keyword\">this</span>.logStartupInfo(context.getParent() == <span class=\"hljs-keyword\">null</span>);\n        <span class=\"hljs-keyword\">this</span>.logStartupProfileInfo(context);\n    &#125;\n    <span class=\"hljs-comment\">// 可配置Bean 工厂 单例注册特殊bean</span>\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    beanFactory.registerSingleton(<span class=\"hljs-string\">\"springApplicationArguments\"</span>, applicationArguments);\n    <span class=\"hljs-keyword\">if</span> (printedBanner != <span class=\"hljs-keyword\">null</span>) &#123;\n        beanFactory.registerSingleton(<span class=\"hljs-string\">\"springBootBanner\"</span>, printedBanner);\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (beanFactory <span class=\"hljs-keyword\">instanceof</span> DefaultListableBeanFactory) &#123;\n        ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(<span class=\"hljs-keyword\">this</span>.allowBeanDefinitionOverriding);\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.lazyInitialization) &#123;\n        context.addBeanFactoryPostProcessor(<span class=\"hljs-keyword\">new</span> LazyInitializationBeanFactoryPostProcessor());\n    &#125;\n    <span class=\"hljs-comment\">// 加载所有资源</span>\n    Set&lt;Object&gt; sources = <span class=\"hljs-keyword\">this</span>.getAllSources();\n    Assert.notEmpty(sources, <span class=\"hljs-string\">\"Sources must not be empty\"</span>);\n    <span class=\"hljs-keyword\">this</span>.load(context, sources.toArray(<span class=\"hljs-keyword\">new</span> Object[<span class=\"hljs-number\">0</span>]));\n    <span class=\"hljs-comment\">// 广播上下文加载事件</span>\n    listeners.contextLoaded(context);\n&#125;</code></pre>\n<h3 id=\"SpringApplicationContext-刷新\"><a href=\"#SpringApplicationContext-刷新\" class=\"headerlink\" title=\"SpringApplicationContext 刷新\"></a>SpringApplicationContext 刷新</h3><pre><code class=\"hljs java\">public void refresh() throws BeansException, IllegalStateException &#123;\n    synchronized(this.startupShutdownMonitor) &#123;\n        # 准备刷新 更新状态、校验必要属性、设置监听器列表\n        this.prepareRefresh();\n        // 设置SerializationId \n        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();\n        // 后置处理器设置注册各类环境配置Bean\n        this.prepareBeanFactory(beanFactory);\n        try &#123;\n            // 后置处理器空方法用于第三方拓展\n            this.postProcessBeanFactory(beanFactory);\n            this.invokeBeanFactoryPostProcessors(beanFactory);\n            this.registerBeanPostProcessors(beanFactory);\n            this.initMessageSource();\n            this.initApplicationEventMulticaster();\n            this.onRefresh();\n            this.registerListeners();\n            this.finishBeanFactoryInitialization(beanFactory);\n            this.finishRefresh();\n        &#125; catch (BeansException var9) &#123;\n            if (this.logger.isWarnEnabled()) &#123;\n                this.logger.warn(\"Exception encountered during context initialization - cancelling refresh attempt: \" + var9);\n            &#125;\n\n            this.destroyBeans();\n            this.cancelRefresh(var9);\n            throw var9;\n        &#125; finally &#123;\n            this.resetCommonCaches();\n        &#125;\n\n    &#125;\n&#125;</code></pre>\n<h4 id=\"prepareRefresh-准备刷新上下文\"><a href=\"#prepareRefresh-准备刷新上下文\" class=\"headerlink\" title=\"prepareRefresh 准备刷新上下文\"></a>prepareRefresh 准备刷新上下文</h4><ol>\n<li>设置上下文状态记录跟踪日志</li>\n<li>初始化配置资源并校验环境必要属性</li>\n<li>新增监听器列表 <code>earlyApplicationListeners</code><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepareRefresh</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.startupDate = System.currentTimeMillis();\n    <span class=\"hljs-keyword\">this</span>.closed.set(<span class=\"hljs-keyword\">false</span>);\n    <span class=\"hljs-keyword\">this</span>.active.set(<span class=\"hljs-keyword\">true</span>);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.logger.isDebugEnabled()) &#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.logger.isTraceEnabled()) &#123;\n        <span class=\"hljs-keyword\">this</span>.logger.trace(<span class=\"hljs-string\">\"Refreshing \"</span> + <span class=\"hljs-keyword\">this</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        <span class=\"hljs-keyword\">this</span>.logger.debug(<span class=\"hljs-string\">\"Refreshing \"</span> + <span class=\"hljs-keyword\">this</span>.getDisplayName());\n    &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">this</span>.initPropertySources();\n    <span class=\"hljs-keyword\">this</span>.getEnvironment().validateRequiredProperties();\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.earlyApplicationListeners == <span class=\"hljs-keyword\">null</span>) &#123;\n    <span class=\"hljs-keyword\">this</span>.earlyApplicationListeners = <span class=\"hljs-keyword\">new</span> LinkedHashSet(<span class=\"hljs-keyword\">this</span>.applicationListeners);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    <span class=\"hljs-keyword\">this</span>.applicationListeners.clear();\n    <span class=\"hljs-keyword\">this</span>.applicationListeners.addAll(<span class=\"hljs-keyword\">this</span>.earlyApplicationListeners);\n    &#125;\n\n    <span class=\"hljs-keyword\">this</span>.earlyApplicationEvents = <span class=\"hljs-keyword\">new</span> LinkedHashSet();\n&#125;</code></pre>\n</li>\n</ol>\n<h4 id=\"prepareBeanFactory-准备-BeanFactory\"><a href=\"#prepareBeanFactory-准备-BeanFactory\" class=\"headerlink\" title=\"prepareBeanFactory 准备 BeanFactory\"></a>prepareBeanFactory 准备 BeanFactory</h4><ol>\n<li>加载 <code>ClassLoader</code>、新增 <code>StandardBeanExpressionResolver</code> 标准的<code>Bean</code>表达式解析器、<code>ResourceEditorRegistrar</code> 属性编辑注册器</li>\n<li>添加 <code>ApplicationContextAwareProcessor</code> 后置处理器用于处理 Bean 初始化前后操作，忽略依赖接口列表新增<code>EnvironmentAware</code>、<code>ApplicationEventPushlisherAware</code>、<code>ResouceLoaderAware</code>、<code>EmbedderValueResolverAware</code>、<code>MessageSourceAware</code>、<code>ApplicationContextAware</code>接口，由于<code>ApplicationContextAwareProcesser</code>已实现以上功能</li>\n<li>新增<code>ApplicationListenerDetector</code> 监听器检测器用于内置 Bean 发布事件</li>\n<li>注册单例 Bean <code>environment</code>、<code>systemProperties</code>、<code>systemEnvironment</code><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepareBeanFactory</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;\n    <span class=\"hljs-comment\">// 设置 ClassLoader 用于加载 Bean </span>\n    beanFactory.setBeanClassLoader(<span class=\"hljs-keyword\">this</span>.getClassLoader());\n    <span class=\"hljs-comment\">// 设置 StandardBeanExpressionResolver（标准 Bean EL 表达式解析器） 用于解析#&#123;&#125;</span>\n    beanFactory.setBeanExpressionResolver(<span class=\"hljs-keyword\">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n    <span class=\"hljs-comment\">// 新增 属性编辑注册器 </span>\n    beanFactory.addPropertyEditorRegistrar(<span class=\"hljs-keyword\">new</span> ResourceEditorRegistrar(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.getEnvironment()));\n    <span class=\"hljs-comment\">// 新增 Bean 后置处理器</span>\n    beanFactory.addBeanPostProcessor(<span class=\"hljs-keyword\">new</span> ApplicationContextAwareProcessor(<span class=\"hljs-keyword\">this</span>));\n    <span class=\"hljs-comment\">// 忽略以下接口类依赖</span>\n    beanFactory.ignoreDependencyInterface(EnvironmentAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.ignoreDependencyInterface(MessageSourceAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.registerResolvableDependency(BeanFactory<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">beanFactory</span>)</span>;\n    beanFactory.registerResolvableDependency(ResourceLoader<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">this</span>)</span>;\n    beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">this</span>)</span>;\n    beanFactory.registerResolvableDependency(ApplicationContext<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">this</span>)</span>;\n    beanFactory.addBeanPostProcessor(<span class=\"hljs-keyword\">new</span> ApplicationListenerDetector(<span class=\"hljs-keyword\">this</span>));\n    <span class=\"hljs-keyword\">if</span> (beanFactory.containsBean(<span class=\"hljs-string\">\"loadTimeWeaver\"</span>)) &#123;\n        beanFactory.addBeanPostProcessor(<span class=\"hljs-keyword\">new</span> LoadTimeWeaverAwareProcessor(beanFactory));\n        beanFactory.setTempClassLoader(<span class=\"hljs-keyword\">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (!beanFactory.containsLocalBean(<span class=\"hljs-string\">\"environment\"</span>)) &#123;\n        beanFactory.registerSingleton(<span class=\"hljs-string\">\"environment\"</span>, <span class=\"hljs-keyword\">this</span>.getEnvironment());\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (!beanFactory.containsLocalBean(<span class=\"hljs-string\">\"systemProperties\"</span>)) &#123;\n        beanFactory.registerSingleton(<span class=\"hljs-string\">\"systemProperties\"</span>, <span class=\"hljs-keyword\">this</span>.getEnvironment().getSystemProperties());\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (!beanFactory.containsLocalBean(<span class=\"hljs-string\">\"systemEnvironment\"</span>)) &#123;\n        beanFactory.registerSingleton(<span class=\"hljs-string\">\"systemEnvironment\"</span>, <span class=\"hljs-keyword\">this</span>.getEnvironment().getSystemEnvironment());\n    &#125;\n\n&#125;</code></pre>\n</li>\n</ol>\n<h4 id=\"postProcessBeanFactory-后置处理器\"><a href=\"#postProcessBeanFactory-后置处理器\" class=\"headerlink\" title=\"postProcessBeanFactory 后置处理器\"></a>postProcessBeanFactory 后置处理器</h4><p>根据第三方组件拓展新增后置处理器忽略接口依赖<br><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// ServletWebServerApplicationContext 提供的方法 </span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postProcessBeanFactory</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;\n    beanFactory.addBeanPostProcessor(<span class=\"hljs-keyword\">new</span> WebApplicationContextServletContextAwareProcessor(<span class=\"hljs-keyword\">this</span>));\n    beanFactory.ignoreDependencyInterface(ServletContextAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    <span class=\"hljs-keyword\">this</span>.registerWebApplicationScopes();\n&#125;\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postProcessBeanFactory</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;\n    <span class=\"hljs-keyword\">super</span>.postProcessBeanFactory(beanFactory);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.basePackages != <span class=\"hljs-keyword\">null</span> &amp;&amp; <span class=\"hljs-keyword\">this</span>.basePackages.length &gt; <span class=\"hljs-number\">0</span>) &#123;\n        <span class=\"hljs-keyword\">this</span>.scanner.scan(<span class=\"hljs-keyword\">this</span>.basePackages);\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.annotatedClasses.isEmpty()) &#123;\n        <span class=\"hljs-keyword\">this</span>.reader.register(ClassUtils.toClassArray(<span class=\"hljs-keyword\">this</span>.annotatedClasses));\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"invokeBeanFactoryPostProcessors-调用-Bean-工厂后置处理器\"><a href=\"#invokeBeanFactoryPostProcessors-调用-Bean-工厂后置处理器\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors 调用 Bean 工厂后置处理器\"></a>invokeBeanFactoryPostProcessors 调用 Bean 工厂后置处理器</h4><ol>\n<li>迭代上下文中<code>beanFactoryPostProcessors</code> 后置处理器集合，如果是<code>BeanDefinitionRegistryPostProcessor</code> 则调用执行<code>postProcessBeanDefinitionRegistry</code>否则仅收集与<code>regularPostProcessors</code></li>\n<li>循环类型为<code>BeanDefinitionRegistryPostProcessor</code>的处理器名字集合判断<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">invokeBeanFactoryPostProcessors</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;\n    Set&lt;String&gt; processedBeans = <span class=\"hljs-keyword\">new</span> HashSet();\n    ArrayList regularPostProcessors;\n    ArrayList registryProcessors;\n    <span class=\"hljs-keyword\">int</span> var9;\n    ArrayList currentRegistryProcessors;\n    String[] postProcessorNames;\n    <span class=\"hljs-keyword\">if</span> (beanFactory <span class=\"hljs-keyword\">instanceof</span> BeanDefinitionRegistry) &#123;\n        BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;\n        regularPostProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n        registryProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n        Iterator var6 = beanFactoryPostProcessors.iterator();\n        <span class=\"hljs-comment\">// 迭代判断类型分配收集和执行 postProcessBeanDefinitionRegistry</span>\n        <span class=\"hljs-keyword\">while</span>(var6.hasNext()) &#123;\n            BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var6.next();\n            <span class=\"hljs-keyword\">if</span> (postProcessor <span class=\"hljs-keyword\">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;\n                BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor)postProcessor;\n                registryProcessor.postProcessBeanDefinitionRegistry(registry);\n                registryProcessors.add(registryProcessor);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                regularPostProcessors.add(postProcessor);\n            &#125;\n        &#125;\n\n        currentRegistryProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">true</span>, <span class=\"hljs-title\">false</span>)</span>;\n        String[] var16 = postProcessorNames;\n        var9 = postProcessorNames.length;\n\n        <span class=\"hljs-keyword\">int</span> var10;\n        String ppName;\n        <span class=\"hljs-comment\">// </span>\n        <span class=\"hljs-keyword\">for</span>(var10 = <span class=\"hljs-number\">0</span>; var10 &lt; var9; ++var10) &#123;\n            ppName = var16[var10];\n            <span class=\"hljs-keyword\">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)) </span>&#123;\n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n                processedBeans.add(ppName);\n            &#125;\n        &#125;\n\n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n        registryProcessors.addAll(currentRegistryProcessors);\n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n        currentRegistryProcessors.clear();\n        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">true</span>, <span class=\"hljs-title\">false</span>)</span>;\n        var16 = postProcessorNames;\n        var9 = postProcessorNames.length;\n\n        <span class=\"hljs-keyword\">for</span>(var10 = <span class=\"hljs-number\">0</span>; var10 &lt; var9; ++var10) &#123;\n            ppName = var16[var10];\n            <span class=\"hljs-keyword\">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)) </span>&#123;\n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n                processedBeans.add(ppName);\n            &#125;\n        &#125;\n\n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n        registryProcessors.addAll(currentRegistryProcessors);\n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n        currentRegistryProcessors.clear();\n        <span class=\"hljs-keyword\">boolean</span> reiterate = <span class=\"hljs-keyword\">true</span>;\n\n        <span class=\"hljs-keyword\">while</span>(reiterate) &#123;\n            reiterate = <span class=\"hljs-keyword\">false</span>;\n            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">true</span>, <span class=\"hljs-title\">false</span>)</span>;\n            String[] var19 = postProcessorNames;\n            var10 = postProcessorNames.length;\n\n            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> var26 = <span class=\"hljs-number\">0</span>; var26 &lt; var10; ++var26) &#123;\n                String ppName = var19[var26];\n                <span class=\"hljs-keyword\">if</span> (!processedBeans.contains(ppName)) &#123;\n                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n                    processedBeans.add(ppName);\n                    reiterate = <span class=\"hljs-keyword\">true</span>;\n                &#125;\n            &#125;\n\n            sortPostProcessors(currentRegistryProcessors, beanFactory);\n            registryProcessors.addAll(currentRegistryProcessors);\n            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n            currentRegistryProcessors.clear();\n        &#125;\n\n        invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);\n        invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    &#125;\n\n    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">true</span>, <span class=\"hljs-title\">false</span>)</span>;\n    regularPostProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n    registryProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n    currentRegistryProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n    postProcessorNames = postProcessorNames;\n    <span class=\"hljs-keyword\">int</span> var20 = postProcessorNames.length;\n\n    String ppName;\n    <span class=\"hljs-keyword\">for</span>(var9 = <span class=\"hljs-number\">0</span>; var9 &lt; var20; ++var9) &#123;\n        ppName = postProcessorNames[var9];\n        <span class=\"hljs-keyword\">if</span> (!processedBeans.contains(ppName)) &#123;\n            <span class=\"hljs-keyword\">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)) </span>&#123;\n                regularPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)) </span>&#123;\n                registryProcessors.add(ppName);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                currentRegistryProcessors.add(ppName);\n            &#125;\n        &#125;\n    &#125;\n\n    sortPostProcessors(regularPostProcessors, beanFactory);\n    invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class=\"hljs-keyword\">new</span> ArrayList(registryProcessors.size());\n    Iterator var21 = registryProcessors.iterator();\n\n    <span class=\"hljs-keyword\">while</span>(var21.hasNext()) &#123;\n        String postProcessorName = (String)var21.next();\n        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n    &#125;\n\n    sortPostProcessors(orderedPostProcessors, beanFactory);\n    invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class=\"hljs-keyword\">new</span> ArrayList(currentRegistryProcessors.size());\n    Iterator var24 = currentRegistryProcessors.iterator();\n\n    <span class=\"hljs-keyword\">while</span>(var24.hasNext()) &#123;\n        ppName = (String)var24.next();\n        nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n    &#125;\n\n    invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    beanFactory.clearMetadataCache();\n&#125;</code></pre>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>当配置环境初始化完毕后下一步容器创建、准备、刷新、刷新后处理</p>\n</blockquote>\n<h3 id=\"SpringApplicationContext-容器创建\"><a href=\"#SpringApplicationContext-容器创建\" class=\"headerlink\" title=\"SpringApplicationContext 容器创建\"></a>SpringApplicationContext 容器创建</h3><p>根据应用类型去实例化相应的容器对象，SpringBoot 使用<code>AnnotationConfigServletWebServerApplicationContext</code>，实例化会初始化<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefinitionScanner</code> </p>\n<ul>\n<li>AnnotatedBeanDefinitionReader 用于管理<code>BeanDefinition</code>，包含 <code>BeanDefinitionRegistry</code>注册管理、<code>BeanNameGenerator</code> beanName生成规则、<code>scopeMetadataResolver</code> Scope注解解析器</li>\n<li>ClassPathBeanDefinitionScanner 用与类扫描包含了匹配规则<code>**/*.class/</code>和过滤条件<code>@Component</code>（所以我们项目中常常使用的@Service、@Controller会被注册）、<code>scopeMetadataResolver</code> Scope注解解析器、<code>resourcePatternResolver</code>资源加载器等</li>\n</ul>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 根据类型对应Class利用反射创建实例 </span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> ConfigurableApplicationContext <span class=\"hljs-title\">createApplicationContext</span><span class=\"hljs-params\">()</span> </span>&#123;\n    Class&lt;?&gt; contextClass = <span class=\"hljs-keyword\">this</span>.applicationContextClass;\n    <span class=\"hljs-keyword\">if</span> (contextClass == <span class=\"hljs-keyword\">null</span>) &#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            <span class=\"hljs-keyword\">switch</span>(<span class=\"hljs-keyword\">this</span>.webApplicationType) &#123;\n            <span class=\"hljs-keyword\">case</span> SERVLET:\n                contextClass = Class.forName(<span class=\"hljs-string\">\"org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext\"</span>);\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> REACTIVE:\n                contextClass = Class.forName(<span class=\"hljs-string\">\"org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext\"</span>);\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">default</span>:\n                contextClass = Class.forName(<span class=\"hljs-string\">\"org.springframework.context.annotation.AnnotationConfigApplicationContext\"</span>);\n            &#125;\n        &#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException var3) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Unable create a default ApplicationContext, please specify an ApplicationContextClass\"</span>, var3);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> (ConfigurableApplicationContext)BeanUtils.instantiateClass(contextClass);\n&#125;\n\n<span class=\"hljs-comment\">// AnnotationConfigSelvetWebServerApplicationContext 构造方法 </span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AnnotationConfigServletWebServerApplicationContext</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.annotatedClasses = <span class=\"hljs-keyword\">new</span> LinkedHashSet();\n    <span class=\"hljs-keyword\">this</span>.reader = <span class=\"hljs-keyword\">new</span> AnnotatedBeanDefinitionReader(<span class=\"hljs-keyword\">this</span>);\n    <span class=\"hljs-keyword\">this</span>.scanner = <span class=\"hljs-keyword\">new</span> ClassPathBeanDefinitionScanner(<span class=\"hljs-keyword\">this</span>);\n&#125;</code></pre>\n<p><img src=\"/images/2020/05/19/beb83e10-99b4-11ea-bc19-85fa9aca2a18.png\" srcset=\"/img/loading.gif\" alt=\"ConfigurableApplicationContext 可配置上下文结构\"></p>\n<h3 id=\"SpringApplicationContext-准备\"><a href=\"#SpringApplicationContext-准备\" class=\"headerlink\" title=\"SpringApplicationContext 准备\"></a>SpringApplicationContext 准备</h3><ol>\n<li>上下文加载装配环境包含<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefinitionScanner</code></li>\n<li>配置上下文的 bean 生成器及 ResourceLoader 资源加载器，广播上下文准备事件并开启日志</li>\n<li>获取<code>DefaultListableBeanFactory</code>并单例注册<code>springApplicationArguments</code>、<code>springBootBanner</code></li>\n<li>加载所有资源创建 <code>BeanDefinitionReader</code>读取资源根据资源类型分类解析</li>\n<li>广播上下文加载完毕事件</li>\n</ol>\n<ul>\n<li>XmlBeanDefinitionReader xml 配置文件读取加载 bean</li>\n<li>AnnotatedBeanDefinitionReader 注解方法读取</li>\n<li>ClassPathBeanDefinitionScanner 类路径扫描器</li>\n<li>GroovyBeanDefinitionReader groovy 方法加载 bean</li>\n</ul>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepareContext</span><span class=\"hljs-params\">(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;\n    <span class=\"hljs-comment\">// 装载可配置环境</span>\n    context.setEnvironment(environment);\n    <span class=\"hljs-comment\">// 配置上下文的 bean 生成器及资源加载器</span>\n    <span class=\"hljs-keyword\">this</span>.postProcessApplicationContext(context);\n    <span class=\"hljs-comment\">// 循环遍历所有初始化器</span>\n    <span class=\"hljs-keyword\">this</span>.applyInitializers(context);\n    <span class=\"hljs-comment\">// 广播上下文准备事件</span>\n    listeners.contextPrepared(context);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.logStartupInfo) &#123;\n        <span class=\"hljs-keyword\">this</span>.logStartupInfo(context.getParent() == <span class=\"hljs-keyword\">null</span>);\n        <span class=\"hljs-keyword\">this</span>.logStartupProfileInfo(context);\n    &#125;\n    <span class=\"hljs-comment\">// 可配置Bean 工厂 单例注册特殊bean</span>\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    beanFactory.registerSingleton(<span class=\"hljs-string\">\"springApplicationArguments\"</span>, applicationArguments);\n    <span class=\"hljs-keyword\">if</span> (printedBanner != <span class=\"hljs-keyword\">null</span>) &#123;\n        beanFactory.registerSingleton(<span class=\"hljs-string\">\"springBootBanner\"</span>, printedBanner);\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (beanFactory <span class=\"hljs-keyword\">instanceof</span> DefaultListableBeanFactory) &#123;\n        ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(<span class=\"hljs-keyword\">this</span>.allowBeanDefinitionOverriding);\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.lazyInitialization) &#123;\n        context.addBeanFactoryPostProcessor(<span class=\"hljs-keyword\">new</span> LazyInitializationBeanFactoryPostProcessor());\n    &#125;\n    <span class=\"hljs-comment\">// 加载所有资源</span>\n    Set&lt;Object&gt; sources = <span class=\"hljs-keyword\">this</span>.getAllSources();\n    Assert.notEmpty(sources, <span class=\"hljs-string\">\"Sources must not be empty\"</span>);\n    <span class=\"hljs-keyword\">this</span>.load(context, sources.toArray(<span class=\"hljs-keyword\">new</span> Object[<span class=\"hljs-number\">0</span>]));\n    <span class=\"hljs-comment\">// 广播上下文加载事件</span>\n    listeners.contextLoaded(context);\n&#125;</code></pre>\n<h3 id=\"SpringApplicationContext-刷新\"><a href=\"#SpringApplicationContext-刷新\" class=\"headerlink\" title=\"SpringApplicationContext 刷新\"></a>SpringApplicationContext 刷新</h3><pre><code class=\"hljs java\">public void refresh() throws BeansException, IllegalStateException &#123;\n    synchronized(this.startupShutdownMonitor) &#123;\n        # 准备刷新 更新状态、校验必要属性、设置监听器列表\n        this.prepareRefresh();\n        // 设置SerializationId \n        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();\n        // 后置处理器设置注册各类环境配置Bean\n        this.prepareBeanFactory(beanFactory);\n        try &#123;\n            // 后置处理器空方法用于第三方拓展\n            this.postProcessBeanFactory(beanFactory);\n            this.invokeBeanFactoryPostProcessors(beanFactory);\n            this.registerBeanPostProcessors(beanFactory);\n            this.initMessageSource();\n            this.initApplicationEventMulticaster();\n            this.onRefresh();\n            this.registerListeners();\n            this.finishBeanFactoryInitialization(beanFactory);\n            this.finishRefresh();\n        &#125; catch (BeansException var9) &#123;\n            if (this.logger.isWarnEnabled()) &#123;\n                this.logger.warn(\"Exception encountered during context initialization - cancelling refresh attempt: \" + var9);\n            &#125;\n\n            this.destroyBeans();\n            this.cancelRefresh(var9);\n            throw var9;\n        &#125; finally &#123;\n            this.resetCommonCaches();\n        &#125;\n\n    &#125;\n&#125;</code></pre>\n<h4 id=\"prepareRefresh-准备刷新上下文\"><a href=\"#prepareRefresh-准备刷新上下文\" class=\"headerlink\" title=\"prepareRefresh 准备刷新上下文\"></a>prepareRefresh 准备刷新上下文</h4><ol>\n<li>设置上下文状态记录跟踪日志</li>\n<li>初始化配置资源并校验环境必要属性</li>\n<li>新增监听器列表 <code>earlyApplicationListeners</code><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepareRefresh</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.startupDate = System.currentTimeMillis();\n    <span class=\"hljs-keyword\">this</span>.closed.set(<span class=\"hljs-keyword\">false</span>);\n    <span class=\"hljs-keyword\">this</span>.active.set(<span class=\"hljs-keyword\">true</span>);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.logger.isDebugEnabled()) &#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.logger.isTraceEnabled()) &#123;\n        <span class=\"hljs-keyword\">this</span>.logger.trace(<span class=\"hljs-string\">\"Refreshing \"</span> + <span class=\"hljs-keyword\">this</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        <span class=\"hljs-keyword\">this</span>.logger.debug(<span class=\"hljs-string\">\"Refreshing \"</span> + <span class=\"hljs-keyword\">this</span>.getDisplayName());\n    &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">this</span>.initPropertySources();\n    <span class=\"hljs-keyword\">this</span>.getEnvironment().validateRequiredProperties();\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.earlyApplicationListeners == <span class=\"hljs-keyword\">null</span>) &#123;\n    <span class=\"hljs-keyword\">this</span>.earlyApplicationListeners = <span class=\"hljs-keyword\">new</span> LinkedHashSet(<span class=\"hljs-keyword\">this</span>.applicationListeners);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    <span class=\"hljs-keyword\">this</span>.applicationListeners.clear();\n    <span class=\"hljs-keyword\">this</span>.applicationListeners.addAll(<span class=\"hljs-keyword\">this</span>.earlyApplicationListeners);\n    &#125;\n\n    <span class=\"hljs-keyword\">this</span>.earlyApplicationEvents = <span class=\"hljs-keyword\">new</span> LinkedHashSet();\n&#125;</code></pre>\n</li>\n</ol>\n<h4 id=\"prepareBeanFactory-准备-BeanFactory\"><a href=\"#prepareBeanFactory-准备-BeanFactory\" class=\"headerlink\" title=\"prepareBeanFactory 准备 BeanFactory\"></a>prepareBeanFactory 准备 BeanFactory</h4><ol>\n<li>加载 <code>ClassLoader</code>、新增 <code>StandardBeanExpressionResolver</code> 标准的<code>Bean</code>表达式解析器、<code>ResourceEditorRegistrar</code> 属性编辑注册器</li>\n<li>添加 <code>ApplicationContextAwareProcessor</code> 后置处理器用于处理 Bean 初始化前后操作，忽略依赖接口列表新增<code>EnvironmentAware</code>、<code>ApplicationEventPushlisherAware</code>、<code>ResouceLoaderAware</code>、<code>EmbedderValueResolverAware</code>、<code>MessageSourceAware</code>、<code>ApplicationContextAware</code>接口，由于<code>ApplicationContextAwareProcesser</code>已实现以上功能</li>\n<li>新增<code>ApplicationListenerDetector</code> 监听器检测器用于内置 Bean 发布事件</li>\n<li>注册单例 Bean <code>environment</code>、<code>systemProperties</code>、<code>systemEnvironment</code><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepareBeanFactory</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;\n    <span class=\"hljs-comment\">// 设置 ClassLoader 用于加载 Bean </span>\n    beanFactory.setBeanClassLoader(<span class=\"hljs-keyword\">this</span>.getClassLoader());\n    <span class=\"hljs-comment\">// 设置 StandardBeanExpressionResolver（标准 Bean EL 表达式解析器） 用于解析#&#123;&#125;</span>\n    beanFactory.setBeanExpressionResolver(<span class=\"hljs-keyword\">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n    <span class=\"hljs-comment\">// 新增 属性编辑注册器 </span>\n    beanFactory.addPropertyEditorRegistrar(<span class=\"hljs-keyword\">new</span> ResourceEditorRegistrar(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span>.getEnvironment()));\n    <span class=\"hljs-comment\">// 新增 Bean 后置处理器</span>\n    beanFactory.addBeanPostProcessor(<span class=\"hljs-keyword\">new</span> ApplicationContextAwareProcessor(<span class=\"hljs-keyword\">this</span>));\n    <span class=\"hljs-comment\">// 忽略以下接口类依赖</span>\n    beanFactory.ignoreDependencyInterface(EnvironmentAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.ignoreDependencyInterface(MessageSourceAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    beanFactory.registerResolvableDependency(BeanFactory<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">beanFactory</span>)</span>;\n    beanFactory.registerResolvableDependency(ResourceLoader<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">this</span>)</span>;\n    beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">this</span>)</span>;\n    beanFactory.registerResolvableDependency(ApplicationContext<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">this</span>)</span>;\n    beanFactory.addBeanPostProcessor(<span class=\"hljs-keyword\">new</span> ApplicationListenerDetector(<span class=\"hljs-keyword\">this</span>));\n    <span class=\"hljs-keyword\">if</span> (beanFactory.containsBean(<span class=\"hljs-string\">\"loadTimeWeaver\"</span>)) &#123;\n        beanFactory.addBeanPostProcessor(<span class=\"hljs-keyword\">new</span> LoadTimeWeaverAwareProcessor(beanFactory));\n        beanFactory.setTempClassLoader(<span class=\"hljs-keyword\">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (!beanFactory.containsLocalBean(<span class=\"hljs-string\">\"environment\"</span>)) &#123;\n        beanFactory.registerSingleton(<span class=\"hljs-string\">\"environment\"</span>, <span class=\"hljs-keyword\">this</span>.getEnvironment());\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (!beanFactory.containsLocalBean(<span class=\"hljs-string\">\"systemProperties\"</span>)) &#123;\n        beanFactory.registerSingleton(<span class=\"hljs-string\">\"systemProperties\"</span>, <span class=\"hljs-keyword\">this</span>.getEnvironment().getSystemProperties());\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (!beanFactory.containsLocalBean(<span class=\"hljs-string\">\"systemEnvironment\"</span>)) &#123;\n        beanFactory.registerSingleton(<span class=\"hljs-string\">\"systemEnvironment\"</span>, <span class=\"hljs-keyword\">this</span>.getEnvironment().getSystemEnvironment());\n    &#125;\n\n&#125;</code></pre>\n</li>\n</ol>\n<h4 id=\"postProcessBeanFactory-后置处理器\"><a href=\"#postProcessBeanFactory-后置处理器\" class=\"headerlink\" title=\"postProcessBeanFactory 后置处理器\"></a>postProcessBeanFactory 后置处理器</h4><p>根据第三方组件拓展新增后置处理器忽略接口依赖<br><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// ServletWebServerApplicationContext 提供的方法 </span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postProcessBeanFactory</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;\n    beanFactory.addBeanPostProcessor(<span class=\"hljs-keyword\">new</span> WebApplicationContextServletContextAwareProcessor(<span class=\"hljs-keyword\">this</span>));\n    beanFactory.ignoreDependencyInterface(ServletContextAware<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    <span class=\"hljs-keyword\">this</span>.registerWebApplicationScopes();\n&#125;\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postProcessBeanFactory</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;\n    <span class=\"hljs-keyword\">super</span>.postProcessBeanFactory(beanFactory);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.basePackages != <span class=\"hljs-keyword\">null</span> &amp;&amp; <span class=\"hljs-keyword\">this</span>.basePackages.length &gt; <span class=\"hljs-number\">0</span>) &#123;\n        <span class=\"hljs-keyword\">this</span>.scanner.scan(<span class=\"hljs-keyword\">this</span>.basePackages);\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.annotatedClasses.isEmpty()) &#123;\n        <span class=\"hljs-keyword\">this</span>.reader.register(ClassUtils.toClassArray(<span class=\"hljs-keyword\">this</span>.annotatedClasses));\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"invokeBeanFactoryPostProcessors-调用-Bean-工厂后置处理器\"><a href=\"#invokeBeanFactoryPostProcessors-调用-Bean-工厂后置处理器\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors 调用 Bean 工厂后置处理器\"></a>invokeBeanFactoryPostProcessors 调用 Bean 工厂后置处理器</h4><ol>\n<li>迭代上下文中<code>beanFactoryPostProcessors</code> 后置处理器集合，如果是<code>BeanDefinitionRegistryPostProcessor</code> 则调用执行<code>postProcessBeanDefinitionRegistry</code>否则仅收集与<code>regularPostProcessors</code></li>\n<li>循环类型为<code>BeanDefinitionRegistryPostProcessor</code>的处理器名字集合判断<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">invokeBeanFactoryPostProcessors</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;\n    Set&lt;String&gt; processedBeans = <span class=\"hljs-keyword\">new</span> HashSet();\n    ArrayList regularPostProcessors;\n    ArrayList registryProcessors;\n    <span class=\"hljs-keyword\">int</span> var9;\n    ArrayList currentRegistryProcessors;\n    String[] postProcessorNames;\n    <span class=\"hljs-keyword\">if</span> (beanFactory <span class=\"hljs-keyword\">instanceof</span> BeanDefinitionRegistry) &#123;\n        BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;\n        regularPostProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n        registryProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n        Iterator var6 = beanFactoryPostProcessors.iterator();\n        <span class=\"hljs-comment\">// 迭代判断类型分配收集和执行 postProcessBeanDefinitionRegistry</span>\n        <span class=\"hljs-keyword\">while</span>(var6.hasNext()) &#123;\n            BeanFactoryPostProcessor postProcessor = (BeanFactoryPostProcessor)var6.next();\n            <span class=\"hljs-keyword\">if</span> (postProcessor <span class=\"hljs-keyword\">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;\n                BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor)postProcessor;\n                registryProcessor.postProcessBeanDefinitionRegistry(registry);\n                registryProcessors.add(registryProcessor);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                regularPostProcessors.add(postProcessor);\n            &#125;\n        &#125;\n\n        currentRegistryProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">true</span>, <span class=\"hljs-title\">false</span>)</span>;\n        String[] var16 = postProcessorNames;\n        var9 = postProcessorNames.length;\n\n        <span class=\"hljs-keyword\">int</span> var10;\n        String ppName;\n        <span class=\"hljs-comment\">// </span>\n        <span class=\"hljs-keyword\">for</span>(var10 = <span class=\"hljs-number\">0</span>; var10 &lt; var9; ++var10) &#123;\n            ppName = var16[var10];\n            <span class=\"hljs-keyword\">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)) </span>&#123;\n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n                processedBeans.add(ppName);\n            &#125;\n        &#125;\n\n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n        registryProcessors.addAll(currentRegistryProcessors);\n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n        currentRegistryProcessors.clear();\n        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">true</span>, <span class=\"hljs-title\">false</span>)</span>;\n        var16 = postProcessorNames;\n        var9 = postProcessorNames.length;\n\n        <span class=\"hljs-keyword\">for</span>(var10 = <span class=\"hljs-number\">0</span>; var10 &lt; var9; ++var10) &#123;\n            ppName = var16[var10];\n            <span class=\"hljs-keyword\">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)) </span>&#123;\n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n                processedBeans.add(ppName);\n            &#125;\n        &#125;\n\n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n        registryProcessors.addAll(currentRegistryProcessors);\n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n        currentRegistryProcessors.clear();\n        <span class=\"hljs-keyword\">boolean</span> reiterate = <span class=\"hljs-keyword\">true</span>;\n\n        <span class=\"hljs-keyword\">while</span>(reiterate) &#123;\n            reiterate = <span class=\"hljs-keyword\">false</span>;\n            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">true</span>, <span class=\"hljs-title\">false</span>)</span>;\n            String[] var19 = postProcessorNames;\n            var10 = postProcessorNames.length;\n\n            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> var26 = <span class=\"hljs-number\">0</span>; var26 &lt; var10; ++var26) &#123;\n                String ppName = var19[var26];\n                <span class=\"hljs-keyword\">if</span> (!processedBeans.contains(ppName)) &#123;\n                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n                    processedBeans.add(ppName);\n                    reiterate = <span class=\"hljs-keyword\">true</span>;\n                &#125;\n            &#125;\n\n            sortPostProcessors(currentRegistryProcessors, beanFactory);\n            registryProcessors.addAll(currentRegistryProcessors);\n            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n            currentRegistryProcessors.clear();\n        &#125;\n\n        invokeBeanFactoryPostProcessors((Collection)registryProcessors, (ConfigurableListableBeanFactory)beanFactory);\n        invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        invokeBeanFactoryPostProcessors((Collection)beanFactoryPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    &#125;\n\n    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, <span class=\"hljs-title\">true</span>, <span class=\"hljs-title\">false</span>)</span>;\n    regularPostProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n    registryProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n    currentRegistryProcessors = <span class=\"hljs-keyword\">new</span> ArrayList();\n    postProcessorNames = postProcessorNames;\n    <span class=\"hljs-keyword\">int</span> var20 = postProcessorNames.length;\n\n    String ppName;\n    <span class=\"hljs-keyword\">for</span>(var9 = <span class=\"hljs-number\">0</span>; var9 &lt; var20; ++var9) &#123;\n        ppName = postProcessorNames[var9];\n        <span class=\"hljs-keyword\">if</span> (!processedBeans.contains(ppName)) &#123;\n            <span class=\"hljs-keyword\">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)) </span>&#123;\n                regularPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)) </span>&#123;\n                registryProcessors.add(ppName);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                currentRegistryProcessors.add(ppName);\n            &#125;\n        &#125;\n    &#125;\n\n    sortPostProcessors(regularPostProcessors, beanFactory);\n    invokeBeanFactoryPostProcessors((Collection)regularPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class=\"hljs-keyword\">new</span> ArrayList(registryProcessors.size());\n    Iterator var21 = registryProcessors.iterator();\n\n    <span class=\"hljs-keyword\">while</span>(var21.hasNext()) &#123;\n        String postProcessorName = (String)var21.next();\n        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n    &#125;\n\n    sortPostProcessors(orderedPostProcessors, beanFactory);\n    invokeBeanFactoryPostProcessors((Collection)orderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class=\"hljs-keyword\">new</span> ArrayList(currentRegistryProcessors.size());\n    Iterator var24 = currentRegistryProcessors.iterator();\n\n    <span class=\"hljs-keyword\">while</span>(var24.hasNext()) &#123;\n        ppName = (String)var24.next();\n        nonOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n    &#125;\n\n    invokeBeanFactoryPostProcessors((Collection)nonOrderedPostProcessors, (ConfigurableListableBeanFactory)beanFactory);\n    beanFactory.clearMetadataCache();\n&#125;</code></pre>\n</li>\n</ol>\n"},{"title":"SpringMVC 运行原理","date":"2019-04-22T06:56:12.000Z","_content":"![](/images/spring.jpg)\n> 面试经常会问到 SpringMVC 运行原理真是一脸懵逼，太细节的都不记得了就知道撸代码，现在记录并复习下。\n\n### SpringMVC 工作原理\n![SpringMVC 工作流程](/images/springmvc.jpg)\n1. 用户通过浏览器访问项目，请求会发送到`DispatcherServlet`前端控制器\n2. 通过`HandlerMapping`找到对应的`Controller`对应注解`@RequestMapping`的值\n3. 根据`Controller`方法通过`HandlerAdapter`处理适配器查找`handler`\n4. `HandlerAdapter`执行适配的`handler`开始正式的业务逻辑执行\n5. 处理完业务会返回`ModleAndView`，`Model`为返回数据，`View`为返回的视图\n6. 根据`View`执行`ViewResolver`找到对应逻辑页面\n7. `DispatcherSerlvet`会把`Model`传给`View`进行页面渲染\n\n### DispatcherServlet\n前端控制器是 SpringMVC 的核心是所有请求的入口函数，处理请求、转发请求、处理结果、返回结果，默认初始化一些`HandlerAdapter`、`HandMapping`、`HandlerExceptionResolver`等组件\n``` java\nstatic {\n        try {\n            ClassPathResource resource = new ClassPathResource(\"DispatcherServlet.properties\", DispatcherServlet.class);\n            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n        } catch (IOException var1) {\n            throw new IllegalStateException(\"Could not load 'DispatcherServlet.properties': \" + var1.getMessage());\n        }\n    }\n```\n读取`DispatcherServlet.properties`初始化使用的策略\n``` java\nprotected void onRefresh(ApplicationContext context) {\n    this.initStrategies(context);\n}\n\nprotected void initStrategies(ApplicationContext context) {\n    this.initMultipartResolver(context);\n    this.initLocaleResolver(context);\n    this.initThemeResolver(context);\n    this.initHandlerMappings(context);\n    this.initHandlerAdapters(context);\n    this.initHandlerExceptionResolvers(context);\n    this.initRequestToViewNameTranslator(context);\n    this.initViewResolvers(context);\n    this.initFlashMapManager(context);\n}\n```\n通过继承`FrameworkServlet`抽象类复写`onRefresh`方法，根据上下文`ApplicationContext`对象执行`initStrategies`初始化策略。\n\n### HandlerMapping\n根据请求的`Url`找到对应的`Handler`，即我们项目中平时所谓的`Controller`，我们可以通过配置文件、注解方式、实现接口方式。\n![HandlerMapping 类图](/images/HandlerMapping.png)\n- **BeanNameUrlHandlerMapping** 通过`bean`名称或别名，必须已`/`开头和方法类必须实现`Controller`接口。\n``` java\n<bean name=\"/beanNameUrlController\" class=\"com.test.web.MessageControl\"/>\n\npublic class MessageControl implements Controller {\n    public ModelAndView handleRequest(HttpServletRequest request,\n           HttpServletResponseresponse) throws Exception {\n       ModelAndView mav = new ModelAndView(\"index\");\n       return mav;\n    }\n}\n```\n\n- **SimpleUrlHandlerMapping** \n``` java\n\n<bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n    <property name=\"mappings\">\n        <props>\n            <prop key=\"/test.do\">testController</prop>\n        </props>\n     </property>\n</bean>\n<bean id=\"testController\" class=\"com.test.controller.SimpleUrlHandlerMappingController\" />\n \n \npublic class SimpleUrlHandlerMappingController implements Controller {\n    protected final Log logger = LogFactory.getLog(this.getClass());\n    //@Override\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        logger.info(\"run here\");\n        return null;\n}\n```\n\n- **RequestMappingHandlerMapping** 项目中最常用的一种配置方法，配合`@Controller`和`@RequestMapping`一起使用。\n``` java\n\n<!-- 注册HandlerMapper、HandlerAdapter两个映射类 -->\n<mvc:annotation-driven />\n \n<!-- 访问静态资源 -->\n<mvc:default-servlet-handler />\n \n<!-- 配置扫描的包 -->\n<context:component-scan base-package=\"com.test.*\" />\n \n@RestController\n@RequestMapping(\"/hello\")\npublic class HelloController {\n    protected final Log logger = LogFactory.getLog(this.getClass());\n \n    @RequestMapping(\"/index\")\n    public String index(){\n        return \"test\";\n}\n```","source":"_posts/SpringMVC 工作原理.md","raw":"---\ntitle: SpringMVC 运行原理\ndate: 2019-04-22 14:56:12\ncategories: [Java]\ntags:\n\t - Spring\n---\n![](/images/spring.jpg)\n> 面试经常会问到 SpringMVC 运行原理真是一脸懵逼，太细节的都不记得了就知道撸代码，现在记录并复习下。\n\n### SpringMVC 工作原理\n![SpringMVC 工作流程](/images/springmvc.jpg)\n1. 用户通过浏览器访问项目，请求会发送到`DispatcherServlet`前端控制器\n2. 通过`HandlerMapping`找到对应的`Controller`对应注解`@RequestMapping`的值\n3. 根据`Controller`方法通过`HandlerAdapter`处理适配器查找`handler`\n4. `HandlerAdapter`执行适配的`handler`开始正式的业务逻辑执行\n5. 处理完业务会返回`ModleAndView`，`Model`为返回数据，`View`为返回的视图\n6. 根据`View`执行`ViewResolver`找到对应逻辑页面\n7. `DispatcherSerlvet`会把`Model`传给`View`进行页面渲染\n\n### DispatcherServlet\n前端控制器是 SpringMVC 的核心是所有请求的入口函数，处理请求、转发请求、处理结果、返回结果，默认初始化一些`HandlerAdapter`、`HandMapping`、`HandlerExceptionResolver`等组件\n``` java\nstatic {\n        try {\n            ClassPathResource resource = new ClassPathResource(\"DispatcherServlet.properties\", DispatcherServlet.class);\n            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n        } catch (IOException var1) {\n            throw new IllegalStateException(\"Could not load 'DispatcherServlet.properties': \" + var1.getMessage());\n        }\n    }\n```\n读取`DispatcherServlet.properties`初始化使用的策略\n``` java\nprotected void onRefresh(ApplicationContext context) {\n    this.initStrategies(context);\n}\n\nprotected void initStrategies(ApplicationContext context) {\n    this.initMultipartResolver(context);\n    this.initLocaleResolver(context);\n    this.initThemeResolver(context);\n    this.initHandlerMappings(context);\n    this.initHandlerAdapters(context);\n    this.initHandlerExceptionResolvers(context);\n    this.initRequestToViewNameTranslator(context);\n    this.initViewResolvers(context);\n    this.initFlashMapManager(context);\n}\n```\n通过继承`FrameworkServlet`抽象类复写`onRefresh`方法，根据上下文`ApplicationContext`对象执行`initStrategies`初始化策略。\n\n### HandlerMapping\n根据请求的`Url`找到对应的`Handler`，即我们项目中平时所谓的`Controller`，我们可以通过配置文件、注解方式、实现接口方式。\n![HandlerMapping 类图](/images/HandlerMapping.png)\n- **BeanNameUrlHandlerMapping** 通过`bean`名称或别名，必须已`/`开头和方法类必须实现`Controller`接口。\n``` java\n<bean name=\"/beanNameUrlController\" class=\"com.test.web.MessageControl\"/>\n\npublic class MessageControl implements Controller {\n    public ModelAndView handleRequest(HttpServletRequest request,\n           HttpServletResponseresponse) throws Exception {\n       ModelAndView mav = new ModelAndView(\"index\");\n       return mav;\n    }\n}\n```\n\n- **SimpleUrlHandlerMapping** \n``` java\n\n<bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n    <property name=\"mappings\">\n        <props>\n            <prop key=\"/test.do\">testController</prop>\n        </props>\n     </property>\n</bean>\n<bean id=\"testController\" class=\"com.test.controller.SimpleUrlHandlerMappingController\" />\n \n \npublic class SimpleUrlHandlerMappingController implements Controller {\n    protected final Log logger = LogFactory.getLog(this.getClass());\n    //@Override\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        logger.info(\"run here\");\n        return null;\n}\n```\n\n- **RequestMappingHandlerMapping** 项目中最常用的一种配置方法，配合`@Controller`和`@RequestMapping`一起使用。\n``` java\n\n<!-- 注册HandlerMapper、HandlerAdapter两个映射类 -->\n<mvc:annotation-driven />\n \n<!-- 访问静态资源 -->\n<mvc:default-servlet-handler />\n \n<!-- 配置扫描的包 -->\n<context:component-scan base-package=\"com.test.*\" />\n \n@RestController\n@RequestMapping(\"/hello\")\npublic class HelloController {\n    protected final Log logger = LogFactory.getLog(this.getClass());\n \n    @RequestMapping(\"/index\")\n    public String index(){\n        return \"test\";\n}\n```","slug":"SpringMVC 工作原理","published":1,"updated":"2020-08-10T01:48:44.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc99b003hjsudx1fn4420","content":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>面试经常会问到 SpringMVC 运行原理真是一脸懵逼，太细节的都不记得了就知道撸代码，现在记录并复习下。</p>\n</blockquote>\n<h3 id=\"SpringMVC-工作原理\"><a href=\"#SpringMVC-工作原理\" class=\"headerlink\" title=\"SpringMVC 工作原理\"></a>SpringMVC 工作原理</h3><p><img src=\"/images/springmvc.jpg\" srcset=\"/img/loading.gif\" alt=\"SpringMVC 工作流程\"></p>\n<ol>\n<li>用户通过浏览器访问项目，请求会发送到<code>DispatcherServlet</code>前端控制器</li>\n<li>通过<code>HandlerMapping</code>找到对应的<code>Controller</code>对应注解<code>@RequestMapping</code>的值</li>\n<li>根据<code>Controller</code>方法通过<code>HandlerAdapter</code>处理适配器查找<code>handler</code></li>\n<li><code>HandlerAdapter</code>执行适配的<code>handler</code>开始正式的业务逻辑执行</li>\n<li>处理完业务会返回<code>ModleAndView</code>，<code>Model</code>为返回数据，<code>View</code>为返回的视图</li>\n<li>根据<code>View</code>执行<code>ViewResolver</code>找到对应逻辑页面</li>\n<li><code>DispatcherSerlvet</code>会把<code>Model</code>传给<code>View</code>进行页面渲染</li>\n</ol>\n<h3 id=\"DispatcherServlet\"><a href=\"#DispatcherServlet\" class=\"headerlink\" title=\"DispatcherServlet\"></a>DispatcherServlet</h3><p>前端控制器是 SpringMVC 的核心是所有请求的入口函数，处理请求、转发请求、处理结果、返回结果，默认初始化一些<code>HandlerAdapter</code>、<code>HandMapping</code>、<code>HandlerExceptionResolver</code>等组件<br><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> &#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            ClassPathResource resource = <span class=\"hljs-keyword\">new</span> ClassPathResource(<span class=\"hljs-string\">\"DispatcherServlet.properties\"</span>, DispatcherServlet<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n        &#125; <span class=\"hljs-keyword\">catch</span> (IOException var1) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Could not load 'DispatcherServlet.properties': \"</span> + var1.getMessage());\n        &#125;\n    &#125;</code></pre></p>\n<p>读取<code>DispatcherServlet.properties</code>初始化使用的策略<br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onRefresh</span><span class=\"hljs-params\">(ApplicationContext context)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.initStrategies(context);\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initStrategies</span><span class=\"hljs-params\">(ApplicationContext context)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.initMultipartResolver(context);\n    <span class=\"hljs-keyword\">this</span>.initLocaleResolver(context);\n    <span class=\"hljs-keyword\">this</span>.initThemeResolver(context);\n    <span class=\"hljs-keyword\">this</span>.initHandlerMappings(context);\n    <span class=\"hljs-keyword\">this</span>.initHandlerAdapters(context);\n    <span class=\"hljs-keyword\">this</span>.initHandlerExceptionResolvers(context);\n    <span class=\"hljs-keyword\">this</span>.initRequestToViewNameTranslator(context);\n    <span class=\"hljs-keyword\">this</span>.initViewResolvers(context);\n    <span class=\"hljs-keyword\">this</span>.initFlashMapManager(context);\n&#125;</code></pre></p>\n<p>通过继承<code>FrameworkServlet</code>抽象类复写<code>onRefresh</code>方法，根据上下文<code>ApplicationContext</code>对象执行<code>initStrategies</code>初始化策略。</p>\n<h3 id=\"HandlerMapping\"><a href=\"#HandlerMapping\" class=\"headerlink\" title=\"HandlerMapping\"></a>HandlerMapping</h3><p>根据请求的<code>Url</code>找到对应的<code>Handler</code>，即我们项目中平时所谓的<code>Controller</code>，我们可以通过配置文件、注解方式、实现接口方式。<br><img src=\"/images/HandlerMapping.png\" srcset=\"/img/loading.gif\" alt=\"HandlerMapping 类图\"></p>\n<ul>\n<li><p><strong>BeanNameUrlHandlerMapping</strong> 通过<code>bean</code>名称或别名，必须已<code>/</code>开头和方法类必须实现<code>Controller</code>接口。</p>\n<pre><code class=\"hljs java\">&lt;bean name=<span class=\"hljs-string\">\"/beanNameUrlController\"</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">\"com.test.web.MessageControl\"</span>/&gt;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageControl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Controller</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ModelAndView <span class=\"hljs-title\">handleRequest</span><span class=\"hljs-params\">(HttpServletRequest request,\n           HttpServletResponseresponse)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n       ModelAndView mav = <span class=\"hljs-keyword\">new</span> ModelAndView(<span class=\"hljs-string\">\"index\"</span>);\n       <span class=\"hljs-keyword\">return</span> mav;\n    &#125;\n&#125;</code></pre>\n</li>\n<li><p><strong>SimpleUrlHandlerMapping</strong> </p>\n<pre><code class=\"hljs java\">\n&lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt;\n    &lt;property name=\"mappings\"&gt;\n        &lt;props&gt;\n            &lt;prop key=\"/test.do\"&gt;testController&lt;/prop&gt;\n        &lt;/props&gt;\n     &lt;/property&gt;\n&lt;/bean&gt;\n&lt;bean id=\"testController\" class=\"com.test.controller.SimpleUrlHandlerMappingController\" /&gt;\n \n \npublic class SimpleUrlHandlerMappingController implements Controller &#123;\n    protected final Log logger = LogFactory.getLog(this.getClass());\n    //@Override\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        logger.info(\"run here\");\n        return null;\n&#125;</code></pre>\n</li>\n<li><p><strong>RequestMappingHandlerMapping</strong> 项目中最常用的一种配置方法，配合<code>@Controller</code>和<code>@RequestMapping</code>一起使用。</p>\n<pre><code class=\"hljs java\">\n&lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;\n&lt;mvc:annotation-driven /&gt;\n \n&lt;!-- 访问静态资源 --&gt;\n&lt;mvc:<span class=\"hljs-keyword\">default</span>-servlet-handler /&gt;\n \n&lt;!-- 配置扫描的包 --&gt;\n&lt;context:component-scan base-<span class=\"hljs-keyword\">package</span>=<span class=\"hljs-string\">\"com.test.*\"</span> /&gt;\n \n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>&#123;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">final</span> Log logger = LogFactory.getLog(<span class=\"hljs-keyword\">this</span>.getClass());\n \n    <span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/index\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">index</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"test\"</span>;\n&#125;</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>面试经常会问到 SpringMVC 运行原理真是一脸懵逼，太细节的都不记得了就知道撸代码，现在记录并复习下。</p>\n</blockquote>\n<h3 id=\"SpringMVC-工作原理\"><a href=\"#SpringMVC-工作原理\" class=\"headerlink\" title=\"SpringMVC 工作原理\"></a>SpringMVC 工作原理</h3><p><img src=\"/images/springmvc.jpg\" srcset=\"/img/loading.gif\" alt=\"SpringMVC 工作流程\"></p>\n<ol>\n<li>用户通过浏览器访问项目，请求会发送到<code>DispatcherServlet</code>前端控制器</li>\n<li>通过<code>HandlerMapping</code>找到对应的<code>Controller</code>对应注解<code>@RequestMapping</code>的值</li>\n<li>根据<code>Controller</code>方法通过<code>HandlerAdapter</code>处理适配器查找<code>handler</code></li>\n<li><code>HandlerAdapter</code>执行适配的<code>handler</code>开始正式的业务逻辑执行</li>\n<li>处理完业务会返回<code>ModleAndView</code>，<code>Model</code>为返回数据，<code>View</code>为返回的视图</li>\n<li>根据<code>View</code>执行<code>ViewResolver</code>找到对应逻辑页面</li>\n<li><code>DispatcherSerlvet</code>会把<code>Model</code>传给<code>View</code>进行页面渲染</li>\n</ol>\n<h3 id=\"DispatcherServlet\"><a href=\"#DispatcherServlet\" class=\"headerlink\" title=\"DispatcherServlet\"></a>DispatcherServlet</h3><p>前端控制器是 SpringMVC 的核心是所有请求的入口函数，处理请求、转发请求、处理结果、返回结果，默认初始化一些<code>HandlerAdapter</code>、<code>HandMapping</code>、<code>HandlerExceptionResolver</code>等组件<br><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> &#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            ClassPathResource resource = <span class=\"hljs-keyword\">new</span> ClassPathResource(<span class=\"hljs-string\">\"DispatcherServlet.properties\"</span>, DispatcherServlet<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n        &#125; <span class=\"hljs-keyword\">catch</span> (IOException var1) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Could not load 'DispatcherServlet.properties': \"</span> + var1.getMessage());\n        &#125;\n    &#125;</code></pre></p>\n<p>读取<code>DispatcherServlet.properties</code>初始化使用的策略<br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onRefresh</span><span class=\"hljs-params\">(ApplicationContext context)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.initStrategies(context);\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initStrategies</span><span class=\"hljs-params\">(ApplicationContext context)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.initMultipartResolver(context);\n    <span class=\"hljs-keyword\">this</span>.initLocaleResolver(context);\n    <span class=\"hljs-keyword\">this</span>.initThemeResolver(context);\n    <span class=\"hljs-keyword\">this</span>.initHandlerMappings(context);\n    <span class=\"hljs-keyword\">this</span>.initHandlerAdapters(context);\n    <span class=\"hljs-keyword\">this</span>.initHandlerExceptionResolvers(context);\n    <span class=\"hljs-keyword\">this</span>.initRequestToViewNameTranslator(context);\n    <span class=\"hljs-keyword\">this</span>.initViewResolvers(context);\n    <span class=\"hljs-keyword\">this</span>.initFlashMapManager(context);\n&#125;</code></pre></p>\n<p>通过继承<code>FrameworkServlet</code>抽象类复写<code>onRefresh</code>方法，根据上下文<code>ApplicationContext</code>对象执行<code>initStrategies</code>初始化策略。</p>\n<h3 id=\"HandlerMapping\"><a href=\"#HandlerMapping\" class=\"headerlink\" title=\"HandlerMapping\"></a>HandlerMapping</h3><p>根据请求的<code>Url</code>找到对应的<code>Handler</code>，即我们项目中平时所谓的<code>Controller</code>，我们可以通过配置文件、注解方式、实现接口方式。<br><img src=\"/images/HandlerMapping.png\" srcset=\"/img/loading.gif\" alt=\"HandlerMapping 类图\"></p>\n<ul>\n<li><p><strong>BeanNameUrlHandlerMapping</strong> 通过<code>bean</code>名称或别名，必须已<code>/</code>开头和方法类必须实现<code>Controller</code>接口。</p>\n<pre><code class=\"hljs java\">&lt;bean name=<span class=\"hljs-string\">\"/beanNameUrlController\"</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">\"com.test.web.MessageControl\"</span>/&gt;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageControl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Controller</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ModelAndView <span class=\"hljs-title\">handleRequest</span><span class=\"hljs-params\">(HttpServletRequest request,\n           HttpServletResponseresponse)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n       ModelAndView mav = <span class=\"hljs-keyword\">new</span> ModelAndView(<span class=\"hljs-string\">\"index\"</span>);\n       <span class=\"hljs-keyword\">return</span> mav;\n    &#125;\n&#125;</code></pre>\n</li>\n<li><p><strong>SimpleUrlHandlerMapping</strong> </p>\n<pre><code class=\"hljs java\">\n&lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt;\n    &lt;property name=\"mappings\"&gt;\n        &lt;props&gt;\n            &lt;prop key=\"/test.do\"&gt;testController&lt;/prop&gt;\n        &lt;/props&gt;\n     &lt;/property&gt;\n&lt;/bean&gt;\n&lt;bean id=\"testController\" class=\"com.test.controller.SimpleUrlHandlerMappingController\" /&gt;\n \n \npublic class SimpleUrlHandlerMappingController implements Controller &#123;\n    protected final Log logger = LogFactory.getLog(this.getClass());\n    //@Override\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        logger.info(\"run here\");\n        return null;\n&#125;</code></pre>\n</li>\n<li><p><strong>RequestMappingHandlerMapping</strong> 项目中最常用的一种配置方法，配合<code>@Controller</code>和<code>@RequestMapping</code>一起使用。</p>\n<pre><code class=\"hljs java\">\n&lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;\n&lt;mvc:annotation-driven /&gt;\n \n&lt;!-- 访问静态资源 --&gt;\n&lt;mvc:<span class=\"hljs-keyword\">default</span>-servlet-handler /&gt;\n \n&lt;!-- 配置扫描的包 --&gt;\n&lt;context:component-scan base-<span class=\"hljs-keyword\">package</span>=<span class=\"hljs-string\">\"com.test.*\"</span> /&gt;\n \n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>&#123;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">final</span> Log logger = LogFactory.getLog(<span class=\"hljs-keyword\">this</span>.getClass());\n \n    <span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/index\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">index</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"test\"</span>;\n&#125;</code></pre></li>\n</ul>\n"},{"title":"SpringBoot 启动源码解析（一）之初见","toc":false,"date":"2020-04-14T06:14:36.000Z","_content":"![](/images/spring.jpg)\n> Springboot 启动流程一直面试都会问到，所以看看源码学习它是如何启动并完成利用了那些技术\n\n### SpringBoot 实例化\nSpringBoot 以`main`方法来启动项目构造方法，调用静态方法`run`内部在实例化 SpringApplication 从参数来看，我们可以启动多个 SpringApplication\n``` java\n\npublic static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {\n        return run(new Class[]{primarySource}, args);\n}\n\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n        return (new SpringApplication(primarySources)).run(args);\n}\n\n```\n\nSpringApplication 的构造方法用于初始化各种默认参数监听器、初始化器、WebApplicationType、命令行参数等\n\n``` java\n// SpringApplication 构造方法\npublic SpringApplication(Object... sources) {\n    this.sources = new LinkedHashSet();\n    // 控制台打印\n    this.bannerMode = Mode.CONSOLE;\n    // 开启日志\n    this.logStartupInfo = true;\n    // 开启命令行参数 以 -- 开头\n    this.addCommandLineProperties = true;\n    // 开启转化 service\n    this.addConversionService = true;\n    // 开启无头\n    this.headless = true;\n    // 开启注册关闭 Hook\n    this.registerShutdownHook = true;\n    // 额外 profiles\n    this.additionalProfiles = new HashSet();\n    // 自定义环境\n    this.isCustomEnvironment = false;\n    // 资源装载类\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    // 主要参数 args[]\n    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));\n    // 判断应用类型 WebApplicationType 枚举 ReActive、Servlet、None \n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    // 加载初始化器和监听器 \n    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n    // 判断 main 方法入口类\n    this.mainApplicationClass = this.deduceMainApplicationClass();\n}\n```\n\n#### WebApplicationType.deduceFromClasspath() 应用类型判断\n用于判断当前项目是否为`Servlet`环境，看代码可知通过不存在`DispatcherHandler`（分发处理器）、`DispatcherServlet`（分发中心）、`ServletContainer`（Servlet 容器）3个类来判断响应式应用，通过存在`Servlet`、`ConfigurableWebApplicationContext`同时存在来判断`Servlet`环境\n\n``` java\nstatic WebApplicationType deduceFromClasspath() {\n    if (ClassUtils.isPresent(\"org.springframework.web.reactive.DispatcherHandler\", (ClassLoader)null) && !ClassUtils.isPresent(\"org.springframework.web.servlet.DispatcherServlet\", (ClassLoader)null) && !ClassUtils.isPresent(\"org.glassfish.jersey.servlet.ServletContainer\", (ClassLoader)null)) {\n        return REACTIVE;\n    } else {\n        String[] var0 = SERVLET_INDICATOR_CLASSES;\n        int var1 = var0.length;\n\n        for(int var2 = 0; var2 < var1; ++var2) {\n            String className = var0[var2];\n            if (!ClassUtils.isPresent(className, (ClassLoader)null)) {\n                return NONE;\n            }\n        }\n        return SERVLET;\n    }\n}\n```\n\n#### setInitializers、setListeners 初始化监听器和初始化器\n\n监听器和初始化器都用调用`getSpringFactoriesInstances`来进行实例化\n``` java\nprivate <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {\n    ClassLoader classLoader = this.getClassLoader();\n    // 获取配置文件中的 ClassName\n    Set<String> names = new LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));\n    // 根据类型创建实例\n    List<T> instances = this.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);\n    // 按照优先级排序\n    AnnotationAwareOrderComparator.sort(instances);\n    return instances;\n}\n```\n\n通过`SpringFactoriesLoader.loadSpringFactories`遍历获取所有依赖包中`META-INF/spring.factories`文件解析出键值对`Map<String, List<String>>`集合，很多第三方组件`starter`就是编写`spring.factories`来实现自动装配功能，这里使用了静态缓存`SpringFactoriesLoader.cache`只需一次解析下次直接读取缓存\n\n``` java\nprivate static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n    MultiValueMap<String, String> result = (MultiValueMap)cache.get(classLoader);\n    if (result != null) {\n            return result;\n    } else {\n        try {\n            Enumeration<URL> urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\");\n            LinkedMultiValueMap result = new LinkedMultiValueMap();\n\n            while(urls.hasMoreElements()) {\n                URL url = (URL)urls.nextElement();\n                UrlResource resource = new UrlResource(url);\n                Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n                Iterator var6 = properties.entrySet().iterator();\n\n                while(var6.hasNext()) {\n                    Entry<?, ?> entry = (Entry)var6.next();\n                    String factoryClassName = ((String)entry.getKey()).trim();\n                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());\n                    int var10 = var9.length;\n\n                    for(int var11 = 0; var11 < var10; ++var11) {\n                        String factoryName = var9[var11];\n                        result.add(factoryClassName, factoryName.trim());\n                    }\n                }\n            }\n\n                cache.put(classLoader, result);\n                return result;\n            } catch (IOException var13) {\n                throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var13);\n            }\n        }\n    }\n```\n\n通过`createSpringFactoriesInstances`利用类反射特性来实例化之前获取`Class`集合\n\n``` java\nprivate <T> List<T> createSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, ClassLoader classLoader, Object[] args, Set<String> names) {\n    List<T> instances = new ArrayList(names.size());\n    Iterator var7 = names.iterator();\n\n    while(var7.hasNext()) {\n        String name = (String)var7.next();\n\n        try {\n            Class<?> instanceClass = ClassUtils.forName(name, classLoader);\n            Assert.isAssignable(type, instanceClass);\n            Constructor<?> constructor = instanceClass.getDeclaredConstructor(parameterTypes);\n            T instance = BeanUtils.instantiateClass(constructor, args);\n            instances.add(instance);\n        } catch (Throwable var12) {\n            throw new IllegalArgumentException(\"Cannot instantiate \" + type + \" : \" + name, var12);\n        }\n    }\n        return instances;\n    }\n```\n\n#### deduceMainApplicationClass 判断 main Class\n获取当前线程堆栈跟踪元素然后遍历调用链判断每个方法名称是否为`main`获取入口类\n``` java\nprivate Class<?> deduceMainApplicationClass() {\n    try {\n        StackTraceElement[] stackTrace = (new RuntimeException()).getStackTrace();\n        StackTraceElement[] var2 = stackTrace;\n        int var3 = stackTrace.length;\n\n        for(int var4 = 0; var4 < var3; ++var4) {\n            StackTraceElement stackTraceElement = var2[var4];\n            if (\"main\".equals(stackTraceElement.getMethodName())) {\n                return Class.forName(stackTraceElement.getClassName());\n            }\n        }\n    } catch (ClassNotFoundException var6) {\n    }\n\n    return null;\n}   \n```\n\n### SpringBoot run 方法\nSpringApplication `run` 方法就是正式开始环境配置刷新容器等操作，下一节会仔细讲解每一步代码流程\n\n``` java\npublic ConfigurableApplicationContext run(String... args) {\n    // 监控器实例化\n    StopWatch stopWatch = new StopWatch();\n    // 启动监控器\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList();\n    // 无头配置初始化\n    this.configureHeadlessProperty();\n    // 初始化 SpringApplicationRunListeners 并开启\n    SpringApplicationRunListeners listeners = this.getRunListeners(args);\n    listeners.starting();\n    Collection exceptionReporters;\n    try {\n        // 初始化应用参数\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\t\n        // 初始化配置环境 （property）\n        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);\n        this.configureIgnoreBeanInfo(environment);\n        Banner printedBanner = this.printBanner(environment);\n        context = this.createApplicationContext();\n        // 初始化异常上报\n        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class,new Class[]{ConfigurableApplicationContext.class},context);\n        // 准备刷新容器\n        this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n        this.refreshContext(context);\n        this.afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);\n        }\n        listeners.started(context);\n        this.callRunners(context, applicationArguments);\n    } catch (Throwable var10) {\n        this.handleRunFailure(context, var10, exceptionReporters, listeners);\n        throw new IllegalStateException(var10);\n    }\n\n    try {\n        listeners.running(context);\n        return context;\n    } catch (Throwable var9) {\n        this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);\n        throw new IllegalStateException(var9);\n    }\n}\n```\n","source":"_posts/Springboot 启动过程（一）.md","raw":"---\ntitle: SpringBoot 启动源码解析（一）之初见\ntags:\n  - Spring\ncategories:\n  - Spring\ntoc: false\ndate: 2020-04-14 14:14:36\n---\n![](/images/spring.jpg)\n> Springboot 启动流程一直面试都会问到，所以看看源码学习它是如何启动并完成利用了那些技术\n\n### SpringBoot 实例化\nSpringBoot 以`main`方法来启动项目构造方法，调用静态方法`run`内部在实例化 SpringApplication 从参数来看，我们可以启动多个 SpringApplication\n``` java\n\npublic static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {\n        return run(new Class[]{primarySource}, args);\n}\n\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n        return (new SpringApplication(primarySources)).run(args);\n}\n\n```\n\nSpringApplication 的构造方法用于初始化各种默认参数监听器、初始化器、WebApplicationType、命令行参数等\n\n``` java\n// SpringApplication 构造方法\npublic SpringApplication(Object... sources) {\n    this.sources = new LinkedHashSet();\n    // 控制台打印\n    this.bannerMode = Mode.CONSOLE;\n    // 开启日志\n    this.logStartupInfo = true;\n    // 开启命令行参数 以 -- 开头\n    this.addCommandLineProperties = true;\n    // 开启转化 service\n    this.addConversionService = true;\n    // 开启无头\n    this.headless = true;\n    // 开启注册关闭 Hook\n    this.registerShutdownHook = true;\n    // 额外 profiles\n    this.additionalProfiles = new HashSet();\n    // 自定义环境\n    this.isCustomEnvironment = false;\n    // 资源装载类\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    // 主要参数 args[]\n    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));\n    // 判断应用类型 WebApplicationType 枚举 ReActive、Servlet、None \n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    // 加载初始化器和监听器 \n    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n    // 判断 main 方法入口类\n    this.mainApplicationClass = this.deduceMainApplicationClass();\n}\n```\n\n#### WebApplicationType.deduceFromClasspath() 应用类型判断\n用于判断当前项目是否为`Servlet`环境，看代码可知通过不存在`DispatcherHandler`（分发处理器）、`DispatcherServlet`（分发中心）、`ServletContainer`（Servlet 容器）3个类来判断响应式应用，通过存在`Servlet`、`ConfigurableWebApplicationContext`同时存在来判断`Servlet`环境\n\n``` java\nstatic WebApplicationType deduceFromClasspath() {\n    if (ClassUtils.isPresent(\"org.springframework.web.reactive.DispatcherHandler\", (ClassLoader)null) && !ClassUtils.isPresent(\"org.springframework.web.servlet.DispatcherServlet\", (ClassLoader)null) && !ClassUtils.isPresent(\"org.glassfish.jersey.servlet.ServletContainer\", (ClassLoader)null)) {\n        return REACTIVE;\n    } else {\n        String[] var0 = SERVLET_INDICATOR_CLASSES;\n        int var1 = var0.length;\n\n        for(int var2 = 0; var2 < var1; ++var2) {\n            String className = var0[var2];\n            if (!ClassUtils.isPresent(className, (ClassLoader)null)) {\n                return NONE;\n            }\n        }\n        return SERVLET;\n    }\n}\n```\n\n#### setInitializers、setListeners 初始化监听器和初始化器\n\n监听器和初始化器都用调用`getSpringFactoriesInstances`来进行实例化\n``` java\nprivate <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {\n    ClassLoader classLoader = this.getClassLoader();\n    // 获取配置文件中的 ClassName\n    Set<String> names = new LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));\n    // 根据类型创建实例\n    List<T> instances = this.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);\n    // 按照优先级排序\n    AnnotationAwareOrderComparator.sort(instances);\n    return instances;\n}\n```\n\n通过`SpringFactoriesLoader.loadSpringFactories`遍历获取所有依赖包中`META-INF/spring.factories`文件解析出键值对`Map<String, List<String>>`集合，很多第三方组件`starter`就是编写`spring.factories`来实现自动装配功能，这里使用了静态缓存`SpringFactoriesLoader.cache`只需一次解析下次直接读取缓存\n\n``` java\nprivate static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n    MultiValueMap<String, String> result = (MultiValueMap)cache.get(classLoader);\n    if (result != null) {\n            return result;\n    } else {\n        try {\n            Enumeration<URL> urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\");\n            LinkedMultiValueMap result = new LinkedMultiValueMap();\n\n            while(urls.hasMoreElements()) {\n                URL url = (URL)urls.nextElement();\n                UrlResource resource = new UrlResource(url);\n                Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n                Iterator var6 = properties.entrySet().iterator();\n\n                while(var6.hasNext()) {\n                    Entry<?, ?> entry = (Entry)var6.next();\n                    String factoryClassName = ((String)entry.getKey()).trim();\n                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());\n                    int var10 = var9.length;\n\n                    for(int var11 = 0; var11 < var10; ++var11) {\n                        String factoryName = var9[var11];\n                        result.add(factoryClassName, factoryName.trim());\n                    }\n                }\n            }\n\n                cache.put(classLoader, result);\n                return result;\n            } catch (IOException var13) {\n                throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var13);\n            }\n        }\n    }\n```\n\n通过`createSpringFactoriesInstances`利用类反射特性来实例化之前获取`Class`集合\n\n``` java\nprivate <T> List<T> createSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, ClassLoader classLoader, Object[] args, Set<String> names) {\n    List<T> instances = new ArrayList(names.size());\n    Iterator var7 = names.iterator();\n\n    while(var7.hasNext()) {\n        String name = (String)var7.next();\n\n        try {\n            Class<?> instanceClass = ClassUtils.forName(name, classLoader);\n            Assert.isAssignable(type, instanceClass);\n            Constructor<?> constructor = instanceClass.getDeclaredConstructor(parameterTypes);\n            T instance = BeanUtils.instantiateClass(constructor, args);\n            instances.add(instance);\n        } catch (Throwable var12) {\n            throw new IllegalArgumentException(\"Cannot instantiate \" + type + \" : \" + name, var12);\n        }\n    }\n        return instances;\n    }\n```\n\n#### deduceMainApplicationClass 判断 main Class\n获取当前线程堆栈跟踪元素然后遍历调用链判断每个方法名称是否为`main`获取入口类\n``` java\nprivate Class<?> deduceMainApplicationClass() {\n    try {\n        StackTraceElement[] stackTrace = (new RuntimeException()).getStackTrace();\n        StackTraceElement[] var2 = stackTrace;\n        int var3 = stackTrace.length;\n\n        for(int var4 = 0; var4 < var3; ++var4) {\n            StackTraceElement stackTraceElement = var2[var4];\n            if (\"main\".equals(stackTraceElement.getMethodName())) {\n                return Class.forName(stackTraceElement.getClassName());\n            }\n        }\n    } catch (ClassNotFoundException var6) {\n    }\n\n    return null;\n}   \n```\n\n### SpringBoot run 方法\nSpringApplication `run` 方法就是正式开始环境配置刷新容器等操作，下一节会仔细讲解每一步代码流程\n\n``` java\npublic ConfigurableApplicationContext run(String... args) {\n    // 监控器实例化\n    StopWatch stopWatch = new StopWatch();\n    // 启动监控器\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList();\n    // 无头配置初始化\n    this.configureHeadlessProperty();\n    // 初始化 SpringApplicationRunListeners 并开启\n    SpringApplicationRunListeners listeners = this.getRunListeners(args);\n    listeners.starting();\n    Collection exceptionReporters;\n    try {\n        // 初始化应用参数\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\t\n        // 初始化配置环境 （property）\n        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);\n        this.configureIgnoreBeanInfo(environment);\n        Banner printedBanner = this.printBanner(environment);\n        context = this.createApplicationContext();\n        // 初始化异常上报\n        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class,new Class[]{ConfigurableApplicationContext.class},context);\n        // 准备刷新容器\n        this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n        this.refreshContext(context);\n        this.afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);\n        }\n        listeners.started(context);\n        this.callRunners(context, applicationArguments);\n    } catch (Throwable var10) {\n        this.handleRunFailure(context, var10, exceptionReporters, listeners);\n        throw new IllegalStateException(var10);\n    }\n\n    try {\n        listeners.running(context);\n        return context;\n    } catch (Throwable var9) {\n        this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);\n        throw new IllegalStateException(var9);\n    }\n}\n```\n","slug":"Springboot 启动过程（一）","published":1,"updated":"2020-11-18T07:45:57.315Z","_id":"ckhmyc99d003ljsudgntd7o5t","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>Springboot 启动流程一直面试都会问到，所以看看源码学习它是如何启动并完成利用了那些技术</p>\n</blockquote>\n<h3 id=\"SpringBoot-实例化\"><a href=\"#SpringBoot-实例化\" class=\"headerlink\" title=\"SpringBoot 实例化\"></a>SpringBoot 实例化</h3><p>SpringBoot 以<code>main</code>方法来启动项目构造方法，调用静态方法<code>run</code>内部在实例化 SpringApplication 从参数来看，我们可以启动多个 SpringApplication<br><pre><code class=\"hljs java\">\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> ConfigurableApplicationContext <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> run(<span class=\"hljs-keyword\">new</span> Class[]&#123;primarySource&#125;, args);\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> ConfigurableApplicationContext <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">new</span> SpringApplication(primarySources)).run(args);\n&#125;</code></pre></p>\n<p>SpringApplication 的构造方法用于初始化各种默认参数监听器、初始化器、WebApplicationType、命令行参数等</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">// SpringApplication 构造方法</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">SpringApplication</span><span class=\"hljs-params\">(Object... sources)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.sources = <span class=\"hljs-keyword\">new</span> LinkedHashSet();\n    <span class=\"hljs-comment\">// 控制台打印</span>\n    <span class=\"hljs-keyword\">this</span>.bannerMode = Mode.CONSOLE;\n    <span class=\"hljs-comment\">// 开启日志</span>\n    <span class=\"hljs-keyword\">this</span>.logStartupInfo = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 开启命令行参数 以 -- 开头</span>\n    <span class=\"hljs-keyword\">this</span>.addCommandLineProperties = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 开启转化 service</span>\n    <span class=\"hljs-keyword\">this</span>.addConversionService = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 开启无头</span>\n    <span class=\"hljs-keyword\">this</span>.headless = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 开启注册关闭 Hook</span>\n    <span class=\"hljs-keyword\">this</span>.registerShutdownHook = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 额外 profiles</span>\n    <span class=\"hljs-keyword\">this</span>.additionalProfiles = <span class=\"hljs-keyword\">new</span> HashSet();\n    <span class=\"hljs-comment\">// 自定义环境</span>\n    <span class=\"hljs-keyword\">this</span>.isCustomEnvironment = <span class=\"hljs-keyword\">false</span>;\n    <span class=\"hljs-comment\">// 资源装载类</span>\n    <span class=\"hljs-keyword\">this</span>.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, <span class=\"hljs-string\">\"PrimarySources must not be null\"</span>);\n    <span class=\"hljs-comment\">// 主要参数 args[]</span>\n    <span class=\"hljs-keyword\">this</span>.primarySources = <span class=\"hljs-keyword\">new</span> LinkedHashSet(Arrays.asList(primarySources));\n    <span class=\"hljs-comment\">// 判断应用类型 WebApplicationType 枚举 ReActive、Servlet、None </span>\n    <span class=\"hljs-keyword\">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();\n    <span class=\"hljs-comment\">// 加载初始化器和监听器 </span>\n    <span class=\"hljs-keyword\">this</span>.setInitializers(<span class=\"hljs-keyword\">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n    <span class=\"hljs-keyword\">this</span>.setListeners(<span class=\"hljs-keyword\">this</span>.getSpringFactoriesInstances(ApplicationListener<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n    <span class=\"hljs-comment\">// 判断 main 方法入口类</span>\n    <span class=\"hljs-keyword\">this</span>.mainApplicationClass = <span class=\"hljs-keyword\">this</span>.deduceMainApplicationClass();\n&#125;</code></pre>\n<h4 id=\"WebApplicationType-deduceFromClasspath-应用类型判断\"><a href=\"#WebApplicationType-deduceFromClasspath-应用类型判断\" class=\"headerlink\" title=\"WebApplicationType.deduceFromClasspath() 应用类型判断\"></a>WebApplicationType.deduceFromClasspath() 应用类型判断</h4><p>用于判断当前项目是否为<code>Servlet</code>环境，看代码可知通过不存在<code>DispatcherHandler</code>（分发处理器）、<code>DispatcherServlet</code>（分发中心）、<code>ServletContainer</code>（Servlet 容器）3个类来判断响应式应用，通过存在<code>Servlet</code>、<code>ConfigurableWebApplicationContext</code>同时存在来判断<code>Servlet</code>环境</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> WebApplicationType <span class=\"hljs-title\">deduceFromClasspath</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (ClassUtils.isPresent(<span class=\"hljs-string\">\"org.springframework.web.reactive.DispatcherHandler\"</span>, (ClassLoader)<span class=\"hljs-keyword\">null</span>) &amp;&amp; !ClassUtils.isPresent(<span class=\"hljs-string\">\"org.springframework.web.servlet.DispatcherServlet\"</span>, (ClassLoader)<span class=\"hljs-keyword\">null</span>) &amp;&amp; !ClassUtils.isPresent(<span class=\"hljs-string\">\"org.glassfish.jersey.servlet.ServletContainer\"</span>, (ClassLoader)<span class=\"hljs-keyword\">null</span>)) &#123;\n        <span class=\"hljs-keyword\">return</span> REACTIVE;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        String[] var0 = SERVLET_INDICATOR_CLASSES;\n        <span class=\"hljs-keyword\">int</span> var1 = var0.length;\n\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> var2 = <span class=\"hljs-number\">0</span>; var2 &lt; var1; ++var2) &#123;\n            String className = var0[var2];\n            <span class=\"hljs-keyword\">if</span> (!ClassUtils.isPresent(className, (ClassLoader)<span class=\"hljs-keyword\">null</span>)) &#123;\n                <span class=\"hljs-keyword\">return</span> NONE;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> SERVLET;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"setInitializers、setListeners-初始化监听器和初始化器\"><a href=\"#setInitializers、setListeners-初始化监听器和初始化器\" class=\"headerlink\" title=\"setInitializers、setListeners 初始化监听器和初始化器\"></a>setInitializers、setListeners 初始化监听器和初始化器</h4><p>监听器和初始化器都用调用<code>getSpringFactoriesInstances</code>来进行实例化<br><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> &lt;T&gt; <span class=\"hljs-function\">Collection&lt;T&gt; <span class=\"hljs-title\">getSpringFactoriesInstances</span><span class=\"hljs-params\">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;\n    ClassLoader classLoader = <span class=\"hljs-keyword\">this</span>.getClassLoader();\n    <span class=\"hljs-comment\">// 获取配置文件中的 ClassName</span>\n    Set&lt;String&gt; names = <span class=\"hljs-keyword\">new</span> LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));\n    <span class=\"hljs-comment\">// 根据类型创建实例</span>\n    List&lt;T&gt; instances = <span class=\"hljs-keyword\">this</span>.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);\n    <span class=\"hljs-comment\">// 按照优先级排序</span>\n    AnnotationAwareOrderComparator.sort(instances);\n    <span class=\"hljs-keyword\">return</span> instances;\n&#125;</code></pre></p>\n<p>通过<code>SpringFactoriesLoader.loadSpringFactories</code>遍历获取所有依赖包中<code>META-INF/spring.factories</code>文件解析出键值对<code>Map&lt;String, List&lt;String&gt;&gt;</code>集合，很多第三方组件<code>starter</code>就是编写<code>spring.factories</code>来实现自动装配功能，这里使用了静态缓存<code>SpringFactoriesLoader.cache</code>只需一次解析下次直接读取缓存</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class=\"hljs-meta\">@Nullable</span> ClassLoader classLoader) &#123;\n    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);\n    <span class=\"hljs-keyword\">if</span> (result != <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> result;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            Enumeration&lt;URL&gt; urls = classLoader != <span class=\"hljs-keyword\">null</span> ? classLoader.getResources(<span class=\"hljs-string\">\"META-INF/spring.factories\"</span>) : ClassLoader.getSystemResources(<span class=\"hljs-string\">\"META-INF/spring.factories\"</span>);\n            LinkedMultiValueMap result = <span class=\"hljs-keyword\">new</span> LinkedMultiValueMap();\n\n            <span class=\"hljs-keyword\">while</span>(urls.hasMoreElements()) &#123;\n                URL url = (URL)urls.nextElement();\n                UrlResource resource = <span class=\"hljs-keyword\">new</span> UrlResource(url);\n                Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n                Iterator var6 = properties.entrySet().iterator();\n\n                <span class=\"hljs-keyword\">while</span>(var6.hasNext()) &#123;\n                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();\n                    String factoryClassName = ((String)entry.getKey()).trim();\n                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());\n                    <span class=\"hljs-keyword\">int</span> var10 = var9.length;\n\n                    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> var11 = <span class=\"hljs-number\">0</span>; var11 &lt; var10; ++var11) &#123;\n                        String factoryName = var9[var11];\n                        result.add(factoryClassName, factoryName.trim());\n                    &#125;\n                &#125;\n            &#125;\n\n                cache.put(classLoader, result);\n                <span class=\"hljs-keyword\">return</span> result;\n            &#125; <span class=\"hljs-keyword\">catch</span> (IOException var13) &#123;\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Unable to load factories from location [META-INF/spring.factories]\"</span>, var13);\n            &#125;\n        &#125;\n    &#125;</code></pre>\n<p>通过<code>createSpringFactoriesInstances</code>利用类反射特性来实例化之前获取<code>Class</code>集合</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> &lt;T&gt; <span class=\"hljs-function\">List&lt;T&gt; <span class=\"hljs-title\">createSpringFactoriesInstances</span><span class=\"hljs-params\">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> </span>&#123;\n    List&lt;T&gt; instances = <span class=\"hljs-keyword\">new</span> ArrayList(names.size());\n    Iterator var7 = names.iterator();\n\n    <span class=\"hljs-keyword\">while</span>(var7.hasNext()) &#123;\n        String name = (String)var7.next();\n\n        <span class=\"hljs-keyword\">try</span> &#123;\n            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);\n            Assert.isAssignable(type, instanceClass);\n            Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);\n            T instance = BeanUtils.instantiateClass(constructor, args);\n            instances.add(instance);\n        &#125; <span class=\"hljs-keyword\">catch</span> (Throwable var12) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Cannot instantiate \"</span> + type + <span class=\"hljs-string\">\" : \"</span> + name, var12);\n        &#125;\n    &#125;\n        <span class=\"hljs-keyword\">return</span> instances;\n    &#125;</code></pre>\n<h4 id=\"deduceMainApplicationClass-判断-main-Class\"><a href=\"#deduceMainApplicationClass-判断-main-Class\" class=\"headerlink\" title=\"deduceMainApplicationClass 判断 main Class\"></a>deduceMainApplicationClass 判断 main Class</h4><p>获取当前线程堆栈跟踪元素然后遍历调用链判断每个方法名称是否为<code>main</code>获取入口类<br><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;\n    <span class=\"hljs-keyword\">try</span> &#123;\n        StackTraceElement[] stackTrace = (<span class=\"hljs-keyword\">new</span> RuntimeException()).getStackTrace();\n        StackTraceElement[] var2 = stackTrace;\n        <span class=\"hljs-keyword\">int</span> var3 = stackTrace.length;\n\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> var4 = <span class=\"hljs-number\">0</span>; var4 &lt; var3; ++var4) &#123;\n            StackTraceElement stackTraceElement = var2[var4];\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"main\"</span>.equals(stackTraceElement.getMethodName())) &#123;\n                <span class=\"hljs-keyword\">return</span> Class.forName(stackTraceElement.getClassName());\n            &#125;\n        &#125;\n    &#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException var6) &#123;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n&#125;</code></pre></p>\n<h3 id=\"SpringBoot-run-方法\"><a href=\"#SpringBoot-run-方法\" class=\"headerlink\" title=\"SpringBoot run 方法\"></a>SpringBoot run 方法</h3><p>SpringApplication <code>run</code> 方法就是正式开始环境配置刷新容器等操作，下一节会仔细讲解每一步代码流程</p>\n<pre><code class=\"hljs java\">public ConfigurableApplicationContext run(String... args) &#123;\n    // 监控器实例化\n    StopWatch stopWatch = new StopWatch();\n    // 启动监控器\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList();\n    // 无头配置初始化\n    this.configureHeadlessProperty();\n    // 初始化 SpringApplicationRunListeners 并开启\n    SpringApplicationRunListeners listeners = this.getRunListeners(args);\n    listeners.starting();\n    Collection exceptionReporters;\n    try &#123;\n        // 初始化应用参数\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\t\n        // 初始化配置环境 （property）\n        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);\n        this.configureIgnoreBeanInfo(environment);\n        Banner printedBanner = this.printBanner(environment);\n        context = this.createApplicationContext();\n        // 初始化异常上报\n        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class,new Class[]&#123;ConfigurableApplicationContext.class&#125;,context);\n        // 准备刷新容器\n        this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n        this.refreshContext(context);\n        this.afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) &#123;\n            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);\n        &#125;\n        listeners.started(context);\n        this.callRunners(context, applicationArguments);\n    &#125; catch (Throwable var10) &#123;\n        this.handleRunFailure(context, var10, exceptionReporters, listeners);\n        throw new IllegalStateException(var10);\n    &#125;\n\n    try &#123;\n        listeners.running(context);\n        return context;\n    &#125; catch (Throwable var9) &#123;\n        this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);\n        throw new IllegalStateException(var9);\n    &#125;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>Springboot 启动流程一直面试都会问到，所以看看源码学习它是如何启动并完成利用了那些技术</p>\n</blockquote>\n<h3 id=\"SpringBoot-实例化\"><a href=\"#SpringBoot-实例化\" class=\"headerlink\" title=\"SpringBoot 实例化\"></a>SpringBoot 实例化</h3><p>SpringBoot 以<code>main</code>方法来启动项目构造方法，调用静态方法<code>run</code>内部在实例化 SpringApplication 从参数来看，我们可以启动多个 SpringApplication<br><pre><code class=\"hljs java\">\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> ConfigurableApplicationContext <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> run(<span class=\"hljs-keyword\">new</span> Class[]&#123;primarySource&#125;, args);\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> ConfigurableApplicationContext <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">new</span> SpringApplication(primarySources)).run(args);\n&#125;</code></pre></p>\n<p>SpringApplication 的构造方法用于初始化各种默认参数监听器、初始化器、WebApplicationType、命令行参数等</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">// SpringApplication 构造方法</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">SpringApplication</span><span class=\"hljs-params\">(Object... sources)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.sources = <span class=\"hljs-keyword\">new</span> LinkedHashSet();\n    <span class=\"hljs-comment\">// 控制台打印</span>\n    <span class=\"hljs-keyword\">this</span>.bannerMode = Mode.CONSOLE;\n    <span class=\"hljs-comment\">// 开启日志</span>\n    <span class=\"hljs-keyword\">this</span>.logStartupInfo = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 开启命令行参数 以 -- 开头</span>\n    <span class=\"hljs-keyword\">this</span>.addCommandLineProperties = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 开启转化 service</span>\n    <span class=\"hljs-keyword\">this</span>.addConversionService = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 开启无头</span>\n    <span class=\"hljs-keyword\">this</span>.headless = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 开启注册关闭 Hook</span>\n    <span class=\"hljs-keyword\">this</span>.registerShutdownHook = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 额外 profiles</span>\n    <span class=\"hljs-keyword\">this</span>.additionalProfiles = <span class=\"hljs-keyword\">new</span> HashSet();\n    <span class=\"hljs-comment\">// 自定义环境</span>\n    <span class=\"hljs-keyword\">this</span>.isCustomEnvironment = <span class=\"hljs-keyword\">false</span>;\n    <span class=\"hljs-comment\">// 资源装载类</span>\n    <span class=\"hljs-keyword\">this</span>.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, <span class=\"hljs-string\">\"PrimarySources must not be null\"</span>);\n    <span class=\"hljs-comment\">// 主要参数 args[]</span>\n    <span class=\"hljs-keyword\">this</span>.primarySources = <span class=\"hljs-keyword\">new</span> LinkedHashSet(Arrays.asList(primarySources));\n    <span class=\"hljs-comment\">// 判断应用类型 WebApplicationType 枚举 ReActive、Servlet、None </span>\n    <span class=\"hljs-keyword\">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();\n    <span class=\"hljs-comment\">// 加载初始化器和监听器 </span>\n    <span class=\"hljs-keyword\">this</span>.setInitializers(<span class=\"hljs-keyword\">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n    <span class=\"hljs-keyword\">this</span>.setListeners(<span class=\"hljs-keyword\">this</span>.getSpringFactoriesInstances(ApplicationListener<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>;\n    <span class=\"hljs-comment\">// 判断 main 方法入口类</span>\n    <span class=\"hljs-keyword\">this</span>.mainApplicationClass = <span class=\"hljs-keyword\">this</span>.deduceMainApplicationClass();\n&#125;</code></pre>\n<h4 id=\"WebApplicationType-deduceFromClasspath-应用类型判断\"><a href=\"#WebApplicationType-deduceFromClasspath-应用类型判断\" class=\"headerlink\" title=\"WebApplicationType.deduceFromClasspath() 应用类型判断\"></a>WebApplicationType.deduceFromClasspath() 应用类型判断</h4><p>用于判断当前项目是否为<code>Servlet</code>环境，看代码可知通过不存在<code>DispatcherHandler</code>（分发处理器）、<code>DispatcherServlet</code>（分发中心）、<code>ServletContainer</code>（Servlet 容器）3个类来判断响应式应用，通过存在<code>Servlet</code>、<code>ConfigurableWebApplicationContext</code>同时存在来判断<code>Servlet</code>环境</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> WebApplicationType <span class=\"hljs-title\">deduceFromClasspath</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (ClassUtils.isPresent(<span class=\"hljs-string\">\"org.springframework.web.reactive.DispatcherHandler\"</span>, (ClassLoader)<span class=\"hljs-keyword\">null</span>) &amp;&amp; !ClassUtils.isPresent(<span class=\"hljs-string\">\"org.springframework.web.servlet.DispatcherServlet\"</span>, (ClassLoader)<span class=\"hljs-keyword\">null</span>) &amp;&amp; !ClassUtils.isPresent(<span class=\"hljs-string\">\"org.glassfish.jersey.servlet.ServletContainer\"</span>, (ClassLoader)<span class=\"hljs-keyword\">null</span>)) &#123;\n        <span class=\"hljs-keyword\">return</span> REACTIVE;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        String[] var0 = SERVLET_INDICATOR_CLASSES;\n        <span class=\"hljs-keyword\">int</span> var1 = var0.length;\n\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> var2 = <span class=\"hljs-number\">0</span>; var2 &lt; var1; ++var2) &#123;\n            String className = var0[var2];\n            <span class=\"hljs-keyword\">if</span> (!ClassUtils.isPresent(className, (ClassLoader)<span class=\"hljs-keyword\">null</span>)) &#123;\n                <span class=\"hljs-keyword\">return</span> NONE;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> SERVLET;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"setInitializers、setListeners-初始化监听器和初始化器\"><a href=\"#setInitializers、setListeners-初始化监听器和初始化器\" class=\"headerlink\" title=\"setInitializers、setListeners 初始化监听器和初始化器\"></a>setInitializers、setListeners 初始化监听器和初始化器</h4><p>监听器和初始化器都用调用<code>getSpringFactoriesInstances</code>来进行实例化<br><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> &lt;T&gt; <span class=\"hljs-function\">Collection&lt;T&gt; <span class=\"hljs-title\">getSpringFactoriesInstances</span><span class=\"hljs-params\">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;\n    ClassLoader classLoader = <span class=\"hljs-keyword\">this</span>.getClassLoader();\n    <span class=\"hljs-comment\">// 获取配置文件中的 ClassName</span>\n    Set&lt;String&gt; names = <span class=\"hljs-keyword\">new</span> LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));\n    <span class=\"hljs-comment\">// 根据类型创建实例</span>\n    List&lt;T&gt; instances = <span class=\"hljs-keyword\">this</span>.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);\n    <span class=\"hljs-comment\">// 按照优先级排序</span>\n    AnnotationAwareOrderComparator.sort(instances);\n    <span class=\"hljs-keyword\">return</span> instances;\n&#125;</code></pre></p>\n<p>通过<code>SpringFactoriesLoader.loadSpringFactories</code>遍历获取所有依赖包中<code>META-INF/spring.factories</code>文件解析出键值对<code>Map&lt;String, List&lt;String&gt;&gt;</code>集合，很多第三方组件<code>starter</code>就是编写<code>spring.factories</code>来实现自动装配功能，这里使用了静态缓存<code>SpringFactoriesLoader.cache</code>只需一次解析下次直接读取缓存</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class=\"hljs-meta\">@Nullable</span> ClassLoader classLoader) &#123;\n    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);\n    <span class=\"hljs-keyword\">if</span> (result != <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> result;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            Enumeration&lt;URL&gt; urls = classLoader != <span class=\"hljs-keyword\">null</span> ? classLoader.getResources(<span class=\"hljs-string\">\"META-INF/spring.factories\"</span>) : ClassLoader.getSystemResources(<span class=\"hljs-string\">\"META-INF/spring.factories\"</span>);\n            LinkedMultiValueMap result = <span class=\"hljs-keyword\">new</span> LinkedMultiValueMap();\n\n            <span class=\"hljs-keyword\">while</span>(urls.hasMoreElements()) &#123;\n                URL url = (URL)urls.nextElement();\n                UrlResource resource = <span class=\"hljs-keyword\">new</span> UrlResource(url);\n                Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n                Iterator var6 = properties.entrySet().iterator();\n\n                <span class=\"hljs-keyword\">while</span>(var6.hasNext()) &#123;\n                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();\n                    String factoryClassName = ((String)entry.getKey()).trim();\n                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());\n                    <span class=\"hljs-keyword\">int</span> var10 = var9.length;\n\n                    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> var11 = <span class=\"hljs-number\">0</span>; var11 &lt; var10; ++var11) &#123;\n                        String factoryName = var9[var11];\n                        result.add(factoryClassName, factoryName.trim());\n                    &#125;\n                &#125;\n            &#125;\n\n                cache.put(classLoader, result);\n                <span class=\"hljs-keyword\">return</span> result;\n            &#125; <span class=\"hljs-keyword\">catch</span> (IOException var13) &#123;\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Unable to load factories from location [META-INF/spring.factories]\"</span>, var13);\n            &#125;\n        &#125;\n    &#125;</code></pre>\n<p>通过<code>createSpringFactoriesInstances</code>利用类反射特性来实例化之前获取<code>Class</code>集合</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> &lt;T&gt; <span class=\"hljs-function\">List&lt;T&gt; <span class=\"hljs-title\">createSpringFactoriesInstances</span><span class=\"hljs-params\">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> </span>&#123;\n    List&lt;T&gt; instances = <span class=\"hljs-keyword\">new</span> ArrayList(names.size());\n    Iterator var7 = names.iterator();\n\n    <span class=\"hljs-keyword\">while</span>(var7.hasNext()) &#123;\n        String name = (String)var7.next();\n\n        <span class=\"hljs-keyword\">try</span> &#123;\n            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);\n            Assert.isAssignable(type, instanceClass);\n            Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);\n            T instance = BeanUtils.instantiateClass(constructor, args);\n            instances.add(instance);\n        &#125; <span class=\"hljs-keyword\">catch</span> (Throwable var12) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Cannot instantiate \"</span> + type + <span class=\"hljs-string\">\" : \"</span> + name, var12);\n        &#125;\n    &#125;\n        <span class=\"hljs-keyword\">return</span> instances;\n    &#125;</code></pre>\n<h4 id=\"deduceMainApplicationClass-判断-main-Class\"><a href=\"#deduceMainApplicationClass-判断-main-Class\" class=\"headerlink\" title=\"deduceMainApplicationClass 判断 main Class\"></a>deduceMainApplicationClass 判断 main Class</h4><p>获取当前线程堆栈跟踪元素然后遍历调用链判断每个方法名称是否为<code>main</code>获取入口类<br><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;\n    <span class=\"hljs-keyword\">try</span> &#123;\n        StackTraceElement[] stackTrace = (<span class=\"hljs-keyword\">new</span> RuntimeException()).getStackTrace();\n        StackTraceElement[] var2 = stackTrace;\n        <span class=\"hljs-keyword\">int</span> var3 = stackTrace.length;\n\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> var4 = <span class=\"hljs-number\">0</span>; var4 &lt; var3; ++var4) &#123;\n            StackTraceElement stackTraceElement = var2[var4];\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"main\"</span>.equals(stackTraceElement.getMethodName())) &#123;\n                <span class=\"hljs-keyword\">return</span> Class.forName(stackTraceElement.getClassName());\n            &#125;\n        &#125;\n    &#125; <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException var6) &#123;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n&#125;</code></pre></p>\n<h3 id=\"SpringBoot-run-方法\"><a href=\"#SpringBoot-run-方法\" class=\"headerlink\" title=\"SpringBoot run 方法\"></a>SpringBoot run 方法</h3><p>SpringApplication <code>run</code> 方法就是正式开始环境配置刷新容器等操作，下一节会仔细讲解每一步代码流程</p>\n<pre><code class=\"hljs java\">public ConfigurableApplicationContext run(String... args) &#123;\n    // 监控器实例化\n    StopWatch stopWatch = new StopWatch();\n    // 启动监控器\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList();\n    // 无头配置初始化\n    this.configureHeadlessProperty();\n    // 初始化 SpringApplicationRunListeners 并开启\n    SpringApplicationRunListeners listeners = this.getRunListeners(args);\n    listeners.starting();\n    Collection exceptionReporters;\n    try &#123;\n        // 初始化应用参数\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\t\n        // 初始化配置环境 （property）\n        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);\n        this.configureIgnoreBeanInfo(environment);\n        Banner printedBanner = this.printBanner(environment);\n        context = this.createApplicationContext();\n        // 初始化异常上报\n        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class,new Class[]&#123;ConfigurableApplicationContext.class&#125;,context);\n        // 准备刷新容器\n        this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n        this.refreshContext(context);\n        this.afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) &#123;\n            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);\n        &#125;\n        listeners.started(context);\n        this.callRunners(context, applicationArguments);\n    &#125; catch (Throwable var10) &#123;\n        this.handleRunFailure(context, var10, exceptionReporters, listeners);\n        throw new IllegalStateException(var10);\n    &#125;\n\n    try &#123;\n        listeners.running(context);\n        return context;\n    &#125; catch (Throwable var9) &#123;\n        this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);\n        throw new IllegalStateException(var9);\n    &#125;\n&#125;</code></pre>\n"},{"title":"SpringBoot 启动源码解析（三）之配置环境","toc":false,"date":"2020-05-09T02:14:36.000Z","_content":"\n![](/images/spring.jpg)\n> 继监听器初始化完毕接来下开始可配置环境预处理\n\n### ApplicationArguments 默认参数初始化\n初始化`DefaultApplicationArguments`默认应用参数，通过`SimpleCommandLineArgsParser`对额外参数数组循环读取以`--`开头的命令行分割形成键值对封装为`SimpleCommandLinePropertySource`对象\n``` java\npublic CommandLineArgs parse(String... args) {\n    CommandLineArgs commandLineArgs = new CommandLineArgs();\n    String[] var3 = args;\n    int var4 = args.length;\n    \n    for(int var5 = 0; var5 < var4; ++var5) {\n        String arg = var3[var5];\n        if (arg.startsWith(\"--\")) {\n            String optionText = arg.substring(2);\n            String optionValue = null;\n            int indexOfEqualsSign = optionText.indexOf(61);\n            String optionName;\n            if (indexOfEqualsSign > -1) {\n                optionName = optionText.substring(0, indexOfEqualsSign);\n                optionValue = optionText.substring(indexOfEqualsSign + 1);\n            } else {\n                optionName = optionText;\n            }\n\n            if (optionName.isEmpty()) {\n                throw new IllegalArgumentException(\"Invalid argument syntax: \" + arg);\n            }\n\n            commandLineArgs.addOptionArg(optionName, optionValue);\n        } else {\n            commandLineArgs.addNonOptionArg(arg);\n        }\n    }\n    return commandLineArgs;\n}\n```\n\n### ConfigurableEnvironment 准备\n默认参数初始化完毕后开始配置环境准备阶段\n``` java\nprivate ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) {\n    // 根据当前应用类型实例化环境\n    ConfigurableEnvironment environment = this.getOrCreateEnvironment();\n    // 命令行额外参数添加\n    this.configureEnvironment((ConfigurableEnvironment)environment, applicationArguments.getSourceArgs());\n    // SpringConfigurationPropertySources 保存之前 MutablePropertySources 数据\n    ConfigurationPropertySources.attach((Environment)environment);\n    // 监听器广播配置环境准备事件\n    listeners.environmentPrepared((ConfigurableEnvironment)environment);\n    // 绑定 Spring 默认的配置文件中信息\n    this.bindToSpringApplication((ConfigurableEnvironment)environment);\n    // 是否为自定义容器 否则进行容器转化\n    if (!this.isCustomEnvironment) {\n        environment = (new EnvironmentConverter(this.getClassLoader())).convertEnvironmentIfNecessary((ConfigurableEnvironment)environment, this.deduceEnvironmentClass());\n    }\n\n    ConfigurationPropertySources.attach((Environment)environment);\n    return (ConfigurableEnvironment)environment;\n}\n```\n\n#### getOrCreateEnvironment \n根据当前应用类型实例化不同的环境，所有环境对象都继承`StandardEnvironment`，默认配置环境`MutablePropertySources`对象里`propertySourceList`会新增以下`PropertySource`\n``` java\nprivate ConfigurableEnvironment getOrCreateEnvironment() {\n    if (this.environment != null) {\n        return this.environment;\n    } else {\n        switch(this.webApplicationType) {\n        case SERVLET:\n            return new StandardServletEnvironment();\n        case REACTIVE:\n            return new StandardReactiveWebEnvironment();\n        default:\n            return new StandardEnvironment();\n        }\n    }\n}\n```\n####  configureEnvironment 配置环境\n根据之前实例化的配置环境加载`propertySource`、`profiles`\n``` java\nprotected void configureEnvironment(ConfigurableEnvironment environment, String[] args) {\n    if (this.addConversionService) {\n        ConversionService conversionService = ApplicationConversionService.getSharedInstance();\n        environment.setConversionService((ConfigurableConversionService)conversionService);\n    }\n    // 命令行加入属性资源\n    this.configurePropertySources(environment, args);\n    this.configureProfiles(environment, args);\n}\n```\n实例化`ConversionService`并加载到环境中，内部方法使用了**双重验证同步锁**单例模式\n``` java\npublic static ConversionService getSharedInstance() {\n    ApplicationConversionService sharedInstance = sharedInstance;\n    if (sharedInstance == null) {\n        Class var1 = ApplicationConversionService.class;\n        # 添加同步锁\n        synchronized(ApplicationConversionService.class) {\n            sharedInstance = sharedInstance;\n            if (sharedInstance == null) {\n                sharedInstance = new ApplicationConversionService();\n                sharedInstance = sharedInstance;\n            }\n        }\n    }\n\n    return sharedInstance;\n}\n```\n将之前的命令行配置环境新增或替换配置环境的`MutablePropertySources`，装配面板额外添加 `configureProfiles` ，在实际开发中用于测试生产配置分离，不同情况下激活不同的`profile`\n``` java\nprotected void configurePropertySources(ConfigurableEnvironment environment, String[] args) {\n    MutablePropertySources sources = environment.getPropertySources();\n    if (this.defaultProperties != null && !this.defaultProperties.isEmpty()) {\n        sources.addLast(new MapPropertySource(\"defaultProperties\", this.defaultProperties));\n    }\n    // 命令行配置是否开启同时命令行数组大于0\n    if (this.addCommandLineProperties && args.length > 0) {\n        String name = \"commandLineArgs\";\n        // 如果有则进行替换否则新增\n        if (sources.contains(name)) {\n            PropertySource<?> source = sources.get(name);\n            CompositePropertySource composite = new CompositePropertySource(name);\n            composite.addPropertySource(new SimpleCommandLinePropertySource(\"springApplicationCommandLineArgs\", args));\n            composite.addPropertySource(source);\n            sources.replace(name, composite);\n        } else {\n            sources.addFirst(new SimpleCommandLinePropertySource(args));\n        }\n    }\n}\n\nprotected void configureProfiles(ConfigurableEnvironment environment, String[] args) {\n    Set<String> profiles = new LinkedHashSet(this.additionalProfiles);\n    profiles.addAll(Arrays.asList(environment.getActiveProfiles()));\n    environment.setActiveProfiles(StringUtils.toStringArray(profiles));\n}\n```\n接下来将`ConfigurationPropertySourcesPropertySource`加入`MutablePropertySources`，然后通过监听器广播发送`ApplicationEnvironmentPreparedEvent`应用环境准备事件，最后返回最终的容器中配属性资源包含以下\n\n- **PropertiesPropertySource {name='systemProperties'}** ：保存当前系统配置情况的键值对信息（缺省信息）\n- **SystemEnvironmentPropertySource {name='systemEnvironment'}** ： 对象保存当前系统环境变量键值对信息（缺省信息）\n- **StubPropertySource {name='servletContextInitParams'}** ：保存上下文初始化参数 （Servlet 特有）\n- **StubPropertySource {name='servletConfigInitParams'}** ：保存设置初始化参数（Servlet 特有）\n- **JndiPropertySource {name='jndiProperties'}** ：保存Jndi相关配置（Servlet 特有）\n- **SimpleCommandLinePropertySource {name='commandLineArgs'}** ：保存命令行额外参数\n- **ConfigurationPropertySourcesPropertySource {name='configurationProperties'}** ：保存 MutablePropertySources 信息包含所有的配置信息\n- **OriginTrackedMapPropertySource {name='applicationConfig: [classpath:/application.yml]'}** ：保存`spring`默认配置文件`properties`或`yml`中键值对信息\n\n","source":"_posts/Springboot 启动过程（三）.md","raw":"---\ntitle: SpringBoot 启动源码解析（三）之配置环境\ntags:\n  - Spring\ncategories:\n  - Spring\ntoc: false\ndate: 2020-05-09 10:14:36\n---\n\n![](/images/spring.jpg)\n> 继监听器初始化完毕接来下开始可配置环境预处理\n\n### ApplicationArguments 默认参数初始化\n初始化`DefaultApplicationArguments`默认应用参数，通过`SimpleCommandLineArgsParser`对额外参数数组循环读取以`--`开头的命令行分割形成键值对封装为`SimpleCommandLinePropertySource`对象\n``` java\npublic CommandLineArgs parse(String... args) {\n    CommandLineArgs commandLineArgs = new CommandLineArgs();\n    String[] var3 = args;\n    int var4 = args.length;\n    \n    for(int var5 = 0; var5 < var4; ++var5) {\n        String arg = var3[var5];\n        if (arg.startsWith(\"--\")) {\n            String optionText = arg.substring(2);\n            String optionValue = null;\n            int indexOfEqualsSign = optionText.indexOf(61);\n            String optionName;\n            if (indexOfEqualsSign > -1) {\n                optionName = optionText.substring(0, indexOfEqualsSign);\n                optionValue = optionText.substring(indexOfEqualsSign + 1);\n            } else {\n                optionName = optionText;\n            }\n\n            if (optionName.isEmpty()) {\n                throw new IllegalArgumentException(\"Invalid argument syntax: \" + arg);\n            }\n\n            commandLineArgs.addOptionArg(optionName, optionValue);\n        } else {\n            commandLineArgs.addNonOptionArg(arg);\n        }\n    }\n    return commandLineArgs;\n}\n```\n\n### ConfigurableEnvironment 准备\n默认参数初始化完毕后开始配置环境准备阶段\n``` java\nprivate ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) {\n    // 根据当前应用类型实例化环境\n    ConfigurableEnvironment environment = this.getOrCreateEnvironment();\n    // 命令行额外参数添加\n    this.configureEnvironment((ConfigurableEnvironment)environment, applicationArguments.getSourceArgs());\n    // SpringConfigurationPropertySources 保存之前 MutablePropertySources 数据\n    ConfigurationPropertySources.attach((Environment)environment);\n    // 监听器广播配置环境准备事件\n    listeners.environmentPrepared((ConfigurableEnvironment)environment);\n    // 绑定 Spring 默认的配置文件中信息\n    this.bindToSpringApplication((ConfigurableEnvironment)environment);\n    // 是否为自定义容器 否则进行容器转化\n    if (!this.isCustomEnvironment) {\n        environment = (new EnvironmentConverter(this.getClassLoader())).convertEnvironmentIfNecessary((ConfigurableEnvironment)environment, this.deduceEnvironmentClass());\n    }\n\n    ConfigurationPropertySources.attach((Environment)environment);\n    return (ConfigurableEnvironment)environment;\n}\n```\n\n#### getOrCreateEnvironment \n根据当前应用类型实例化不同的环境，所有环境对象都继承`StandardEnvironment`，默认配置环境`MutablePropertySources`对象里`propertySourceList`会新增以下`PropertySource`\n``` java\nprivate ConfigurableEnvironment getOrCreateEnvironment() {\n    if (this.environment != null) {\n        return this.environment;\n    } else {\n        switch(this.webApplicationType) {\n        case SERVLET:\n            return new StandardServletEnvironment();\n        case REACTIVE:\n            return new StandardReactiveWebEnvironment();\n        default:\n            return new StandardEnvironment();\n        }\n    }\n}\n```\n####  configureEnvironment 配置环境\n根据之前实例化的配置环境加载`propertySource`、`profiles`\n``` java\nprotected void configureEnvironment(ConfigurableEnvironment environment, String[] args) {\n    if (this.addConversionService) {\n        ConversionService conversionService = ApplicationConversionService.getSharedInstance();\n        environment.setConversionService((ConfigurableConversionService)conversionService);\n    }\n    // 命令行加入属性资源\n    this.configurePropertySources(environment, args);\n    this.configureProfiles(environment, args);\n}\n```\n实例化`ConversionService`并加载到环境中，内部方法使用了**双重验证同步锁**单例模式\n``` java\npublic static ConversionService getSharedInstance() {\n    ApplicationConversionService sharedInstance = sharedInstance;\n    if (sharedInstance == null) {\n        Class var1 = ApplicationConversionService.class;\n        # 添加同步锁\n        synchronized(ApplicationConversionService.class) {\n            sharedInstance = sharedInstance;\n            if (sharedInstance == null) {\n                sharedInstance = new ApplicationConversionService();\n                sharedInstance = sharedInstance;\n            }\n        }\n    }\n\n    return sharedInstance;\n}\n```\n将之前的命令行配置环境新增或替换配置环境的`MutablePropertySources`，装配面板额外添加 `configureProfiles` ，在实际开发中用于测试生产配置分离，不同情况下激活不同的`profile`\n``` java\nprotected void configurePropertySources(ConfigurableEnvironment environment, String[] args) {\n    MutablePropertySources sources = environment.getPropertySources();\n    if (this.defaultProperties != null && !this.defaultProperties.isEmpty()) {\n        sources.addLast(new MapPropertySource(\"defaultProperties\", this.defaultProperties));\n    }\n    // 命令行配置是否开启同时命令行数组大于0\n    if (this.addCommandLineProperties && args.length > 0) {\n        String name = \"commandLineArgs\";\n        // 如果有则进行替换否则新增\n        if (sources.contains(name)) {\n            PropertySource<?> source = sources.get(name);\n            CompositePropertySource composite = new CompositePropertySource(name);\n            composite.addPropertySource(new SimpleCommandLinePropertySource(\"springApplicationCommandLineArgs\", args));\n            composite.addPropertySource(source);\n            sources.replace(name, composite);\n        } else {\n            sources.addFirst(new SimpleCommandLinePropertySource(args));\n        }\n    }\n}\n\nprotected void configureProfiles(ConfigurableEnvironment environment, String[] args) {\n    Set<String> profiles = new LinkedHashSet(this.additionalProfiles);\n    profiles.addAll(Arrays.asList(environment.getActiveProfiles()));\n    environment.setActiveProfiles(StringUtils.toStringArray(profiles));\n}\n```\n接下来将`ConfigurationPropertySourcesPropertySource`加入`MutablePropertySources`，然后通过监听器广播发送`ApplicationEnvironmentPreparedEvent`应用环境准备事件，最后返回最终的容器中配属性资源包含以下\n\n- **PropertiesPropertySource {name='systemProperties'}** ：保存当前系统配置情况的键值对信息（缺省信息）\n- **SystemEnvironmentPropertySource {name='systemEnvironment'}** ： 对象保存当前系统环境变量键值对信息（缺省信息）\n- **StubPropertySource {name='servletContextInitParams'}** ：保存上下文初始化参数 （Servlet 特有）\n- **StubPropertySource {name='servletConfigInitParams'}** ：保存设置初始化参数（Servlet 特有）\n- **JndiPropertySource {name='jndiProperties'}** ：保存Jndi相关配置（Servlet 特有）\n- **SimpleCommandLinePropertySource {name='commandLineArgs'}** ：保存命令行额外参数\n- **ConfigurationPropertySourcesPropertySource {name='configurationProperties'}** ：保存 MutablePropertySources 信息包含所有的配置信息\n- **OriginTrackedMapPropertySource {name='applicationConfig: [classpath:/application.yml]'}** ：保存`spring`默认配置文件`properties`或`yml`中键值对信息\n\n","slug":"Springboot 启动过程（三）","published":1,"updated":"2020-08-10T01:48:44.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc99h003njsud2to6afy6","content":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>继监听器初始化完毕接来下开始可配置环境预处理</p>\n</blockquote>\n<h3 id=\"ApplicationArguments-默认参数初始化\"><a href=\"#ApplicationArguments-默认参数初始化\" class=\"headerlink\" title=\"ApplicationArguments 默认参数初始化\"></a>ApplicationArguments 默认参数初始化</h3><p>初始化<code>DefaultApplicationArguments</code>默认应用参数，通过<code>SimpleCommandLineArgsParser</code>对额外参数数组循环读取以<code>--</code>开头的命令行分割形成键值对封装为<code>SimpleCommandLinePropertySource</code>对象<br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> CommandLineArgs <span class=\"hljs-title\">parse</span><span class=\"hljs-params\">(String... args)</span> </span>&#123;\n    CommandLineArgs commandLineArgs = <span class=\"hljs-keyword\">new</span> CommandLineArgs();\n    String[] var3 = args;\n    <span class=\"hljs-keyword\">int</span> var4 = args.length;\n    \n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> var5 = <span class=\"hljs-number\">0</span>; var5 &lt; var4; ++var5) &#123;\n        String arg = var3[var5];\n        <span class=\"hljs-keyword\">if</span> (arg.startsWith(<span class=\"hljs-string\">\"--\"</span>)) &#123;\n            String optionText = arg.substring(<span class=\"hljs-number\">2</span>);\n            String optionValue = <span class=\"hljs-keyword\">null</span>;\n            <span class=\"hljs-keyword\">int</span> indexOfEqualsSign = optionText.indexOf(<span class=\"hljs-number\">61</span>);\n            String optionName;\n            <span class=\"hljs-keyword\">if</span> (indexOfEqualsSign &gt; -<span class=\"hljs-number\">1</span>) &#123;\n                optionName = optionText.substring(<span class=\"hljs-number\">0</span>, indexOfEqualsSign);\n                optionValue = optionText.substring(indexOfEqualsSign + <span class=\"hljs-number\">1</span>);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                optionName = optionText;\n            &#125;\n\n            <span class=\"hljs-keyword\">if</span> (optionName.isEmpty()) &#123;\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Invalid argument syntax: \"</span> + arg);\n            &#125;\n\n            commandLineArgs.addOptionArg(optionName, optionValue);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            commandLineArgs.addNonOptionArg(arg);\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> commandLineArgs;\n&#125;</code></pre></p>\n<h3 id=\"ConfigurableEnvironment-准备\"><a href=\"#ConfigurableEnvironment-准备\" class=\"headerlink\" title=\"ConfigurableEnvironment 准备\"></a>ConfigurableEnvironment 准备</h3><p>默认参数初始化完毕后开始配置环境准备阶段<br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> ConfigurableEnvironment <span class=\"hljs-title\">prepareEnvironment</span><span class=\"hljs-params\">(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</span> </span>&#123;\n    <span class=\"hljs-comment\">// 根据当前应用类型实例化环境</span>\n    ConfigurableEnvironment environment = <span class=\"hljs-keyword\">this</span>.getOrCreateEnvironment();\n    <span class=\"hljs-comment\">// 命令行额外参数添加</span>\n    <span class=\"hljs-keyword\">this</span>.configureEnvironment((ConfigurableEnvironment)environment, applicationArguments.getSourceArgs());\n    <span class=\"hljs-comment\">// SpringConfigurationPropertySources 保存之前 MutablePropertySources 数据</span>\n    ConfigurationPropertySources.attach((Environment)environment);\n    <span class=\"hljs-comment\">// 监听器广播配置环境准备事件</span>\n    listeners.environmentPrepared((ConfigurableEnvironment)environment);\n    <span class=\"hljs-comment\">// 绑定 Spring 默认的配置文件中信息</span>\n    <span class=\"hljs-keyword\">this</span>.bindToSpringApplication((ConfigurableEnvironment)environment);\n    <span class=\"hljs-comment\">// 是否为自定义容器 否则进行容器转化</span>\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.isCustomEnvironment) &#123;\n        environment = (<span class=\"hljs-keyword\">new</span> EnvironmentConverter(<span class=\"hljs-keyword\">this</span>.getClassLoader())).convertEnvironmentIfNecessary((ConfigurableEnvironment)environment, <span class=\"hljs-keyword\">this</span>.deduceEnvironmentClass());\n    &#125;\n\n    ConfigurationPropertySources.attach((Environment)environment);\n    <span class=\"hljs-keyword\">return</span> (ConfigurableEnvironment)environment;\n&#125;</code></pre></p>\n<h4 id=\"getOrCreateEnvironment\"><a href=\"#getOrCreateEnvironment\" class=\"headerlink\" title=\"getOrCreateEnvironment\"></a>getOrCreateEnvironment</h4><p>根据当前应用类型实例化不同的环境，所有环境对象都继承<code>StandardEnvironment</code>，默认配置环境<code>MutablePropertySources</code>对象里<code>propertySourceList</code>会新增以下<code>PropertySource</code><br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> ConfigurableEnvironment <span class=\"hljs-title\">getOrCreateEnvironment</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.environment != <span class=\"hljs-keyword\">null</span>) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.environment;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        <span class=\"hljs-keyword\">switch</span>(<span class=\"hljs-keyword\">this</span>.webApplicationType) &#123;\n        <span class=\"hljs-keyword\">case</span> SERVLET:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> StandardServletEnvironment();\n        <span class=\"hljs-keyword\">case</span> REACTIVE:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> StandardReactiveWebEnvironment();\n        <span class=\"hljs-keyword\">default</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> StandardEnvironment();\n        &#125;\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"configureEnvironment-配置环境\"><a href=\"#configureEnvironment-配置环境\" class=\"headerlink\" title=\"configureEnvironment 配置环境\"></a>configureEnvironment 配置环境</h4><p>根据之前实例化的配置环境加载<code>propertySource</code>、<code>profiles</code><br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configureEnvironment</span><span class=\"hljs-params\">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.addConversionService) &#123;\n        ConversionService conversionService = ApplicationConversionService.getSharedInstance();\n        environment.setConversionService((ConfigurableConversionService)conversionService);\n    &#125;\n    <span class=\"hljs-comment\">// 命令行加入属性资源</span>\n    <span class=\"hljs-keyword\">this</span>.configurePropertySources(environment, args);\n    <span class=\"hljs-keyword\">this</span>.configureProfiles(environment, args);\n&#125;</code></pre></p>\n<p>实例化<code>ConversionService</code>并加载到环境中，内部方法使用了<strong>双重验证同步锁</strong>单例模式<br><pre><code class=\"hljs java\">public static ConversionService getSharedInstance() &#123;\n    ApplicationConversionService sharedInstance = sharedInstance;\n    if (sharedInstance == null) &#123;\n        Class var1 = ApplicationConversionService.class;\n        # 添加同步锁\n        synchronized(ApplicationConversionService.class) &#123;\n            sharedInstance = sharedInstance;\n            if (sharedInstance == null) &#123;\n                sharedInstance = new ApplicationConversionService();\n                sharedInstance = sharedInstance;\n            &#125;\n        &#125;\n    &#125;\n\n    return sharedInstance;\n&#125;</code></pre></p>\n<p>将之前的命令行配置环境新增或替换配置环境的<code>MutablePropertySources</code>，装配面板额外添加 <code>configureProfiles</code> ，在实际开发中用于测试生产配置分离，不同情况下激活不同的<code>profile</code><br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configurePropertySources</span><span class=\"hljs-params\">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;\n    MutablePropertySources sources = environment.getPropertySources();\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.defaultProperties != <span class=\"hljs-keyword\">null</span> &amp;&amp; !<span class=\"hljs-keyword\">this</span>.defaultProperties.isEmpty()) &#123;\n        sources.addLast(<span class=\"hljs-keyword\">new</span> MapPropertySource(<span class=\"hljs-string\">\"defaultProperties\"</span>, <span class=\"hljs-keyword\">this</span>.defaultProperties));\n    &#125;\n    <span class=\"hljs-comment\">// 命令行配置是否开启同时命令行数组大于0</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.addCommandLineProperties &amp;&amp; args.length &gt; <span class=\"hljs-number\">0</span>) &#123;\n        String name = <span class=\"hljs-string\">\"commandLineArgs\"</span>;\n        <span class=\"hljs-comment\">// 如果有则进行替换否则新增</span>\n        <span class=\"hljs-keyword\">if</span> (sources.contains(name)) &#123;\n            PropertySource&lt;?&gt; source = sources.get(name);\n            CompositePropertySource composite = <span class=\"hljs-keyword\">new</span> CompositePropertySource(name);\n            composite.addPropertySource(<span class=\"hljs-keyword\">new</span> SimpleCommandLinePropertySource(<span class=\"hljs-string\">\"springApplicationCommandLineArgs\"</span>, args));\n            composite.addPropertySource(source);\n            sources.replace(name, composite);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            sources.addFirst(<span class=\"hljs-keyword\">new</span> SimpleCommandLinePropertySource(args));\n        &#125;\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configureProfiles</span><span class=\"hljs-params\">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;\n    Set&lt;String&gt; profiles = <span class=\"hljs-keyword\">new</span> LinkedHashSet(<span class=\"hljs-keyword\">this</span>.additionalProfiles);\n    profiles.addAll(Arrays.asList(environment.getActiveProfiles()));\n    environment.setActiveProfiles(StringUtils.toStringArray(profiles));\n&#125;</code></pre></p>\n<p>接下来将<code>ConfigurationPropertySourcesPropertySource</code>加入<code>MutablePropertySources</code>，然后通过监听器广播发送<code>ApplicationEnvironmentPreparedEvent</code>应用环境准备事件，最后返回最终的容器中配属性资源包含以下</p>\n<ul>\n<li><strong>PropertiesPropertySource {name=’systemProperties’}</strong> ：保存当前系统配置情况的键值对信息（缺省信息）</li>\n<li><strong>SystemEnvironmentPropertySource {name=’systemEnvironment’}</strong> ： 对象保存当前系统环境变量键值对信息（缺省信息）</li>\n<li><strong>StubPropertySource {name=’servletContextInitParams’}</strong> ：保存上下文初始化参数 （Servlet 特有）</li>\n<li><strong>StubPropertySource {name=’servletConfigInitParams’}</strong> ：保存设置初始化参数（Servlet 特有）</li>\n<li><strong>JndiPropertySource {name=’jndiProperties’}</strong> ：保存Jndi相关配置（Servlet 特有）</li>\n<li><strong>SimpleCommandLinePropertySource {name=’commandLineArgs’}</strong> ：保存命令行额外参数</li>\n<li><strong>ConfigurationPropertySourcesPropertySource {name=’configurationProperties’}</strong> ：保存 MutablePropertySources 信息包含所有的配置信息</li>\n<li><strong>OriginTrackedMapPropertySource {name=’applicationConfig: [classpath:/application.yml]’}</strong> ：保存<code>spring</code>默认配置文件<code>properties</code>或<code>yml</code>中键值对信息</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>继监听器初始化完毕接来下开始可配置环境预处理</p>\n</blockquote>\n<h3 id=\"ApplicationArguments-默认参数初始化\"><a href=\"#ApplicationArguments-默认参数初始化\" class=\"headerlink\" title=\"ApplicationArguments 默认参数初始化\"></a>ApplicationArguments 默认参数初始化</h3><p>初始化<code>DefaultApplicationArguments</code>默认应用参数，通过<code>SimpleCommandLineArgsParser</code>对额外参数数组循环读取以<code>--</code>开头的命令行分割形成键值对封装为<code>SimpleCommandLinePropertySource</code>对象<br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> CommandLineArgs <span class=\"hljs-title\">parse</span><span class=\"hljs-params\">(String... args)</span> </span>&#123;\n    CommandLineArgs commandLineArgs = <span class=\"hljs-keyword\">new</span> CommandLineArgs();\n    String[] var3 = args;\n    <span class=\"hljs-keyword\">int</span> var4 = args.length;\n    \n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> var5 = <span class=\"hljs-number\">0</span>; var5 &lt; var4; ++var5) &#123;\n        String arg = var3[var5];\n        <span class=\"hljs-keyword\">if</span> (arg.startsWith(<span class=\"hljs-string\">\"--\"</span>)) &#123;\n            String optionText = arg.substring(<span class=\"hljs-number\">2</span>);\n            String optionValue = <span class=\"hljs-keyword\">null</span>;\n            <span class=\"hljs-keyword\">int</span> indexOfEqualsSign = optionText.indexOf(<span class=\"hljs-number\">61</span>);\n            String optionName;\n            <span class=\"hljs-keyword\">if</span> (indexOfEqualsSign &gt; -<span class=\"hljs-number\">1</span>) &#123;\n                optionName = optionText.substring(<span class=\"hljs-number\">0</span>, indexOfEqualsSign);\n                optionValue = optionText.substring(indexOfEqualsSign + <span class=\"hljs-number\">1</span>);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                optionName = optionText;\n            &#125;\n\n            <span class=\"hljs-keyword\">if</span> (optionName.isEmpty()) &#123;\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Invalid argument syntax: \"</span> + arg);\n            &#125;\n\n            commandLineArgs.addOptionArg(optionName, optionValue);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            commandLineArgs.addNonOptionArg(arg);\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> commandLineArgs;\n&#125;</code></pre></p>\n<h3 id=\"ConfigurableEnvironment-准备\"><a href=\"#ConfigurableEnvironment-准备\" class=\"headerlink\" title=\"ConfigurableEnvironment 准备\"></a>ConfigurableEnvironment 准备</h3><p>默认参数初始化完毕后开始配置环境准备阶段<br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> ConfigurableEnvironment <span class=\"hljs-title\">prepareEnvironment</span><span class=\"hljs-params\">(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</span> </span>&#123;\n    <span class=\"hljs-comment\">// 根据当前应用类型实例化环境</span>\n    ConfigurableEnvironment environment = <span class=\"hljs-keyword\">this</span>.getOrCreateEnvironment();\n    <span class=\"hljs-comment\">// 命令行额外参数添加</span>\n    <span class=\"hljs-keyword\">this</span>.configureEnvironment((ConfigurableEnvironment)environment, applicationArguments.getSourceArgs());\n    <span class=\"hljs-comment\">// SpringConfigurationPropertySources 保存之前 MutablePropertySources 数据</span>\n    ConfigurationPropertySources.attach((Environment)environment);\n    <span class=\"hljs-comment\">// 监听器广播配置环境准备事件</span>\n    listeners.environmentPrepared((ConfigurableEnvironment)environment);\n    <span class=\"hljs-comment\">// 绑定 Spring 默认的配置文件中信息</span>\n    <span class=\"hljs-keyword\">this</span>.bindToSpringApplication((ConfigurableEnvironment)environment);\n    <span class=\"hljs-comment\">// 是否为自定义容器 否则进行容器转化</span>\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.isCustomEnvironment) &#123;\n        environment = (<span class=\"hljs-keyword\">new</span> EnvironmentConverter(<span class=\"hljs-keyword\">this</span>.getClassLoader())).convertEnvironmentIfNecessary((ConfigurableEnvironment)environment, <span class=\"hljs-keyword\">this</span>.deduceEnvironmentClass());\n    &#125;\n\n    ConfigurationPropertySources.attach((Environment)environment);\n    <span class=\"hljs-keyword\">return</span> (ConfigurableEnvironment)environment;\n&#125;</code></pre></p>\n<h4 id=\"getOrCreateEnvironment\"><a href=\"#getOrCreateEnvironment\" class=\"headerlink\" title=\"getOrCreateEnvironment\"></a>getOrCreateEnvironment</h4><p>根据当前应用类型实例化不同的环境，所有环境对象都继承<code>StandardEnvironment</code>，默认配置环境<code>MutablePropertySources</code>对象里<code>propertySourceList</code>会新增以下<code>PropertySource</code><br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> ConfigurableEnvironment <span class=\"hljs-title\">getOrCreateEnvironment</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.environment != <span class=\"hljs-keyword\">null</span>) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.environment;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        <span class=\"hljs-keyword\">switch</span>(<span class=\"hljs-keyword\">this</span>.webApplicationType) &#123;\n        <span class=\"hljs-keyword\">case</span> SERVLET:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> StandardServletEnvironment();\n        <span class=\"hljs-keyword\">case</span> REACTIVE:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> StandardReactiveWebEnvironment();\n        <span class=\"hljs-keyword\">default</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> StandardEnvironment();\n        &#125;\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"configureEnvironment-配置环境\"><a href=\"#configureEnvironment-配置环境\" class=\"headerlink\" title=\"configureEnvironment 配置环境\"></a>configureEnvironment 配置环境</h4><p>根据之前实例化的配置环境加载<code>propertySource</code>、<code>profiles</code><br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configureEnvironment</span><span class=\"hljs-params\">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.addConversionService) &#123;\n        ConversionService conversionService = ApplicationConversionService.getSharedInstance();\n        environment.setConversionService((ConfigurableConversionService)conversionService);\n    &#125;\n    <span class=\"hljs-comment\">// 命令行加入属性资源</span>\n    <span class=\"hljs-keyword\">this</span>.configurePropertySources(environment, args);\n    <span class=\"hljs-keyword\">this</span>.configureProfiles(environment, args);\n&#125;</code></pre></p>\n<p>实例化<code>ConversionService</code>并加载到环境中，内部方法使用了<strong>双重验证同步锁</strong>单例模式<br><pre><code class=\"hljs java\">public static ConversionService getSharedInstance() &#123;\n    ApplicationConversionService sharedInstance = sharedInstance;\n    if (sharedInstance == null) &#123;\n        Class var1 = ApplicationConversionService.class;\n        # 添加同步锁\n        synchronized(ApplicationConversionService.class) &#123;\n            sharedInstance = sharedInstance;\n            if (sharedInstance == null) &#123;\n                sharedInstance = new ApplicationConversionService();\n                sharedInstance = sharedInstance;\n            &#125;\n        &#125;\n    &#125;\n\n    return sharedInstance;\n&#125;</code></pre></p>\n<p>将之前的命令行配置环境新增或替换配置环境的<code>MutablePropertySources</code>，装配面板额外添加 <code>configureProfiles</code> ，在实际开发中用于测试生产配置分离，不同情况下激活不同的<code>profile</code><br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configurePropertySources</span><span class=\"hljs-params\">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;\n    MutablePropertySources sources = environment.getPropertySources();\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.defaultProperties != <span class=\"hljs-keyword\">null</span> &amp;&amp; !<span class=\"hljs-keyword\">this</span>.defaultProperties.isEmpty()) &#123;\n        sources.addLast(<span class=\"hljs-keyword\">new</span> MapPropertySource(<span class=\"hljs-string\">\"defaultProperties\"</span>, <span class=\"hljs-keyword\">this</span>.defaultProperties));\n    &#125;\n    <span class=\"hljs-comment\">// 命令行配置是否开启同时命令行数组大于0</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.addCommandLineProperties &amp;&amp; args.length &gt; <span class=\"hljs-number\">0</span>) &#123;\n        String name = <span class=\"hljs-string\">\"commandLineArgs\"</span>;\n        <span class=\"hljs-comment\">// 如果有则进行替换否则新增</span>\n        <span class=\"hljs-keyword\">if</span> (sources.contains(name)) &#123;\n            PropertySource&lt;?&gt; source = sources.get(name);\n            CompositePropertySource composite = <span class=\"hljs-keyword\">new</span> CompositePropertySource(name);\n            composite.addPropertySource(<span class=\"hljs-keyword\">new</span> SimpleCommandLinePropertySource(<span class=\"hljs-string\">\"springApplicationCommandLineArgs\"</span>, args));\n            composite.addPropertySource(source);\n            sources.replace(name, composite);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            sources.addFirst(<span class=\"hljs-keyword\">new</span> SimpleCommandLinePropertySource(args));\n        &#125;\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configureProfiles</span><span class=\"hljs-params\">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;\n    Set&lt;String&gt; profiles = <span class=\"hljs-keyword\">new</span> LinkedHashSet(<span class=\"hljs-keyword\">this</span>.additionalProfiles);\n    profiles.addAll(Arrays.asList(environment.getActiveProfiles()));\n    environment.setActiveProfiles(StringUtils.toStringArray(profiles));\n&#125;</code></pre></p>\n<p>接下来将<code>ConfigurationPropertySourcesPropertySource</code>加入<code>MutablePropertySources</code>，然后通过监听器广播发送<code>ApplicationEnvironmentPreparedEvent</code>应用环境准备事件，最后返回最终的容器中配属性资源包含以下</p>\n<ul>\n<li><strong>PropertiesPropertySource {name=’systemProperties’}</strong> ：保存当前系统配置情况的键值对信息（缺省信息）</li>\n<li><strong>SystemEnvironmentPropertySource {name=’systemEnvironment’}</strong> ： 对象保存当前系统环境变量键值对信息（缺省信息）</li>\n<li><strong>StubPropertySource {name=’servletContextInitParams’}</strong> ：保存上下文初始化参数 （Servlet 特有）</li>\n<li><strong>StubPropertySource {name=’servletConfigInitParams’}</strong> ：保存设置初始化参数（Servlet 特有）</li>\n<li><strong>JndiPropertySource {name=’jndiProperties’}</strong> ：保存Jndi相关配置（Servlet 特有）</li>\n<li><strong>SimpleCommandLinePropertySource {name=’commandLineArgs’}</strong> ：保存命令行额外参数</li>\n<li><strong>ConfigurationPropertySourcesPropertySource {name=’configurationProperties’}</strong> ：保存 MutablePropertySources 信息包含所有的配置信息</li>\n<li><strong>OriginTrackedMapPropertySource {name=’applicationConfig: [classpath:/application.yml]’}</strong> ：保存<code>spring</code>默认配置文件<code>properties</code>或<code>yml</code>中键值对信息</li>\n</ul>\n"},{"title":"SpringBoot 启动源码解析（二）之监听器","toc":false,"date":"2020-05-11T06:14:36.000Z","_content":"\n![](/images/spring.jpg)\n> 监听器在 Spring 中特别重要可以自定义监听器获取各类事件做一些特殊操作\n\n### SpringApplicationRunListeners 事件监听器\n将存于`MATE/spring.factories`中的`SpringApplicationRunListener`类型全部实例化，传入`SpringApplication`对象作为参数\n``` java\n private SpringApplicationRunListeners getRunListeners(String[] args) {\n        Class<?>[] types = new Class[]{SpringApplication.class, String[].class};\n        return new SpringApplicationRunListeners(logger, this.getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));\n}\n```\n以`EventPublishingRunListener`（事件推送监听器）为例，将之前已实例化`ApplicationListener`加入`SimpleApplicationEventMulticaster`（事件多广播器）的`defaultRetriever`(检索器) 中待事件发生遍历推送\n\n``` java\npublic EventPublishingRunListener(SpringApplication application, String[] args) {\n    this.application = application;\n    this.args = args;\n    // 初始化事件广播器\n    this.initialMulticaster = new SimpleApplicationEventMulticaster();\n    // 遍历监听器集合并加入事件广播器中\n    Iterator var3 = application.getListeners().iterator();\n    while(var3.hasNext()) {\n        ApplicationListener<?> listener = (ApplicationListener)var3.next();\n        this.initialMulticaster.addApplicationListener(listener);\n    }\n}\n\npublic void addApplicationListener(ApplicationListener<?> listener) {\n    synchronized(this.retrievalMutex) {\n        Object singletonTarget = AopProxyUtils.getSingletonTarget(listener);\n        if (singletonTarget instanceof ApplicationListener) {\n            this.defaultRetriever.applicationListeners.remove(singletonTarget);\n        }\n        this.defaultRetriever.applicationListeners.add(listener);\n        // 清空检索器缓存\n        this.retrieverCache.clear();\n    }\n}\n```\n\n#### ApplicationEvent 事件\n在 Spring 的启动的个个阶段会推送不同的 ApplicationEvent 事件至监听器完成相应阶段的逻辑操作\n- **ApplicationStartingEvent**：在 Environment 和 ApplicationContext 可用之前 & 在 ApplicationListener 注册之后发布。\n- **ApplicationEnvironmentPreparedEvent** ：配置环境完毕时推送，获取到当前配`ConfigurableEnvironment`可自定义修改配置或新增额外配置\n- **ApplicationContextInitializedEvent**：在 bean 定义加载之前 & ApplicationContextInitializers 被调用之后 & ApplicationContext 开始准备之后发布\n- **ApplicationPreparedEvent**：在 ApplicationContext 完全准备好并且没有刷新之前发布，此时 bean 定义即将加载， \n Environment 已经准备好被使用。\n- **ApplicationStartedEvent**：在 ApplicationContext 刷新之后，调用 ApplicationRunner 和 CommandLineRunner 之前发布\n- **ApplicationReadyEvent**：应用已经准备好接受请求时发布。\n\n#### SimpleApplicationEventMulticaster 事件广播器\n![simpleApplicationEventMulticaster](/images/simpleApplicationEventMulticaster.png)\n每次事件发生内部调用`multicastEvent`方循环调用监听器`onApplicationEvent`，如果有线程池则异步调用否则同步调用，事件监听推送就是经典的__观察者设计模式__\n``` java\npublic void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType) {\n    // 可解决类型\n    ResolvableType type = eventType != null ? eventType : this.resolveDefaultEventType(event);\n    // 根据事件类型和可解决类型过滤已有监听器\n    Iterator var4 = this.getApplicationListeners(event, type).iterator();\n\n    while(var4.hasNext()) {\n        ApplicationListener<?> listener = (ApplicationListener)var4.next();\n        // 获取线程池\n        Executor executor = this.getTaskExecutor();\n        if (executor != null) {\n            executor.execute(() -> {\n                this.invokeListener(listener, event);\n            });\n        } else {\n            this.invokeListener(listener, event);\n        }\n    }\n}\n```\n\n当事件发生并不是所有的监听器都需要推送，通过父类`AbstractApplicationEventMulticaster`中`getApplicationListeners`方法过滤集合并以`AbstractApplicationEventMulticaster.ListenerCacheKey`作为 key `AbstractApplicationEventMulticaster.ListenerRetriever` 作为 value 的`ConcurrentHashMap`检索器缓存用于各种事件检索，`supportsEvent`代码中先判断当前监听器类型如果为`GenericApplicationListener`则调用`supportsEventType`和`supportsSourceType`方法判断是否都为`true`否则通过`GenericApplicationListenerAdapter`适配器进行包装转化后判断\n\n``` java\nprotected Collection<ApplicationListener<?>> getApplicationListeners(ApplicationEvent event, ResolvableType eventType) {\n    Object source = event.getSource();\n    Class<?> sourceType = source != null ? source.getClass() : null;\n    // 实例化监听器缓存 key\n    AbstractApplicationEventMulticaster.ListenerCacheKey cacheKey = new AbstractApplicationEventMulticaster.ListenerCacheKey(eventType, sourceType);\n    // 根据 key 获取相应监听器检索器\n    AbstractApplicationEventMulticaster.ListenerRetriever retriever = (AbstractApplicationEventMulticaster.ListenerRetriever)this.retrieverCache.get(cacheKey);\n    // 存在直接返回否则进行判断过滤生成缓存\n    if (retriever != null) {\n        return retriever.getApplicationListeners();\n    } else if (this.beanClassLoader == null || ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) && (sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader))) {\n        synchronized(this.retrievalMutex) {\n            // 获取监听器检索器缓存\n            retriever = (AbstractApplicationEventMulticaster.ListenerRetriever)this.retrieverCache.get(cacheKey);\n            if (retriever != null) {\n                return retriever.getApplicationListeners();\n            } else {\n                // 实例化一个标识已过滤的监听器检索器\n                retriever = new AbstractApplicationEventMulticaster.ListenerRetriever(true);\n                // 根据事件类型和来源类型进行检索过滤\n                Collection<ApplicationListener<?>> listeners = this.retrieveApplicationListeners(eventType, sourceType, retriever);\n                // 将该事件类型的检索器加入 Map 缓存\n                this.retrieverCache.put(cacheKey, retriever);\n                return listeners;\n            }\n        }\n    } else {\n        return this.retrieveApplicationListeners(eventType, sourceType, (AbstractApplicationEventMulticaster.ListenerRetriever)null);\n    }\n}\n\n// 判读是否支持该事件类型以及来源\nprotected boolean supportsEvent(ApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType) {\n    GenericApplicationListener smartListener = listener instanceof GenericApplicationListener ? (GenericApplicationListener)listener : new GenericApplicationListenerAdapter(listener);\n    return ((GenericApplicationListener)smartListener).supportsEventType(eventType) && ((GenericApplicationListener)smartListener).supportsSourceType(sourceType);\n}\n```\n\n>>  在 SimpleApplicationEventMulticaster 实例化时会将默认的 defaultRetriever 引用赋值给 `retrievalMutex` 检索互斥体，在内部很多方法都使用了 synchronized(this.retrievalMutex) 同步锁来保证线程安全","source":"_posts/Springboot 启动过程（二）.md","raw":"---\ntitle: SpringBoot 启动源码解析（二）之监听器\ntags:\n  - Spring\ncategories:\n  - Spring\ntoc: false\ndate: 2020-05-11 14:14:36\n---\n\n![](/images/spring.jpg)\n> 监听器在 Spring 中特别重要可以自定义监听器获取各类事件做一些特殊操作\n\n### SpringApplicationRunListeners 事件监听器\n将存于`MATE/spring.factories`中的`SpringApplicationRunListener`类型全部实例化，传入`SpringApplication`对象作为参数\n``` java\n private SpringApplicationRunListeners getRunListeners(String[] args) {\n        Class<?>[] types = new Class[]{SpringApplication.class, String[].class};\n        return new SpringApplicationRunListeners(logger, this.getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));\n}\n```\n以`EventPublishingRunListener`（事件推送监听器）为例，将之前已实例化`ApplicationListener`加入`SimpleApplicationEventMulticaster`（事件多广播器）的`defaultRetriever`(检索器) 中待事件发生遍历推送\n\n``` java\npublic EventPublishingRunListener(SpringApplication application, String[] args) {\n    this.application = application;\n    this.args = args;\n    // 初始化事件广播器\n    this.initialMulticaster = new SimpleApplicationEventMulticaster();\n    // 遍历监听器集合并加入事件广播器中\n    Iterator var3 = application.getListeners().iterator();\n    while(var3.hasNext()) {\n        ApplicationListener<?> listener = (ApplicationListener)var3.next();\n        this.initialMulticaster.addApplicationListener(listener);\n    }\n}\n\npublic void addApplicationListener(ApplicationListener<?> listener) {\n    synchronized(this.retrievalMutex) {\n        Object singletonTarget = AopProxyUtils.getSingletonTarget(listener);\n        if (singletonTarget instanceof ApplicationListener) {\n            this.defaultRetriever.applicationListeners.remove(singletonTarget);\n        }\n        this.defaultRetriever.applicationListeners.add(listener);\n        // 清空检索器缓存\n        this.retrieverCache.clear();\n    }\n}\n```\n\n#### ApplicationEvent 事件\n在 Spring 的启动的个个阶段会推送不同的 ApplicationEvent 事件至监听器完成相应阶段的逻辑操作\n- **ApplicationStartingEvent**：在 Environment 和 ApplicationContext 可用之前 & 在 ApplicationListener 注册之后发布。\n- **ApplicationEnvironmentPreparedEvent** ：配置环境完毕时推送，获取到当前配`ConfigurableEnvironment`可自定义修改配置或新增额外配置\n- **ApplicationContextInitializedEvent**：在 bean 定义加载之前 & ApplicationContextInitializers 被调用之后 & ApplicationContext 开始准备之后发布\n- **ApplicationPreparedEvent**：在 ApplicationContext 完全准备好并且没有刷新之前发布，此时 bean 定义即将加载， \n Environment 已经准备好被使用。\n- **ApplicationStartedEvent**：在 ApplicationContext 刷新之后，调用 ApplicationRunner 和 CommandLineRunner 之前发布\n- **ApplicationReadyEvent**：应用已经准备好接受请求时发布。\n\n#### SimpleApplicationEventMulticaster 事件广播器\n![simpleApplicationEventMulticaster](/images/simpleApplicationEventMulticaster.png)\n每次事件发生内部调用`multicastEvent`方循环调用监听器`onApplicationEvent`，如果有线程池则异步调用否则同步调用，事件监听推送就是经典的__观察者设计模式__\n``` java\npublic void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType) {\n    // 可解决类型\n    ResolvableType type = eventType != null ? eventType : this.resolveDefaultEventType(event);\n    // 根据事件类型和可解决类型过滤已有监听器\n    Iterator var4 = this.getApplicationListeners(event, type).iterator();\n\n    while(var4.hasNext()) {\n        ApplicationListener<?> listener = (ApplicationListener)var4.next();\n        // 获取线程池\n        Executor executor = this.getTaskExecutor();\n        if (executor != null) {\n            executor.execute(() -> {\n                this.invokeListener(listener, event);\n            });\n        } else {\n            this.invokeListener(listener, event);\n        }\n    }\n}\n```\n\n当事件发生并不是所有的监听器都需要推送，通过父类`AbstractApplicationEventMulticaster`中`getApplicationListeners`方法过滤集合并以`AbstractApplicationEventMulticaster.ListenerCacheKey`作为 key `AbstractApplicationEventMulticaster.ListenerRetriever` 作为 value 的`ConcurrentHashMap`检索器缓存用于各种事件检索，`supportsEvent`代码中先判断当前监听器类型如果为`GenericApplicationListener`则调用`supportsEventType`和`supportsSourceType`方法判断是否都为`true`否则通过`GenericApplicationListenerAdapter`适配器进行包装转化后判断\n\n``` java\nprotected Collection<ApplicationListener<?>> getApplicationListeners(ApplicationEvent event, ResolvableType eventType) {\n    Object source = event.getSource();\n    Class<?> sourceType = source != null ? source.getClass() : null;\n    // 实例化监听器缓存 key\n    AbstractApplicationEventMulticaster.ListenerCacheKey cacheKey = new AbstractApplicationEventMulticaster.ListenerCacheKey(eventType, sourceType);\n    // 根据 key 获取相应监听器检索器\n    AbstractApplicationEventMulticaster.ListenerRetriever retriever = (AbstractApplicationEventMulticaster.ListenerRetriever)this.retrieverCache.get(cacheKey);\n    // 存在直接返回否则进行判断过滤生成缓存\n    if (retriever != null) {\n        return retriever.getApplicationListeners();\n    } else if (this.beanClassLoader == null || ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) && (sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader))) {\n        synchronized(this.retrievalMutex) {\n            // 获取监听器检索器缓存\n            retriever = (AbstractApplicationEventMulticaster.ListenerRetriever)this.retrieverCache.get(cacheKey);\n            if (retriever != null) {\n                return retriever.getApplicationListeners();\n            } else {\n                // 实例化一个标识已过滤的监听器检索器\n                retriever = new AbstractApplicationEventMulticaster.ListenerRetriever(true);\n                // 根据事件类型和来源类型进行检索过滤\n                Collection<ApplicationListener<?>> listeners = this.retrieveApplicationListeners(eventType, sourceType, retriever);\n                // 将该事件类型的检索器加入 Map 缓存\n                this.retrieverCache.put(cacheKey, retriever);\n                return listeners;\n            }\n        }\n    } else {\n        return this.retrieveApplicationListeners(eventType, sourceType, (AbstractApplicationEventMulticaster.ListenerRetriever)null);\n    }\n}\n\n// 判读是否支持该事件类型以及来源\nprotected boolean supportsEvent(ApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType) {\n    GenericApplicationListener smartListener = listener instanceof GenericApplicationListener ? (GenericApplicationListener)listener : new GenericApplicationListenerAdapter(listener);\n    return ((GenericApplicationListener)smartListener).supportsEventType(eventType) && ((GenericApplicationListener)smartListener).supportsSourceType(sourceType);\n}\n```\n\n>>  在 SimpleApplicationEventMulticaster 实例化时会将默认的 defaultRetriever 引用赋值给 `retrievalMutex` 检索互斥体，在内部很多方法都使用了 synchronized(this.retrievalMutex) 同步锁来保证线程安全","slug":"Springboot 启动过程（二）","published":1,"updated":"2020-08-10T01:48:44.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc99k003qjsudms2hbp3h","content":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>监听器在 Spring 中特别重要可以自定义监听器获取各类事件做一些特殊操作</p>\n</blockquote>\n<h3 id=\"SpringApplicationRunListeners-事件监听器\"><a href=\"#SpringApplicationRunListeners-事件监听器\" class=\"headerlink\" title=\"SpringApplicationRunListeners 事件监听器\"></a>SpringApplicationRunListeners 事件监听器</h3><p>将存于<code>MATE/spring.factories</code>中的<code>SpringApplicationRunListener</code>类型全部实例化，传入<code>SpringApplication</code>对象作为参数<br><pre><code class=\"hljs java\"> private SpringApplicationRunListeners getRunListeners(String[] args) &#123;\n        Class&lt;?&gt;[] types = new Class[]&#123;SpringApplication.class, String[].class&#125;;\n        return new SpringApplicationRunListeners(logger, this.getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));\n&#125;</code></pre></p>\n<p>以<code>EventPublishingRunListener</code>（事件推送监听器）为例，将之前已实例化<code>ApplicationListener</code>加入<code>SimpleApplicationEventMulticaster</code>（事件多广播器）的<code>defaultRetriever</code>(检索器) 中待事件发生遍历推送</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">EventPublishingRunListener</span><span class=\"hljs-params\">(SpringApplication application, String[] args)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.application = application;\n    <span class=\"hljs-keyword\">this</span>.args = args;\n    <span class=\"hljs-comment\">// 初始化事件广播器</span>\n    <span class=\"hljs-keyword\">this</span>.initialMulticaster = <span class=\"hljs-keyword\">new</span> SimpleApplicationEventMulticaster();\n    <span class=\"hljs-comment\">// 遍历监听器集合并加入事件广播器中</span>\n    Iterator var3 = application.getListeners().iterator();\n    <span class=\"hljs-keyword\">while</span>(var3.hasNext()) &#123;\n        ApplicationListener&lt;?&gt; listener = (ApplicationListener)var3.next();\n        <span class=\"hljs-keyword\">this</span>.initialMulticaster.addApplicationListener(listener);\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addApplicationListener</span><span class=\"hljs-params\">(ApplicationListener&lt;?&gt; listener)</span> </span>&#123;\n    <span class=\"hljs-keyword\">synchronized</span>(<span class=\"hljs-keyword\">this</span>.retrievalMutex) &#123;\n        Object singletonTarget = AopProxyUtils.getSingletonTarget(listener);\n        <span class=\"hljs-keyword\">if</span> (singletonTarget <span class=\"hljs-keyword\">instanceof</span> ApplicationListener) &#123;\n            <span class=\"hljs-keyword\">this</span>.defaultRetriever.applicationListeners.remove(singletonTarget);\n        &#125;\n        <span class=\"hljs-keyword\">this</span>.defaultRetriever.applicationListeners.add(listener);\n        <span class=\"hljs-comment\">// 清空检索器缓存</span>\n        <span class=\"hljs-keyword\">this</span>.retrieverCache.clear();\n    &#125;\n&#125;</code></pre>\n<h4 id=\"ApplicationEvent-事件\"><a href=\"#ApplicationEvent-事件\" class=\"headerlink\" title=\"ApplicationEvent 事件\"></a>ApplicationEvent 事件</h4><p>在 Spring 的启动的个个阶段会推送不同的 ApplicationEvent 事件至监听器完成相应阶段的逻辑操作</p>\n<ul>\n<li><strong>ApplicationStartingEvent</strong>：在 Environment 和 ApplicationContext 可用之前 &amp; 在 ApplicationListener 注册之后发布。</li>\n<li><strong>ApplicationEnvironmentPreparedEvent</strong> ：配置环境完毕时推送，获取到当前配<code>ConfigurableEnvironment</code>可自定义修改配置或新增额外配置</li>\n<li><strong>ApplicationContextInitializedEvent</strong>：在 bean 定义加载之前 &amp; ApplicationContextInitializers 被调用之后 &amp; ApplicationContext 开始准备之后发布</li>\n<li><strong>ApplicationPreparedEvent</strong>：在 ApplicationContext 完全准备好并且没有刷新之前发布，此时 bean 定义即将加载，<br>Environment 已经准备好被使用。</li>\n<li><strong>ApplicationStartedEvent</strong>：在 ApplicationContext 刷新之后，调用 ApplicationRunner 和 CommandLineRunner 之前发布</li>\n<li><strong>ApplicationReadyEvent</strong>：应用已经准备好接受请求时发布。</li>\n</ul>\n<h4 id=\"SimpleApplicationEventMulticaster-事件广播器\"><a href=\"#SimpleApplicationEventMulticaster-事件广播器\" class=\"headerlink\" title=\"SimpleApplicationEventMulticaster 事件广播器\"></a>SimpleApplicationEventMulticaster 事件广播器</h4><p><img src=\"/images/simpleApplicationEventMulticaster.png\" srcset=\"/img/loading.gif\" alt=\"simpleApplicationEventMulticaster\"><br>每次事件发生内部调用<code>multicastEvent</code>方循环调用监听器<code>onApplicationEvent</code>，如果有线程池则异步调用否则同步调用，事件监听推送就是经典的<strong>观察者设计模式</strong><br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">multicastEvent</span><span class=\"hljs-params\">(ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;\n    <span class=\"hljs-comment\">// 可解决类型</span>\n    ResolvableType type = eventType != <span class=\"hljs-keyword\">null</span> ? eventType : <span class=\"hljs-keyword\">this</span>.resolveDefaultEventType(event);\n    <span class=\"hljs-comment\">// 根据事件类型和可解决类型过滤已有监听器</span>\n    Iterator var4 = <span class=\"hljs-keyword\">this</span>.getApplicationListeners(event, type).iterator();\n\n    <span class=\"hljs-keyword\">while</span>(var4.hasNext()) &#123;\n        ApplicationListener&lt;?&gt; listener = (ApplicationListener)var4.next();\n        <span class=\"hljs-comment\">// 获取线程池</span>\n        Executor executor = <span class=\"hljs-keyword\">this</span>.getTaskExecutor();\n        <span class=\"hljs-keyword\">if</span> (executor != <span class=\"hljs-keyword\">null</span>) &#123;\n            executor.execute(() -&gt; &#123;\n                <span class=\"hljs-keyword\">this</span>.invokeListener(listener, event);\n            &#125;);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            <span class=\"hljs-keyword\">this</span>.invokeListener(listener, event);\n        &#125;\n    &#125;\n&#125;</code></pre></p>\n<p>当事件发生并不是所有的监听器都需要推送，通过父类<code>AbstractApplicationEventMulticaster</code>中<code>getApplicationListeners</code>方法过滤集合并以<code>AbstractApplicationEventMulticaster.ListenerCacheKey</code>作为 key <code>AbstractApplicationEventMulticaster.ListenerRetriever</code> 作为 value 的<code>ConcurrentHashMap</code>检索器缓存用于各种事件检索，<code>supportsEvent</code>代码中先判断当前监听器类型如果为<code>GenericApplicationListener</code>则调用<code>supportsEventType</code>和<code>supportsSourceType</code>方法判断是否都为<code>true</code>否则通过<code>GenericApplicationListenerAdapter</code>适配器进行包装转化后判断</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(ApplicationEvent event, ResolvableType eventType) &#123;\n    Object source = event.getSource();\n    Class&lt;?&gt; sourceType = source != <span class=\"hljs-keyword\">null</span> ? source.getClass() : <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-comment\">// 实例化监听器缓存 key</span>\n    AbstractApplicationEventMulticaster.ListenerCacheKey cacheKey = <span class=\"hljs-keyword\">new</span> AbstractApplicationEventMulticaster.ListenerCacheKey(eventType, sourceType);\n    <span class=\"hljs-comment\">// 根据 key 获取相应监听器检索器</span>\n    AbstractApplicationEventMulticaster.ListenerRetriever retriever = (AbstractApplicationEventMulticaster.ListenerRetriever)<span class=\"hljs-keyword\">this</span>.retrieverCache.get(cacheKey);\n    <span class=\"hljs-comment\">// 存在直接返回否则进行判断过滤生成缓存</span>\n    <span class=\"hljs-keyword\">if</span> (retriever != <span class=\"hljs-keyword\">null</span>) &#123;\n        <span class=\"hljs-keyword\">return</span> retriever.getApplicationListeners();\n    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.beanClassLoader == <span class=\"hljs-keyword\">null</span> || ClassUtils.isCacheSafe(event.getClass(), <span class=\"hljs-keyword\">this</span>.beanClassLoader) &amp;&amp; (sourceType == <span class=\"hljs-keyword\">null</span> || ClassUtils.isCacheSafe(sourceType, <span class=\"hljs-keyword\">this</span>.beanClassLoader))) &#123;\n        <span class=\"hljs-keyword\">synchronized</span>(<span class=\"hljs-keyword\">this</span>.retrievalMutex) &#123;\n            <span class=\"hljs-comment\">// 获取监听器检索器缓存</span>\n            retriever = (AbstractApplicationEventMulticaster.ListenerRetriever)<span class=\"hljs-keyword\">this</span>.retrieverCache.get(cacheKey);\n            <span class=\"hljs-keyword\">if</span> (retriever != <span class=\"hljs-keyword\">null</span>) &#123;\n                <span class=\"hljs-keyword\">return</span> retriever.getApplicationListeners();\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-comment\">// 实例化一个标识已过滤的监听器检索器</span>\n                retriever = <span class=\"hljs-keyword\">new</span> AbstractApplicationEventMulticaster.ListenerRetriever(<span class=\"hljs-keyword\">true</span>);\n                <span class=\"hljs-comment\">// 根据事件类型和来源类型进行检索过滤</span>\n                Collection&lt;ApplicationListener&lt;?&gt;&gt; listeners = <span class=\"hljs-keyword\">this</span>.retrieveApplicationListeners(eventType, sourceType, retriever);\n                <span class=\"hljs-comment\">// 将该事件类型的检索器加入 Map 缓存</span>\n                <span class=\"hljs-keyword\">this</span>.retrieverCache.put(cacheKey, retriever);\n                <span class=\"hljs-keyword\">return</span> listeners;\n            &#125;\n        &#125;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.retrieveApplicationListeners(eventType, sourceType, (AbstractApplicationEventMulticaster.ListenerRetriever)<span class=\"hljs-keyword\">null</span>);\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">// 判读是否支持该事件类型以及来源</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">supportsEvent</span><span class=\"hljs-params\">(ApplicationListener&lt;?&gt; listener, ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType)</span> </span>&#123;\n    GenericApplicationListener smartListener = listener <span class=\"hljs-keyword\">instanceof</span> GenericApplicationListener ? (GenericApplicationListener)listener : <span class=\"hljs-keyword\">new</span> GenericApplicationListenerAdapter(listener);\n    <span class=\"hljs-keyword\">return</span> ((GenericApplicationListener)smartListener).supportsEventType(eventType) &amp;&amp; ((GenericApplicationListener)smartListener).supportsSourceType(sourceType);\n&#125;</code></pre>\n<blockquote>\n<blockquote>\n<p> 在 SimpleApplicationEventMulticaster 实例化时会将默认的 defaultRetriever 引用赋值给 <code>retrievalMutex</code> 检索互斥体，在内部很多方法都使用了 synchronized(this.retrievalMutex) 同步锁来保证线程安全</p>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>监听器在 Spring 中特别重要可以自定义监听器获取各类事件做一些特殊操作</p>\n</blockquote>\n<h3 id=\"SpringApplicationRunListeners-事件监听器\"><a href=\"#SpringApplicationRunListeners-事件监听器\" class=\"headerlink\" title=\"SpringApplicationRunListeners 事件监听器\"></a>SpringApplicationRunListeners 事件监听器</h3><p>将存于<code>MATE/spring.factories</code>中的<code>SpringApplicationRunListener</code>类型全部实例化，传入<code>SpringApplication</code>对象作为参数<br><pre><code class=\"hljs java\"> private SpringApplicationRunListeners getRunListeners(String[] args) &#123;\n        Class&lt;?&gt;[] types = new Class[]&#123;SpringApplication.class, String[].class&#125;;\n        return new SpringApplicationRunListeners(logger, this.getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));\n&#125;</code></pre></p>\n<p>以<code>EventPublishingRunListener</code>（事件推送监听器）为例，将之前已实例化<code>ApplicationListener</code>加入<code>SimpleApplicationEventMulticaster</code>（事件多广播器）的<code>defaultRetriever</code>(检索器) 中待事件发生遍历推送</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">EventPublishingRunListener</span><span class=\"hljs-params\">(SpringApplication application, String[] args)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.application = application;\n    <span class=\"hljs-keyword\">this</span>.args = args;\n    <span class=\"hljs-comment\">// 初始化事件广播器</span>\n    <span class=\"hljs-keyword\">this</span>.initialMulticaster = <span class=\"hljs-keyword\">new</span> SimpleApplicationEventMulticaster();\n    <span class=\"hljs-comment\">// 遍历监听器集合并加入事件广播器中</span>\n    Iterator var3 = application.getListeners().iterator();\n    <span class=\"hljs-keyword\">while</span>(var3.hasNext()) &#123;\n        ApplicationListener&lt;?&gt; listener = (ApplicationListener)var3.next();\n        <span class=\"hljs-keyword\">this</span>.initialMulticaster.addApplicationListener(listener);\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addApplicationListener</span><span class=\"hljs-params\">(ApplicationListener&lt;?&gt; listener)</span> </span>&#123;\n    <span class=\"hljs-keyword\">synchronized</span>(<span class=\"hljs-keyword\">this</span>.retrievalMutex) &#123;\n        Object singletonTarget = AopProxyUtils.getSingletonTarget(listener);\n        <span class=\"hljs-keyword\">if</span> (singletonTarget <span class=\"hljs-keyword\">instanceof</span> ApplicationListener) &#123;\n            <span class=\"hljs-keyword\">this</span>.defaultRetriever.applicationListeners.remove(singletonTarget);\n        &#125;\n        <span class=\"hljs-keyword\">this</span>.defaultRetriever.applicationListeners.add(listener);\n        <span class=\"hljs-comment\">// 清空检索器缓存</span>\n        <span class=\"hljs-keyword\">this</span>.retrieverCache.clear();\n    &#125;\n&#125;</code></pre>\n<h4 id=\"ApplicationEvent-事件\"><a href=\"#ApplicationEvent-事件\" class=\"headerlink\" title=\"ApplicationEvent 事件\"></a>ApplicationEvent 事件</h4><p>在 Spring 的启动的个个阶段会推送不同的 ApplicationEvent 事件至监听器完成相应阶段的逻辑操作</p>\n<ul>\n<li><strong>ApplicationStartingEvent</strong>：在 Environment 和 ApplicationContext 可用之前 &amp; 在 ApplicationListener 注册之后发布。</li>\n<li><strong>ApplicationEnvironmentPreparedEvent</strong> ：配置环境完毕时推送，获取到当前配<code>ConfigurableEnvironment</code>可自定义修改配置或新增额外配置</li>\n<li><strong>ApplicationContextInitializedEvent</strong>：在 bean 定义加载之前 &amp; ApplicationContextInitializers 被调用之后 &amp; ApplicationContext 开始准备之后发布</li>\n<li><strong>ApplicationPreparedEvent</strong>：在 ApplicationContext 完全准备好并且没有刷新之前发布，此时 bean 定义即将加载，<br>Environment 已经准备好被使用。</li>\n<li><strong>ApplicationStartedEvent</strong>：在 ApplicationContext 刷新之后，调用 ApplicationRunner 和 CommandLineRunner 之前发布</li>\n<li><strong>ApplicationReadyEvent</strong>：应用已经准备好接受请求时发布。</li>\n</ul>\n<h4 id=\"SimpleApplicationEventMulticaster-事件广播器\"><a href=\"#SimpleApplicationEventMulticaster-事件广播器\" class=\"headerlink\" title=\"SimpleApplicationEventMulticaster 事件广播器\"></a>SimpleApplicationEventMulticaster 事件广播器</h4><p><img src=\"/images/simpleApplicationEventMulticaster.png\" srcset=\"/img/loading.gif\" alt=\"simpleApplicationEventMulticaster\"><br>每次事件发生内部调用<code>multicastEvent</code>方循环调用监听器<code>onApplicationEvent</code>，如果有线程池则异步调用否则同步调用，事件监听推送就是经典的<strong>观察者设计模式</strong><br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">multicastEvent</span><span class=\"hljs-params\">(ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;\n    <span class=\"hljs-comment\">// 可解决类型</span>\n    ResolvableType type = eventType != <span class=\"hljs-keyword\">null</span> ? eventType : <span class=\"hljs-keyword\">this</span>.resolveDefaultEventType(event);\n    <span class=\"hljs-comment\">// 根据事件类型和可解决类型过滤已有监听器</span>\n    Iterator var4 = <span class=\"hljs-keyword\">this</span>.getApplicationListeners(event, type).iterator();\n\n    <span class=\"hljs-keyword\">while</span>(var4.hasNext()) &#123;\n        ApplicationListener&lt;?&gt; listener = (ApplicationListener)var4.next();\n        <span class=\"hljs-comment\">// 获取线程池</span>\n        Executor executor = <span class=\"hljs-keyword\">this</span>.getTaskExecutor();\n        <span class=\"hljs-keyword\">if</span> (executor != <span class=\"hljs-keyword\">null</span>) &#123;\n            executor.execute(() -&gt; &#123;\n                <span class=\"hljs-keyword\">this</span>.invokeListener(listener, event);\n            &#125;);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            <span class=\"hljs-keyword\">this</span>.invokeListener(listener, event);\n        &#125;\n    &#125;\n&#125;</code></pre></p>\n<p>当事件发生并不是所有的监听器都需要推送，通过父类<code>AbstractApplicationEventMulticaster</code>中<code>getApplicationListeners</code>方法过滤集合并以<code>AbstractApplicationEventMulticaster.ListenerCacheKey</code>作为 key <code>AbstractApplicationEventMulticaster.ListenerRetriever</code> 作为 value 的<code>ConcurrentHashMap</code>检索器缓存用于各种事件检索，<code>supportsEvent</code>代码中先判断当前监听器类型如果为<code>GenericApplicationListener</code>则调用<code>supportsEventType</code>和<code>supportsSourceType</code>方法判断是否都为<code>true</code>否则通过<code>GenericApplicationListenerAdapter</code>适配器进行包装转化后判断</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(ApplicationEvent event, ResolvableType eventType) &#123;\n    Object source = event.getSource();\n    Class&lt;?&gt; sourceType = source != <span class=\"hljs-keyword\">null</span> ? source.getClass() : <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-comment\">// 实例化监听器缓存 key</span>\n    AbstractApplicationEventMulticaster.ListenerCacheKey cacheKey = <span class=\"hljs-keyword\">new</span> AbstractApplicationEventMulticaster.ListenerCacheKey(eventType, sourceType);\n    <span class=\"hljs-comment\">// 根据 key 获取相应监听器检索器</span>\n    AbstractApplicationEventMulticaster.ListenerRetriever retriever = (AbstractApplicationEventMulticaster.ListenerRetriever)<span class=\"hljs-keyword\">this</span>.retrieverCache.get(cacheKey);\n    <span class=\"hljs-comment\">// 存在直接返回否则进行判断过滤生成缓存</span>\n    <span class=\"hljs-keyword\">if</span> (retriever != <span class=\"hljs-keyword\">null</span>) &#123;\n        <span class=\"hljs-keyword\">return</span> retriever.getApplicationListeners();\n    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.beanClassLoader == <span class=\"hljs-keyword\">null</span> || ClassUtils.isCacheSafe(event.getClass(), <span class=\"hljs-keyword\">this</span>.beanClassLoader) &amp;&amp; (sourceType == <span class=\"hljs-keyword\">null</span> || ClassUtils.isCacheSafe(sourceType, <span class=\"hljs-keyword\">this</span>.beanClassLoader))) &#123;\n        <span class=\"hljs-keyword\">synchronized</span>(<span class=\"hljs-keyword\">this</span>.retrievalMutex) &#123;\n            <span class=\"hljs-comment\">// 获取监听器检索器缓存</span>\n            retriever = (AbstractApplicationEventMulticaster.ListenerRetriever)<span class=\"hljs-keyword\">this</span>.retrieverCache.get(cacheKey);\n            <span class=\"hljs-keyword\">if</span> (retriever != <span class=\"hljs-keyword\">null</span>) &#123;\n                <span class=\"hljs-keyword\">return</span> retriever.getApplicationListeners();\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-comment\">// 实例化一个标识已过滤的监听器检索器</span>\n                retriever = <span class=\"hljs-keyword\">new</span> AbstractApplicationEventMulticaster.ListenerRetriever(<span class=\"hljs-keyword\">true</span>);\n                <span class=\"hljs-comment\">// 根据事件类型和来源类型进行检索过滤</span>\n                Collection&lt;ApplicationListener&lt;?&gt;&gt; listeners = <span class=\"hljs-keyword\">this</span>.retrieveApplicationListeners(eventType, sourceType, retriever);\n                <span class=\"hljs-comment\">// 将该事件类型的检索器加入 Map 缓存</span>\n                <span class=\"hljs-keyword\">this</span>.retrieverCache.put(cacheKey, retriever);\n                <span class=\"hljs-keyword\">return</span> listeners;\n            &#125;\n        &#125;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.retrieveApplicationListeners(eventType, sourceType, (AbstractApplicationEventMulticaster.ListenerRetriever)<span class=\"hljs-keyword\">null</span>);\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">// 判读是否支持该事件类型以及来源</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">supportsEvent</span><span class=\"hljs-params\">(ApplicationListener&lt;?&gt; listener, ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType)</span> </span>&#123;\n    GenericApplicationListener smartListener = listener <span class=\"hljs-keyword\">instanceof</span> GenericApplicationListener ? (GenericApplicationListener)listener : <span class=\"hljs-keyword\">new</span> GenericApplicationListenerAdapter(listener);\n    <span class=\"hljs-keyword\">return</span> ((GenericApplicationListener)smartListener).supportsEventType(eventType) &amp;&amp; ((GenericApplicationListener)smartListener).supportsSourceType(sourceType);\n&#125;</code></pre>\n<blockquote>\n<blockquote>\n<p> 在 SimpleApplicationEventMulticaster 实例化时会将默认的 defaultRetriever 引用赋值给 <code>retrievalMutex</code> 检索互斥体，在内部很多方法都使用了 synchronized(this.retrievalMutex) 同步锁来保证线程安全</p>\n</blockquote>\n</blockquote>\n"},{"title":"SpringCloud 服务中心之 Eureka","date":"2018-08-01T08:43:15.000Z","_content":"![Eureka](/images/SpringCloud.jpg)\n\n>SpringCloud微服务架构基于SpringBoot进行开发组件，即插即用非常方便，用了Spring Boot根本停不下来。SpringCloud包含了服务和注册中心(Zookeeper Eureka Consul)、熔断器(Hystrix)、动态路由(Zuul)、配置中心(Spring cloud config)、负责均衡(Ribbon)、REST服务调用(Fegin)等集成组件。让我们一步步通过项目来学习SpringCloud！\n\n ## 1. Eureka 服务发现和注册\nEureka 是 Netflix 旗下微服务开发组件，用于服务发现和注册中心，分为服务端和客户端，服务端作为注册中心作为其他客户端的提供注册服务，客户端将需要暴露的接口服务注册到服务端中，通过周期性向服务端发送心跳保证自身健康可用性。\n\n\n## 2. EurekaServer 注册中心搭建\n首先建立项目使用maven来构建项目，pom.xml依赖关系如下本项目用最新的版本进行教程，相关的官方教程可查看[Spring Cloud Eureka](http://projects.spring.io/spring-cloud/#quick-start)\n#### pom.xml maven依赖配置\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n<modelVersion>4.0.0</modelVersion>\n<artifactId>EurekaServer</artifactId>\n\n<properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n    <java.version>1.8</java.version>\n</properties>\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.0.1.RELEASE</version>\n</parent>\n\n<dependencyManagement>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-dependencies</artifactId>\n        <version>Finchley.SR1</version>\n        <type>pom</type>\n        <scope>import</scope>\n    </dependency>\n</dependencies>\n</dependencyManagement>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n</dependencies>\n<!--项目构建maven插件-->\n<build>\n<plugins>\n    <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n    </plugin>\n</plugins>\n</build>\n</project>\n```\n##### SpringBoot 启动配置项\n``` java\npackage com;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n\n@SpringBootApplication\n@EnableEurekaServer\n@EnableWebSecurity\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class，args);\n    }\n}\n```\n#### WebSecurityConfig 安全认证配置\n``` java\npackage com.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable(); //关闭csrf\n        http.authorizeRequests().anyRequest().authenticated().and().httpBasic(); //开启认证\n    }\n}\n```\n#### application.yml 基本配置项\n``` yml\n#Eureka 服务中心设置 \neureka:\n  client:\n    #自身不注册\n    register-with-eureka: false\n    #是否开启检索服务\n    fetch-registry: false\n#security安全校验  \nspring:\n  security:\n    user:\n      name: root\n      password: 123123\n#服务器端口设置\nserver:\n  port: 8888\n```\n启动项目通过 http://localhost:8888 查看Eureka注册中心管理页面，为了安全性加入了security安全校验，输入账号密码进入管理页面。\n![Eureka Server Center](/images/eureka.png)\n\n## 3.  EurekaClient 服务搭建\n#### pom.xml maven依赖配置\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <artifactId>EurekaClient</artifactId>\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.0.1.RELEASE</version>\n    </parent>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Finchley.SR1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n    </dependencies>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n#### SpringBoot 启动配置项\n``` java\npackage com;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@SpringBootApplication\n@EnableEurekaClient\n@RestController\npublic class Application {\n\n    @RequestMapping(\"/test1\")\n    public String myTestService(){\n        return \"测试1\";\n    }\n\n    @RequestMapping(\"/test2\")\n    public String myTestService2(){\n        return \"测试2\";\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class，args);\n    }\n}\n```\n#### application.yml配置\n``` yml\n#  设置服务名\nspring:\n  application:\n    name: EurekaClient1\n#  设置注册中心地址 root:123123为注册中心设置的账号密码\neureka:\n  client:\n    service-url:\n      defaultZone: http://root:123123@localhost:8888/eureka\n```","source":"_posts/SprintCloud微服务-Eureka.md","raw":"---\ntitle: SpringCloud 服务中心之 Eureka\ndate: 2018-08-01 16:43:15\ncategories: [Spring]\ntags:\n    - Spring\n    - Java\n---\n![Eureka](/images/SpringCloud.jpg)\n\n>SpringCloud微服务架构基于SpringBoot进行开发组件，即插即用非常方便，用了Spring Boot根本停不下来。SpringCloud包含了服务和注册中心(Zookeeper Eureka Consul)、熔断器(Hystrix)、动态路由(Zuul)、配置中心(Spring cloud config)、负责均衡(Ribbon)、REST服务调用(Fegin)等集成组件。让我们一步步通过项目来学习SpringCloud！\n\n ## 1. Eureka 服务发现和注册\nEureka 是 Netflix 旗下微服务开发组件，用于服务发现和注册中心，分为服务端和客户端，服务端作为注册中心作为其他客户端的提供注册服务，客户端将需要暴露的接口服务注册到服务端中，通过周期性向服务端发送心跳保证自身健康可用性。\n\n\n## 2. EurekaServer 注册中心搭建\n首先建立项目使用maven来构建项目，pom.xml依赖关系如下本项目用最新的版本进行教程，相关的官方教程可查看[Spring Cloud Eureka](http://projects.spring.io/spring-cloud/#quick-start)\n#### pom.xml maven依赖配置\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n<modelVersion>4.0.0</modelVersion>\n<artifactId>EurekaServer</artifactId>\n\n<properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n    <java.version>1.8</java.version>\n</properties>\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.0.1.RELEASE</version>\n</parent>\n\n<dependencyManagement>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-dependencies</artifactId>\n        <version>Finchley.SR1</version>\n        <type>pom</type>\n        <scope>import</scope>\n    </dependency>\n</dependencies>\n</dependencyManagement>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n</dependencies>\n<!--项目构建maven插件-->\n<build>\n<plugins>\n    <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n    </plugin>\n</plugins>\n</build>\n</project>\n```\n##### SpringBoot 启动配置项\n``` java\npackage com;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n\n@SpringBootApplication\n@EnableEurekaServer\n@EnableWebSecurity\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class，args);\n    }\n}\n```\n#### WebSecurityConfig 安全认证配置\n``` java\npackage com.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable(); //关闭csrf\n        http.authorizeRequests().anyRequest().authenticated().and().httpBasic(); //开启认证\n    }\n}\n```\n#### application.yml 基本配置项\n``` yml\n#Eureka 服务中心设置 \neureka:\n  client:\n    #自身不注册\n    register-with-eureka: false\n    #是否开启检索服务\n    fetch-registry: false\n#security安全校验  \nspring:\n  security:\n    user:\n      name: root\n      password: 123123\n#服务器端口设置\nserver:\n  port: 8888\n```\n启动项目通过 http://localhost:8888 查看Eureka注册中心管理页面，为了安全性加入了security安全校验，输入账号密码进入管理页面。\n![Eureka Server Center](/images/eureka.png)\n\n## 3.  EurekaClient 服务搭建\n#### pom.xml maven依赖配置\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <artifactId>EurekaClient</artifactId>\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.0.1.RELEASE</version>\n    </parent>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Finchley.SR1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n    </dependencies>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n#### SpringBoot 启动配置项\n``` java\npackage com;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@SpringBootApplication\n@EnableEurekaClient\n@RestController\npublic class Application {\n\n    @RequestMapping(\"/test1\")\n    public String myTestService(){\n        return \"测试1\";\n    }\n\n    @RequestMapping(\"/test2\")\n    public String myTestService2(){\n        return \"测试2\";\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class，args);\n    }\n}\n```\n#### application.yml配置\n``` yml\n#  设置服务名\nspring:\n  application:\n    name: EurekaClient1\n#  设置注册中心地址 root:123123为注册中心设置的账号密码\neureka:\n  client:\n    service-url:\n      defaultZone: http://root:123123@localhost:8888/eureka\n```","slug":"SprintCloud微服务-Eureka","published":1,"updated":"2020-08-10T01:48:44.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc99o003tjsuddlrr9vmy","content":"<p><img src=\"/images/SpringCloud.jpg\" srcset=\"/img/loading.gif\" alt=\"Eureka\"></p>\n<blockquote>\n<p>SpringCloud微服务架构基于SpringBoot进行开发组件，即插即用非常方便，用了Spring Boot根本停不下来。SpringCloud包含了服务和注册中心(Zookeeper Eureka Consul)、熔断器(Hystrix)、动态路由(Zuul)、配置中心(Spring cloud config)、负责均衡(Ribbon)、REST服务调用(Fegin)等集成组件。让我们一步步通过项目来学习SpringCloud！</p>\n</blockquote>\n<h2 id=\"1-Eureka-服务发现和注册\"><a href=\"#1-Eureka-服务发现和注册\" class=\"headerlink\" title=\"1. Eureka 服务发现和注册\"></a>1. Eureka 服务发现和注册</h2><p>Eureka 是 Netflix 旗下微服务开发组件，用于服务发现和注册中心，分为服务端和客户端，服务端作为注册中心作为其他客户端的提供注册服务，客户端将需要暴露的接口服务注册到服务端中，通过周期性向服务端发送心跳保证自身健康可用性。</p>\n<h2 id=\"2-EurekaServer-注册中心搭建\"><a href=\"#2-EurekaServer-注册中心搭建\" class=\"headerlink\" title=\"2. EurekaServer 注册中心搭建\"></a>2. EurekaServer 注册中心搭建</h2><p>首先建立项目使用maven来构建项目，pom.xml依赖关系如下本项目用最新的版本进行教程，相关的官方教程可查看<a href=\"http://projects.spring.io/spring-cloud/#quick-start\" target=\"_blank\" rel=\"noopener\">Spring Cloud Eureka</a></p>\n<h4 id=\"pom-xml-maven依赖配置\"><a href=\"#pom-xml-maven依赖配置\" class=\"headerlink\" title=\"pom.xml maven依赖配置\"></a>pom.xml maven依赖配置</h4><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>EurekaServer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.1.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencyManagement</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-dependencies<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>Finchley.SR1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">type</span>&gt;</span>pom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">type</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>import<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencyManagement</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!--项目构建maven插件--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span></code></pre>\n<h5 id=\"SpringBoot-启动配置项\"><a href=\"#SpringBoot-启动配置项\" class=\"headerlink\" title=\"SpringBoot 启动配置项\"></a>SpringBoot 启动配置项</h5><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n<span class=\"hljs-keyword\">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@EnableEurekaServer</span>\n<span class=\"hljs-meta\">@EnableWebSecurity</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        SpringApplication.run(Application<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>，<span class=\"hljs-title\">args</span>)</span>;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"WebSecurityConfig-安全认证配置\"><a href=\"#WebSecurityConfig-安全认证配置\" class=\"headerlink\" title=\"WebSecurityConfig 安全认证配置\"></a>WebSecurityConfig 安全认证配置</h4><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.config;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.Configuration;\n<span class=\"hljs-keyword\">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;\n<span class=\"hljs-keyword\">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n<span class=\"hljs-keyword\">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebSecurityConfig</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WebSecurityConfigurerAdapter</span> </span>&#123;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">(HttpSecurity http)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n        http.csrf().disable(); <span class=\"hljs-comment\">//关闭csrf</span>\n        http.authorizeRequests().anyRequest().authenticated().and().httpBasic(); <span class=\"hljs-comment\">//开启认证</span>\n    &#125;\n&#125;</code></pre>\n<h4 id=\"application-yml-基本配置项\"><a href=\"#application-yml-基本配置项\" class=\"headerlink\" title=\"application.yml 基本配置项\"></a>application.yml 基本配置项</h4><pre><code class=\"hljs yml\"><span class=\"hljs-comment\">#Eureka 服务中心设置 </span>\n<span class=\"hljs-attr\">eureka:</span>\n  <span class=\"hljs-attr\">client:</span>\n    <span class=\"hljs-comment\">#自身不注册</span>\n    <span class=\"hljs-attr\">register-with-eureka:</span> <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-comment\">#是否开启检索服务</span>\n    <span class=\"hljs-attr\">fetch-registry:</span> <span class=\"hljs-literal\">false</span>\n<span class=\"hljs-comment\">#security安全校验  </span>\n<span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">security:</span>\n    <span class=\"hljs-attr\">user:</span>\n      <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">root</span>\n      <span class=\"hljs-attr\">password:</span> <span class=\"hljs-number\">123123</span>\n<span class=\"hljs-comment\">#服务器端口设置</span>\n<span class=\"hljs-attr\">server:</span>\n  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">8888</span></code></pre>\n<p>启动项目通过 <a href=\"http://localhost:8888\" target=\"_blank\" rel=\"noopener\">http://localhost:8888</a> 查看Eureka注册中心管理页面，为了安全性加入了security安全校验，输入账号密码进入管理页面。<br><img src=\"/images/eureka.png\" srcset=\"/img/loading.gif\" alt=\"Eureka Server Center\"></p>\n<h2 id=\"3-EurekaClient-服务搭建\"><a href=\"#3-EurekaClient-服务搭建\" class=\"headerlink\" title=\"3.  EurekaClient 服务搭建\"></a>3.  EurekaClient 服务搭建</h2><h4 id=\"pom-xml-maven依赖配置-1\"><a href=\"#pom-xml-maven依赖配置-1\" class=\"headerlink\" title=\"pom.xml maven依赖配置\"></a>pom.xml maven依赖配置</h4><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>EurekaClient<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.1.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencyManagement</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-dependencies<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>Finchley.SR1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">type</span>&gt;</span>pom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">type</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>import<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencyManagement</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span></code></pre>\n<h4 id=\"SpringBoot-启动配置项-1\"><a href=\"#SpringBoot-启动配置项-1\" class=\"headerlink\" title=\"SpringBoot 启动配置项\"></a>SpringBoot 启动配置项</h4><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@EnableEurekaClient</span>\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/test1\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">myTestService</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"测试1\"</span>;\n    &#125;\n\n    <span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/test2\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">myTestService2</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"测试2\"</span>;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        SpringApplication.run(Application<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>，<span class=\"hljs-title\">args</span>)</span>;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"application-yml配置\"><a href=\"#application-yml配置\" class=\"headerlink\" title=\"application.yml配置\"></a>application.yml配置</h4><pre><code class=\"hljs yml\"><span class=\"hljs-comment\">#  设置服务名</span>\n<span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">application:</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">EurekaClient1</span>\n<span class=\"hljs-comment\">#  设置注册中心地址 root:123123为注册中心设置的账号密码</span>\n<span class=\"hljs-attr\">eureka:</span>\n  <span class=\"hljs-attr\">client:</span>\n    <span class=\"hljs-attr\">service-url:</span>\n      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://root:123123@localhost:8888/eureka</span></code></pre>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/SpringCloud.jpg\" srcset=\"/img/loading.gif\" alt=\"Eureka\"></p>\n<blockquote>\n<p>SpringCloud微服务架构基于SpringBoot进行开发组件，即插即用非常方便，用了Spring Boot根本停不下来。SpringCloud包含了服务和注册中心(Zookeeper Eureka Consul)、熔断器(Hystrix)、动态路由(Zuul)、配置中心(Spring cloud config)、负责均衡(Ribbon)、REST服务调用(Fegin)等集成组件。让我们一步步通过项目来学习SpringCloud！</p>\n</blockquote>\n<h2 id=\"1-Eureka-服务发现和注册\"><a href=\"#1-Eureka-服务发现和注册\" class=\"headerlink\" title=\"1. Eureka 服务发现和注册\"></a>1. Eureka 服务发现和注册</h2><p>Eureka 是 Netflix 旗下微服务开发组件，用于服务发现和注册中心，分为服务端和客户端，服务端作为注册中心作为其他客户端的提供注册服务，客户端将需要暴露的接口服务注册到服务端中，通过周期性向服务端发送心跳保证自身健康可用性。</p>\n<h2 id=\"2-EurekaServer-注册中心搭建\"><a href=\"#2-EurekaServer-注册中心搭建\" class=\"headerlink\" title=\"2. EurekaServer 注册中心搭建\"></a>2. EurekaServer 注册中心搭建</h2><p>首先建立项目使用maven来构建项目，pom.xml依赖关系如下本项目用最新的版本进行教程，相关的官方教程可查看<a href=\"http://projects.spring.io/spring-cloud/#quick-start\" target=\"_blank\" rel=\"noopener\">Spring Cloud Eureka</a></p>\n<h4 id=\"pom-xml-maven依赖配置\"><a href=\"#pom-xml-maven依赖配置\" class=\"headerlink\" title=\"pom.xml maven依赖配置\"></a>pom.xml maven依赖配置</h4><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>EurekaServer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.1.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencyManagement</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-dependencies<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>Finchley.SR1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">type</span>&gt;</span>pom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">type</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>import<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencyManagement</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!--项目构建maven插件--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span></code></pre>\n<h5 id=\"SpringBoot-启动配置项\"><a href=\"#SpringBoot-启动配置项\" class=\"headerlink\" title=\"SpringBoot 启动配置项\"></a>SpringBoot 启动配置项</h5><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n<span class=\"hljs-keyword\">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@EnableEurekaServer</span>\n<span class=\"hljs-meta\">@EnableWebSecurity</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        SpringApplication.run(Application<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>，<span class=\"hljs-title\">args</span>)</span>;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"WebSecurityConfig-安全认证配置\"><a href=\"#WebSecurityConfig-安全认证配置\" class=\"headerlink\" title=\"WebSecurityConfig 安全认证配置\"></a>WebSecurityConfig 安全认证配置</h4><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.config;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.context.annotation.Configuration;\n<span class=\"hljs-keyword\">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;\n<span class=\"hljs-keyword\">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n<span class=\"hljs-keyword\">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebSecurityConfig</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WebSecurityConfigurerAdapter</span> </span>&#123;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">(HttpSecurity http)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n        http.csrf().disable(); <span class=\"hljs-comment\">//关闭csrf</span>\n        http.authorizeRequests().anyRequest().authenticated().and().httpBasic(); <span class=\"hljs-comment\">//开启认证</span>\n    &#125;\n&#125;</code></pre>\n<h4 id=\"application-yml-基本配置项\"><a href=\"#application-yml-基本配置项\" class=\"headerlink\" title=\"application.yml 基本配置项\"></a>application.yml 基本配置项</h4><pre><code class=\"hljs yml\"><span class=\"hljs-comment\">#Eureka 服务中心设置 </span>\n<span class=\"hljs-attr\">eureka:</span>\n  <span class=\"hljs-attr\">client:</span>\n    <span class=\"hljs-comment\">#自身不注册</span>\n    <span class=\"hljs-attr\">register-with-eureka:</span> <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-comment\">#是否开启检索服务</span>\n    <span class=\"hljs-attr\">fetch-registry:</span> <span class=\"hljs-literal\">false</span>\n<span class=\"hljs-comment\">#security安全校验  </span>\n<span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">security:</span>\n    <span class=\"hljs-attr\">user:</span>\n      <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">root</span>\n      <span class=\"hljs-attr\">password:</span> <span class=\"hljs-number\">123123</span>\n<span class=\"hljs-comment\">#服务器端口设置</span>\n<span class=\"hljs-attr\">server:</span>\n  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">8888</span></code></pre>\n<p>启动项目通过 <a href=\"http://localhost:8888\" target=\"_blank\" rel=\"noopener\">http://localhost:8888</a> 查看Eureka注册中心管理页面，为了安全性加入了security安全校验，输入账号密码进入管理页面。<br><img src=\"/images/eureka.png\" srcset=\"/img/loading.gif\" alt=\"Eureka Server Center\"></p>\n<h2 id=\"3-EurekaClient-服务搭建\"><a href=\"#3-EurekaClient-服务搭建\" class=\"headerlink\" title=\"3.  EurekaClient 服务搭建\"></a>3.  EurekaClient 服务搭建</h2><h4 id=\"pom-xml-maven依赖配置-1\"><a href=\"#pom-xml-maven依赖配置-1\" class=\"headerlink\" title=\"pom.xml maven依赖配置\"></a>pom.xml maven依赖配置</h4><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>EurekaClient<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.1.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencyManagement</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-dependencies<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>Finchley.SR1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">type</span>&gt;</span>pom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">type</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>import<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencyManagement</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span></code></pre>\n<h4 id=\"SpringBoot-启动配置项-1\"><a href=\"#SpringBoot-启动配置项-1\" class=\"headerlink\" title=\"SpringBoot 启动配置项\"></a>SpringBoot 启动配置项</h4><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@EnableEurekaClient</span>\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/test1\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">myTestService</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"测试1\"</span>;\n    &#125;\n\n    <span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/test2\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">myTestService2</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"测试2\"</span>;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        SpringApplication.run(Application<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>，<span class=\"hljs-title\">args</span>)</span>;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"application-yml配置\"><a href=\"#application-yml配置\" class=\"headerlink\" title=\"application.yml配置\"></a>application.yml配置</h4><pre><code class=\"hljs yml\"><span class=\"hljs-comment\">#  设置服务名</span>\n<span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">application:</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">EurekaClient1</span>\n<span class=\"hljs-comment\">#  设置注册中心地址 root:123123为注册中心设置的账号密码</span>\n<span class=\"hljs-attr\">eureka:</span>\n  <span class=\"hljs-attr\">client:</span>\n    <span class=\"hljs-attr\">service-url:</span>\n      <span class=\"hljs-attr\">defaultZone:</span> <span class=\"hljs-string\">http://root:123123@localhost:8888/eureka</span></code></pre>"},{"title":"Java8 Stream 流操作","date":"2019-03-29T02:06:00.000Z","comments":1,"_content":"![Java](/images/java.jpg)\n\n>记录下 stream 流操作相关代码和一些细节问题。\n\n## Stream(流)\n`Stream` 流基本特性，不改变源数据、延迟执行、不存在数据，可简化代码可读性更高、美观、干净。有代码洁癖的小伙伴赶紧使用起来，它支持筛选、排序、聚合等，`Stream` 的聚合、消费、收集等操作只能进行一次。\n![Stream 流](/images/java-stream.png)\n\n### 常用方法\n``` java\nList<String> strings = Arrays.asList(\"3\",\"1\",\"2\", \"4\");\n\n# filter 筛选操作\nint count = strings.stream()\n\t\t   .filter(string -> string.isEmpty())\n\t\t   .count();\n\n# limit 数量限制\nstrings.stream()\n       .limit(5)\n       .forEach(System.out::println);\n\n# map 将每个元素映射为其他\nstrings.stream()\n       .map(string->string+\"s\")\n       .collect(Collectors.toList());\n\n# skip 忽略前N个元素\nstrings.stream()\n       .skip(2)\n       .collect(Collectors.toList());\n\n# distinct 去重 非基本类型需要重写 hashcode equals 方法\nstrings.stream()\n       .distinct()\n       .forEach(System.out::println);\n\n# sorted 排序 非基本类型需要重写 hashcode equals 方法\nstrings.stream()\n       .sorted(Comparator.comparing(s -> s))    \n       .forEach(System.out::println);\n```","source":"_posts/Stream流操作.md","raw":"---\ntitle: Java8 Stream 流操作\ndate: 2019-03-29 10:06:00\ncategories: [Java]\ncomments: true\ntags:\n\t- Java\n\t- 技术\n---\n![Java](/images/java.jpg)\n\n>记录下 stream 流操作相关代码和一些细节问题。\n\n## Stream(流)\n`Stream` 流基本特性，不改变源数据、延迟执行、不存在数据，可简化代码可读性更高、美观、干净。有代码洁癖的小伙伴赶紧使用起来，它支持筛选、排序、聚合等，`Stream` 的聚合、消费、收集等操作只能进行一次。\n![Stream 流](/images/java-stream.png)\n\n### 常用方法\n``` java\nList<String> strings = Arrays.asList(\"3\",\"1\",\"2\", \"4\");\n\n# filter 筛选操作\nint count = strings.stream()\n\t\t   .filter(string -> string.isEmpty())\n\t\t   .count();\n\n# limit 数量限制\nstrings.stream()\n       .limit(5)\n       .forEach(System.out::println);\n\n# map 将每个元素映射为其他\nstrings.stream()\n       .map(string->string+\"s\")\n       .collect(Collectors.toList());\n\n# skip 忽略前N个元素\nstrings.stream()\n       .skip(2)\n       .collect(Collectors.toList());\n\n# distinct 去重 非基本类型需要重写 hashcode equals 方法\nstrings.stream()\n       .distinct()\n       .forEach(System.out::println);\n\n# sorted 排序 非基本类型需要重写 hashcode equals 方法\nstrings.stream()\n       .sorted(Comparator.comparing(s -> s))    \n       .forEach(System.out::println);\n```","slug":"Stream流操作","published":1,"updated":"2020-08-10T01:48:44.748Z","layout":"post","photos":[],"link":"","_id":"ckhmyc99q003wjsud8owifvdz","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>记录下 stream 流操作相关代码和一些细节问题。</p>\n</blockquote>\n<h2 id=\"Stream-流\"><a href=\"#Stream-流\" class=\"headerlink\" title=\"Stream(流)\"></a>Stream(流)</h2><p><code>Stream</code> 流基本特性，不改变源数据、延迟执行、不存在数据，可简化代码可读性更高、美观、干净。有代码洁癖的小伙伴赶紧使用起来，它支持筛选、排序、聚合等，<code>Stream</code> 的聚合、消费、收集等操作只能进行一次。<br><img src=\"/images/java-stream.png\" srcset=\"/img/loading.gif\" alt=\"Stream 流\"></p>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><pre><code class=\"hljs java\">List&lt;String&gt; strings = Arrays.asList(\"3\",\"1\",\"2\", \"4\");\n\n# filter 筛选操作\nint count = strings.stream()\n\t\t   .filter(string -&gt; string.isEmpty())\n\t\t   .count();\n\n# limit 数量限制\nstrings.stream()\n       .limit(5)\n       .forEach(System.out::println);\n\n# map 将每个元素映射为其他\nstrings.stream()\n       .map(string-&gt;string+\"s\")\n       .collect(Collectors.toList());\n\n# skip 忽略前N个元素\nstrings.stream()\n       .skip(2)\n       .collect(Collectors.toList());\n\n# distinct 去重 非基本类型需要重写 hashcode equals 方法\nstrings.stream()\n       .distinct()\n       .forEach(System.out::println);\n\n# sorted 排序 非基本类型需要重写 hashcode equals 方法\nstrings.stream()\n       .sorted(Comparator.comparing(s -&gt; s))    \n       .forEach(System.out::println);</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>记录下 stream 流操作相关代码和一些细节问题。</p>\n</blockquote>\n<h2 id=\"Stream-流\"><a href=\"#Stream-流\" class=\"headerlink\" title=\"Stream(流)\"></a>Stream(流)</h2><p><code>Stream</code> 流基本特性，不改变源数据、延迟执行、不存在数据，可简化代码可读性更高、美观、干净。有代码洁癖的小伙伴赶紧使用起来，它支持筛选、排序、聚合等，<code>Stream</code> 的聚合、消费、收集等操作只能进行一次。<br><img src=\"/images/java-stream.png\" srcset=\"/img/loading.gif\" alt=\"Stream 流\"></p>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><pre><code class=\"hljs java\">List&lt;String&gt; strings = Arrays.asList(\"3\",\"1\",\"2\", \"4\");\n\n# filter 筛选操作\nint count = strings.stream()\n\t\t   .filter(string -&gt; string.isEmpty())\n\t\t   .count();\n\n# limit 数量限制\nstrings.stream()\n       .limit(5)\n       .forEach(System.out::println);\n\n# map 将每个元素映射为其他\nstrings.stream()\n       .map(string-&gt;string+\"s\")\n       .collect(Collectors.toList());\n\n# skip 忽略前N个元素\nstrings.stream()\n       .skip(2)\n       .collect(Collectors.toList());\n\n# distinct 去重 非基本类型需要重写 hashcode equals 方法\nstrings.stream()\n       .distinct()\n       .forEach(System.out::println);\n\n# sorted 排序 非基本类型需要重写 hashcode equals 方法\nstrings.stream()\n       .sorted(Comparator.comparing(s -&gt; s))    \n       .forEach(System.out::println);</code></pre>"},{"title":"String 类和常量池","toc":false,"date":"2019-03-28T08:09:24.000Z","_content":"\n![Java](/images/java.jpg)\n\n> 面试经常会问到\"\"创建的String和通过new String创建有什么不同。\n\n## String 类和常量池\nString 对象创建的2种方式\n``` java\nString str1 = \"abcd\";\nString str2 = new String(\"abcd\");\nSystem.out.println(str1==str2);\n```\n使用`==`比较的是内存地址，虽然他们的值相同但是由于创建方式的原因它们的内存地址不一样，通过`\"\"`方式创建的字符串存放在常量池中，通过`new`方式是在堆内存中创建一个新的对象，所有他们的内存地址不一样输出`false`。\n![](/images/String==.jpg)\n\n#### `注意：只要是通过new方式创建即会创建一个新的对象`\n\n### String 类型的常量池比较\n- 直接通过`\"\"`声明出来的 String 对象会直接存储在常量池中。\n- 如果不是通过`\"\"`声明的 String 对象。可以使用`intern`方法，它是一个`Native`方法,在运行时常量池中如有值匹配的String字符串则返回，否则创建一个字符串并返回其引用。\n``` java\nString s1 = new String(\"计算机\");\nString s2 = s1.intern();\nString s3 = \"计算机\";\nSystem.out.println(s1 == s2);\nSystem.out.println(s3 == s2);\n```\n输出 `false`、`true`，`s1` 属于堆中对象，`s2` 是常量池中对象,`s3` 属于常量池中对象\n\n\n\n### String 字符串拼接\n``` java\nString str1 = \"str\";\nString str2 = \"ing\";\n\nString str3 = \"str\" + \"ing\";\nString str4 = str1 + str2;  \nString str5 = \"string\";\nSystem.out.println(str3 == str4);\nSystem.out.println(str3 == str5);\nSystem.out.println(str4 == str5);\n```\n输出`false`、`true`、`false`，`str3`常量池对象、`str2`常量池对象、`str3`常量池对象、`str4`堆内对象、`str5`常量池对象\n![](/images/String++.jpg)\n\n## String s= new String(\"abc\")生成了几个对象\n面试经常会问到这样的问题，首先在常量池会生成`\"abc\"`对象，通过`new`会在堆中生成`abc`对象，所以答案是`2`个对象。\n\n## 常量池拓展\n`Java`基本类型的包装类的大部门实现了常量池技术，有`Byte`、`Short`、`Long`、`Charact`、`Boolean`。这5种包装类默认创建了`[-128,127]`的相应类型的缓存数据，超出范围的仍然需去创建新的对象。\n\n以`Integer`为例\n``` java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出true\nInteger i11 = 333;\nInteger i22 = 333;\nSystem.out.println(i11 == i22);// 输出false\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出false\n```\n代码中`Integer i1 = 33`在遍历时会把带代码封装成`Integer i1 = Integer.valueOf(33)`,从而使用的是常量池中的缓存对象。","source":"_posts/String类和常量池.md","raw":"---\ntitle: String 类和常量池\ntags:\n  - 技术\ncategories:\n  - Java\ntoc: false\ndate: 2019-03-28 16:09:24\n---\n\n![Java](/images/java.jpg)\n\n> 面试经常会问到\"\"创建的String和通过new String创建有什么不同。\n\n## String 类和常量池\nString 对象创建的2种方式\n``` java\nString str1 = \"abcd\";\nString str2 = new String(\"abcd\");\nSystem.out.println(str1==str2);\n```\n使用`==`比较的是内存地址，虽然他们的值相同但是由于创建方式的原因它们的内存地址不一样，通过`\"\"`方式创建的字符串存放在常量池中，通过`new`方式是在堆内存中创建一个新的对象，所有他们的内存地址不一样输出`false`。\n![](/images/String==.jpg)\n\n#### `注意：只要是通过new方式创建即会创建一个新的对象`\n\n### String 类型的常量池比较\n- 直接通过`\"\"`声明出来的 String 对象会直接存储在常量池中。\n- 如果不是通过`\"\"`声明的 String 对象。可以使用`intern`方法，它是一个`Native`方法,在运行时常量池中如有值匹配的String字符串则返回，否则创建一个字符串并返回其引用。\n``` java\nString s1 = new String(\"计算机\");\nString s2 = s1.intern();\nString s3 = \"计算机\";\nSystem.out.println(s1 == s2);\nSystem.out.println(s3 == s2);\n```\n输出 `false`、`true`，`s1` 属于堆中对象，`s2` 是常量池中对象,`s3` 属于常量池中对象\n\n\n\n### String 字符串拼接\n``` java\nString str1 = \"str\";\nString str2 = \"ing\";\n\nString str3 = \"str\" + \"ing\";\nString str4 = str1 + str2;  \nString str5 = \"string\";\nSystem.out.println(str3 == str4);\nSystem.out.println(str3 == str5);\nSystem.out.println(str4 == str5);\n```\n输出`false`、`true`、`false`，`str3`常量池对象、`str2`常量池对象、`str3`常量池对象、`str4`堆内对象、`str5`常量池对象\n![](/images/String++.jpg)\n\n## String s= new String(\"abc\")生成了几个对象\n面试经常会问到这样的问题，首先在常量池会生成`\"abc\"`对象，通过`new`会在堆中生成`abc`对象，所以答案是`2`个对象。\n\n## 常量池拓展\n`Java`基本类型的包装类的大部门实现了常量池技术，有`Byte`、`Short`、`Long`、`Charact`、`Boolean`。这5种包装类默认创建了`[-128,127]`的相应类型的缓存数据，超出范围的仍然需去创建新的对象。\n\n以`Integer`为例\n``` java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出true\nInteger i11 = 333;\nInteger i22 = 333;\nSystem.out.println(i11 == i22);// 输出false\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出false\n```\n代码中`Integer i1 = 33`在遍历时会把带代码封装成`Integer i1 = Integer.valueOf(33)`,从而使用的是常量池中的缓存对象。","slug":"String类和常量池","published":1,"updated":"2020-08-10T01:48:44.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc99s003zjsudd23ym4sm","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>面试经常会问到””创建的String和通过new String创建有什么不同。</p>\n</blockquote>\n<h2 id=\"String-类和常量池\"><a href=\"#String-类和常量池\" class=\"headerlink\" title=\"String 类和常量池\"></a>String 类和常量池</h2><p>String 对象创建的2种方式<br><pre><code class=\"hljs java\">String str1 = <span class=\"hljs-string\">\"abcd\"</span>;\nString str2 = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">\"abcd\"</span>);\nSystem.out.println(str1==str2);</code></pre></p>\n<p>使用<code>==</code>比较的是内存地址，虽然他们的值相同但是由于创建方式的原因它们的内存地址不一样，通过<code>&quot;&quot;</code>方式创建的字符串存放在常量池中，通过<code>new</code>方式是在堆内存中创建一个新的对象，所有他们的内存地址不一样输出<code>false</code>。<br><img src=\"/images/String==.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h4 id=\"注意：只要是通过new方式创建即会创建一个新的对象\"><a href=\"#注意：只要是通过new方式创建即会创建一个新的对象\" class=\"headerlink\" title=\"注意：只要是通过new方式创建即会创建一个新的对象\"></a><code>注意：只要是通过new方式创建即会创建一个新的对象</code></h4><h3 id=\"String-类型的常量池比较\"><a href=\"#String-类型的常量池比较\" class=\"headerlink\" title=\"String 类型的常量池比较\"></a>String 类型的常量池比较</h3><ul>\n<li>直接通过<code>&quot;&quot;</code>声明出来的 String 对象会直接存储在常量池中。</li>\n<li>如果不是通过<code>&quot;&quot;</code>声明的 String 对象。可以使用<code>intern</code>方法，它是一个<code>Native</code>方法,在运行时常量池中如有值匹配的String字符串则返回，否则创建一个字符串并返回其引用。<pre><code class=\"hljs java\">String s1 = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">\"计算机\"</span>);\nString s2 = s1.intern();\nString s3 = <span class=\"hljs-string\">\"计算机\"</span>;\nSystem.out.println(s1 == s2);\nSystem.out.println(s3 == s2);</code></pre>\n</li>\n</ul>\n<p>输出 <code>false</code>、<code>true</code>，<code>s1</code> 属于堆中对象，<code>s2</code> 是常量池中对象,<code>s3</code> 属于常量池中对象</p>\n<h3 id=\"String-字符串拼接\"><a href=\"#String-字符串拼接\" class=\"headerlink\" title=\"String 字符串拼接\"></a>String 字符串拼接</h3><pre><code class=\"hljs java\">String str1 = <span class=\"hljs-string\">\"str\"</span>;\nString str2 = <span class=\"hljs-string\">\"ing\"</span>;\n\nString str3 = <span class=\"hljs-string\">\"str\"</span> + <span class=\"hljs-string\">\"ing\"</span>;\nString str4 = str1 + str2;  \nString str5 = <span class=\"hljs-string\">\"string\"</span>;\nSystem.out.println(str3 == str4);\nSystem.out.println(str3 == str5);\nSystem.out.println(str4 == str5);</code></pre>\n<p>输出<code>false</code>、<code>true</code>、<code>false</code>，<code>str3</code>常量池对象、<code>str2</code>常量池对象、<code>str3</code>常量池对象、<code>str4</code>堆内对象、<code>str5</code>常量池对象<br><img src=\"/images/String++.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h2 id=\"String-s-new-String-“abc”-生成了几个对象\"><a href=\"#String-s-new-String-“abc”-生成了几个对象\" class=\"headerlink\" title=\"String s= new String(“abc”)生成了几个对象\"></a>String s= new String(“abc”)生成了几个对象</h2><p>面试经常会问到这样的问题，首先在常量池会生成<code>&quot;abc&quot;</code>对象，通过<code>new</code>会在堆中生成<code>abc</code>对象，所以答案是<code>2</code>个对象。</p>\n<h2 id=\"常量池拓展\"><a href=\"#常量池拓展\" class=\"headerlink\" title=\"常量池拓展\"></a>常量池拓展</h2><p><code>Java</code>基本类型的包装类的大部门实现了常量池技术，有<code>Byte</code>、<code>Short</code>、<code>Long</code>、<code>Charact</code>、<code>Boolean</code>。这5种包装类默认创建了<code>[-128,127]</code>的相应类型的缓存数据，超出范围的仍然需去创建新的对象。</p>\n<p>以<code>Integer</code>为例<br><pre><code class=\"hljs java\">Integer i1 = <span class=\"hljs-number\">33</span>;\nInteger i2 = <span class=\"hljs-number\">33</span>;\nSystem.out.println(i1 == i2);<span class=\"hljs-comment\">// 输出true</span>\nInteger i11 = <span class=\"hljs-number\">333</span>;\nInteger i22 = <span class=\"hljs-number\">333</span>;\nSystem.out.println(i11 == i22);<span class=\"hljs-comment\">// 输出false</span>\nDouble i3 = <span class=\"hljs-number\">1.2</span>;\nDouble i4 = <span class=\"hljs-number\">1.2</span>;\nSystem.out.println(i3 == i4);<span class=\"hljs-comment\">// 输出false</span></code></pre></p>\n<p>代码中<code>Integer i1 = 33</code>在遍历时会把带代码封装成<code>Integer i1 = Integer.valueOf(33)</code>,从而使用的是常量池中的缓存对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>面试经常会问到””创建的String和通过new String创建有什么不同。</p>\n</blockquote>\n<h2 id=\"String-类和常量池\"><a href=\"#String-类和常量池\" class=\"headerlink\" title=\"String 类和常量池\"></a>String 类和常量池</h2><p>String 对象创建的2种方式<br><pre><code class=\"hljs java\">String str1 = <span class=\"hljs-string\">\"abcd\"</span>;\nString str2 = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">\"abcd\"</span>);\nSystem.out.println(str1==str2);</code></pre></p>\n<p>使用<code>==</code>比较的是内存地址，虽然他们的值相同但是由于创建方式的原因它们的内存地址不一样，通过<code>&quot;&quot;</code>方式创建的字符串存放在常量池中，通过<code>new</code>方式是在堆内存中创建一个新的对象，所有他们的内存地址不一样输出<code>false</code>。<br><img src=\"/images/String==.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h4 id=\"注意：只要是通过new方式创建即会创建一个新的对象\"><a href=\"#注意：只要是通过new方式创建即会创建一个新的对象\" class=\"headerlink\" title=\"注意：只要是通过new方式创建即会创建一个新的对象\"></a><code>注意：只要是通过new方式创建即会创建一个新的对象</code></h4><h3 id=\"String-类型的常量池比较\"><a href=\"#String-类型的常量池比较\" class=\"headerlink\" title=\"String 类型的常量池比较\"></a>String 类型的常量池比较</h3><ul>\n<li>直接通过<code>&quot;&quot;</code>声明出来的 String 对象会直接存储在常量池中。</li>\n<li>如果不是通过<code>&quot;&quot;</code>声明的 String 对象。可以使用<code>intern</code>方法，它是一个<code>Native</code>方法,在运行时常量池中如有值匹配的String字符串则返回，否则创建一个字符串并返回其引用。<pre><code class=\"hljs java\">String s1 = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">\"计算机\"</span>);\nString s2 = s1.intern();\nString s3 = <span class=\"hljs-string\">\"计算机\"</span>;\nSystem.out.println(s1 == s2);\nSystem.out.println(s3 == s2);</code></pre>\n</li>\n</ul>\n<p>输出 <code>false</code>、<code>true</code>，<code>s1</code> 属于堆中对象，<code>s2</code> 是常量池中对象,<code>s3</code> 属于常量池中对象</p>\n<h3 id=\"String-字符串拼接\"><a href=\"#String-字符串拼接\" class=\"headerlink\" title=\"String 字符串拼接\"></a>String 字符串拼接</h3><pre><code class=\"hljs java\">String str1 = <span class=\"hljs-string\">\"str\"</span>;\nString str2 = <span class=\"hljs-string\">\"ing\"</span>;\n\nString str3 = <span class=\"hljs-string\">\"str\"</span> + <span class=\"hljs-string\">\"ing\"</span>;\nString str4 = str1 + str2;  \nString str5 = <span class=\"hljs-string\">\"string\"</span>;\nSystem.out.println(str3 == str4);\nSystem.out.println(str3 == str5);\nSystem.out.println(str4 == str5);</code></pre>\n<p>输出<code>false</code>、<code>true</code>、<code>false</code>，<code>str3</code>常量池对象、<code>str2</code>常量池对象、<code>str3</code>常量池对象、<code>str4</code>堆内对象、<code>str5</code>常量池对象<br><img src=\"/images/String++.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h2 id=\"String-s-new-String-“abc”-生成了几个对象\"><a href=\"#String-s-new-String-“abc”-生成了几个对象\" class=\"headerlink\" title=\"String s= new String(“abc”)生成了几个对象\"></a>String s= new String(“abc”)生成了几个对象</h2><p>面试经常会问到这样的问题，首先在常量池会生成<code>&quot;abc&quot;</code>对象，通过<code>new</code>会在堆中生成<code>abc</code>对象，所以答案是<code>2</code>个对象。</p>\n<h2 id=\"常量池拓展\"><a href=\"#常量池拓展\" class=\"headerlink\" title=\"常量池拓展\"></a>常量池拓展</h2><p><code>Java</code>基本类型的包装类的大部门实现了常量池技术，有<code>Byte</code>、<code>Short</code>、<code>Long</code>、<code>Charact</code>、<code>Boolean</code>。这5种包装类默认创建了<code>[-128,127]</code>的相应类型的缓存数据，超出范围的仍然需去创建新的对象。</p>\n<p>以<code>Integer</code>为例<br><pre><code class=\"hljs java\">Integer i1 = <span class=\"hljs-number\">33</span>;\nInteger i2 = <span class=\"hljs-number\">33</span>;\nSystem.out.println(i1 == i2);<span class=\"hljs-comment\">// 输出true</span>\nInteger i11 = <span class=\"hljs-number\">333</span>;\nInteger i22 = <span class=\"hljs-number\">333</span>;\nSystem.out.println(i11 == i22);<span class=\"hljs-comment\">// 输出false</span>\nDouble i3 = <span class=\"hljs-number\">1.2</span>;\nDouble i4 = <span class=\"hljs-number\">1.2</span>;\nSystem.out.println(i3 == i4);<span class=\"hljs-comment\">// 输出false</span></code></pre></p>\n<p>代码中<code>Integer i1 = 33</code>在遍历时会把带代码封装成<code>Integer i1 = Integer.valueOf(33)</code>,从而使用的是常量池中的缓存对象。</p>\n"},{"title":"ThreadPoolExecutor 线程池","toc":false,"date":"2019-11-26T08:52:31.000Z","_content":"\n### ThreadPoolExecutor 线程池\n在阿里开发手册里使用线程池特别提到了禁止使用 __Executors__ 创建线程池，通过源码可知 _ Executors_ 提供的几种默认线程池其内部都是通过new ThreadPoolExcutor()进行创建，由于项目场景不一样在各种情况下默认提供的线程池都有一定缺陷\n\n``` java\n public ThreadPoolExecutor(int corePoolSize, \n                              int maximumPoolSize,  \n                              long keepAliveTime,  \n                              TimeUnit unit,  \n                              BlockingQueue<Runnable> workQueue, \n                              ThreadFactory threadFactory, \n                              RejectedExecutionHandler handler ) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n##### 参数解释\n|参数|意义|\n|-|-|\n|corePoolSize|核心线程池数 核心线程即使空闲也会存在除非设置了 allowCoreThreadTimeOut |\n|maximumPoolSize|最大线程池数|\n|keepAliveTime|线程空闲时间|\n|unit|线程空闲时间单位|\n|workQueue|线程等待队列 ArrayBlockQueue、LinkedBlockQueue|\n|threadFactory|线程创建工厂类|\n|handler|饱和拒绝策略类 实现 RejectedExecutionHandler 接口自定义策略|\n\n\n##### 预配置线程池\n- Executors.newCachedThreadPool()\n``` java\n  public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n```\nmaximumPoolSize 设置为 Interger.MAX_VALUE 说明这是一个几乎无限大小的线程池，SynchornousQueue 无缓冲无存储数据队列每当请求过来会直接创建线程，当消费速度小于生产速度创建过多线程不能及时回收导致 OOM\n\n- Executors.newSingleThreadExecutor()\n``` java\nreturn new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n```\n与 newCachedThreadPool 不一样的是 maximumPoolSize 为 1，但是所用队列为 LinkedBlockingQueue 无界链表阻塞队列默认大小为 Interger.MAX_VALUE，当消费速度小于生产速度队列里的待消费线程堆积过多导致 OOM\n\n- Executors.newFixedThreadPool(int nThreads)\n``` java\nreturn new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n```\n虽然 maximumPoolSize、corePoolSize 可自行设置，但是由于使用 LinkedBlockingQueue 默认大小问题一样会导致队列堆积产生 OOM\n\n### 线程池执行过程\n![线程池执行过程](/images/ThreadPoolExcutor.jpg)\n\n##### 源码分析\n``` java\n//提交任务\npublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        int c = ctl.get();\n\t// 获取当前工作线程数量是否小于核心线程池容量 \n\t// 小于则创建初始化核心线程 \n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n\t// 超过核心线程池数则进行判断任务队列是否已满 检测线程池是否处于运行状态且任务队列添加成功\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n\t    // 再次检查建线程池状态是否为运行 \n\t    // 运行状态且工作线程数为0：执行 addWorker()\n\t    // 非运行状态：执行拒绝策略\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n\t//队列已满 直接创建新的线程失败则执行拒绝策略\n        else if (!addWorker(command, false))\n            reject(command);\n}\n\n//添加任务\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // 判断队列 线程池状态\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n\t\t\n            for (;;) {\n                int wc = workerCountOf(c);\n\t\t// 大于默认线程池最大容量或大于核心线程池或最大线程池限制\n                if (wc >= CAPACITY ||\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n\t\t// CAS 比较替换自增更新线程池数   \n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n        }\n\t// 将传入的线程进行 Worker 包装  \n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n            if (t != null) {\n\t\t// 加锁\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();\n                try {\n                    // 获取线程池状态并判断\n                    int rs = runStateOf(ctl.get());\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n\t\t\t// 添加待执行 HashSet<Worker>\n                        workers.add(w);\n\t\t\t// 更新最大线程池数\n                        int s = workers.size();\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        workerAdded = true;\n                    }\n                } finally {\n\t\t    // 解锁\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n\t\t    // 任务添加成功 启动线程\n                    t.start();\n                    workerStarted = true;\n                }\n            }\n        } finally {\n\t    // 启动任务失败 移除任务\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n}\n```\n##### 线程状态\n|状态|解释|\n|-|-|-|\n|RUNNING|运行状态，可处理新任务并执行队列中的任务|\n|SHUTDOWN|关闭状态，不接受新任务但处理队列中的任务|\n|STOP|停止状态，不接受新任务不处理队列中任务且中断执行中的任务|\n|TIDYING|整理状态，所有任务已结束，workerCount = 0，将执行 terminated() 方法|\n|TERMINATED|结束状态，terminated() 方法执行完毕|\n\n### 线程池参数\n\n#### ThreadFactory 线程工厂类\n通过实现 ThreadFactory 接口可做自定义线程生成工厂，可以自定义设置线程的name、group、优先级等，默认线程工厂创建的线程为非守护线程且有相同的优先级。\n``` java\n    static class DefaultThreadFactory implements ThreadFactory {\n        private static final AtomicInteger poolNumber = new AtomicInteger(1);\n        private final ThreadGroup group;\n        private final AtomicInteger threadNumber = new AtomicInteger(1);\n        private final String namePrefix;\n\n        DefaultThreadFactory() {\n            SecurityManager s = System.getSecurityManager();\n            group = (s != null) ? s.getThreadGroup() :\n                                  Thread.currentThread().getThreadGroup();\n            namePrefix = \"pool-\" +\n                          poolNumber.getAndIncrement() +\n                         \"-thread-\";\n        }\n\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(group, r,\n                                  namePrefix + threadNumber.getAndIncrement(),\n                                  0);\n\t    // 设置非守护线程\n            if (t.isDaemon())\n                t.setDaemon(false);\n\t    // 设置默认优先级\n            if (t.getPriority() != Thread.NORM_PRIORITY)\n                t.setPriority(Thread.NORM_PRIORITY);\n            return t;\n        }\n    }\n```\n\n\n#### 线程队列\n线程队列用于存放提交的任务，队列实际的最大容量 = maximumPoolSize+ queueSize，根据业务场景采用不同的线程队列可最大限度的发挥线程池的性能\n\n- SynchronousQueue 无缓冲无容量不存储元素的阻塞等待队列，每次提交任务需要等待消费配对才能进行下一个任务否则一直阻塞\n- ArrayBlockingQueue 有界缓存等待队列可以设置队列的容量，当线程池大于 coolPoolSize 则缓存到队列中直到饱和，合理的控制队列大小避免 OOM\n- LinkedBlockingQueue 无解缓存等待队列其容量大小为 Interger.Max ，线程池 maximumPoolSize 参数直接无效\n\n#### 拒绝策略\n- 当线程池任务线程小于 corePoolSize 时，则会创建核心线程执行任务不会从队列中取空闲线程\n- 当线程池任务大于 corePoolSize 时，则会从线程队列中取出空闲现场执行任务\n- 当线程池任务大于 corePoolSize　且线程队列中无空闲现场，则会创建新的线程执行任务直到创建线程数大于　maximumPoolSize，线程池便会执行 RejectedExecutionHandler 拒绝策略\n\n#### 默认策略\n\n|名称|策略|\n|-|-|\n|AbortPolicy|线程池满达到上限啧抛出异常|\n|DiscardOldestPolicy|线程池满达到上限丢弃最老的一个任务即最先被丢入缓存队列的任务|\n|DiscardPolicy|线程池满达到上限直接丢弃任务|\n\n根据业务的需求可以实现 RejectedExecutionHandler 接口自定义拒绝的策略","source":"_posts/ThreadPoolExecutor-线程池.md","raw":"---\ntitle: ThreadPoolExecutor 线程池\ntags: []\ncategories: []\ntoc: false\ndate: 2019-11-26 16:52:31\n---\n\n### ThreadPoolExecutor 线程池\n在阿里开发手册里使用线程池特别提到了禁止使用 __Executors__ 创建线程池，通过源码可知 _ Executors_ 提供的几种默认线程池其内部都是通过new ThreadPoolExcutor()进行创建，由于项目场景不一样在各种情况下默认提供的线程池都有一定缺陷\n\n``` java\n public ThreadPoolExecutor(int corePoolSize, \n                              int maximumPoolSize,  \n                              long keepAliveTime,  \n                              TimeUnit unit,  \n                              BlockingQueue<Runnable> workQueue, \n                              ThreadFactory threadFactory, \n                              RejectedExecutionHandler handler ) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n##### 参数解释\n|参数|意义|\n|-|-|\n|corePoolSize|核心线程池数 核心线程即使空闲也会存在除非设置了 allowCoreThreadTimeOut |\n|maximumPoolSize|最大线程池数|\n|keepAliveTime|线程空闲时间|\n|unit|线程空闲时间单位|\n|workQueue|线程等待队列 ArrayBlockQueue、LinkedBlockQueue|\n|threadFactory|线程创建工厂类|\n|handler|饱和拒绝策略类 实现 RejectedExecutionHandler 接口自定义策略|\n\n\n##### 预配置线程池\n- Executors.newCachedThreadPool()\n``` java\n  public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n```\nmaximumPoolSize 设置为 Interger.MAX_VALUE 说明这是一个几乎无限大小的线程池，SynchornousQueue 无缓冲无存储数据队列每当请求过来会直接创建线程，当消费速度小于生产速度创建过多线程不能及时回收导致 OOM\n\n- Executors.newSingleThreadExecutor()\n``` java\nreturn new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n```\n与 newCachedThreadPool 不一样的是 maximumPoolSize 为 1，但是所用队列为 LinkedBlockingQueue 无界链表阻塞队列默认大小为 Interger.MAX_VALUE，当消费速度小于生产速度队列里的待消费线程堆积过多导致 OOM\n\n- Executors.newFixedThreadPool(int nThreads)\n``` java\nreturn new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n```\n虽然 maximumPoolSize、corePoolSize 可自行设置，但是由于使用 LinkedBlockingQueue 默认大小问题一样会导致队列堆积产生 OOM\n\n### 线程池执行过程\n![线程池执行过程](/images/ThreadPoolExcutor.jpg)\n\n##### 源码分析\n``` java\n//提交任务\npublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        int c = ctl.get();\n\t// 获取当前工作线程数量是否小于核心线程池容量 \n\t// 小于则创建初始化核心线程 \n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n\t// 超过核心线程池数则进行判断任务队列是否已满 检测线程池是否处于运行状态且任务队列添加成功\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n\t    // 再次检查建线程池状态是否为运行 \n\t    // 运行状态且工作线程数为0：执行 addWorker()\n\t    // 非运行状态：执行拒绝策略\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n\t//队列已满 直接创建新的线程失败则执行拒绝策略\n        else if (!addWorker(command, false))\n            reject(command);\n}\n\n//添加任务\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // 判断队列 线程池状态\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n\t\t\n            for (;;) {\n                int wc = workerCountOf(c);\n\t\t// 大于默认线程池最大容量或大于核心线程池或最大线程池限制\n                if (wc >= CAPACITY ||\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n\t\t// CAS 比较替换自增更新线程池数   \n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n        }\n\t// 将传入的线程进行 Worker 包装  \n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n            if (t != null) {\n\t\t// 加锁\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();\n                try {\n                    // 获取线程池状态并判断\n                    int rs = runStateOf(ctl.get());\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n\t\t\t// 添加待执行 HashSet<Worker>\n                        workers.add(w);\n\t\t\t// 更新最大线程池数\n                        int s = workers.size();\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        workerAdded = true;\n                    }\n                } finally {\n\t\t    // 解锁\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n\t\t    // 任务添加成功 启动线程\n                    t.start();\n                    workerStarted = true;\n                }\n            }\n        } finally {\n\t    // 启动任务失败 移除任务\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n}\n```\n##### 线程状态\n|状态|解释|\n|-|-|-|\n|RUNNING|运行状态，可处理新任务并执行队列中的任务|\n|SHUTDOWN|关闭状态，不接受新任务但处理队列中的任务|\n|STOP|停止状态，不接受新任务不处理队列中任务且中断执行中的任务|\n|TIDYING|整理状态，所有任务已结束，workerCount = 0，将执行 terminated() 方法|\n|TERMINATED|结束状态，terminated() 方法执行完毕|\n\n### 线程池参数\n\n#### ThreadFactory 线程工厂类\n通过实现 ThreadFactory 接口可做自定义线程生成工厂，可以自定义设置线程的name、group、优先级等，默认线程工厂创建的线程为非守护线程且有相同的优先级。\n``` java\n    static class DefaultThreadFactory implements ThreadFactory {\n        private static final AtomicInteger poolNumber = new AtomicInteger(1);\n        private final ThreadGroup group;\n        private final AtomicInteger threadNumber = new AtomicInteger(1);\n        private final String namePrefix;\n\n        DefaultThreadFactory() {\n            SecurityManager s = System.getSecurityManager();\n            group = (s != null) ? s.getThreadGroup() :\n                                  Thread.currentThread().getThreadGroup();\n            namePrefix = \"pool-\" +\n                          poolNumber.getAndIncrement() +\n                         \"-thread-\";\n        }\n\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(group, r,\n                                  namePrefix + threadNumber.getAndIncrement(),\n                                  0);\n\t    // 设置非守护线程\n            if (t.isDaemon())\n                t.setDaemon(false);\n\t    // 设置默认优先级\n            if (t.getPriority() != Thread.NORM_PRIORITY)\n                t.setPriority(Thread.NORM_PRIORITY);\n            return t;\n        }\n    }\n```\n\n\n#### 线程队列\n线程队列用于存放提交的任务，队列实际的最大容量 = maximumPoolSize+ queueSize，根据业务场景采用不同的线程队列可最大限度的发挥线程池的性能\n\n- SynchronousQueue 无缓冲无容量不存储元素的阻塞等待队列，每次提交任务需要等待消费配对才能进行下一个任务否则一直阻塞\n- ArrayBlockingQueue 有界缓存等待队列可以设置队列的容量，当线程池大于 coolPoolSize 则缓存到队列中直到饱和，合理的控制队列大小避免 OOM\n- LinkedBlockingQueue 无解缓存等待队列其容量大小为 Interger.Max ，线程池 maximumPoolSize 参数直接无效\n\n#### 拒绝策略\n- 当线程池任务线程小于 corePoolSize 时，则会创建核心线程执行任务不会从队列中取空闲线程\n- 当线程池任务大于 corePoolSize 时，则会从线程队列中取出空闲现场执行任务\n- 当线程池任务大于 corePoolSize　且线程队列中无空闲现场，则会创建新的线程执行任务直到创建线程数大于　maximumPoolSize，线程池便会执行 RejectedExecutionHandler 拒绝策略\n\n#### 默认策略\n\n|名称|策略|\n|-|-|\n|AbortPolicy|线程池满达到上限啧抛出异常|\n|DiscardOldestPolicy|线程池满达到上限丢弃最老的一个任务即最先被丢入缓存队列的任务|\n|DiscardPolicy|线程池满达到上限直接丢弃任务|\n\n根据业务的需求可以实现 RejectedExecutionHandler 接口自定义拒绝的策略","slug":"ThreadPoolExecutor-线程池","published":1,"updated":"2020-08-13T02:34:24.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc99v0043jsudmaew8pxz","content":"<h3 id=\"ThreadPoolExecutor-线程池\"><a href=\"#ThreadPoolExecutor-线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor 线程池\"></a>ThreadPoolExecutor 线程池</h3><p>在阿里开发手册里使用线程池特别提到了禁止使用 <strong>Executors</strong> 创建线程池，通过源码可知 _ Executors_ 提供的几种默认线程池其内部都是通过new ThreadPoolExcutor()进行创建，由于项目场景不一样在各种情况下默认提供的线程池都有一定缺陷</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ThreadPoolExecutor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> corePoolSize, \n                             <span class=\"hljs-keyword\">int</span> maximumPoolSize,  \n                             <span class=\"hljs-keyword\">long</span> keepAliveTime,  \n                             TimeUnit unit,  \n                             BlockingQueue&lt;Runnable&gt; workQueue, \n                             ThreadFactory threadFactory, \n                             RejectedExecutionHandler handler )</span> </span>&#123;\n       <span class=\"hljs-keyword\">if</span> (corePoolSize &lt; <span class=\"hljs-number\">0</span> ||\n           maximumPoolSize &lt;= <span class=\"hljs-number\">0</span> ||\n           maximumPoolSize &lt; corePoolSize ||\n           keepAliveTime &lt; <span class=\"hljs-number\">0</span>)\n           <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException();\n       <span class=\"hljs-keyword\">if</span> (workQueue == <span class=\"hljs-keyword\">null</span> || threadFactory == <span class=\"hljs-keyword\">null</span> || handler == <span class=\"hljs-keyword\">null</span>)\n           <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NullPointerException();\n       <span class=\"hljs-keyword\">this</span>.corePoolSize = corePoolSize;\n       <span class=\"hljs-keyword\">this</span>.maximumPoolSize = maximumPoolSize;\n       <span class=\"hljs-keyword\">this</span>.workQueue = workQueue;\n       <span class=\"hljs-keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);\n       <span class=\"hljs-keyword\">this</span>.threadFactory = threadFactory;\n       <span class=\"hljs-keyword\">this</span>.handler = handler;\n   &#125;</code></pre>\n<h5 id=\"参数解释\"><a href=\"#参数解释\" class=\"headerlink\" title=\"参数解释\"></a>参数解释</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>corePoolSize</td>\n<td>核心线程池数 核心线程即使空闲也会存在除非设置了 allowCoreThreadTimeOut</td>\n</tr>\n<tr>\n<td>maximumPoolSize</td>\n<td>最大线程池数</td>\n</tr>\n<tr>\n<td>keepAliveTime</td>\n<td>线程空闲时间</td>\n</tr>\n<tr>\n<td>unit</td>\n<td>线程空闲时间单位</td>\n</tr>\n<tr>\n<td>workQueue</td>\n<td>线程等待队列 ArrayBlockQueue、LinkedBlockQueue</td>\n</tr>\n<tr>\n<td>threadFactory</td>\n<td>线程创建工厂类</td>\n</tr>\n<tr>\n<td>handler</td>\n<td>饱和拒绝策略类 实现 RejectedExecutionHandler 接口自定义策略</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"预配置线程池\"><a href=\"#预配置线程池\" class=\"headerlink\" title=\"预配置线程池\"></a>预配置线程池</h5><ul>\n<li>Executors.newCachedThreadPool()<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> ExecutorService <span class=\"hljs-title\">newCachedThreadPool</span><span class=\"hljs-params\">()</span> </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ThreadPoolExecutor(<span class=\"hljs-number\">0</span>, Integer.MAX_VALUE,\n                                    <span class=\"hljs-number\">60L</span>, TimeUnit.SECONDS,\n                                    <span class=\"hljs-keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</code></pre>\n</li>\n</ul>\n<p>maximumPoolSize 设置为 Interger.MAX_VALUE 说明这是一个几乎无限大小的线程池，SynchornousQueue 无缓冲无存储数据队列每当请求过来会直接创建线程，当消费速度小于生产速度创建过多线程不能及时回收导致 OOM</p>\n<ul>\n<li>Executors.newSingleThreadExecutor()<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> FinalizableDelegatedExecutorService\n            (<span class=\"hljs-keyword\">new</span> ThreadPoolExecutor(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>,\n                                    <span class=\"hljs-number\">0L</span>, TimeUnit.MILLISECONDS,\n                                    <span class=\"hljs-keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</code></pre>\n</li>\n</ul>\n<p>与 newCachedThreadPool 不一样的是 maximumPoolSize 为 1，但是所用队列为 LinkedBlockingQueue 无界链表阻塞队列默认大小为 Interger.MAX_VALUE，当消费速度小于生产速度队列里的待消费线程堆积过多导致 OOM</p>\n<ul>\n<li>Executors.newFixedThreadPool(int nThreads)<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,\n                                      <span class=\"hljs-number\">0L</span>, TimeUnit.MILLISECONDS,\n                                      <span class=\"hljs-keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</code></pre>\n</li>\n</ul>\n<p>虽然 maximumPoolSize、corePoolSize 可自行设置，但是由于使用 LinkedBlockingQueue 默认大小问题一样会导致队列堆积产生 OOM</p>\n<h3 id=\"线程池执行过程\"><a href=\"#线程池执行过程\" class=\"headerlink\" title=\"线程池执行过程\"></a>线程池执行过程</h3><p><img src=\"/images/ThreadPoolExcutor.jpg\" srcset=\"/img/loading.gif\" alt=\"线程池执行过程\"></p>\n<h5 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h5><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//提交任务</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(Runnable command)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (command == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NullPointerException();\n        <span class=\"hljs-keyword\">int</span> c = ctl.get();\n\t<span class=\"hljs-comment\">// 获取当前工作线程数量是否小于核心线程池容量 </span>\n\t<span class=\"hljs-comment\">// 小于则创建初始化核心线程 </span>\n        <span class=\"hljs-keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;\n            <span class=\"hljs-keyword\">if</span> (addWorker(command, <span class=\"hljs-keyword\">true</span>))\n                <span class=\"hljs-keyword\">return</span>;\n            c = ctl.get();\n        &#125;\n\t<span class=\"hljs-comment\">// 超过核心线程池数则进行判断任务队列是否已满 检测线程池是否处于运行状态且任务队列添加成功</span>\n        <span class=\"hljs-keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;\n            <span class=\"hljs-keyword\">int</span> recheck = ctl.get();\n\t    <span class=\"hljs-comment\">// 再次检查建线程池状态是否为运行 </span>\n\t    <span class=\"hljs-comment\">// 运行状态且工作线程数为0：执行 addWorker()</span>\n\t    <span class=\"hljs-comment\">// 非运行状态：执行拒绝策略</span>\n            <span class=\"hljs-keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))\n                reject(command);\n            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (workerCountOf(recheck) == <span class=\"hljs-number\">0</span>)\n                addWorker(<span class=\"hljs-keyword\">null</span>, <span class=\"hljs-keyword\">false</span>);\n        &#125;\n\t<span class=\"hljs-comment\">//队列已满 直接创建新的线程失败则执行拒绝策略</span>\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!addWorker(command, <span class=\"hljs-keyword\">false</span>))\n            reject(command);\n&#125;\n\n<span class=\"hljs-comment\">//添加任务</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">addWorker</span><span class=\"hljs-params\">(Runnable firstTask, <span class=\"hljs-keyword\">boolean</span> core)</span> </span>&#123;\n        retry:\n        <span class=\"hljs-keyword\">for</span> (;;) &#123;\n            <span class=\"hljs-keyword\">int</span> c = ctl.get();\n            <span class=\"hljs-keyword\">int</span> rs = runStateOf(c);\n\n            <span class=\"hljs-comment\">// 判断队列 线程池状态</span>\n            <span class=\"hljs-keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;\n                ! (rs == SHUTDOWN &amp;&amp;\n                   firstTask == <span class=\"hljs-keyword\">null</span> &amp;&amp;\n                   ! workQueue.isEmpty()))\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n\t\t\n            <span class=\"hljs-keyword\">for</span> (;;) &#123;\n                <span class=\"hljs-keyword\">int</span> wc = workerCountOf(c);\n\t\t<span class=\"hljs-comment\">// 大于默认线程池最大容量或大于核心线程池或最大线程池限制</span>\n                <span class=\"hljs-keyword\">if</span> (wc &gt;= CAPACITY ||\n                    wc &gt;= (core ? corePoolSize : maximumPoolSize))\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n\t\t<span class=\"hljs-comment\">// CAS 比较替换自增更新线程池数   </span>\n                <span class=\"hljs-keyword\">if</span> (compareAndIncrementWorkerCount(c))\n                    <span class=\"hljs-keyword\">break</span> retry;\n                c = ctl.get();  <span class=\"hljs-comment\">// Re-read ctl</span>\n                <span class=\"hljs-keyword\">if</span> (runStateOf(c) != rs)\n                    <span class=\"hljs-keyword\">continue</span> retry;\n                <span class=\"hljs-comment\">// else CAS failed due to workerCount change; retry inner loop</span>\n            &#125;\n        &#125;\n\t<span class=\"hljs-comment\">// 将传入的线程进行 Worker 包装  </span>\n        <span class=\"hljs-keyword\">boolean</span> workerStarted = <span class=\"hljs-keyword\">false</span>;\n        <span class=\"hljs-keyword\">boolean</span> workerAdded = <span class=\"hljs-keyword\">false</span>;\n        Worker w = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            w = <span class=\"hljs-keyword\">new</span> Worker(firstTask);\n            <span class=\"hljs-keyword\">final</span> Thread t = w.thread;\n            <span class=\"hljs-keyword\">if</span> (t != <span class=\"hljs-keyword\">null</span>) &#123;\n\t\t<span class=\"hljs-comment\">// 加锁</span>\n                <span class=\"hljs-keyword\">final</span> ReentrantLock mainLock = <span class=\"hljs-keyword\">this</span>.mainLock;\n                mainLock.lock();\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    <span class=\"hljs-comment\">// 获取线程池状态并判断</span>\n                    <span class=\"hljs-keyword\">int</span> rs = runStateOf(ctl.get());\n                    <span class=\"hljs-keyword\">if</span> (rs &lt; SHUTDOWN ||\n                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"hljs-keyword\">null</span>)) &#123;\n                        <span class=\"hljs-keyword\">if</span> (t.isAlive()) <span class=\"hljs-comment\">// precheck that t is startable</span>\n                            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalThreadStateException();\n\t\t\t<span class=\"hljs-comment\">// 添加待执行 HashSet&lt;Worker&gt;</span>\n                        workers.add(w);\n\t\t\t<span class=\"hljs-comment\">// 更新最大线程池数</span>\n                        <span class=\"hljs-keyword\">int</span> s = workers.size();\n                        <span class=\"hljs-keyword\">if</span> (s &gt; largestPoolSize)\n                            largestPoolSize = s;\n                        workerAdded = <span class=\"hljs-keyword\">true</span>;\n                    &#125;\n                &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n\t\t    <span class=\"hljs-comment\">// 解锁</span>\n                    mainLock.unlock();\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (workerAdded) &#123;\n\t\t    <span class=\"hljs-comment\">// 任务添加成功 启动线程</span>\n                    t.start();\n                    workerStarted = <span class=\"hljs-keyword\">true</span>;\n                &#125;\n            &#125;\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n\t    <span class=\"hljs-comment\">// 启动任务失败 移除任务</span>\n            <span class=\"hljs-keyword\">if</span> (! workerStarted)\n                addWorkerFailed(w);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> workerStarted;\n&#125;</code></pre>\n<h5 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h5><table>\n<thead>\n<tr>\n<th>状态</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RUNNING</td>\n<td>运行状态，可处理新任务并执行队列中的任务</td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>关闭状态，不接受新任务但处理队列中的任务</td>\n</tr>\n<tr>\n<td>STOP</td>\n<td>停止状态，不接受新任务不处理队列中任务且中断执行中的任务</td>\n</tr>\n<tr>\n<td>TIDYING</td>\n<td>整理状态，所有任务已结束，workerCount = 0，将执行 terminated() 方法</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>结束状态，terminated() 方法执行完毕</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"线程池参数\"><a href=\"#线程池参数\" class=\"headerlink\" title=\"线程池参数\"></a>线程池参数</h3><h4 id=\"ThreadFactory-线程工厂类\"><a href=\"#ThreadFactory-线程工厂类\" class=\"headerlink\" title=\"ThreadFactory 线程工厂类\"></a>ThreadFactory 线程工厂类</h4><p>通过实现 ThreadFactory 接口可做自定义线程生成工厂，可以自定义设置线程的name、group、优先级等，默认线程工厂创建的线程为非守护线程且有相同的优先级。<br><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultThreadFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ThreadFactory</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> AtomicInteger poolNumber = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ThreadGroup group;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> AtomicInteger threadNumber = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String namePrefix;\n\n    DefaultThreadFactory() &#123;\n        SecurityManager s = System.getSecurityManager();\n        group = (s != <span class=\"hljs-keyword\">null</span>) ? s.getThreadGroup() :\n                              Thread.currentThread().getThreadGroup();\n        namePrefix = <span class=\"hljs-string\">\"pool-\"</span> +\n                      poolNumber.getAndIncrement() +\n                     <span class=\"hljs-string\">\"-thread-\"</span>;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Thread <span class=\"hljs-title\">newThread</span><span class=\"hljs-params\">(Runnable r)</span> </span>&#123;\n        Thread t = <span class=\"hljs-keyword\">new</span> Thread(group, r,\n                              namePrefix + threadNumber.getAndIncrement(),\n                              <span class=\"hljs-number\">0</span>);\n <span class=\"hljs-comment\">// 设置非守护线程</span>\n        <span class=\"hljs-keyword\">if</span> (t.isDaemon())\n            t.setDaemon(<span class=\"hljs-keyword\">false</span>);\n <span class=\"hljs-comment\">// 设置默认优先级</span>\n        <span class=\"hljs-keyword\">if</span> (t.getPriority() != Thread.NORM_PRIORITY)\n            t.setPriority(Thread.NORM_PRIORITY);\n        <span class=\"hljs-keyword\">return</span> t;\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"线程队列\"><a href=\"#线程队列\" class=\"headerlink\" title=\"线程队列\"></a>线程队列</h4><p>线程队列用于存放提交的任务，队列实际的最大容量 = maximumPoolSize+ queueSize，根据业务场景采用不同的线程队列可最大限度的发挥线程池的性能</p>\n<ul>\n<li>SynchronousQueue 无缓冲无容量不存储元素的阻塞等待队列，每次提交任务需要等待消费配对才能进行下一个任务否则一直阻塞</li>\n<li>ArrayBlockingQueue 有界缓存等待队列可以设置队列的容量，当线程池大于 coolPoolSize 则缓存到队列中直到饱和，合理的控制队列大小避免 OOM</li>\n<li>LinkedBlockingQueue 无解缓存等待队列其容量大小为 Interger.Max ，线程池 maximumPoolSize 参数直接无效</li>\n</ul>\n<h4 id=\"拒绝策略\"><a href=\"#拒绝策略\" class=\"headerlink\" title=\"拒绝策略\"></a>拒绝策略</h4><ul>\n<li>当线程池任务线程小于 corePoolSize 时，则会创建核心线程执行任务不会从队列中取空闲线程</li>\n<li>当线程池任务大于 corePoolSize 时，则会从线程队列中取出空闲现场执行任务</li>\n<li>当线程池任务大于 corePoolSize　且线程队列中无空闲现场，则会创建新的线程执行任务直到创建线程数大于　maximumPoolSize，线程池便会执行 RejectedExecutionHandler 拒绝策略</li>\n</ul>\n<h4 id=\"默认策略\"><a href=\"#默认策略\" class=\"headerlink\" title=\"默认策略\"></a>默认策略</h4><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>策略</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AbortPolicy</td>\n<td>线程池满达到上限啧抛出异常</td>\n</tr>\n<tr>\n<td>DiscardOldestPolicy</td>\n<td>线程池满达到上限丢弃最老的一个任务即最先被丢入缓存队列的任务</td>\n</tr>\n<tr>\n<td>DiscardPolicy</td>\n<td>线程池满达到上限直接丢弃任务</td>\n</tr>\n</tbody>\n</table>\n<p>根据业务的需求可以实现 RejectedExecutionHandler 接口自定义拒绝的策略</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"ThreadPoolExecutor-线程池\"><a href=\"#ThreadPoolExecutor-线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor 线程池\"></a>ThreadPoolExecutor 线程池</h3><p>在阿里开发手册里使用线程池特别提到了禁止使用 <strong>Executors</strong> 创建线程池，通过源码可知 _ Executors_ 提供的几种默认线程池其内部都是通过new ThreadPoolExcutor()进行创建，由于项目场景不一样在各种情况下默认提供的线程池都有一定缺陷</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ThreadPoolExecutor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> corePoolSize, \n                             <span class=\"hljs-keyword\">int</span> maximumPoolSize,  \n                             <span class=\"hljs-keyword\">long</span> keepAliveTime,  \n                             TimeUnit unit,  \n                             BlockingQueue&lt;Runnable&gt; workQueue, \n                             ThreadFactory threadFactory, \n                             RejectedExecutionHandler handler )</span> </span>&#123;\n       <span class=\"hljs-keyword\">if</span> (corePoolSize &lt; <span class=\"hljs-number\">0</span> ||\n           maximumPoolSize &lt;= <span class=\"hljs-number\">0</span> ||\n           maximumPoolSize &lt; corePoolSize ||\n           keepAliveTime &lt; <span class=\"hljs-number\">0</span>)\n           <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException();\n       <span class=\"hljs-keyword\">if</span> (workQueue == <span class=\"hljs-keyword\">null</span> || threadFactory == <span class=\"hljs-keyword\">null</span> || handler == <span class=\"hljs-keyword\">null</span>)\n           <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NullPointerException();\n       <span class=\"hljs-keyword\">this</span>.corePoolSize = corePoolSize;\n       <span class=\"hljs-keyword\">this</span>.maximumPoolSize = maximumPoolSize;\n       <span class=\"hljs-keyword\">this</span>.workQueue = workQueue;\n       <span class=\"hljs-keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);\n       <span class=\"hljs-keyword\">this</span>.threadFactory = threadFactory;\n       <span class=\"hljs-keyword\">this</span>.handler = handler;\n   &#125;</code></pre>\n<h5 id=\"参数解释\"><a href=\"#参数解释\" class=\"headerlink\" title=\"参数解释\"></a>参数解释</h5><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>corePoolSize</td>\n<td>核心线程池数 核心线程即使空闲也会存在除非设置了 allowCoreThreadTimeOut</td>\n</tr>\n<tr>\n<td>maximumPoolSize</td>\n<td>最大线程池数</td>\n</tr>\n<tr>\n<td>keepAliveTime</td>\n<td>线程空闲时间</td>\n</tr>\n<tr>\n<td>unit</td>\n<td>线程空闲时间单位</td>\n</tr>\n<tr>\n<td>workQueue</td>\n<td>线程等待队列 ArrayBlockQueue、LinkedBlockQueue</td>\n</tr>\n<tr>\n<td>threadFactory</td>\n<td>线程创建工厂类</td>\n</tr>\n<tr>\n<td>handler</td>\n<td>饱和拒绝策略类 实现 RejectedExecutionHandler 接口自定义策略</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"预配置线程池\"><a href=\"#预配置线程池\" class=\"headerlink\" title=\"预配置线程池\"></a>预配置线程池</h5><ul>\n<li>Executors.newCachedThreadPool()<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> ExecutorService <span class=\"hljs-title\">newCachedThreadPool</span><span class=\"hljs-params\">()</span> </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ThreadPoolExecutor(<span class=\"hljs-number\">0</span>, Integer.MAX_VALUE,\n                                    <span class=\"hljs-number\">60L</span>, TimeUnit.SECONDS,\n                                    <span class=\"hljs-keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</code></pre>\n</li>\n</ul>\n<p>maximumPoolSize 设置为 Interger.MAX_VALUE 说明这是一个几乎无限大小的线程池，SynchornousQueue 无缓冲无存储数据队列每当请求过来会直接创建线程，当消费速度小于生产速度创建过多线程不能及时回收导致 OOM</p>\n<ul>\n<li>Executors.newSingleThreadExecutor()<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> FinalizableDelegatedExecutorService\n            (<span class=\"hljs-keyword\">new</span> ThreadPoolExecutor(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>,\n                                    <span class=\"hljs-number\">0L</span>, TimeUnit.MILLISECONDS,\n                                    <span class=\"hljs-keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</code></pre>\n</li>\n</ul>\n<p>与 newCachedThreadPool 不一样的是 maximumPoolSize 为 1，但是所用队列为 LinkedBlockingQueue 无界链表阻塞队列默认大小为 Interger.MAX_VALUE，当消费速度小于生产速度队列里的待消费线程堆积过多导致 OOM</p>\n<ul>\n<li>Executors.newFixedThreadPool(int nThreads)<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,\n                                      <span class=\"hljs-number\">0L</span>, TimeUnit.MILLISECONDS,\n                                      <span class=\"hljs-keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</code></pre>\n</li>\n</ul>\n<p>虽然 maximumPoolSize、corePoolSize 可自行设置，但是由于使用 LinkedBlockingQueue 默认大小问题一样会导致队列堆积产生 OOM</p>\n<h3 id=\"线程池执行过程\"><a href=\"#线程池执行过程\" class=\"headerlink\" title=\"线程池执行过程\"></a>线程池执行过程</h3><p><img src=\"/images/ThreadPoolExcutor.jpg\" srcset=\"/img/loading.gif\" alt=\"线程池执行过程\"></p>\n<h5 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h5><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//提交任务</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(Runnable command)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (command == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NullPointerException();\n        <span class=\"hljs-keyword\">int</span> c = ctl.get();\n\t<span class=\"hljs-comment\">// 获取当前工作线程数量是否小于核心线程池容量 </span>\n\t<span class=\"hljs-comment\">// 小于则创建初始化核心线程 </span>\n        <span class=\"hljs-keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;\n            <span class=\"hljs-keyword\">if</span> (addWorker(command, <span class=\"hljs-keyword\">true</span>))\n                <span class=\"hljs-keyword\">return</span>;\n            c = ctl.get();\n        &#125;\n\t<span class=\"hljs-comment\">// 超过核心线程池数则进行判断任务队列是否已满 检测线程池是否处于运行状态且任务队列添加成功</span>\n        <span class=\"hljs-keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;\n            <span class=\"hljs-keyword\">int</span> recheck = ctl.get();\n\t    <span class=\"hljs-comment\">// 再次检查建线程池状态是否为运行 </span>\n\t    <span class=\"hljs-comment\">// 运行状态且工作线程数为0：执行 addWorker()</span>\n\t    <span class=\"hljs-comment\">// 非运行状态：执行拒绝策略</span>\n            <span class=\"hljs-keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))\n                reject(command);\n            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (workerCountOf(recheck) == <span class=\"hljs-number\">0</span>)\n                addWorker(<span class=\"hljs-keyword\">null</span>, <span class=\"hljs-keyword\">false</span>);\n        &#125;\n\t<span class=\"hljs-comment\">//队列已满 直接创建新的线程失败则执行拒绝策略</span>\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!addWorker(command, <span class=\"hljs-keyword\">false</span>))\n            reject(command);\n&#125;\n\n<span class=\"hljs-comment\">//添加任务</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">addWorker</span><span class=\"hljs-params\">(Runnable firstTask, <span class=\"hljs-keyword\">boolean</span> core)</span> </span>&#123;\n        retry:\n        <span class=\"hljs-keyword\">for</span> (;;) &#123;\n            <span class=\"hljs-keyword\">int</span> c = ctl.get();\n            <span class=\"hljs-keyword\">int</span> rs = runStateOf(c);\n\n            <span class=\"hljs-comment\">// 判断队列 线程池状态</span>\n            <span class=\"hljs-keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;\n                ! (rs == SHUTDOWN &amp;&amp;\n                   firstTask == <span class=\"hljs-keyword\">null</span> &amp;&amp;\n                   ! workQueue.isEmpty()))\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n\t\t\n            <span class=\"hljs-keyword\">for</span> (;;) &#123;\n                <span class=\"hljs-keyword\">int</span> wc = workerCountOf(c);\n\t\t<span class=\"hljs-comment\">// 大于默认线程池最大容量或大于核心线程池或最大线程池限制</span>\n                <span class=\"hljs-keyword\">if</span> (wc &gt;= CAPACITY ||\n                    wc &gt;= (core ? corePoolSize : maximumPoolSize))\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n\t\t<span class=\"hljs-comment\">// CAS 比较替换自增更新线程池数   </span>\n                <span class=\"hljs-keyword\">if</span> (compareAndIncrementWorkerCount(c))\n                    <span class=\"hljs-keyword\">break</span> retry;\n                c = ctl.get();  <span class=\"hljs-comment\">// Re-read ctl</span>\n                <span class=\"hljs-keyword\">if</span> (runStateOf(c) != rs)\n                    <span class=\"hljs-keyword\">continue</span> retry;\n                <span class=\"hljs-comment\">// else CAS failed due to workerCount change; retry inner loop</span>\n            &#125;\n        &#125;\n\t<span class=\"hljs-comment\">// 将传入的线程进行 Worker 包装  </span>\n        <span class=\"hljs-keyword\">boolean</span> workerStarted = <span class=\"hljs-keyword\">false</span>;\n        <span class=\"hljs-keyword\">boolean</span> workerAdded = <span class=\"hljs-keyword\">false</span>;\n        Worker w = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            w = <span class=\"hljs-keyword\">new</span> Worker(firstTask);\n            <span class=\"hljs-keyword\">final</span> Thread t = w.thread;\n            <span class=\"hljs-keyword\">if</span> (t != <span class=\"hljs-keyword\">null</span>) &#123;\n\t\t<span class=\"hljs-comment\">// 加锁</span>\n                <span class=\"hljs-keyword\">final</span> ReentrantLock mainLock = <span class=\"hljs-keyword\">this</span>.mainLock;\n                mainLock.lock();\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    <span class=\"hljs-comment\">// 获取线程池状态并判断</span>\n                    <span class=\"hljs-keyword\">int</span> rs = runStateOf(ctl.get());\n                    <span class=\"hljs-keyword\">if</span> (rs &lt; SHUTDOWN ||\n                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"hljs-keyword\">null</span>)) &#123;\n                        <span class=\"hljs-keyword\">if</span> (t.isAlive()) <span class=\"hljs-comment\">// precheck that t is startable</span>\n                            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalThreadStateException();\n\t\t\t<span class=\"hljs-comment\">// 添加待执行 HashSet&lt;Worker&gt;</span>\n                        workers.add(w);\n\t\t\t<span class=\"hljs-comment\">// 更新最大线程池数</span>\n                        <span class=\"hljs-keyword\">int</span> s = workers.size();\n                        <span class=\"hljs-keyword\">if</span> (s &gt; largestPoolSize)\n                            largestPoolSize = s;\n                        workerAdded = <span class=\"hljs-keyword\">true</span>;\n                    &#125;\n                &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n\t\t    <span class=\"hljs-comment\">// 解锁</span>\n                    mainLock.unlock();\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (workerAdded) &#123;\n\t\t    <span class=\"hljs-comment\">// 任务添加成功 启动线程</span>\n                    t.start();\n                    workerStarted = <span class=\"hljs-keyword\">true</span>;\n                &#125;\n            &#125;\n        &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n\t    <span class=\"hljs-comment\">// 启动任务失败 移除任务</span>\n            <span class=\"hljs-keyword\">if</span> (! workerStarted)\n                addWorkerFailed(w);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> workerStarted;\n&#125;</code></pre>\n<h5 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h5><table>\n<thead>\n<tr>\n<th>状态</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RUNNING</td>\n<td>运行状态，可处理新任务并执行队列中的任务</td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>关闭状态，不接受新任务但处理队列中的任务</td>\n</tr>\n<tr>\n<td>STOP</td>\n<td>停止状态，不接受新任务不处理队列中任务且中断执行中的任务</td>\n</tr>\n<tr>\n<td>TIDYING</td>\n<td>整理状态，所有任务已结束，workerCount = 0，将执行 terminated() 方法</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>结束状态，terminated() 方法执行完毕</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"线程池参数\"><a href=\"#线程池参数\" class=\"headerlink\" title=\"线程池参数\"></a>线程池参数</h3><h4 id=\"ThreadFactory-线程工厂类\"><a href=\"#ThreadFactory-线程工厂类\" class=\"headerlink\" title=\"ThreadFactory 线程工厂类\"></a>ThreadFactory 线程工厂类</h4><p>通过实现 ThreadFactory 接口可做自定义线程生成工厂，可以自定义设置线程的name、group、优先级等，默认线程工厂创建的线程为非守护线程且有相同的优先级。<br><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultThreadFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ThreadFactory</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> AtomicInteger poolNumber = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ThreadGroup group;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> AtomicInteger threadNumber = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String namePrefix;\n\n    DefaultThreadFactory() &#123;\n        SecurityManager s = System.getSecurityManager();\n        group = (s != <span class=\"hljs-keyword\">null</span>) ? s.getThreadGroup() :\n                              Thread.currentThread().getThreadGroup();\n        namePrefix = <span class=\"hljs-string\">\"pool-\"</span> +\n                      poolNumber.getAndIncrement() +\n                     <span class=\"hljs-string\">\"-thread-\"</span>;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Thread <span class=\"hljs-title\">newThread</span><span class=\"hljs-params\">(Runnable r)</span> </span>&#123;\n        Thread t = <span class=\"hljs-keyword\">new</span> Thread(group, r,\n                              namePrefix + threadNumber.getAndIncrement(),\n                              <span class=\"hljs-number\">0</span>);\n <span class=\"hljs-comment\">// 设置非守护线程</span>\n        <span class=\"hljs-keyword\">if</span> (t.isDaemon())\n            t.setDaemon(<span class=\"hljs-keyword\">false</span>);\n <span class=\"hljs-comment\">// 设置默认优先级</span>\n        <span class=\"hljs-keyword\">if</span> (t.getPriority() != Thread.NORM_PRIORITY)\n            t.setPriority(Thread.NORM_PRIORITY);\n        <span class=\"hljs-keyword\">return</span> t;\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"线程队列\"><a href=\"#线程队列\" class=\"headerlink\" title=\"线程队列\"></a>线程队列</h4><p>线程队列用于存放提交的任务，队列实际的最大容量 = maximumPoolSize+ queueSize，根据业务场景采用不同的线程队列可最大限度的发挥线程池的性能</p>\n<ul>\n<li>SynchronousQueue 无缓冲无容量不存储元素的阻塞等待队列，每次提交任务需要等待消费配对才能进行下一个任务否则一直阻塞</li>\n<li>ArrayBlockingQueue 有界缓存等待队列可以设置队列的容量，当线程池大于 coolPoolSize 则缓存到队列中直到饱和，合理的控制队列大小避免 OOM</li>\n<li>LinkedBlockingQueue 无解缓存等待队列其容量大小为 Interger.Max ，线程池 maximumPoolSize 参数直接无效</li>\n</ul>\n<h4 id=\"拒绝策略\"><a href=\"#拒绝策略\" class=\"headerlink\" title=\"拒绝策略\"></a>拒绝策略</h4><ul>\n<li>当线程池任务线程小于 corePoolSize 时，则会创建核心线程执行任务不会从队列中取空闲线程</li>\n<li>当线程池任务大于 corePoolSize 时，则会从线程队列中取出空闲现场执行任务</li>\n<li>当线程池任务大于 corePoolSize　且线程队列中无空闲现场，则会创建新的线程执行任务直到创建线程数大于　maximumPoolSize，线程池便会执行 RejectedExecutionHandler 拒绝策略</li>\n</ul>\n<h4 id=\"默认策略\"><a href=\"#默认策略\" class=\"headerlink\" title=\"默认策略\"></a>默认策略</h4><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>策略</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AbortPolicy</td>\n<td>线程池满达到上限啧抛出异常</td>\n</tr>\n<tr>\n<td>DiscardOldestPolicy</td>\n<td>线程池满达到上限丢弃最老的一个任务即最先被丢入缓存队列的任务</td>\n</tr>\n<tr>\n<td>DiscardPolicy</td>\n<td>线程池满达到上限直接丢弃任务</td>\n</tr>\n</tbody>\n</table>\n<p>根据业务的需求可以实现 RejectedExecutionHandler 接口自定义拒绝的策略</p>\n"},{"title":"V2Ray 搭建记录","toc":false,"date":"2019-07-17T03:24:48.000Z","_content":"\n> Vultr 上次的一次特殊事件被封了，后来无意间看到了新的云梯 V2Ray 搭建起来更方便简单，搜了下教程重新搭建并记录\n\n## V2Ray 服务安装\n执行官网的一键脚本，执行完毕会自动安装好`unzip`与`deamon`软件，应用程序默认安装在`/usr/bin/v2ray/v2ray`，当有新版本发布只需再执行该脚本即可\n\n``` bash\nbash <(curl -L -s https://install.direct/go.sh)\n```\n\n#### V2Ray 配置文件\n安装完毕可以通过`cat /etc/v2ray/config.json`查看配置文件，可以通过`vi`命令修改保存配置文件达到自定义\n``` json\n{\n  \"inbounds\": [{\n    \"port\": 10067,\n    \"protocol\": \"vmess\",\n    \"settings\": {\n      \"clients\": [\n        {\n          \"id\": \"08e9a92c-8f5d-45ce-8791-44f0d13379e7\",\n          \"level\": 1,\n          \"alterId\": 64\n        }\n      ]\n    }\n  }],\n  \"outbounds\": [{\n    \"protocol\": \"freedom\",\n    \"settings\": {}\n  },{\n    \"protocol\": \"blackhole\",\n    \"settings\": {},\n    \"tag\": \"blocked\"\n  }],\n  \"routing\": {\n    \"rules\": [\n      {\n        \"type\": \"field\",\n        \"ip\": [\"geoip:private\"],\n        \"outboundTag\": \"blocked\"\n      }\n    ]\n  }\n}\n```\n\n- 配置文件中的id、端口、alterId需要和客户端的配置保持一致\n- 服务端使用脚本安装成功之后默认就是`vmess`协议\n\n#### V2Ray 相关脚本\n第一次安装完毕`V2Ray`不会自行启动需要通过以下脚本启动、停止、查看状态\n``` bash\n## 启动\nsystemctl start v2ray\n## 停止\nsystemctl stop v2ray\n## 状态\nsystemctl status v2ray\n```\n由于防火墙原因会导致启用了服务但是无法连接问题，需要把服务相关端口加入防火墙白名单\n``` bash\n## 查看开启的端口\nfirewall-cmd --zone=public --list-ports\n\n## 加入新端口 100067 80 端口\nfirewall-cmd --zone=public --add-port=80/tcp --permanent\nfirewall-cmd --zone=public --add-port=10067/tcp --permanent\nfirewall-cmd --reload\n```\n\n## V2RayN 客户端\n下载 [V2Ray-Core](https://github.com/v2ray/v2ray-core/releases) 解压点击`v2rayN.exe`应用添加`Vmess`服务器\n![](/images/vmess-windows-client.jpg)\n\n填写完毕启用`Http`代理修改代理模式为`PAC`模式，然后就可以愉快的在上google，手机端可以使用[v2rayNG](https://github.com/2dust/v2rayNG/releases)\n\n## BBR 加速\n搭建好了`V2Ray`你感觉速度不够快连接效果不够好，我们可以通过脚本开启`BBR`\n``` bash\n#安装wget，digitalocean默认没有安装wget，安装一下\nyum -y install wget\n\n#执行BBR PLUS修正版一键脚本\nwget -N --no-check-certificate \"https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh\" && chmod +x tcp.sh && ./tcp.sh\n```\n根据自身情况安装内核重启系统后安装`BBR加速`","source":"_posts/V2Ray搭建记录.md","raw":"---\ntitle: V2Ray 搭建记录\ntags:\n  - 心得\ncategories:\n  - 技术\ntoc: false\ndate: 2019-07-17 11:24:48\n---\n\n> Vultr 上次的一次特殊事件被封了，后来无意间看到了新的云梯 V2Ray 搭建起来更方便简单，搜了下教程重新搭建并记录\n\n## V2Ray 服务安装\n执行官网的一键脚本，执行完毕会自动安装好`unzip`与`deamon`软件，应用程序默认安装在`/usr/bin/v2ray/v2ray`，当有新版本发布只需再执行该脚本即可\n\n``` bash\nbash <(curl -L -s https://install.direct/go.sh)\n```\n\n#### V2Ray 配置文件\n安装完毕可以通过`cat /etc/v2ray/config.json`查看配置文件，可以通过`vi`命令修改保存配置文件达到自定义\n``` json\n{\n  \"inbounds\": [{\n    \"port\": 10067,\n    \"protocol\": \"vmess\",\n    \"settings\": {\n      \"clients\": [\n        {\n          \"id\": \"08e9a92c-8f5d-45ce-8791-44f0d13379e7\",\n          \"level\": 1,\n          \"alterId\": 64\n        }\n      ]\n    }\n  }],\n  \"outbounds\": [{\n    \"protocol\": \"freedom\",\n    \"settings\": {}\n  },{\n    \"protocol\": \"blackhole\",\n    \"settings\": {},\n    \"tag\": \"blocked\"\n  }],\n  \"routing\": {\n    \"rules\": [\n      {\n        \"type\": \"field\",\n        \"ip\": [\"geoip:private\"],\n        \"outboundTag\": \"blocked\"\n      }\n    ]\n  }\n}\n```\n\n- 配置文件中的id、端口、alterId需要和客户端的配置保持一致\n- 服务端使用脚本安装成功之后默认就是`vmess`协议\n\n#### V2Ray 相关脚本\n第一次安装完毕`V2Ray`不会自行启动需要通过以下脚本启动、停止、查看状态\n``` bash\n## 启动\nsystemctl start v2ray\n## 停止\nsystemctl stop v2ray\n## 状态\nsystemctl status v2ray\n```\n由于防火墙原因会导致启用了服务但是无法连接问题，需要把服务相关端口加入防火墙白名单\n``` bash\n## 查看开启的端口\nfirewall-cmd --zone=public --list-ports\n\n## 加入新端口 100067 80 端口\nfirewall-cmd --zone=public --add-port=80/tcp --permanent\nfirewall-cmd --zone=public --add-port=10067/tcp --permanent\nfirewall-cmd --reload\n```\n\n## V2RayN 客户端\n下载 [V2Ray-Core](https://github.com/v2ray/v2ray-core/releases) 解压点击`v2rayN.exe`应用添加`Vmess`服务器\n![](/images/vmess-windows-client.jpg)\n\n填写完毕启用`Http`代理修改代理模式为`PAC`模式，然后就可以愉快的在上google，手机端可以使用[v2rayNG](https://github.com/2dust/v2rayNG/releases)\n\n## BBR 加速\n搭建好了`V2Ray`你感觉速度不够快连接效果不够好，我们可以通过脚本开启`BBR`\n``` bash\n#安装wget，digitalocean默认没有安装wget，安装一下\nyum -y install wget\n\n#执行BBR PLUS修正版一键脚本\nwget -N --no-check-certificate \"https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh\" && chmod +x tcp.sh && ./tcp.sh\n```\n根据自身情况安装内核重启系统后安装`BBR加速`","slug":"V2Ray搭建记录","published":1,"updated":"2020-08-10T01:48:44.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc99x0046jsudprdgl95g","content":"<blockquote>\n<p>Vultr 上次的一次特殊事件被封了，后来无意间看到了新的云梯 V2Ray 搭建起来更方便简单，搜了下教程重新搭建并记录</p>\n</blockquote>\n<h2 id=\"V2Ray-服务安装\"><a href=\"#V2Ray-服务安装\" class=\"headerlink\" title=\"V2Ray 服务安装\"></a>V2Ray 服务安装</h2><p>执行官网的一键脚本，执行完毕会自动安装好<code>unzip</code>与<code>deamon</code>软件，应用程序默认安装在<code>/usr/bin/v2ray/v2ray</code>，当有新版本发布只需再执行该脚本即可</p>\n<pre><code class=\"hljs bash\">bash &lt;(curl -L -s https://install.direct/go.sh)</code></pre>\n<h4 id=\"V2Ray-配置文件\"><a href=\"#V2Ray-配置文件\" class=\"headerlink\" title=\"V2Ray 配置文件\"></a>V2Ray 配置文件</h4><p>安装完毕可以通过<code>cat /etc/v2ray/config.json</code>查看配置文件，可以通过<code>vi</code>命令修改保存配置文件达到自定义<br><pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">\"inbounds\"</span>: [&#123;\n    <span class=\"hljs-attr\">\"port\"</span>: <span class=\"hljs-number\">10067</span>,\n    <span class=\"hljs-attr\">\"protocol\"</span>: <span class=\"hljs-string\">\"vmess\"</span>,\n    <span class=\"hljs-attr\">\"settings\"</span>: &#123;\n      <span class=\"hljs-attr\">\"clients\"</span>: [\n        &#123;\n          <span class=\"hljs-attr\">\"id\"</span>: <span class=\"hljs-string\">\"08e9a92c-8f5d-45ce-8791-44f0d13379e7\"</span>,\n          <span class=\"hljs-attr\">\"level\"</span>: <span class=\"hljs-number\">1</span>,\n          <span class=\"hljs-attr\">\"alterId\"</span>: <span class=\"hljs-number\">64</span>\n        &#125;\n      ]\n    &#125;\n  &#125;],\n  <span class=\"hljs-attr\">\"outbounds\"</span>: [&#123;\n    <span class=\"hljs-attr\">\"protocol\"</span>: <span class=\"hljs-string\">\"freedom\"</span>,\n    <span class=\"hljs-attr\">\"settings\"</span>: &#123;&#125;\n  &#125;,&#123;\n    <span class=\"hljs-attr\">\"protocol\"</span>: <span class=\"hljs-string\">\"blackhole\"</span>,\n    <span class=\"hljs-attr\">\"settings\"</span>: &#123;&#125;,\n    <span class=\"hljs-attr\">\"tag\"</span>: <span class=\"hljs-string\">\"blocked\"</span>\n  &#125;],\n  <span class=\"hljs-attr\">\"routing\"</span>: &#123;\n    <span class=\"hljs-attr\">\"rules\"</span>: [\n      &#123;\n        <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"field\"</span>,\n        <span class=\"hljs-attr\">\"ip\"</span>: [<span class=\"hljs-string\">\"geoip:private\"</span>],\n        <span class=\"hljs-attr\">\"outboundTag\"</span>: <span class=\"hljs-string\">\"blocked\"</span>\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre></p>\n<ul>\n<li>配置文件中的id、端口、alterId需要和客户端的配置保持一致</li>\n<li>服务端使用脚本安装成功之后默认就是<code>vmess</code>协议</li>\n</ul>\n<h4 id=\"V2Ray-相关脚本\"><a href=\"#V2Ray-相关脚本\" class=\"headerlink\" title=\"V2Ray 相关脚本\"></a>V2Ray 相关脚本</h4><p>第一次安装完毕<code>V2Ray</code>不会自行启动需要通过以下脚本启动、停止、查看状态<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">## 启动</span>\nsystemctl start v2ray\n<span class=\"hljs-comment\">## 停止</span>\nsystemctl stop v2ray\n<span class=\"hljs-comment\">## 状态</span>\nsystemctl status v2ray</code></pre></p>\n<p>由于防火墙原因会导致启用了服务但是无法连接问题，需要把服务相关端口加入防火墙白名单<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">## 查看开启的端口</span>\nfirewall-cmd --zone=public --list-ports\n\n<span class=\"hljs-comment\">## 加入新端口 100067 80 端口</span>\nfirewall-cmd --zone=public --add-port=80/tcp --permanent\nfirewall-cmd --zone=public --add-port=10067/tcp --permanent\nfirewall-cmd --reload</code></pre></p>\n<h2 id=\"V2RayN-客户端\"><a href=\"#V2RayN-客户端\" class=\"headerlink\" title=\"V2RayN 客户端\"></a>V2RayN 客户端</h2><p>下载 <a href=\"https://github.com/v2ray/v2ray-core/releases\" target=\"_blank\" rel=\"noopener\">V2Ray-Core</a> 解压点击<code>v2rayN.exe</code>应用添加<code>Vmess</code>服务器<br><img src=\"/images/vmess-windows-client.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>填写完毕启用<code>Http</code>代理修改代理模式为<code>PAC</code>模式，然后就可以愉快的在上google，手机端可以使用<a href=\"https://github.com/2dust/v2rayNG/releases\" target=\"_blank\" rel=\"noopener\">v2rayNG</a></p>\n<h2 id=\"BBR-加速\"><a href=\"#BBR-加速\" class=\"headerlink\" title=\"BBR 加速\"></a>BBR 加速</h2><p>搭建好了<code>V2Ray</code>你感觉速度不够快连接效果不够好，我们可以通过脚本开启<code>BBR</code><br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#安装wget，digitalocean默认没有安装wget，安装一下</span>\nyum -y install wget\n\n<span class=\"hljs-comment\">#执行BBR PLUS修正版一键脚本</span>\nwget -N --no-check-certificate <span class=\"hljs-string\">\"https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh\"</span> &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</code></pre></p>\n<p>根据自身情况安装内核重启系统后安装<code>BBR加速</code></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Vultr 上次的一次特殊事件被封了，后来无意间看到了新的云梯 V2Ray 搭建起来更方便简单，搜了下教程重新搭建并记录</p>\n</blockquote>\n<h2 id=\"V2Ray-服务安装\"><a href=\"#V2Ray-服务安装\" class=\"headerlink\" title=\"V2Ray 服务安装\"></a>V2Ray 服务安装</h2><p>执行官网的一键脚本，执行完毕会自动安装好<code>unzip</code>与<code>deamon</code>软件，应用程序默认安装在<code>/usr/bin/v2ray/v2ray</code>，当有新版本发布只需再执行该脚本即可</p>\n<pre><code class=\"hljs bash\">bash &lt;(curl -L -s https://install.direct/go.sh)</code></pre>\n<h4 id=\"V2Ray-配置文件\"><a href=\"#V2Ray-配置文件\" class=\"headerlink\" title=\"V2Ray 配置文件\"></a>V2Ray 配置文件</h4><p>安装完毕可以通过<code>cat /etc/v2ray/config.json</code>查看配置文件，可以通过<code>vi</code>命令修改保存配置文件达到自定义<br><pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">\"inbounds\"</span>: [&#123;\n    <span class=\"hljs-attr\">\"port\"</span>: <span class=\"hljs-number\">10067</span>,\n    <span class=\"hljs-attr\">\"protocol\"</span>: <span class=\"hljs-string\">\"vmess\"</span>,\n    <span class=\"hljs-attr\">\"settings\"</span>: &#123;\n      <span class=\"hljs-attr\">\"clients\"</span>: [\n        &#123;\n          <span class=\"hljs-attr\">\"id\"</span>: <span class=\"hljs-string\">\"08e9a92c-8f5d-45ce-8791-44f0d13379e7\"</span>,\n          <span class=\"hljs-attr\">\"level\"</span>: <span class=\"hljs-number\">1</span>,\n          <span class=\"hljs-attr\">\"alterId\"</span>: <span class=\"hljs-number\">64</span>\n        &#125;\n      ]\n    &#125;\n  &#125;],\n  <span class=\"hljs-attr\">\"outbounds\"</span>: [&#123;\n    <span class=\"hljs-attr\">\"protocol\"</span>: <span class=\"hljs-string\">\"freedom\"</span>,\n    <span class=\"hljs-attr\">\"settings\"</span>: &#123;&#125;\n  &#125;,&#123;\n    <span class=\"hljs-attr\">\"protocol\"</span>: <span class=\"hljs-string\">\"blackhole\"</span>,\n    <span class=\"hljs-attr\">\"settings\"</span>: &#123;&#125;,\n    <span class=\"hljs-attr\">\"tag\"</span>: <span class=\"hljs-string\">\"blocked\"</span>\n  &#125;],\n  <span class=\"hljs-attr\">\"routing\"</span>: &#123;\n    <span class=\"hljs-attr\">\"rules\"</span>: [\n      &#123;\n        <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"field\"</span>,\n        <span class=\"hljs-attr\">\"ip\"</span>: [<span class=\"hljs-string\">\"geoip:private\"</span>],\n        <span class=\"hljs-attr\">\"outboundTag\"</span>: <span class=\"hljs-string\">\"blocked\"</span>\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre></p>\n<ul>\n<li>配置文件中的id、端口、alterId需要和客户端的配置保持一致</li>\n<li>服务端使用脚本安装成功之后默认就是<code>vmess</code>协议</li>\n</ul>\n<h4 id=\"V2Ray-相关脚本\"><a href=\"#V2Ray-相关脚本\" class=\"headerlink\" title=\"V2Ray 相关脚本\"></a>V2Ray 相关脚本</h4><p>第一次安装完毕<code>V2Ray</code>不会自行启动需要通过以下脚本启动、停止、查看状态<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">## 启动</span>\nsystemctl start v2ray\n<span class=\"hljs-comment\">## 停止</span>\nsystemctl stop v2ray\n<span class=\"hljs-comment\">## 状态</span>\nsystemctl status v2ray</code></pre></p>\n<p>由于防火墙原因会导致启用了服务但是无法连接问题，需要把服务相关端口加入防火墙白名单<br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">## 查看开启的端口</span>\nfirewall-cmd --zone=public --list-ports\n\n<span class=\"hljs-comment\">## 加入新端口 100067 80 端口</span>\nfirewall-cmd --zone=public --add-port=80/tcp --permanent\nfirewall-cmd --zone=public --add-port=10067/tcp --permanent\nfirewall-cmd --reload</code></pre></p>\n<h2 id=\"V2RayN-客户端\"><a href=\"#V2RayN-客户端\" class=\"headerlink\" title=\"V2RayN 客户端\"></a>V2RayN 客户端</h2><p>下载 <a href=\"https://github.com/v2ray/v2ray-core/releases\" target=\"_blank\" rel=\"noopener\">V2Ray-Core</a> 解压点击<code>v2rayN.exe</code>应用添加<code>Vmess</code>服务器<br><img src=\"/images/vmess-windows-client.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<p>填写完毕启用<code>Http</code>代理修改代理模式为<code>PAC</code>模式，然后就可以愉快的在上google，手机端可以使用<a href=\"https://github.com/2dust/v2rayNG/releases\" target=\"_blank\" rel=\"noopener\">v2rayNG</a></p>\n<h2 id=\"BBR-加速\"><a href=\"#BBR-加速\" class=\"headerlink\" title=\"BBR 加速\"></a>BBR 加速</h2><p>搭建好了<code>V2Ray</code>你感觉速度不够快连接效果不够好，我们可以通过脚本开启<code>BBR</code><br><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#安装wget，digitalocean默认没有安装wget，安装一下</span>\nyum -y install wget\n\n<span class=\"hljs-comment\">#执行BBR PLUS修正版一键脚本</span>\nwget -N --no-check-certificate <span class=\"hljs-string\">\"https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh\"</span> &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</code></pre></p>\n<p>根据自身情况安装内核重启系统后安装<code>BBR加速</code></p>\n"},{"layout":"post","title":"Vue 复杂的 table 表单代码块","date":"2019-07-17T02:51:26.000Z","comments":1,"_content":"\n![](/images/vue.jpg)\n\n> 记录项目中遇到的Element UI 中遇到的各种情况 代码块\n\n## Vue Form Table 双向绑定\n `form` 和 `table`配合使用其中`refundPsgList`循环出来的元素在数据双向绑定上`prop`的值需要特殊改造，使用`scope.$index`来进行绑定，一般情况下`prop`和对应的`v-model`保持一致\n``` js\n<el-form :model=\"refundCashDetail\" ref=\"refundCashDetail\">\n  <el-table\n    :data=\"refundCashDetail.refundPsgList\"\n    size=\"mini\"\n    border\n    style=\"width: 100%\">\n    <el-table-column width=\"60\" label=\"序号\" align=\"center\">\n      <template slot-scope=\"scope\">\n        {{ scope.$index + 1 }}\n      </template>\n    </el-table-column>\n    <el-table-column prop=\"name\" label=\"姓名\" align=\"center\"></el-table-column>\n    <el-table-column label=\"实际退定金\" align=\"center\">\n      <template slot-scope=\"scope\">\n        <el-form-item\n          :prop=\"'refundPsgList.'+ scope.$index +'.practicalCash'\"\n          :inline-message=\"true\"\n          :rules=\"[{ type: 'number',required:true,message:'金额不能为空',trigger: 'blur'}]\">\n          <el-input-number\n                   :placeholder=\"scope.row.oneDeposit+'/每人'\"\n                   v-model.number=\"scope.row.practicalCash\"\n                   :max=\"refundCashDetail.orderDetail.oneDeposit\"\n                   autocomplete=\"off\"\n                   :min=\"0\"/>\n        </el-form-item>\n      </template>\n    </el-table-column>\n  </el-table>\n</el-form>\n```\n\n","source":"_posts/Vue复杂的table表单代码块.md","raw":"---\nlayout: post\ntitle: Vue 复杂的 table 表单代码块\ndate: 2019-07-17 10:51:26\ncategories: [Java]\ncomments: true\ntags:\n\t- Java\n\t- 技术\n---\n\n![](/images/vue.jpg)\n\n> 记录项目中遇到的Element UI 中遇到的各种情况 代码块\n\n## Vue Form Table 双向绑定\n `form` 和 `table`配合使用其中`refundPsgList`循环出来的元素在数据双向绑定上`prop`的值需要特殊改造，使用`scope.$index`来进行绑定，一般情况下`prop`和对应的`v-model`保持一致\n``` js\n<el-form :model=\"refundCashDetail\" ref=\"refundCashDetail\">\n  <el-table\n    :data=\"refundCashDetail.refundPsgList\"\n    size=\"mini\"\n    border\n    style=\"width: 100%\">\n    <el-table-column width=\"60\" label=\"序号\" align=\"center\">\n      <template slot-scope=\"scope\">\n        {{ scope.$index + 1 }}\n      </template>\n    </el-table-column>\n    <el-table-column prop=\"name\" label=\"姓名\" align=\"center\"></el-table-column>\n    <el-table-column label=\"实际退定金\" align=\"center\">\n      <template slot-scope=\"scope\">\n        <el-form-item\n          :prop=\"'refundPsgList.'+ scope.$index +'.practicalCash'\"\n          :inline-message=\"true\"\n          :rules=\"[{ type: 'number',required:true,message:'金额不能为空',trigger: 'blur'}]\">\n          <el-input-number\n                   :placeholder=\"scope.row.oneDeposit+'/每人'\"\n                   v-model.number=\"scope.row.practicalCash\"\n                   :max=\"refundCashDetail.orderDetail.oneDeposit\"\n                   autocomplete=\"off\"\n                   :min=\"0\"/>\n        </el-form-item>\n      </template>\n    </el-table-column>\n  </el-table>\n</el-form>\n```\n\n","slug":"Vue复杂的table表单代码块","published":1,"updated":"2020-08-10T01:48:44.752Z","photos":[],"link":"","_id":"ckhmyc9a1004djsudr8dbpo0s","content":"<p><img src=\"/images/vue.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录项目中遇到的Element UI 中遇到的各种情况 代码块</p>\n</blockquote>\n<h2 id=\"Vue-Form-Table-双向绑定\"><a href=\"#Vue-Form-Table-双向绑定\" class=\"headerlink\" title=\"Vue Form Table 双向绑定\"></a>Vue Form Table 双向绑定</h2><p> <code>form</code> 和 <code>table</code>配合使用其中<code>refundPsgList</code>循环出来的元素在数据双向绑定上<code>prop</code>的值需要特殊改造，使用<code>scope.$index</code>来进行绑定，一般情况下<code>prop</code>和对应的<code>v-model</code>保持一致<br><pre><code class=\"hljs js\">&lt;el-form :model=<span class=\"hljs-string\">\"refundCashDetail\"</span> ref=<span class=\"hljs-string\">\"refundCashDetail\"</span>&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-table</span>\n    <span class=\"hljs-attr\">:data</span>=<span class=\"hljs-string\">\"refundCashDetail.refundPsgList\"</span>\n    <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"mini\"</span>\n    <span class=\"hljs-attr\">border</span>\n    <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"width: 100%\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-table-column</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"60\"</span> <span class=\"hljs-attr\">label</span>=<span class=\"hljs-string\">\"序号\"</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">\"center\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"scope\"</span>&gt;</span>\n        &#123;&#123; scope.$index + 1 &#125;&#125;\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-table-column</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-table-column</span> <span class=\"hljs-attr\">prop</span>=<span class=\"hljs-string\">\"name\"</span> <span class=\"hljs-attr\">label</span>=<span class=\"hljs-string\">\"姓名\"</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">\"center\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-table-column</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-table-column</span> <span class=\"hljs-attr\">label</span>=<span class=\"hljs-string\">\"实际退定金\"</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">\"center\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"scope\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-form-item</span>\n          <span class=\"hljs-attr\">:prop</span>=<span class=\"hljs-string\">\"'refundPsgList.'+ scope.$index +'.practicalCash'\"</span>\n          <span class=\"hljs-attr\">:inline-message</span>=<span class=\"hljs-string\">\"true\"</span>\n          <span class=\"hljs-attr\">:rules</span>=<span class=\"hljs-string\">\"[&#123; type: 'number',required:true,message:'金额不能为空',trigger: 'blur'&#125;]\"</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-input-number</span>\n                   <span class=\"hljs-attr\">:placeholder</span>=<span class=\"hljs-string\">\"scope.row.oneDeposit+'/每人'\"</span>\n                   <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"scope.row.practicalCash\"</span>\n                   <span class=\"hljs-attr\">:max</span>=<span class=\"hljs-string\">\"refundCashDetail.orderDetail.oneDeposit\"</span>\n                   <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">\"off\"</span>\n                   <span class=\"hljs-attr\">:min</span>=<span class=\"hljs-string\">\"0\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-form-item</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-table-column</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-table</span>&gt;</span></span>\n&lt;<span class=\"hljs-regexp\">/el-form&gt;</span></code></pre></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/vue.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>记录项目中遇到的Element UI 中遇到的各种情况 代码块</p>\n</blockquote>\n<h2 id=\"Vue-Form-Table-双向绑定\"><a href=\"#Vue-Form-Table-双向绑定\" class=\"headerlink\" title=\"Vue Form Table 双向绑定\"></a>Vue Form Table 双向绑定</h2><p> <code>form</code> 和 <code>table</code>配合使用其中<code>refundPsgList</code>循环出来的元素在数据双向绑定上<code>prop</code>的值需要特殊改造，使用<code>scope.$index</code>来进行绑定，一般情况下<code>prop</code>和对应的<code>v-model</code>保持一致<br><pre><code class=\"hljs js\">&lt;el-form :model=<span class=\"hljs-string\">\"refundCashDetail\"</span> ref=<span class=\"hljs-string\">\"refundCashDetail\"</span>&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-table</span>\n    <span class=\"hljs-attr\">:data</span>=<span class=\"hljs-string\">\"refundCashDetail.refundPsgList\"</span>\n    <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"mini\"</span>\n    <span class=\"hljs-attr\">border</span>\n    <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"width: 100%\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-table-column</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"60\"</span> <span class=\"hljs-attr\">label</span>=<span class=\"hljs-string\">\"序号\"</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">\"center\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"scope\"</span>&gt;</span>\n        &#123;&#123; scope.$index + 1 &#125;&#125;\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-table-column</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-table-column</span> <span class=\"hljs-attr\">prop</span>=<span class=\"hljs-string\">\"name\"</span> <span class=\"hljs-attr\">label</span>=<span class=\"hljs-string\">\"姓名\"</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">\"center\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-table-column</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-table-column</span> <span class=\"hljs-attr\">label</span>=<span class=\"hljs-string\">\"实际退定金\"</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">\"center\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"scope\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-form-item</span>\n          <span class=\"hljs-attr\">:prop</span>=<span class=\"hljs-string\">\"'refundPsgList.'+ scope.$index +'.practicalCash'\"</span>\n          <span class=\"hljs-attr\">:inline-message</span>=<span class=\"hljs-string\">\"true\"</span>\n          <span class=\"hljs-attr\">:rules</span>=<span class=\"hljs-string\">\"[&#123; type: 'number',required:true,message:'金额不能为空',trigger: 'blur'&#125;]\"</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-input-number</span>\n                   <span class=\"hljs-attr\">:placeholder</span>=<span class=\"hljs-string\">\"scope.row.oneDeposit+'/每人'\"</span>\n                   <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"scope.row.practicalCash\"</span>\n                   <span class=\"hljs-attr\">:max</span>=<span class=\"hljs-string\">\"refundCashDetail.orderDetail.oneDeposit\"</span>\n                   <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">\"off\"</span>\n                   <span class=\"hljs-attr\">:min</span>=<span class=\"hljs-string\">\"0\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-form-item</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-table-column</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-table</span>&gt;</span></span>\n&lt;<span class=\"hljs-regexp\">/el-form&gt;</span></code></pre></p>\n"},{"title":"Winsw 把 java 项目做成服务","date":"2018-08-16T12:04:17.000Z","_content":"\n>jar项目需要通过命令行jar -jar 执行脚本启动显示控制台，由于强迫症可以使用javaw -jar来执行可以在后台执行，但通过java编译启动在window环境下进程名都为java.exe一旦项目多了当你要更新部署更新关闭项目时候就懵逼了有可能就会误操作，通过Google发现有个开源的软件\nwinsw 可以把任何软件做为window 的服务来管理，这样在services.msc 服务管理里可以很方便的进行管理更新部署。\n\n## 1.Winsw 环境\nWinsw是个开源项目，Github地址为:https://github.com/kohsuke/winsw 依赖环境为NET2 或 NET4， 可通过配置文件进行修改。\n\n## 2.JAVA 项目注册服务\n根据作者的介绍注册的服务依赖于配置文件 *.xml，这里需要注意的是xml的文件名称必须和winsw.exe同名。默认是按软件的名称来匹配配置文件。例如你把winsw.exe重复名为test.exe那配置文件必须为test.xml不然不无法使用。\n``` xml\n<service>\n  <id>MyTest</id>\n  <name>MyTest</name>\n  <description>测试jar项目服务</description>\n  <env name=\"JENKINS_HOME\" value=\"%BASE%\"/>\n  <executable>java</executable>\n  <arguments>-Xrs -Xmx256m -jar \"%BASE%\\test.jar\" --httpPort=8080</arguments>\n  <logmode>rotate</logmode>\n</service>\n```\n配置文件解释:\n- id：服务名称 (唯一)\n- name：显示服务名称\n- description：服务描述\n- env：环境变量 JENKINS_HOME 赋值给 %BASE%\n- executable：执行命令 这里我们是用java启动\n- arguments：执行的一些参数\n- logmode：日志模式\n这里 executable arguments 就相当于你在控制台执行的脚本，根据你的需求进行改变命令和参数。\n通过控制台进入winsw软件目录执行`` winsw.exe install`` 注册服务， winsw为软件名称可以自行修改。执行成功可以在控制看到\n![注册成功](/images/winsw.png)\n\n如果发现错误请查看 `[软件名称].wrapper.log` 日志排查，是否配置文件名和软件名不一致或者配置的地址不存在等。然后你可以通过 services.msc 对你的服务进行操作了启动，停止。注册的服务默认是AutoStart每次重启电脑都会自动启动。\n\n配置文件的相关其他设置可以参考: https://github.com/kohsuke/winsw/blob/master/doc/xmlConfigFile.md\n","source":"_posts/Winsw把java项目做成服务.md","raw":"---\ntitle: Winsw 把 java 项目做成服务\ndate: 2018-08-16 20:04:17\ncategories: [技术]\ntags: \n\t- Java\n---\n\n>jar项目需要通过命令行jar -jar 执行脚本启动显示控制台，由于强迫症可以使用javaw -jar来执行可以在后台执行，但通过java编译启动在window环境下进程名都为java.exe一旦项目多了当你要更新部署更新关闭项目时候就懵逼了有可能就会误操作，通过Google发现有个开源的软件\nwinsw 可以把任何软件做为window 的服务来管理，这样在services.msc 服务管理里可以很方便的进行管理更新部署。\n\n## 1.Winsw 环境\nWinsw是个开源项目，Github地址为:https://github.com/kohsuke/winsw 依赖环境为NET2 或 NET4， 可通过配置文件进行修改。\n\n## 2.JAVA 项目注册服务\n根据作者的介绍注册的服务依赖于配置文件 *.xml，这里需要注意的是xml的文件名称必须和winsw.exe同名。默认是按软件的名称来匹配配置文件。例如你把winsw.exe重复名为test.exe那配置文件必须为test.xml不然不无法使用。\n``` xml\n<service>\n  <id>MyTest</id>\n  <name>MyTest</name>\n  <description>测试jar项目服务</description>\n  <env name=\"JENKINS_HOME\" value=\"%BASE%\"/>\n  <executable>java</executable>\n  <arguments>-Xrs -Xmx256m -jar \"%BASE%\\test.jar\" --httpPort=8080</arguments>\n  <logmode>rotate</logmode>\n</service>\n```\n配置文件解释:\n- id：服务名称 (唯一)\n- name：显示服务名称\n- description：服务描述\n- env：环境变量 JENKINS_HOME 赋值给 %BASE%\n- executable：执行命令 这里我们是用java启动\n- arguments：执行的一些参数\n- logmode：日志模式\n这里 executable arguments 就相当于你在控制台执行的脚本，根据你的需求进行改变命令和参数。\n通过控制台进入winsw软件目录执行`` winsw.exe install`` 注册服务， winsw为软件名称可以自行修改。执行成功可以在控制看到\n![注册成功](/images/winsw.png)\n\n如果发现错误请查看 `[软件名称].wrapper.log` 日志排查，是否配置文件名和软件名不一致或者配置的地址不存在等。然后你可以通过 services.msc 对你的服务进行操作了启动，停止。注册的服务默认是AutoStart每次重启电脑都会自动启动。\n\n配置文件的相关其他设置可以参考: https://github.com/kohsuke/winsw/blob/master/doc/xmlConfigFile.md\n","slug":"Winsw把java项目做成服务","published":1,"updated":"2020-08-10T01:48:44.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9a3004hjsud5ectkqaq","content":"<blockquote>\n<p>jar项目需要通过命令行jar -jar 执行脚本启动显示控制台，由于强迫症可以使用javaw -jar来执行可以在后台执行，但通过java编译启动在window环境下进程名都为java.exe一旦项目多了当你要更新部署更新关闭项目时候就懵逼了有可能就会误操作，通过Google发现有个开源的软件<br>winsw 可以把任何软件做为window 的服务来管理，这样在services.msc 服务管理里可以很方便的进行管理更新部署。</p>\n</blockquote>\n<h2 id=\"1-Winsw-环境\"><a href=\"#1-Winsw-环境\" class=\"headerlink\" title=\"1.Winsw 环境\"></a>1.Winsw 环境</h2><p>Winsw是个开源项目，Github地址为:<a href=\"https://github.com/kohsuke/winsw\" target=\"_blank\" rel=\"noopener\">https://github.com/kohsuke/winsw</a> 依赖环境为NET2 或 NET4， 可通过配置文件进行修改。</p>\n<h2 id=\"2-JAVA-项目注册服务\"><a href=\"#2-JAVA-项目注册服务\" class=\"headerlink\" title=\"2.JAVA 项目注册服务\"></a>2.JAVA 项目注册服务</h2><p>根据作者的介绍注册的服务依赖于配置文件 *.xml，这里需要注意的是xml的文件名称必须和winsw.exe同名。默认是按软件的名称来匹配配置文件。例如你把winsw.exe重复名为test.exe那配置文件必须为test.xml不然不无法使用。<br><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">service</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>MyTest<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>MyTest<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">description</span>&gt;</span>测试jar项目服务<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">description</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">env</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"JENKINS_HOME\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"%BASE%\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">executable</span>&gt;</span>java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">executable</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">arguments</span>&gt;</span>-Xrs -Xmx256m -jar \"%BASE%\\test.jar\" --httpPort=8080<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">arguments</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">logmode</span>&gt;</span>rotate<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">logmode</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">service</span>&gt;</span></code></pre></p>\n<p>配置文件解释:</p>\n<ul>\n<li>id：服务名称 (唯一)</li>\n<li>name：显示服务名称</li>\n<li>description：服务描述</li>\n<li>env：环境变量 JENKINS_HOME 赋值给 %BASE%</li>\n<li>executable：执行命令 这里我们是用java启动</li>\n<li>arguments：执行的一些参数</li>\n<li>logmode：日志模式<br>这里 executable arguments 就相当于你在控制台执行的脚本，根据你的需求进行改变命令和参数。<br>通过控制台进入winsw软件目录执行<code>winsw.exe install</code> 注册服务， winsw为软件名称可以自行修改。执行成功可以在控制看到<br><img src=\"/images/winsw.png\" srcset=\"/img/loading.gif\" alt=\"注册成功\"></li>\n</ul>\n<p>如果发现错误请查看 <code>[软件名称].wrapper.log</code> 日志排查，是否配置文件名和软件名不一致或者配置的地址不存在等。然后你可以通过 services.msc 对你的服务进行操作了启动，停止。注册的服务默认是AutoStart每次重启电脑都会自动启动。</p>\n<p>配置文件的相关其他设置可以参考: <a href=\"https://github.com/kohsuke/winsw/blob/master/doc/xmlConfigFile.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kohsuke/winsw/blob/master/doc/xmlConfigFile.md</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>jar项目需要通过命令行jar -jar 执行脚本启动显示控制台，由于强迫症可以使用javaw -jar来执行可以在后台执行，但通过java编译启动在window环境下进程名都为java.exe一旦项目多了当你要更新部署更新关闭项目时候就懵逼了有可能就会误操作，通过Google发现有个开源的软件<br>winsw 可以把任何软件做为window 的服务来管理，这样在services.msc 服务管理里可以很方便的进行管理更新部署。</p>\n</blockquote>\n<h2 id=\"1-Winsw-环境\"><a href=\"#1-Winsw-环境\" class=\"headerlink\" title=\"1.Winsw 环境\"></a>1.Winsw 环境</h2><p>Winsw是个开源项目，Github地址为:<a href=\"https://github.com/kohsuke/winsw\" target=\"_blank\" rel=\"noopener\">https://github.com/kohsuke/winsw</a> 依赖环境为NET2 或 NET4， 可通过配置文件进行修改。</p>\n<h2 id=\"2-JAVA-项目注册服务\"><a href=\"#2-JAVA-项目注册服务\" class=\"headerlink\" title=\"2.JAVA 项目注册服务\"></a>2.JAVA 项目注册服务</h2><p>根据作者的介绍注册的服务依赖于配置文件 *.xml，这里需要注意的是xml的文件名称必须和winsw.exe同名。默认是按软件的名称来匹配配置文件。例如你把winsw.exe重复名为test.exe那配置文件必须为test.xml不然不无法使用。<br><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">service</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>MyTest<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>MyTest<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">description</span>&gt;</span>测试jar项目服务<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">description</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">env</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"JENKINS_HOME\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"%BASE%\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">executable</span>&gt;</span>java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">executable</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">arguments</span>&gt;</span>-Xrs -Xmx256m -jar \"%BASE%\\test.jar\" --httpPort=8080<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">arguments</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">logmode</span>&gt;</span>rotate<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">logmode</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">service</span>&gt;</span></code></pre></p>\n<p>配置文件解释:</p>\n<ul>\n<li>id：服务名称 (唯一)</li>\n<li>name：显示服务名称</li>\n<li>description：服务描述</li>\n<li>env：环境变量 JENKINS_HOME 赋值给 %BASE%</li>\n<li>executable：执行命令 这里我们是用java启动</li>\n<li>arguments：执行的一些参数</li>\n<li>logmode：日志模式<br>这里 executable arguments 就相当于你在控制台执行的脚本，根据你的需求进行改变命令和参数。<br>通过控制台进入winsw软件目录执行<code>winsw.exe install</code> 注册服务， winsw为软件名称可以自行修改。执行成功可以在控制看到<br><img src=\"/images/winsw.png\" srcset=\"/img/loading.gif\" alt=\"注册成功\"></li>\n</ul>\n<p>如果发现错误请查看 <code>[软件名称].wrapper.log</code> 日志排查，是否配置文件名和软件名不一致或者配置的地址不存在等。然后你可以通过 services.msc 对你的服务进行操作了启动，停止。注册的服务默认是AutoStart每次重启电脑都会自动启动。</p>\n<p>配置文件的相关其他设置可以参考: <a href=\"https://github.com/kohsuke/winsw/blob/master/doc/xmlConfigFile.md\" target=\"_blank\" rel=\"noopener\">https://github.com/kohsuke/winsw/blob/master/doc/xmlConfigFile.md</a></p>\n"},{"title":"fast-fail 和 fast-safe的区别","toc":false,"date":"2019-07-24T03:25:10.000Z","_content":"\n![Java](/images/java.jpg)\n\n> 回头复习下一些面试常见的一些问题 fast-fail 和 fast-safe 两种机制\n\n### fast-fail\nfast-fail 快速失败，在`java.util`包下的集合进行迭代遍历时会调用`checkForComodification`方法检查，当`modCount != expectedModCount`时会抛出`ConcurrentModificationException`异常\n``` java\n final void checkForComodification() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n }\n```\n\n#### 注意\n在多线程环境下并发操作集合可能会导致`modCount`与`expectedModCount`的值和预期不一致导致条件判断通过不会抛出异常，因此在多线程环境下应该使用`java.concurrent`包下的集合\n\n\n### fast-safe\nfast-safe 安全失败，任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出`ConcurrentModificationException`\n\n#### 注意\n由于 fast-safe 遍历是采用了复制原有集合内容作为一个新的集合进行遍历，所以会带来更大的内存消耗且原始数据发现变化后是不能被迭代器所检测发现数据变化\n\n\n||Fail Fast Iterator|Fail Safe Iterator|\n|-|-|-|\n|Throw ConcurrentModificationException|Yes|No|\n|Clone Object|No|Yes|\n|Memory OverHead|No|Yes|\n|Examples|ArrayList、HashMap、HashSet|CopyOnWriteArrayList、ConcurrentHashMap|","source":"_posts/fast-fail和fast-safe的区别.md","raw":"---\ntitle: fast-fail 和 fast-safe的区别\ntags:\n  - Java\ncategories:\n  - Java\ntoc: false\ndate: 2019-07-24 11:25:10\n---\n\n![Java](/images/java.jpg)\n\n> 回头复习下一些面试常见的一些问题 fast-fail 和 fast-safe 两种机制\n\n### fast-fail\nfast-fail 快速失败，在`java.util`包下的集合进行迭代遍历时会调用`checkForComodification`方法检查，当`modCount != expectedModCount`时会抛出`ConcurrentModificationException`异常\n``` java\n final void checkForComodification() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n }\n```\n\n#### 注意\n在多线程环境下并发操作集合可能会导致`modCount`与`expectedModCount`的值和预期不一致导致条件判断通过不会抛出异常，因此在多线程环境下应该使用`java.concurrent`包下的集合\n\n\n### fast-safe\nfast-safe 安全失败，任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出`ConcurrentModificationException`\n\n#### 注意\n由于 fast-safe 遍历是采用了复制原有集合内容作为一个新的集合进行遍历，所以会带来更大的内存消耗且原始数据发现变化后是不能被迭代器所检测发现数据变化\n\n\n||Fail Fast Iterator|Fail Safe Iterator|\n|-|-|-|\n|Throw ConcurrentModificationException|Yes|No|\n|Clone Object|No|Yes|\n|Memory OverHead|No|Yes|\n|Examples|ArrayList、HashMap、HashSet|CopyOnWriteArrayList、ConcurrentHashMap|","slug":"fast-fail和fast-safe的区别","published":1,"updated":"2020-08-10T01:48:44.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9a5004kjsudb0zhmqqr","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>回头复习下一些面试常见的一些问题 fast-fail 和 fast-safe 两种机制</p>\n</blockquote>\n<h3 id=\"fast-fail\"><a href=\"#fast-fail\" class=\"headerlink\" title=\"fast-fail\"></a>fast-fail</h3><p>fast-fail 快速失败，在<code>java.util</code>包下的集合进行迭代遍历时会调用<code>checkForComodification</code>方法检查，当<code>modCount != expectedModCount</code>时会抛出<code>ConcurrentModificationException</code>异常<br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">checkForComodification</span><span class=\"hljs-params\">()</span> </span>&#123;\n           <span class=\"hljs-keyword\">if</span> (modCount != expectedModCount)\n               <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ConcurrentModificationException();\n&#125;</code></pre></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>在多线程环境下并发操作集合可能会导致<code>modCount</code>与<code>expectedModCount</code>的值和预期不一致导致条件判断通过不会抛出异常，因此在多线程环境下应该使用<code>java.concurrent</code>包下的集合</p>\n<h3 id=\"fast-safe\"><a href=\"#fast-safe\" class=\"headerlink\" title=\"fast-safe\"></a>fast-safe</h3><p>fast-safe 安全失败，任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出<code>ConcurrentModificationException</code></p>\n<h4 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>由于 fast-safe 遍历是采用了复制原有集合内容作为一个新的集合进行遍历，所以会带来更大的内存消耗且原始数据发现变化后是不能被迭代器所检测发现数据变化</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Fail Fast Iterator</th>\n<th>Fail Safe Iterator</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Throw ConcurrentModificationException</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Clone Object</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Memory OverHead</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Examples</td>\n<td>ArrayList、HashMap、HashSet</td>\n<td>CopyOnWriteArrayList、ConcurrentHashMap</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt=\"Java\"></p>\n<blockquote>\n<p>回头复习下一些面试常见的一些问题 fast-fail 和 fast-safe 两种机制</p>\n</blockquote>\n<h3 id=\"fast-fail\"><a href=\"#fast-fail\" class=\"headerlink\" title=\"fast-fail\"></a>fast-fail</h3><p>fast-fail 快速失败，在<code>java.util</code>包下的集合进行迭代遍历时会调用<code>checkForComodification</code>方法检查，当<code>modCount != expectedModCount</code>时会抛出<code>ConcurrentModificationException</code>异常<br><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">checkForComodification</span><span class=\"hljs-params\">()</span> </span>&#123;\n           <span class=\"hljs-keyword\">if</span> (modCount != expectedModCount)\n               <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ConcurrentModificationException();\n&#125;</code></pre></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>在多线程环境下并发操作集合可能会导致<code>modCount</code>与<code>expectedModCount</code>的值和预期不一致导致条件判断通过不会抛出异常，因此在多线程环境下应该使用<code>java.concurrent</code>包下的集合</p>\n<h3 id=\"fast-safe\"><a href=\"#fast-safe\" class=\"headerlink\" title=\"fast-safe\"></a>fast-safe</h3><p>fast-safe 安全失败，任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出<code>ConcurrentModificationException</code></p>\n<h4 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>由于 fast-safe 遍历是采用了复制原有集合内容作为一个新的集合进行遍历，所以会带来更大的内存消耗且原始数据发现变化后是不能被迭代器所检测发现数据变化</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Fail Fast Iterator</th>\n<th>Fail Safe Iterator</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Throw ConcurrentModificationException</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Clone Object</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Memory OverHead</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Examples</td>\n<td>ArrayList、HashMap、HashSet</td>\n<td>CopyOnWriteArrayList、ConcurrentHashMap</td>\n</tr>\n</tbody>\n</table>\n"},{"layout":"post","title":"Hexo+GitHub 第一次搭建笔记","date":"2018-05-24T06:48:00.000Z","comments":1,"_content":"\n![Hexo](/images/hexo.jpg)\n\n> Hexo+GitHub 搭建踩坑行动，平时有什么代码心得或者遇到一些奇葩BUG、都没有记下来，后来遇到类似的问题居然又忘记了，所以想自己搭建一个博客记录下一些平时遇到的问题和需要解决的一些技术问题记录下来以便以后回来还可以查阅，就用Hexo搭建一个静态的博客。\n\n## 1.Hexo 环境准备\n * [Node.js](http://nodejs.cn/) hexo依赖环境\n * [Git Bash](https://git-scm.com/) 根据OS下载安装包 用于发布和更新微博\n \n#### 安装 Hexo\n``` bash\n#1.安装hexo环境\nnpm install hexo-cli -g  \n#2.初始化hexo blog 文件夹和相关带代码 bolgName为文件夹名称\nhexo init [blogName]\n#3.进入博客文件夹\ncd blog\n#4.进行依赖更新安装\nnpm install\n ```\n \n\n#### 常用指令\n```bash\n#新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。\n$ hexo init [folder]\n#新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 \n#default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。\n$ hexo new [layout] <title>\n#生成静态文件。\n$ hexo g\n#发表草稿\n$ hexo publish [layout] <filename>\n# 启动服务器。默认情况下，访问网址为： http://localhost:4000/\n$ hexo s\n# 部署网站\n$ hexo deploy\n# -p， --port\t重设端口\n# -s， --static\t只使用静态文件\n# -l， --log\t启动日记记录，使用覆盖记录格式\n ```\n \n ## 2.GitHub Page 准备\n* 登录Github创建一个reqo，名称为 `` [yourname].github.io `` (这里注意下yourname最好跟你库的用户名一样)\n\n* 本地使用git设置username 和email \n        \n```\ngit config --global user.name [username]\ngit config --global user.email [email]\n```\n\n* GitHub SSH KEY 设置\n![GitHub SSH key设置](/images/ssh-key.jpg) \n\n``` bash\n    ssh-keygen -t rsa -C [email]\n```\n秘钥 `` C:\\Users\\serwer\\.ssh\\id_rsa.pub `` 复制添加到Github SSH Key中\n\n在 **Git Bash** 中验证是否添加成功：``ssh -T git@github.com``\n\n* 配置_config.yml 发布静态文件到github，修改_config.yml进行github发布设置\n\n``` yml\ndeploy:\n  type: git\n  repo: git@github.com:[username]/[username].github.io.git\n  branch: master\n ```\n 通过 **Git Bash** `` hexo d `` 进行发布更新到github 然后访问你的reqo page即可看到属于你自己的静态微博    \n \n 可能遇到的问题：\n  ![缺少发布插件](/images/error.jpg)\n  \n  解决方法:`` npm install --save hexo-deployer-git `` 安装hexo git发布插件然后执行``hexo d`` \n\n \n    ","source":"_posts/hexo.md","raw":"---\nlayout: post\ntitle: \"Hexo+GitHub 第一次搭建笔记\"\ndate: 2018-05-24 14:48\ncategories: [技术]\ncomments: true\ntags: \n\t- 心得 \n---\n\n![Hexo](/images/hexo.jpg)\n\n> Hexo+GitHub 搭建踩坑行动，平时有什么代码心得或者遇到一些奇葩BUG、都没有记下来，后来遇到类似的问题居然又忘记了，所以想自己搭建一个博客记录下一些平时遇到的问题和需要解决的一些技术问题记录下来以便以后回来还可以查阅，就用Hexo搭建一个静态的博客。\n\n## 1.Hexo 环境准备\n * [Node.js](http://nodejs.cn/) hexo依赖环境\n * [Git Bash](https://git-scm.com/) 根据OS下载安装包 用于发布和更新微博\n \n#### 安装 Hexo\n``` bash\n#1.安装hexo环境\nnpm install hexo-cli -g  \n#2.初始化hexo blog 文件夹和相关带代码 bolgName为文件夹名称\nhexo init [blogName]\n#3.进入博客文件夹\ncd blog\n#4.进行依赖更新安装\nnpm install\n ```\n \n\n#### 常用指令\n```bash\n#新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。\n$ hexo init [folder]\n#新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 \n#default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。\n$ hexo new [layout] <title>\n#生成静态文件。\n$ hexo g\n#发表草稿\n$ hexo publish [layout] <filename>\n# 启动服务器。默认情况下，访问网址为： http://localhost:4000/\n$ hexo s\n# 部署网站\n$ hexo deploy\n# -p， --port\t重设端口\n# -s， --static\t只使用静态文件\n# -l， --log\t启动日记记录，使用覆盖记录格式\n ```\n \n ## 2.GitHub Page 准备\n* 登录Github创建一个reqo，名称为 `` [yourname].github.io `` (这里注意下yourname最好跟你库的用户名一样)\n\n* 本地使用git设置username 和email \n        \n```\ngit config --global user.name [username]\ngit config --global user.email [email]\n```\n\n* GitHub SSH KEY 设置\n![GitHub SSH key设置](/images/ssh-key.jpg) \n\n``` bash\n    ssh-keygen -t rsa -C [email]\n```\n秘钥 `` C:\\Users\\serwer\\.ssh\\id_rsa.pub `` 复制添加到Github SSH Key中\n\n在 **Git Bash** 中验证是否添加成功：``ssh -T git@github.com``\n\n* 配置_config.yml 发布静态文件到github，修改_config.yml进行github发布设置\n\n``` yml\ndeploy:\n  type: git\n  repo: git@github.com:[username]/[username].github.io.git\n  branch: master\n ```\n 通过 **Git Bash** `` hexo d `` 进行发布更新到github 然后访问你的reqo page即可看到属于你自己的静态微博    \n \n 可能遇到的问题：\n  ![缺少发布插件](/images/error.jpg)\n  \n  解决方法:`` npm install --save hexo-deployer-git `` 安装hexo git发布插件然后执行``hexo d`` \n\n \n    ","slug":"hexo","published":1,"updated":"2020-08-10T01:48:44.755Z","photos":[],"link":"","_id":"ckhmyc9a7004ojsud05kbyvsr","content":"<p><img src=\"/images/hexo.jpg\" srcset=\"/img/loading.gif\" alt=\"Hexo\"></p>\n<blockquote>\n<p>Hexo+GitHub 搭建踩坑行动，平时有什么代码心得或者遇到一些奇葩BUG、都没有记下来，后来遇到类似的问题居然又忘记了，所以想自己搭建一个博客记录下一些平时遇到的问题和需要解决的一些技术问题记录下来以便以后回来还可以查阅，就用Hexo搭建一个静态的博客。</p>\n</blockquote>\n<h2 id=\"1-Hexo-环境准备\"><a href=\"#1-Hexo-环境准备\" class=\"headerlink\" title=\"1.Hexo 环境准备\"></a>1.Hexo 环境准备</h2><ul>\n<li><a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">Node.js</a> hexo依赖环境</li>\n<li><a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git Bash</a> 根据OS下载安装包 用于发布和更新微博</li>\n</ul>\n<h4 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h4><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#1.安装hexo环境</span>\nnpm install hexo-cli -g  \n<span class=\"hljs-comment\">#2.初始化hexo blog 文件夹和相关带代码 bolgName为文件夹名称</span>\nhexo init [blogName]\n<span class=\"hljs-comment\">#3.进入博客文件夹</span>\n<span class=\"hljs-built_in\">cd</span> blog\n<span class=\"hljs-comment\">#4.进行依赖更新安装</span>\nnpm install</code></pre>\n<h4 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h4><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</span>\n$ hexo init [folder]\n<span class=\"hljs-comment\">#新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 </span>\n<span class=\"hljs-comment\">#default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</span>\n$ hexo new [layout] &lt;title&gt;\n<span class=\"hljs-comment\">#生成静态文件。</span>\n$ hexo g\n<span class=\"hljs-comment\">#发表草稿</span>\n$ hexo publish [layout] &lt;filename&gt;\n<span class=\"hljs-comment\"># 启动服务器。默认情况下，访问网址为： http://localhost:4000/</span>\n$ hexo s\n<span class=\"hljs-comment\"># 部署网站</span>\n$ hexo deploy\n<span class=\"hljs-comment\"># -p， --port\t重设端口</span>\n<span class=\"hljs-comment\"># -s， --static\t只使用静态文件</span>\n<span class=\"hljs-comment\"># -l， --log\t启动日记记录，使用覆盖记录格式</span></code></pre>\n<h2 id=\"2-GitHub-Page-准备\"><a href=\"#2-GitHub-Page-准备\" class=\"headerlink\" title=\"2.GitHub Page 准备\"></a>2.GitHub Page 准备</h2><ul>\n<li><p>登录Github创建一个reqo，名称为 <code>[yourname].github.io</code> (这里注意下yourname最好跟你库的用户名一样)</p>\n</li>\n<li><p>本地使用git设置username 和email </p>\n</li>\n</ul>\n<pre><code class=\"hljs undefined\">git<span class=\"hljs-built_in\"> config </span>--global user.name [username]\ngit<span class=\"hljs-built_in\"> config </span>--global user.email [email]</code></pre>\n<ul>\n<li>GitHub SSH KEY 设置<br><img src=\"/images/ssh-key.jpg\" srcset=\"/img/loading.gif\" alt=\"GitHub SSH key设置\"> </li>\n</ul>\n<pre><code class=\"hljs bash\">ssh-keygen -t rsa -C [email]</code></pre>\n<p>秘钥 <code>C:\\Users\\serwer\\.ssh\\id_rsa.pub</code> 复制添加到Github SSH Key中</p>\n<p>在 <strong>Git Bash</strong> 中验证是否添加成功：<code>ssh -T git@github.com</code></p>\n<ul>\n<li>配置_config.yml 发布静态文件到github，修改_config.yml进行github发布设置</li>\n</ul>\n<pre><code class=\"hljs yml\"><span class=\"hljs-attr\">deploy:</span>\n  <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">git</span>\n  <span class=\"hljs-attr\">repo:</span> <span class=\"hljs-string\">git@github.com:[username]/[username].github.io.git</span>\n  <span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">master</span></code></pre>\n<p> 通过 <strong>Git Bash</strong> <code>hexo d</code> 进行发布更新到github 然后访问你的reqo page即可看到属于你自己的静态微博    </p>\n<p> 可能遇到的问题：<br>  <img src=\"/images/error.jpg\" srcset=\"/img/loading.gif\" alt=\"缺少发布插件\"></p>\n<p>  解决方法:<code>npm install --save hexo-deployer-git</code> 安装hexo git发布插件然后执行<code>hexo d</code> </p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/hexo.jpg\" srcset=\"/img/loading.gif\" alt=\"Hexo\"></p>\n<blockquote>\n<p>Hexo+GitHub 搭建踩坑行动，平时有什么代码心得或者遇到一些奇葩BUG、都没有记下来，后来遇到类似的问题居然又忘记了，所以想自己搭建一个博客记录下一些平时遇到的问题和需要解决的一些技术问题记录下来以便以后回来还可以查阅，就用Hexo搭建一个静态的博客。</p>\n</blockquote>\n<h2 id=\"1-Hexo-环境准备\"><a href=\"#1-Hexo-环境准备\" class=\"headerlink\" title=\"1.Hexo 环境准备\"></a>1.Hexo 环境准备</h2><ul>\n<li><a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">Node.js</a> hexo依赖环境</li>\n<li><a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git Bash</a> 根据OS下载安装包 用于发布和更新微博</li>\n</ul>\n<h4 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h4><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#1.安装hexo环境</span>\nnpm install hexo-cli -g  \n<span class=\"hljs-comment\">#2.初始化hexo blog 文件夹和相关带代码 bolgName为文件夹名称</span>\nhexo init [blogName]\n<span class=\"hljs-comment\">#3.进入博客文件夹</span>\n<span class=\"hljs-built_in\">cd</span> blog\n<span class=\"hljs-comment\">#4.进行依赖更新安装</span>\nnpm install</code></pre>\n<h4 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h4><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</span>\n$ hexo init [folder]\n<span class=\"hljs-comment\">#新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 </span>\n<span class=\"hljs-comment\">#default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</span>\n$ hexo new [layout] &lt;title&gt;\n<span class=\"hljs-comment\">#生成静态文件。</span>\n$ hexo g\n<span class=\"hljs-comment\">#发表草稿</span>\n$ hexo publish [layout] &lt;filename&gt;\n<span class=\"hljs-comment\"># 启动服务器。默认情况下，访问网址为： http://localhost:4000/</span>\n$ hexo s\n<span class=\"hljs-comment\"># 部署网站</span>\n$ hexo deploy\n<span class=\"hljs-comment\"># -p， --port\t重设端口</span>\n<span class=\"hljs-comment\"># -s， --static\t只使用静态文件</span>\n<span class=\"hljs-comment\"># -l， --log\t启动日记记录，使用覆盖记录格式</span></code></pre>\n<h2 id=\"2-GitHub-Page-准备\"><a href=\"#2-GitHub-Page-准备\" class=\"headerlink\" title=\"2.GitHub Page 准备\"></a>2.GitHub Page 准备</h2><ul>\n<li><p>登录Github创建一个reqo，名称为 <code>[yourname].github.io</code> (这里注意下yourname最好跟你库的用户名一样)</p>\n</li>\n<li><p>本地使用git设置username 和email </p>\n</li>\n</ul>\n<pre><code class=\"hljs undefined\">git<span class=\"hljs-built_in\"> config </span>--global user.name [username]\ngit<span class=\"hljs-built_in\"> config </span>--global user.email [email]</code></pre>\n<ul>\n<li>GitHub SSH KEY 设置<br><img src=\"/images/ssh-key.jpg\" srcset=\"/img/loading.gif\" alt=\"GitHub SSH key设置\"> </li>\n</ul>\n<pre><code class=\"hljs bash\">ssh-keygen -t rsa -C [email]</code></pre>\n<p>秘钥 <code>C:\\Users\\serwer\\.ssh\\id_rsa.pub</code> 复制添加到Github SSH Key中</p>\n<p>在 <strong>Git Bash</strong> 中验证是否添加成功：<code>ssh -T git@github.com</code></p>\n<ul>\n<li>配置_config.yml 发布静态文件到github，修改_config.yml进行github发布设置</li>\n</ul>\n<pre><code class=\"hljs yml\"><span class=\"hljs-attr\">deploy:</span>\n  <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">git</span>\n  <span class=\"hljs-attr\">repo:</span> <span class=\"hljs-string\">git@github.com:[username]/[username].github.io.git</span>\n  <span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">master</span></code></pre>\n<p> 通过 <strong>Git Bash</strong> <code>hexo d</code> 进行发布更新到github 然后访问你的reqo page即可看到属于你自己的静态微博    </p>\n<p> 可能遇到的问题：<br>  <img src=\"/images/error.jpg\" srcset=\"/img/loading.gif\" alt=\"缺少发布插件\"></p>\n<p>  解决方法:<code>npm install --save hexo-deployer-git</code> 安装hexo git发布插件然后执行<code>hexo d</code> </p>\n"},{"title":"一致性哈希算法","toc":false,"date":"2020-05-18T07:47:02.000Z","_content":"\n### 一致性哈希算法\n#### 特性\n- **平衡性（Balance）**：哈希地址尽可能均匀的分布到所有的地址空间之中，充分利用所有的地址空间 \n- **单调性（Monotonicity）**：当地址空间扩容或缩容时，原有已分配的内容能正确的映射到原有或新的地址空间之中，而一般的哈希算法由于整个地址空间的变化需要重新更新所有的映射关系\n- **分散性（Spread）**：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。\n- **负载（Load）**：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。\n- **平滑性（Smoonthness）**：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的\n\n#### 原理\n在分布式架构中将服务器通过ip地址进行哈希算法确定在0 ~ 2^32^的**闭环**之中的位置，当我们存入某个缓存时候通过算出`hash(key)`得到哈希值，顺时针找到第一个距离最近的服务器操作，如果当前哈希值超过最大值则从0开始继续查找\n![image.png](/images/2020/05/18/c8ff2030-98e4-11ea-baff-f5d93153beb4.png)\n\n\n#### 节点变化\n当架构添加新的服务器或删除，只会影响该新节点逆时针到前一个节点之间的缓存数据，仅需将受影响缓存数据迁移至新节点之中即可，无需更新整个映射关系，如果节点C宕机仅仅是节点B到节点C之间的数据无法使用，其余节点A、B、D都能正常提供服务，对于节点的变化仅需重定位部分数据，具有较好的可扩展性和容错性\n![image.png](/images/2020/05/18/d3568690-98e4-11ea-baff-f5d93153beb4.png)\n\n#### 数据倾斜\n在圆环之中如果节点过少会造成数据倾斜，大量的数据集中在在一个节点少量数据分布到其他节点，为解决此类问题引入了**虚拟节点机制**，对服务器节点多次计算哈希值作为虚拟节点的值，使其数据更加均匀的分散到个个节点\n![image.png](/images/2020/05/18/c3928180-98e6-11ea-ba5c-993f9fbc0aef.png)","source":"_posts/一致性哈希算法.md","raw":"---\ntitle: 一致性哈希算法\ntags: []\ncategories: []\ntoc: false\ndate: 2020-05-18 15:47:02\n---\n\n### 一致性哈希算法\n#### 特性\n- **平衡性（Balance）**：哈希地址尽可能均匀的分布到所有的地址空间之中，充分利用所有的地址空间 \n- **单调性（Monotonicity）**：当地址空间扩容或缩容时，原有已分配的内容能正确的映射到原有或新的地址空间之中，而一般的哈希算法由于整个地址空间的变化需要重新更新所有的映射关系\n- **分散性（Spread）**：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。\n- **负载（Load）**：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。\n- **平滑性（Smoonthness）**：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的\n\n#### 原理\n在分布式架构中将服务器通过ip地址进行哈希算法确定在0 ~ 2^32^的**闭环**之中的位置，当我们存入某个缓存时候通过算出`hash(key)`得到哈希值，顺时针找到第一个距离最近的服务器操作，如果当前哈希值超过最大值则从0开始继续查找\n![image.png](/images/2020/05/18/c8ff2030-98e4-11ea-baff-f5d93153beb4.png)\n\n\n#### 节点变化\n当架构添加新的服务器或删除，只会影响该新节点逆时针到前一个节点之间的缓存数据，仅需将受影响缓存数据迁移至新节点之中即可，无需更新整个映射关系，如果节点C宕机仅仅是节点B到节点C之间的数据无法使用，其余节点A、B、D都能正常提供服务，对于节点的变化仅需重定位部分数据，具有较好的可扩展性和容错性\n![image.png](/images/2020/05/18/d3568690-98e4-11ea-baff-f5d93153beb4.png)\n\n#### 数据倾斜\n在圆环之中如果节点过少会造成数据倾斜，大量的数据集中在在一个节点少量数据分布到其他节点，为解决此类问题引入了**虚拟节点机制**，对服务器节点多次计算哈希值作为虚拟节点的值，使其数据更加均匀的分散到个个节点\n![image.png](/images/2020/05/18/c3928180-98e6-11ea-ba5c-993f9fbc0aef.png)","slug":"一致性哈希算法","published":1,"updated":"2020-08-10T01:48:44.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9a9004rjsud6gl8batd","content":"<h3 id=\"一致性哈希算法\"><a href=\"#一致性哈希算法\" class=\"headerlink\" title=\"一致性哈希算法\"></a>一致性哈希算法</h3><h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><ul>\n<li><strong>平衡性（Balance）</strong>：哈希地址尽可能均匀的分布到所有的地址空间之中，充分利用所有的地址空间 </li>\n<li><strong>单调性（Monotonicity）</strong>：当地址空间扩容或缩容时，原有已分配的内容能正确的映射到原有或新的地址空间之中，而一般的哈希算法由于整个地址空间的变化需要重新更新所有的映射关系</li>\n<li><strong>分散性（Spread）</strong>：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li>\n<li><strong>负载（Load）</strong>：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li>\n<li><strong>平滑性（Smoonthness）</strong>：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的</li>\n</ul>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>在分布式架构中将服务器通过ip地址进行哈希算法确定在0 ~ 2^32^的<strong>闭环</strong>之中的位置，当我们存入某个缓存时候通过算出<code>hash(key)</code>得到哈希值，顺时针找到第一个距离最近的服务器操作，如果当前哈希值超过最大值则从0开始继续查找<br><img src=\"/images/2020/05/18/c8ff2030-98e4-11ea-baff-f5d93153beb4.png\" srcset=\"/img/loading.gif\" alt=\"image.png\"></p>\n<h4 id=\"节点变化\"><a href=\"#节点变化\" class=\"headerlink\" title=\"节点变化\"></a>节点变化</h4><p>当架构添加新的服务器或删除，只会影响该新节点逆时针到前一个节点之间的缓存数据，仅需将受影响缓存数据迁移至新节点之中即可，无需更新整个映射关系，如果节点C宕机仅仅是节点B到节点C之间的数据无法使用，其余节点A、B、D都能正常提供服务，对于节点的变化仅需重定位部分数据，具有较好的可扩展性和容错性<br><img src=\"/images/2020/05/18/d3568690-98e4-11ea-baff-f5d93153beb4.png\" srcset=\"/img/loading.gif\" alt=\"image.png\"></p>\n<h4 id=\"数据倾斜\"><a href=\"#数据倾斜\" class=\"headerlink\" title=\"数据倾斜\"></a>数据倾斜</h4><p>在圆环之中如果节点过少会造成数据倾斜，大量的数据集中在在一个节点少量数据分布到其他节点，为解决此类问题引入了<strong>虚拟节点机制</strong>，对服务器节点多次计算哈希值作为虚拟节点的值，使其数据更加均匀的分散到个个节点<br><img src=\"/images/2020/05/18/c3928180-98e6-11ea-ba5c-993f9fbc0aef.png\" srcset=\"/img/loading.gif\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一致性哈希算法\"><a href=\"#一致性哈希算法\" class=\"headerlink\" title=\"一致性哈希算法\"></a>一致性哈希算法</h3><h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><ul>\n<li><strong>平衡性（Balance）</strong>：哈希地址尽可能均匀的分布到所有的地址空间之中，充分利用所有的地址空间 </li>\n<li><strong>单调性（Monotonicity）</strong>：当地址空间扩容或缩容时，原有已分配的内容能正确的映射到原有或新的地址空间之中，而一般的哈希算法由于整个地址空间的变化需要重新更新所有的映射关系</li>\n<li><strong>分散性（Spread）</strong>：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li>\n<li><strong>负载（Load）</strong>：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li>\n<li><strong>平滑性（Smoonthness）</strong>：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的</li>\n</ul>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>在分布式架构中将服务器通过ip地址进行哈希算法确定在0 ~ 2^32^的<strong>闭环</strong>之中的位置，当我们存入某个缓存时候通过算出<code>hash(key)</code>得到哈希值，顺时针找到第一个距离最近的服务器操作，如果当前哈希值超过最大值则从0开始继续查找<br><img src=\"/images/2020/05/18/c8ff2030-98e4-11ea-baff-f5d93153beb4.png\" srcset=\"/img/loading.gif\" alt=\"image.png\"></p>\n<h4 id=\"节点变化\"><a href=\"#节点变化\" class=\"headerlink\" title=\"节点变化\"></a>节点变化</h4><p>当架构添加新的服务器或删除，只会影响该新节点逆时针到前一个节点之间的缓存数据，仅需将受影响缓存数据迁移至新节点之中即可，无需更新整个映射关系，如果节点C宕机仅仅是节点B到节点C之间的数据无法使用，其余节点A、B、D都能正常提供服务，对于节点的变化仅需重定位部分数据，具有较好的可扩展性和容错性<br><img src=\"/images/2020/05/18/d3568690-98e4-11ea-baff-f5d93153beb4.png\" srcset=\"/img/loading.gif\" alt=\"image.png\"></p>\n<h4 id=\"数据倾斜\"><a href=\"#数据倾斜\" class=\"headerlink\" title=\"数据倾斜\"></a>数据倾斜</h4><p>在圆环之中如果节点过少会造成数据倾斜，大量的数据集中在在一个节点少量数据分布到其他节点，为解决此类问题引入了<strong>虚拟节点机制</strong>，对服务器节点多次计算哈希值作为虚拟节点的值，使其数据更加均匀的分散到个个节点<br><img src=\"/images/2020/05/18/c3928180-98e6-11ea-ba5c-993f9fbc0aef.png\" srcset=\"/img/loading.gif\" alt=\"image.png\"></p>\n"},{"title":"事务传播性","toc":false,"date":"2020-05-26T11:13:42.000Z","_content":"\n![](/images/spring.jpg)\n\n### 事务的传播性\n事务的传播性用来描述在一个事务之中被嵌套到另外一个方法事务是怎么执行传播，Spring 的事务一共有7中传播方式\n- PROPAGATION_REQUIRED 父调用有事务则支持当前事务，没有则创建新事务，这是最常用的事务传播\n- PROPAGATION_SUPPORTS 父调用有事务则支持当前事务，没有以非事务执行\n- PROPAGATION_MANDATORY 父调用有事务则支持当前事务，没有则抛出异常（强制性事务）\n- PROPAGATION_REQUIRE_NEW 子调用创建新的事务当父调用有事务则挂起，子调用事务先执行完毕后再执行父调用事务，当子调用事务已完成父调用发生异常是不影响子调用回滚\n- PROPAGATION_NO_SUPPORTED 子调用以非事务执行，如果父调用有事务则挂起\n- PROPAGATION_NEVER 子调用以非事务执行，如果父调用有事务则抛出异常\n- PROPAGATION_NESTED 父调用有事务则嵌套事务内执行，没有则创建新事务，它与 PROPAGATION_REQUIRES_NEW 区别在于前者与父事务相互独立有先后顺序，而 NESTED 是与父事务一起提交\n\n#### PROPAGATION_REQUIRED\n当A或B抛出异常,AB都会进行回滚操作因为他们在同一事务之中\n\n``` java\n@Transtational(propagation = Propagation.REQUIRED)\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.REQUIRED)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n\n#### PROPAGATION_SUPPORTS\n当A有事务异常AB都会回滚,当A没有事务B异常时会以非事务执行不进行回滚操作\n``` java\n@Transtational(propagation = Propagation.REQUIRED)\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.PROPAGATION_SUPPORTS)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n\n#### PROPAGATION_MANDATORY\n当A调用B方法时如果A没有事务则会抛出异常 `org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation 'mandatory'` ，该方法父调用必须**强制事务**！！\n``` java\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.MANDATORY)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n\n#### PROPAGATION_REQUIRES_NEW\n当A调用B执行到B时A的事务会先挂起，等B事务执行完毕后再执行A事务，所以当B事务完成后A事务发现异常只会回滚A事务相关操作并不会影响到B已提交事务\n``` java\n@Transtational(propagation = Propagation.REQUIRE)\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.REQUIRE_NEW)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n\n#### PROPAGATION_NOT_SUPPORTED\n当A调用B方法时如果A或者B异常，B不回滚A会回滚,因为当A有事务会被挂起B以非事务方式执行\n``` java\n@Transtational(propagation = Propagation.REQUIRE)\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.NOT_SUPPORTED)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n\n#### PROPAGATION_NEVER \n当A调用B方法时如果A有事务则会抛出异常`org.springframework.transaction.IllegalTransactionStateException: Existing transaction found for transaction marked with propagation 'never'`，该方法父调用必须**没有事务**!!\n``` java\n@Transtational(propagation = Propagation.REQUIRE)\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.NEVER)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n","source":"_posts/事务传播性.md","raw":"---\ntitle: 事务传播性\ntags:\n  - Spring\ncategories:\n  - Java\ntoc: false\ndate: 2020-05-26 19:13:42\n---\n\n![](/images/spring.jpg)\n\n### 事务的传播性\n事务的传播性用来描述在一个事务之中被嵌套到另外一个方法事务是怎么执行传播，Spring 的事务一共有7中传播方式\n- PROPAGATION_REQUIRED 父调用有事务则支持当前事务，没有则创建新事务，这是最常用的事务传播\n- PROPAGATION_SUPPORTS 父调用有事务则支持当前事务，没有以非事务执行\n- PROPAGATION_MANDATORY 父调用有事务则支持当前事务，没有则抛出异常（强制性事务）\n- PROPAGATION_REQUIRE_NEW 子调用创建新的事务当父调用有事务则挂起，子调用事务先执行完毕后再执行父调用事务，当子调用事务已完成父调用发生异常是不影响子调用回滚\n- PROPAGATION_NO_SUPPORTED 子调用以非事务执行，如果父调用有事务则挂起\n- PROPAGATION_NEVER 子调用以非事务执行，如果父调用有事务则抛出异常\n- PROPAGATION_NESTED 父调用有事务则嵌套事务内执行，没有则创建新事务，它与 PROPAGATION_REQUIRES_NEW 区别在于前者与父事务相互独立有先后顺序，而 NESTED 是与父事务一起提交\n\n#### PROPAGATION_REQUIRED\n当A或B抛出异常,AB都会进行回滚操作因为他们在同一事务之中\n\n``` java\n@Transtational(propagation = Propagation.REQUIRED)\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.REQUIRED)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n\n#### PROPAGATION_SUPPORTS\n当A有事务异常AB都会回滚,当A没有事务B异常时会以非事务执行不进行回滚操作\n``` java\n@Transtational(propagation = Propagation.REQUIRED)\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.PROPAGATION_SUPPORTS)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n\n#### PROPAGATION_MANDATORY\n当A调用B方法时如果A没有事务则会抛出异常 `org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation 'mandatory'` ，该方法父调用必须**强制事务**！！\n``` java\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.MANDATORY)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n\n#### PROPAGATION_REQUIRES_NEW\n当A调用B执行到B时A的事务会先挂起，等B事务执行完毕后再执行A事务，所以当B事务完成后A事务发现异常只会回滚A事务相关操作并不会影响到B已提交事务\n``` java\n@Transtational(propagation = Propagation.REQUIRE)\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.REQUIRE_NEW)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n\n#### PROPAGATION_NOT_SUPPORTED\n当A调用B方法时如果A或者B异常，B不回滚A会回滚,因为当A有事务会被挂起B以非事务方式执行\n``` java\n@Transtational(propagation = Propagation.REQUIRE)\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.NOT_SUPPORTED)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n\n#### PROPAGATION_NEVER \n当A调用B方法时如果A有事务则会抛出异常`org.springframework.transaction.IllegalTransactionStateException: Existing transaction found for transaction marked with propagation 'never'`，该方法父调用必须**没有事务**!!\n``` java\n@Transtational(propagation = Propagation.REQUIRE)\npublic class serviceA {\n    @Resouce\n    private IServiceB serviceB;\n\n    public void methodA(){\n        // do something\n        serviceB.methodB();\n    } \n}\n\n@Transtational(propagation = Propagation.NEVER)\npublic class serviceB implements IServiceB{\n    public void methodB(){\n        // do something    \n    }\n}\n```\n","slug":"事务传播性","published":1,"updated":"2020-08-10T01:48:44.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9ad004vjsudf5qks9k0","content":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"事务的传播性\"><a href=\"#事务的传播性\" class=\"headerlink\" title=\"事务的传播性\"></a>事务的传播性</h3><p>事务的传播性用来描述在一个事务之中被嵌套到另外一个方法事务是怎么执行传播，Spring 的事务一共有7中传播方式</p>\n<ul>\n<li>PROPAGATION_REQUIRED 父调用有事务则支持当前事务，没有则创建新事务，这是最常用的事务传播</li>\n<li>PROPAGATION_SUPPORTS 父调用有事务则支持当前事务，没有以非事务执行</li>\n<li>PROPAGATION_MANDATORY 父调用有事务则支持当前事务，没有则抛出异常（强制性事务）</li>\n<li>PROPAGATION_REQUIRE_NEW 子调用创建新的事务当父调用有事务则挂起，子调用事务先执行完毕后再执行父调用事务，当子调用事务已完成父调用发生异常是不影响子调用回滚</li>\n<li>PROPAGATION_NO_SUPPORTED 子调用以非事务执行，如果父调用有事务则挂起</li>\n<li>PROPAGATION_NEVER 子调用以非事务执行，如果父调用有事务则抛出异常</li>\n<li>PROPAGATION_NESTED 父调用有事务则嵌套事务内执行，没有则创建新事务，它与 PROPAGATION_REQUIRES_NEW 区别在于前者与父事务相互独立有先后顺序，而 NESTED 是与父事务一起提交</li>\n</ul>\n<h4 id=\"PROPAGATION-REQUIRED\"><a href=\"#PROPAGATION-REQUIRED\" class=\"headerlink\" title=\"PROPAGATION_REQUIRED\"></a>PROPAGATION_REQUIRED</h4><p>当A或B抛出异常,AB都会进行回滚操作因为他们在同一事务之中</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRED)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRED)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre>\n<h4 id=\"PROPAGATION-SUPPORTS\"><a href=\"#PROPAGATION-SUPPORTS\" class=\"headerlink\" title=\"PROPAGATION_SUPPORTS\"></a>PROPAGATION_SUPPORTS</h4><p>当A有事务异常AB都会回滚,当A没有事务B异常时会以非事务执行不进行回滚操作<br><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRED)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.PROPAGATION_SUPPORTS)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"PROPAGATION-MANDATORY\"><a href=\"#PROPAGATION-MANDATORY\" class=\"headerlink\" title=\"PROPAGATION_MANDATORY\"></a>PROPAGATION_MANDATORY</h4><p>当A调用B方法时如果A没有事务则会抛出异常 <code>org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation &#39;mandatory&#39;</code> ，该方法父调用必须<strong>强制事务</strong>！！<br><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.MANDATORY)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"PROPAGATION-REQUIRES-NEW\"><a href=\"#PROPAGATION-REQUIRES-NEW\" class=\"headerlink\" title=\"PROPAGATION_REQUIRES_NEW\"></a>PROPAGATION_REQUIRES_NEW</h4><p>当A调用B执行到B时A的事务会先挂起，等B事务执行完毕后再执行A事务，所以当B事务完成后A事务发现异常只会回滚A事务相关操作并不会影响到B已提交事务<br><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRE)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRE_NEW)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"PROPAGATION-NOT-SUPPORTED\"><a href=\"#PROPAGATION-NOT-SUPPORTED\" class=\"headerlink\" title=\"PROPAGATION_NOT_SUPPORTED\"></a>PROPAGATION_NOT_SUPPORTED</h4><p>当A调用B方法时如果A或者B异常，B不回滚A会回滚,因为当A有事务会被挂起B以非事务方式执行<br><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRE)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.NOT_SUPPORTED)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"PROPAGATION-NEVER\"><a href=\"#PROPAGATION-NEVER\" class=\"headerlink\" title=\"PROPAGATION_NEVER\"></a>PROPAGATION_NEVER</h4><p>当A调用B方法时如果A有事务则会抛出异常<code>org.springframework.transaction.IllegalTransactionStateException: Existing transaction found for transaction marked with propagation &#39;never&#39;</code>，该方法父调用必须<strong>没有事务</strong>!!<br><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRE)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.NEVER)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/spring.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"事务的传播性\"><a href=\"#事务的传播性\" class=\"headerlink\" title=\"事务的传播性\"></a>事务的传播性</h3><p>事务的传播性用来描述在一个事务之中被嵌套到另外一个方法事务是怎么执行传播，Spring 的事务一共有7中传播方式</p>\n<ul>\n<li>PROPAGATION_REQUIRED 父调用有事务则支持当前事务，没有则创建新事务，这是最常用的事务传播</li>\n<li>PROPAGATION_SUPPORTS 父调用有事务则支持当前事务，没有以非事务执行</li>\n<li>PROPAGATION_MANDATORY 父调用有事务则支持当前事务，没有则抛出异常（强制性事务）</li>\n<li>PROPAGATION_REQUIRE_NEW 子调用创建新的事务当父调用有事务则挂起，子调用事务先执行完毕后再执行父调用事务，当子调用事务已完成父调用发生异常是不影响子调用回滚</li>\n<li>PROPAGATION_NO_SUPPORTED 子调用以非事务执行，如果父调用有事务则挂起</li>\n<li>PROPAGATION_NEVER 子调用以非事务执行，如果父调用有事务则抛出异常</li>\n<li>PROPAGATION_NESTED 父调用有事务则嵌套事务内执行，没有则创建新事务，它与 PROPAGATION_REQUIRES_NEW 区别在于前者与父事务相互独立有先后顺序，而 NESTED 是与父事务一起提交</li>\n</ul>\n<h4 id=\"PROPAGATION-REQUIRED\"><a href=\"#PROPAGATION-REQUIRED\" class=\"headerlink\" title=\"PROPAGATION_REQUIRED\"></a>PROPAGATION_REQUIRED</h4><p>当A或B抛出异常,AB都会进行回滚操作因为他们在同一事务之中</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRED)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRED)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre>\n<h4 id=\"PROPAGATION-SUPPORTS\"><a href=\"#PROPAGATION-SUPPORTS\" class=\"headerlink\" title=\"PROPAGATION_SUPPORTS\"></a>PROPAGATION_SUPPORTS</h4><p>当A有事务异常AB都会回滚,当A没有事务B异常时会以非事务执行不进行回滚操作<br><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRED)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.PROPAGATION_SUPPORTS)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"PROPAGATION-MANDATORY\"><a href=\"#PROPAGATION-MANDATORY\" class=\"headerlink\" title=\"PROPAGATION_MANDATORY\"></a>PROPAGATION_MANDATORY</h4><p>当A调用B方法时如果A没有事务则会抛出异常 <code>org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation &#39;mandatory&#39;</code> ，该方法父调用必须<strong>强制事务</strong>！！<br><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.MANDATORY)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"PROPAGATION-REQUIRES-NEW\"><a href=\"#PROPAGATION-REQUIRES-NEW\" class=\"headerlink\" title=\"PROPAGATION_REQUIRES_NEW\"></a>PROPAGATION_REQUIRES_NEW</h4><p>当A调用B执行到B时A的事务会先挂起，等B事务执行完毕后再执行A事务，所以当B事务完成后A事务发现异常只会回滚A事务相关操作并不会影响到B已提交事务<br><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRE)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRE_NEW)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"PROPAGATION-NOT-SUPPORTED\"><a href=\"#PROPAGATION-NOT-SUPPORTED\" class=\"headerlink\" title=\"PROPAGATION_NOT_SUPPORTED\"></a>PROPAGATION_NOT_SUPPORTED</h4><p>当A调用B方法时如果A或者B异常，B不回滚A会回滚,因为当A有事务会被挂起B以非事务方式执行<br><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRE)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.NOT_SUPPORTED)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre></p>\n<h4 id=\"PROPAGATION-NEVER\"><a href=\"#PROPAGATION-NEVER\" class=\"headerlink\" title=\"PROPAGATION_NEVER\"></a>PROPAGATION_NEVER</h4><p>当A调用B方法时如果A有事务则会抛出异常<code>org.springframework.transaction.IllegalTransactionStateException: Existing transaction found for transaction marked with propagation &#39;never&#39;</code>，该方法父调用必须<strong>没有事务</strong>!!<br><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.REQUIRE)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceA</span> </span>&#123;\n    <span class=\"hljs-meta\">@Resouce</span>\n    <span class=\"hljs-keyword\">private</span> IServiceB serviceB;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodA</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something</span>\n        serviceB.methodB();\n    &#125; \n&#125;\n\n<span class=\"hljs-meta\">@Transtational</span>(propagation = Propagation.NEVER)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">serviceB</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IServiceB</span></span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">methodB</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-comment\">// do something    </span>\n    &#125;\n&#125;</code></pre></p>\n"},{"title":"事务的四大特性和隔离级别","toc":false,"date":"2020-05-22T15:51:43.000Z","_content":"\n![](/images/java.jpg)\n\n### 事务的特性 ACID \n事务有四大特性\n- **原子性（Atomicity）** 事务的一系列操作要么都完成，要么都不完成（项目中我们更新多张表数据要么都更新成功，否则就回滚）\n- **一致性（Consistency）** 事务前后数据的完整性保持一致\n- **隔离性（Isolation）** 多个事务同时执行时保证它们之间不受干扰隔离开来\n- **持久性（Durability）** 事务完成对于数据库的数据改变是永久性的\n\n### 事务隔离\n项目中当多个事务同时发生时，事务之间由于访问的数据可能会有重叠在高并发情况下会导致各类问题\n- **脏读** ：A读取到B事务未提交的数据，如果B事务数据回滚，A读取的就是已回滚的脏数据\n- **不可重复读** ：一次事务中读取表同一行数据多次内容不一致（通常发生于更新操作后）\n- **幻读** ：一次事务中读取表数据多次数量不一致（通常发生于新增删除操作后）\n\n#### 事务隔离级别\n|隔离级别|脏读|不可重复读|幻读|\n|-|:-:|:-:|-|\n|READ_UNCOMMITTED（读未提交）|会|会|会|\n|READ_COMMITTED（读已提交）|不会|会|会|\n|REPEATABLE_READ（可重复读）|不会|不会|会|\n|SERIALIZABLE（串行）|不会|不会|不会|\n\n事务隔离就是来防止并发产生的各类问题，`Serializable` （串行）级别最高满足`ACID`事务所有特性，类似数据库锁全表操作其余数据库操作都不能进行只能等待，所以应根据实际情况去先选择隔离级别\n\n#### 数据库事务隔离级别\n- **MySql** 默认事务隔离级别`REPEATABLE_READ` 可重复读\n\t``` sql\n\t# 查看当前的事务隔离级别：\n\tselect @@global.tx_isolation;\n\t#修改当前事务隔离级别：\n\tset global transaction isolation level read committed;\n\t```\n- **Oracle** 支持`READ_COMMITTED` 和 `SERIALIZABLE`这两种事务隔离级别，默认事务隔离级别`READ_COMMITTED`读已提交","source":"_posts/事务隔离性.md","raw":"---\ntitle: 事务的四大特性和隔离级别\ntags:\n  - Java\ncategories:\n  - Java\ntoc: false\ndate: 2020-05-22 23:51:43\n---\n\n![](/images/java.jpg)\n\n### 事务的特性 ACID \n事务有四大特性\n- **原子性（Atomicity）** 事务的一系列操作要么都完成，要么都不完成（项目中我们更新多张表数据要么都更新成功，否则就回滚）\n- **一致性（Consistency）** 事务前后数据的完整性保持一致\n- **隔离性（Isolation）** 多个事务同时执行时保证它们之间不受干扰隔离开来\n- **持久性（Durability）** 事务完成对于数据库的数据改变是永久性的\n\n### 事务隔离\n项目中当多个事务同时发生时，事务之间由于访问的数据可能会有重叠在高并发情况下会导致各类问题\n- **脏读** ：A读取到B事务未提交的数据，如果B事务数据回滚，A读取的就是已回滚的脏数据\n- **不可重复读** ：一次事务中读取表同一行数据多次内容不一致（通常发生于更新操作后）\n- **幻读** ：一次事务中读取表数据多次数量不一致（通常发生于新增删除操作后）\n\n#### 事务隔离级别\n|隔离级别|脏读|不可重复读|幻读|\n|-|:-:|:-:|-|\n|READ_UNCOMMITTED（读未提交）|会|会|会|\n|READ_COMMITTED（读已提交）|不会|会|会|\n|REPEATABLE_READ（可重复读）|不会|不会|会|\n|SERIALIZABLE（串行）|不会|不会|不会|\n\n事务隔离就是来防止并发产生的各类问题，`Serializable` （串行）级别最高满足`ACID`事务所有特性，类似数据库锁全表操作其余数据库操作都不能进行只能等待，所以应根据实际情况去先选择隔离级别\n\n#### 数据库事务隔离级别\n- **MySql** 默认事务隔离级别`REPEATABLE_READ` 可重复读\n\t``` sql\n\t# 查看当前的事务隔离级别：\n\tselect @@global.tx_isolation;\n\t#修改当前事务隔离级别：\n\tset global transaction isolation level read committed;\n\t```\n- **Oracle** 支持`READ_COMMITTED` 和 `SERIALIZABLE`这两种事务隔离级别，默认事务隔离级别`READ_COMMITTED`读已提交","slug":"事务隔离性","published":1,"updated":"2020-08-10T01:48:44.757Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9ag004yjsuduqpbd8br","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"事务的特性-ACID\"><a href=\"#事务的特性-ACID\" class=\"headerlink\" title=\"事务的特性 ACID\"></a>事务的特性 ACID</h3><p>事务有四大特性</p>\n<ul>\n<li><strong>原子性（Atomicity）</strong> 事务的一系列操作要么都完成，要么都不完成（项目中我们更新多张表数据要么都更新成功，否则就回滚）</li>\n<li><strong>一致性（Consistency）</strong> 事务前后数据的完整性保持一致</li>\n<li><strong>隔离性（Isolation）</strong> 多个事务同时执行时保证它们之间不受干扰隔离开来</li>\n<li><strong>持久性（Durability）</strong> 事务完成对于数据库的数据改变是永久性的</li>\n</ul>\n<h3 id=\"事务隔离\"><a href=\"#事务隔离\" class=\"headerlink\" title=\"事务隔离\"></a>事务隔离</h3><p>项目中当多个事务同时发生时，事务之间由于访问的数据可能会有重叠在高并发情况下会导致各类问题</p>\n<ul>\n<li><strong>脏读</strong> ：A读取到B事务未提交的数据，如果B事务数据回滚，A读取的就是已回滚的脏数据</li>\n<li><strong>不可重复读</strong> ：一次事务中读取表同一行数据多次内容不一致（通常发生于更新操作后）</li>\n<li><strong>幻读</strong> ：一次事务中读取表数据多次数量不一致（通常发生于新增删除操作后）</li>\n</ul>\n<h4 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h4><table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>READ_UNCOMMITTED（读未提交）</td>\n<td style=\"text-align:center\">会</td>\n<td style=\"text-align:center\">会</td>\n<td>会</td>\n</tr>\n<tr>\n<td>READ_COMMITTED（读已提交）</td>\n<td style=\"text-align:center\">不会</td>\n<td style=\"text-align:center\">会</td>\n<td>会</td>\n</tr>\n<tr>\n<td>REPEATABLE_READ（可重复读）</td>\n<td style=\"text-align:center\">不会</td>\n<td style=\"text-align:center\">不会</td>\n<td>会</td>\n</tr>\n<tr>\n<td>SERIALIZABLE（串行）</td>\n<td style=\"text-align:center\">不会</td>\n<td style=\"text-align:center\">不会</td>\n<td>不会</td>\n</tr>\n</tbody>\n</table>\n<p>事务隔离就是来防止并发产生的各类问题，<code>Serializable</code> （串行）级别最高满足<code>ACID</code>事务所有特性，类似数据库锁全表操作其余数据库操作都不能进行只能等待，所以应根据实际情况去先选择隔离级别</p>\n<h4 id=\"数据库事务隔离级别\"><a href=\"#数据库事务隔离级别\" class=\"headerlink\" title=\"数据库事务隔离级别\"></a>数据库事务隔离级别</h4><ul>\n<li><p><strong>MySql</strong> 默认事务隔离级别<code>REPEATABLE_READ</code> 可重复读</p>\n  <pre><code class=\"hljs sql\"><span class=\"hljs-comment\"># 查看当前的事务隔离级别：</span>\n<span class=\"hljs-keyword\">select</span> @@global.tx_isolation;\n<span class=\"hljs-comment\">#修改当前事务隔离级别：</span>\n<span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">global</span> <span class=\"hljs-keyword\">transaction</span> <span class=\"hljs-keyword\">isolation</span> <span class=\"hljs-keyword\">level</span> <span class=\"hljs-keyword\">read</span> committed;</code></pre>\n</li>\n<li><p><strong>Oracle</strong> 支持<code>READ_COMMITTED</code> 和 <code>SERIALIZABLE</code>这两种事务隔离级别，默认事务隔离级别<code>READ_COMMITTED</code>读已提交</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"事务的特性-ACID\"><a href=\"#事务的特性-ACID\" class=\"headerlink\" title=\"事务的特性 ACID\"></a>事务的特性 ACID</h3><p>事务有四大特性</p>\n<ul>\n<li><strong>原子性（Atomicity）</strong> 事务的一系列操作要么都完成，要么都不完成（项目中我们更新多张表数据要么都更新成功，否则就回滚）</li>\n<li><strong>一致性（Consistency）</strong> 事务前后数据的完整性保持一致</li>\n<li><strong>隔离性（Isolation）</strong> 多个事务同时执行时保证它们之间不受干扰隔离开来</li>\n<li><strong>持久性（Durability）</strong> 事务完成对于数据库的数据改变是永久性的</li>\n</ul>\n<h3 id=\"事务隔离\"><a href=\"#事务隔离\" class=\"headerlink\" title=\"事务隔离\"></a>事务隔离</h3><p>项目中当多个事务同时发生时，事务之间由于访问的数据可能会有重叠在高并发情况下会导致各类问题</p>\n<ul>\n<li><strong>脏读</strong> ：A读取到B事务未提交的数据，如果B事务数据回滚，A读取的就是已回滚的脏数据</li>\n<li><strong>不可重复读</strong> ：一次事务中读取表同一行数据多次内容不一致（通常发生于更新操作后）</li>\n<li><strong>幻读</strong> ：一次事务中读取表数据多次数量不一致（通常发生于新增删除操作后）</li>\n</ul>\n<h4 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h4><table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>READ_UNCOMMITTED（读未提交）</td>\n<td style=\"text-align:center\">会</td>\n<td style=\"text-align:center\">会</td>\n<td>会</td>\n</tr>\n<tr>\n<td>READ_COMMITTED（读已提交）</td>\n<td style=\"text-align:center\">不会</td>\n<td style=\"text-align:center\">会</td>\n<td>会</td>\n</tr>\n<tr>\n<td>REPEATABLE_READ（可重复读）</td>\n<td style=\"text-align:center\">不会</td>\n<td style=\"text-align:center\">不会</td>\n<td>会</td>\n</tr>\n<tr>\n<td>SERIALIZABLE（串行）</td>\n<td style=\"text-align:center\">不会</td>\n<td style=\"text-align:center\">不会</td>\n<td>不会</td>\n</tr>\n</tbody>\n</table>\n<p>事务隔离就是来防止并发产生的各类问题，<code>Serializable</code> （串行）级别最高满足<code>ACID</code>事务所有特性，类似数据库锁全表操作其余数据库操作都不能进行只能等待，所以应根据实际情况去先选择隔离级别</p>\n<h4 id=\"数据库事务隔离级别\"><a href=\"#数据库事务隔离级别\" class=\"headerlink\" title=\"数据库事务隔离级别\"></a>数据库事务隔离级别</h4><ul>\n<li><p><strong>MySql</strong> 默认事务隔离级别<code>REPEATABLE_READ</code> 可重复读</p>\n  <pre><code class=\"hljs sql\"><span class=\"hljs-comment\"># 查看当前的事务隔离级别：</span>\n<span class=\"hljs-keyword\">select</span> @@global.tx_isolation;\n<span class=\"hljs-comment\">#修改当前事务隔离级别：</span>\n<span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">global</span> <span class=\"hljs-keyword\">transaction</span> <span class=\"hljs-keyword\">isolation</span> <span class=\"hljs-keyword\">level</span> <span class=\"hljs-keyword\">read</span> committed;</code></pre>\n</li>\n<li><p><strong>Oracle</strong> 支持<code>READ_COMMITTED</code> 和 <code>SERIALIZABLE</code>这两种事务隔离级别，默认事务隔离级别<code>READ_COMMITTED</code>读已提交</p>\n</li>\n</ul>\n"},{"title":"大数据 Json 压缩","originContent":"![](/images/java.jpg)\n\n### 问题\n对于页面大数据传输`Content-type:text/html`可以看到`Content-Encoding: gzip`进行了`gzip`压缩，加快了页面渲染默认`application/json`不属于普通格式不会被压缩处理，当遇到一个大`json`时，页面渲染会特别的慢\n\n### SpringBoot 开启gzip 压缩\n`SpringBoot` 内置了 `Tomcat`可以通过配置文件进行`Gzip`压缩\n``` yml\nserver:\n  compression:\n    enabled: true\n    min-response-size: 1024KB\n```\n- min-response-size 相应大于某值后启用压缩\n- mime-types 媒体类型需要压缩的类：application/json、text/html 等\n- enabled 是否开启压缩，默认是 false\n\n``` java\npublic class Compression {\n    private boolean enabled = false;\n    private String[] mimeTypes = new String[]{\"text/html\", \"text/xml\", \"text/plain\", \"text/css\", \"text/javascript\", \"application/javascript\", \"application/json\", \"application/xml\"};\n    private String[] excludedUserAgents = null;\n    private DataSize minResponseSize = DataSize.ofKilobytes(2L);\n}\n```\n","toc":false,"date":"2020-09-17T01:41:13.000Z","_content":"\n![](/images/java.jpg)\n\n### 问题\n对于页面大数据传输`Content-type:text/html`可以看到`Content-Encoding: gzip`进行了`gzip`压缩，加快了页面渲染默认`application/json`不属于普通格式不会被压缩处理，当遇到一个大`json`时，页面渲染会特别的慢\n\n### SpringBoot 开启gzip 压缩\n`SpringBoot` 内置了 `Tomcat`可以通过配置文件进行`Gzip`压缩\n``` yml\nserver:\n  compression:\n    enabled: true\n    min-response-size: 1024KB\n```\n- min-response-size 相应大于某值后启用压缩\n- mime-types 媒体类型需要压缩的类：application/json、text/html 等\n- enabled 是否开启压缩，默认是 false\n\n``` java\npublic class Compression {\n    private boolean enabled = false;\n    private String[] mimeTypes = new String[]{\"text/html\", \"text/xml\", \"text/plain\", \"text/css\", \"text/javascript\", \"application/javascript\", \"application/json\", \"application/xml\"};\n    private String[] excludedUserAgents = null;\n    private DataSize minResponseSize = DataSize.ofKilobytes(2L);\n}\n```\n","source":"_posts/大数据-Json-压缩.md","raw":"---\ntitle: 大数据 Json 压缩\ntags:\n  - Java\noriginContent: >\n  ![](/images/java.jpg)\n\n\n  ### 问题\n\n  对于页面大数据传输`Content-type:text/html`可以看到`Content-Encoding:\n  gzip`进行了`gzip`压缩，加快了页面渲染默认`application/json`不属于普通格式不会被压缩处理，当遇到一个大`json`时，页面渲染会特别的慢\n\n\n  ### SpringBoot 开启gzip 压缩\n\n  `SpringBoot` 内置了 `Tomcat`可以通过配置文件进行`Gzip`压缩\n\n  ``` yml\n\n  server:\n    compression:\n      enabled: true\n      min-response-size: 1024KB\n  ```\n\n  - min-response-size 相应大于某值后启用压缩\n\n  - mime-types 媒体类型需要压缩的类：application/json、text/html 等\n\n  - enabled 是否开启压缩，默认是 false\n\n\n  ``` java\n\n  public class Compression {\n      private boolean enabled = false;\n      private String[] mimeTypes = new String[]{\"text/html\", \"text/xml\", \"text/plain\", \"text/css\", \"text/javascript\", \"application/javascript\", \"application/json\", \"application/xml\"};\n      private String[] excludedUserAgents = null;\n      private DataSize minResponseSize = DataSize.ofKilobytes(2L);\n  }\n\n  ```\ncategories:\n  - 代码块\ntoc: false\ndate: 2020-09-17 09:41:13\n---\n\n![](/images/java.jpg)\n\n### 问题\n对于页面大数据传输`Content-type:text/html`可以看到`Content-Encoding: gzip`进行了`gzip`压缩，加快了页面渲染默认`application/json`不属于普通格式不会被压缩处理，当遇到一个大`json`时，页面渲染会特别的慢\n\n### SpringBoot 开启gzip 压缩\n`SpringBoot` 内置了 `Tomcat`可以通过配置文件进行`Gzip`压缩\n``` yml\nserver:\n  compression:\n    enabled: true\n    min-response-size: 1024KB\n```\n- min-response-size 相应大于某值后启用压缩\n- mime-types 媒体类型需要压缩的类：application/json、text/html 等\n- enabled 是否开启压缩，默认是 false\n\n``` java\npublic class Compression {\n    private boolean enabled = false;\n    private String[] mimeTypes = new String[]{\"text/html\", \"text/xml\", \"text/plain\", \"text/css\", \"text/javascript\", \"application/javascript\", \"application/json\", \"application/xml\"};\n    private String[] excludedUserAgents = null;\n    private DataSize minResponseSize = DataSize.ofKilobytes(2L);\n}\n```\n","slug":"大数据-Json-压缩","published":1,"updated":"2020-09-17T06:33:53.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9ai0052jsudbepocj3z","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>对于页面大数据传输<code>Content-type:text/html</code>可以看到<code>Content-Encoding: gzip</code>进行了<code>gzip</code>压缩，加快了页面渲染默认<code>application/json</code>不属于普通格式不会被压缩处理，当遇到一个大<code>json</code>时，页面渲染会特别的慢</p>\n<h3 id=\"SpringBoot-开启gzip-压缩\"><a href=\"#SpringBoot-开启gzip-压缩\" class=\"headerlink\" title=\"SpringBoot 开启gzip 压缩\"></a>SpringBoot 开启gzip 压缩</h3><p><code>SpringBoot</code> 内置了 <code>Tomcat</code>可以通过配置文件进行<code>Gzip</code>压缩<br><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">server:</span>\n  <span class=\"hljs-attr\">compression:</span>\n    <span class=\"hljs-attr\">enabled:</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-attr\">min-response-size:</span> <span class=\"hljs-string\">1024KB</span></code></pre></p>\n<ul>\n<li>min-response-size 相应大于某值后启用压缩</li>\n<li>mime-types 媒体类型需要压缩的类：application/json、text/html 等</li>\n<li>enabled 是否开启压缩，默认是 false</li>\n</ul>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Compression</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> enabled = <span class=\"hljs-keyword\">false</span>;\n    <span class=\"hljs-keyword\">private</span> String[] mimeTypes = <span class=\"hljs-keyword\">new</span> String[]&#123;<span class=\"hljs-string\">\"text/html\"</span>, <span class=\"hljs-string\">\"text/xml\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>, <span class=\"hljs-string\">\"text/css\"</span>, <span class=\"hljs-string\">\"text/javascript\"</span>, <span class=\"hljs-string\">\"application/javascript\"</span>, <span class=\"hljs-string\">\"application/json\"</span>, <span class=\"hljs-string\">\"application/xml\"</span>&#125;;\n    <span class=\"hljs-keyword\">private</span> String[] excludedUserAgents = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-keyword\">private</span> DataSize minResponseSize = DataSize.ofKilobytes(<span class=\"hljs-number\">2L</span>);\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>对于页面大数据传输<code>Content-type:text/html</code>可以看到<code>Content-Encoding: gzip</code>进行了<code>gzip</code>压缩，加快了页面渲染默认<code>application/json</code>不属于普通格式不会被压缩处理，当遇到一个大<code>json</code>时，页面渲染会特别的慢</p>\n<h3 id=\"SpringBoot-开启gzip-压缩\"><a href=\"#SpringBoot-开启gzip-压缩\" class=\"headerlink\" title=\"SpringBoot 开启gzip 压缩\"></a>SpringBoot 开启gzip 压缩</h3><p><code>SpringBoot</code> 内置了 <code>Tomcat</code>可以通过配置文件进行<code>Gzip</code>压缩<br><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">server:</span>\n  <span class=\"hljs-attr\">compression:</span>\n    <span class=\"hljs-attr\">enabled:</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-attr\">min-response-size:</span> <span class=\"hljs-string\">1024KB</span></code></pre></p>\n<ul>\n<li>min-response-size 相应大于某值后启用压缩</li>\n<li>mime-types 媒体类型需要压缩的类：application/json、text/html 等</li>\n<li>enabled 是否开启压缩，默认是 false</li>\n</ul>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Compression</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> enabled = <span class=\"hljs-keyword\">false</span>;\n    <span class=\"hljs-keyword\">private</span> String[] mimeTypes = <span class=\"hljs-keyword\">new</span> String[]&#123;<span class=\"hljs-string\">\"text/html\"</span>, <span class=\"hljs-string\">\"text/xml\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>, <span class=\"hljs-string\">\"text/css\"</span>, <span class=\"hljs-string\">\"text/javascript\"</span>, <span class=\"hljs-string\">\"application/javascript\"</span>, <span class=\"hljs-string\">\"application/json\"</span>, <span class=\"hljs-string\">\"application/xml\"</span>&#125;;\n    <span class=\"hljs-keyword\">private</span> String[] excludedUserAgents = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-keyword\">private</span> DataSize minResponseSize = DataSize.ofKilobytes(<span class=\"hljs-number\">2L</span>);\n&#125;</code></pre>\n"},{"title":"学习 CompletableFuture","toc":false,"date":"2019-09-17T03:28:10.000Z","_content":"\n![](/images/java.jpg)\n> java 8 函数编程写爽了，发现线程异步调用也可以用函数编程来写逻辑上更清晰代码更简洁明了，特地记录下学习笔记\n\n## CompletableFuture\nCompletableFuture 属于 Future Api 功能上的拓展，它实现了`Future`接口和`CompletableStage`接口简化了异步编程的复杂性并可使用函数编程进行编码，能适应项目中各种场景需求灵活编写。`CompletableStage`提供了线程阶段性调用当现场完成某一些阶段继续进行某一些操作。\n\n#### 创建\nCompletableFuture 的创建常用 supplyAsync() 和 runAsync() 区别 supplyAsync()用于需要返回值，其中`Executor`参数可传入线程池以避免浪费资源，默认使用`ForkJoinPool`线程池，建议传入线程池便于自行控制线程池大小等各类设置。\n\n``` java\n/**\n *  返回值为String异步调用\n */\nCompletable<String> hasResult = CompletableFuture.supplyAsync(() -> {\n\t代码块\n\treturn 结果;\n})\n\n/**\n *  无返回值异步调用\n */\nCompletable<Void> noResult = CompletableFuture.runAsync(() -> {\n\t代码块\n})\n```\n \n#### 转换和运行\nCompletableFuture.get()会阻塞线程直到线程调用完毕返回结果，如果我想将结果进行其他逻辑处理必须要等待结果完成，对于异步构建我们可以使用回调方法不必等待结果返回\n\n- __thenApply()__  有返回值转化，可以获取上一步 CompletableFuture 结果进行处理转化，类似于stream 中的 map() 方法\n- __thenCompose()__ 类似于 thenApply() 用于多个 CompletableFutre 结果处理，类似于 stream 中的 flatMap() 方法\n- __thenRun()__    无返回值转化，不可获取上一步 CompletableFuture 结果\n- __thenAccept()__ 无返回值转化，可以获取上一步 CompletableFuture 结果\n- __thenCombine()__ 组合2个 独立 CompletableFuture 并发运行当2个都完成后进行回调结果转化\n- __thenAcceptBoth()__ 类似于thenCombine(),但无返回值转化\n- __allOf()__ 多个 CompletableFuture 并发运行无返回值，所有结果需要通过特殊处理来获取\n- __anyOf()__ 多个 CompletableFuture 并发运行第一个完成的结果\n- __applyToEither__ 两个 CompletableFuture 取第一个完成的结果进行处理并返回\n- __acceptEither__ 两个 CompletableFuture 取第一个完成的结果进行处理无返回\n\n\n\n> 回调方法带有Async的方法为异步调用为独立的线程与主线程不在同一个线程中，且可传入线程池对象或使用默认的`ForkJoinPool`\n\n``` java\n/**\n *  thenApply 类型转化\n */\nCompletableFuture threadOne = Completable.supplyAsync(() -> ｛\n\t代码块\n\treturn 结果;\n｝).thenApply(s->{\n\t代码块(这里可以引用到s)\n\treturn 结果;\n}).thenAccept(s->{\n\t代码块\n}).thenRun(()->{\n\t代码块\n})；\n\n/**\n *  thenCompose 用于 CompletableFuture 之间链接\n */\nCompletableFuture compose = CompletableFuture.supplyAsync(() -> {\n\t代码块\n\treturn 结果;\n}).thenCompose(s -> CompletableFuture.supplyAsync(()->{\n\t代码块(这里可以引用到s)\n\treturn 结果;\n}))\n\n\n/**\n *  thenCombine 两个 CompletableFuture 并发运行后结果回调\n */\nCompletableFuture combineOne = CompletableFuture.supplyAsync(() -> ｛\n\t代码块\n\treturn 结果;\n});\n\nCompletableFuture combineTwo = CompletableFuture.supplyAsync(() -> ｛\n\t代码块\n\treturn 结果;\n});\n\nCompletableFuture combineThread = combineOne.thenCombine(combineTwo, (o, o2) -> {\n\t代码块\n\treturn o + o2;\n});\n\n/**\n *  allOf 多个 CompletableFuture 全部并行处理完毕后进行处理\n */\nCompletableFuture allOne = CompletableFuture.runAsync(() -> {\n\t代码块\n})\n\nCompletableFuture allTwo = CompletableFuture.runAsync(() -> {\n\t代码块\n})\n\nCompletableFuture allOf = CompletableFuture.allOf(allOne,allTwo);\n\n```\n\n#### 完成结束\n获取异步调用结果使用一下函数\n- __get()__ 阻塞方法等待直到线程执行完毕，会抛出checked异常需要`catch`或者`throws`\n- __get(lont timeOut,TimeUnit unit)__  带有超时时间的阻塞方法\n- __getNow(T valueIfAbsent)__ 立刻获取结果如果没有则返回 `valueIfAbsent`值\n- __join()__ 阻塞方法与get()不同的是会抛出`unchecked`异常\n- __complete(String value)__ 线程直接完成并返回`value`值\n\n#### 异常补偿\n在线程链式调用中如果某一步发生异常后续的所有调用都将不会执行，为了更好的处理可以引入异常补偿，根据实际的业务需求处理异常\n\n-__whenComplete()__ 当完成调用可对有异常情况进行处理\n-__handle()__ 相当于whenComplete()+结果转化","source":"_posts/学习-CompletableFuture.md","raw":"---\ntitle: 学习 CompletableFuture\ntags:\n  - 多线程\ncategories:\n  - Java\ntoc: false\ndate: 2019-09-17 11:28:10\n---\n\n![](/images/java.jpg)\n> java 8 函数编程写爽了，发现线程异步调用也可以用函数编程来写逻辑上更清晰代码更简洁明了，特地记录下学习笔记\n\n## CompletableFuture\nCompletableFuture 属于 Future Api 功能上的拓展，它实现了`Future`接口和`CompletableStage`接口简化了异步编程的复杂性并可使用函数编程进行编码，能适应项目中各种场景需求灵活编写。`CompletableStage`提供了线程阶段性调用当现场完成某一些阶段继续进行某一些操作。\n\n#### 创建\nCompletableFuture 的创建常用 supplyAsync() 和 runAsync() 区别 supplyAsync()用于需要返回值，其中`Executor`参数可传入线程池以避免浪费资源，默认使用`ForkJoinPool`线程池，建议传入线程池便于自行控制线程池大小等各类设置。\n\n``` java\n/**\n *  返回值为String异步调用\n */\nCompletable<String> hasResult = CompletableFuture.supplyAsync(() -> {\n\t代码块\n\treturn 结果;\n})\n\n/**\n *  无返回值异步调用\n */\nCompletable<Void> noResult = CompletableFuture.runAsync(() -> {\n\t代码块\n})\n```\n \n#### 转换和运行\nCompletableFuture.get()会阻塞线程直到线程调用完毕返回结果，如果我想将结果进行其他逻辑处理必须要等待结果完成，对于异步构建我们可以使用回调方法不必等待结果返回\n\n- __thenApply()__  有返回值转化，可以获取上一步 CompletableFuture 结果进行处理转化，类似于stream 中的 map() 方法\n- __thenCompose()__ 类似于 thenApply() 用于多个 CompletableFutre 结果处理，类似于 stream 中的 flatMap() 方法\n- __thenRun()__    无返回值转化，不可获取上一步 CompletableFuture 结果\n- __thenAccept()__ 无返回值转化，可以获取上一步 CompletableFuture 结果\n- __thenCombine()__ 组合2个 独立 CompletableFuture 并发运行当2个都完成后进行回调结果转化\n- __thenAcceptBoth()__ 类似于thenCombine(),但无返回值转化\n- __allOf()__ 多个 CompletableFuture 并发运行无返回值，所有结果需要通过特殊处理来获取\n- __anyOf()__ 多个 CompletableFuture 并发运行第一个完成的结果\n- __applyToEither__ 两个 CompletableFuture 取第一个完成的结果进行处理并返回\n- __acceptEither__ 两个 CompletableFuture 取第一个完成的结果进行处理无返回\n\n\n\n> 回调方法带有Async的方法为异步调用为独立的线程与主线程不在同一个线程中，且可传入线程池对象或使用默认的`ForkJoinPool`\n\n``` java\n/**\n *  thenApply 类型转化\n */\nCompletableFuture threadOne = Completable.supplyAsync(() -> ｛\n\t代码块\n\treturn 结果;\n｝).thenApply(s->{\n\t代码块(这里可以引用到s)\n\treturn 结果;\n}).thenAccept(s->{\n\t代码块\n}).thenRun(()->{\n\t代码块\n})；\n\n/**\n *  thenCompose 用于 CompletableFuture 之间链接\n */\nCompletableFuture compose = CompletableFuture.supplyAsync(() -> {\n\t代码块\n\treturn 结果;\n}).thenCompose(s -> CompletableFuture.supplyAsync(()->{\n\t代码块(这里可以引用到s)\n\treturn 结果;\n}))\n\n\n/**\n *  thenCombine 两个 CompletableFuture 并发运行后结果回调\n */\nCompletableFuture combineOne = CompletableFuture.supplyAsync(() -> ｛\n\t代码块\n\treturn 结果;\n});\n\nCompletableFuture combineTwo = CompletableFuture.supplyAsync(() -> ｛\n\t代码块\n\treturn 结果;\n});\n\nCompletableFuture combineThread = combineOne.thenCombine(combineTwo, (o, o2) -> {\n\t代码块\n\treturn o + o2;\n});\n\n/**\n *  allOf 多个 CompletableFuture 全部并行处理完毕后进行处理\n */\nCompletableFuture allOne = CompletableFuture.runAsync(() -> {\n\t代码块\n})\n\nCompletableFuture allTwo = CompletableFuture.runAsync(() -> {\n\t代码块\n})\n\nCompletableFuture allOf = CompletableFuture.allOf(allOne,allTwo);\n\n```\n\n#### 完成结束\n获取异步调用结果使用一下函数\n- __get()__ 阻塞方法等待直到线程执行完毕，会抛出checked异常需要`catch`或者`throws`\n- __get(lont timeOut,TimeUnit unit)__  带有超时时间的阻塞方法\n- __getNow(T valueIfAbsent)__ 立刻获取结果如果没有则返回 `valueIfAbsent`值\n- __join()__ 阻塞方法与get()不同的是会抛出`unchecked`异常\n- __complete(String value)__ 线程直接完成并返回`value`值\n\n#### 异常补偿\n在线程链式调用中如果某一步发生异常后续的所有调用都将不会执行，为了更好的处理可以引入异常补偿，根据实际的业务需求处理异常\n\n-__whenComplete()__ 当完成调用可对有异常情况进行处理\n-__handle()__ 相当于whenComplete()+结果转化","slug":"学习-CompletableFuture","published":1,"updated":"2020-08-10T01:48:44.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9an0055jsudm975x6lg","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>java 8 函数编程写爽了，发现线程异步调用也可以用函数编程来写逻辑上更清晰代码更简洁明了，特地记录下学习笔记</p>\n</blockquote>\n<h2 id=\"CompletableFuture\"><a href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"></a>CompletableFuture</h2><p>CompletableFuture 属于 Future Api 功能上的拓展，它实现了<code>Future</code>接口和<code>CompletableStage</code>接口简化了异步编程的复杂性并可使用函数编程进行编码，能适应项目中各种场景需求灵活编写。<code>CompletableStage</code>提供了线程阶段性调用当现场完成某一些阶段继续进行某一些操作。</p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>CompletableFuture 的创建常用 supplyAsync() 和 runAsync() 区别 supplyAsync()用于需要返回值，其中<code>Executor</code>参数可传入线程池以避免浪费资源，默认使用<code>ForkJoinPool</code>线程池，建议传入线程池便于自行控制线程池大小等各类设置。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n *  返回值为String异步调用\n */</span>\nCompletable&lt;String&gt; hasResult = CompletableFuture.supplyAsync(() -&gt; &#123;\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;)\n\n<span class=\"hljs-comment\">/**\n *  无返回值异步调用\n */</span>\nCompletable&lt;Void&gt; noResult = CompletableFuture.runAsync(() -&gt; &#123;\n\t代码块\n&#125;)</code></pre>\n<h4 id=\"转换和运行\"><a href=\"#转换和运行\" class=\"headerlink\" title=\"转换和运行\"></a>转换和运行</h4><p>CompletableFuture.get()会阻塞线程直到线程调用完毕返回结果，如果我想将结果进行其他逻辑处理必须要等待结果完成，对于异步构建我们可以使用回调方法不必等待结果返回</p>\n<ul>\n<li><strong>thenApply()</strong>  有返回值转化，可以获取上一步 CompletableFuture 结果进行处理转化，类似于stream 中的 map() 方法</li>\n<li><strong>thenCompose()</strong> 类似于 thenApply() 用于多个 CompletableFutre 结果处理，类似于 stream 中的 flatMap() 方法</li>\n<li><strong>thenRun()</strong>    无返回值转化，不可获取上一步 CompletableFuture 结果</li>\n<li><strong>thenAccept()</strong> 无返回值转化，可以获取上一步 CompletableFuture 结果</li>\n<li><strong>thenCombine()</strong> 组合2个 独立 CompletableFuture 并发运行当2个都完成后进行回调结果转化</li>\n<li><strong>thenAcceptBoth()</strong> 类似于thenCombine(),但无返回值转化</li>\n<li><strong>allOf()</strong> 多个 CompletableFuture 并发运行无返回值，所有结果需要通过特殊处理来获取</li>\n<li><strong>anyOf()</strong> 多个 CompletableFuture 并发运行第一个完成的结果</li>\n<li><strong>applyToEither</strong> 两个 CompletableFuture 取第一个完成的结果进行处理并返回</li>\n<li><strong>acceptEither</strong> 两个 CompletableFuture 取第一个完成的结果进行处理无返回</li>\n</ul>\n<blockquote>\n<p>回调方法带有Async的方法为异步调用为独立的线程与主线程不在同一个线程中，且可传入线程池对象或使用默认的<code>ForkJoinPool</code></p>\n</blockquote>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n *  thenApply 类型转化\n */</span>\nCompletableFuture threadOne = Completable.supplyAsync(() -&gt; ｛\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> 结果;\n｝).thenApply(s-&gt;&#123;\n\t代码块(这里可以引用到s)\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;).thenAccept(s-&gt;&#123;\n\t代码块\n&#125;).thenRun(()-&gt;&#123;\n\t代码块\n&#125;)；\n\n<span class=\"hljs-comment\">/**\n *  thenCompose 用于 CompletableFuture 之间链接\n */</span>\nCompletableFuture compose = CompletableFuture.supplyAsync(() -&gt; &#123;\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;).thenCompose(s -&gt; CompletableFuture.supplyAsync(()-&gt;&#123;\n\t代码块(这里可以引用到s)\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;))\n\n\n<span class=\"hljs-comment\">/**\n *  thenCombine 两个 CompletableFuture 并发运行后结果回调\n */</span>\nCompletableFuture combineOne = CompletableFuture.supplyAsync(() -&gt; ｛\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;);\n\nCompletableFuture combineTwo = CompletableFuture.supplyAsync(() -&gt; ｛\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;);\n\nCompletableFuture combineThread = combineOne.thenCombine(combineTwo, (o, o2) -&gt; &#123;\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> o + o2;\n&#125;);\n\n<span class=\"hljs-comment\">/**\n *  allOf 多个 CompletableFuture 全部并行处理完毕后进行处理\n */</span>\nCompletableFuture allOne = CompletableFuture.runAsync(() -&gt; &#123;\n\t代码块\n&#125;)\n\nCompletableFuture allTwo = CompletableFuture.runAsync(() -&gt; &#123;\n\t代码块\n&#125;)\n\nCompletableFuture allOf = CompletableFuture.allOf(allOne,allTwo);</code></pre>\n<h4 id=\"完成结束\"><a href=\"#完成结束\" class=\"headerlink\" title=\"完成结束\"></a>完成结束</h4><p>获取异步调用结果使用一下函数</p>\n<ul>\n<li><strong>get()</strong> 阻塞方法等待直到线程执行完毕，会抛出checked异常需要<code>catch</code>或者<code>throws</code></li>\n<li><strong>get(lont timeOut,TimeUnit unit)</strong>  带有超时时间的阻塞方法</li>\n<li><strong>getNow(T valueIfAbsent)</strong> 立刻获取结果如果没有则返回 <code>valueIfAbsent</code>值</li>\n<li><strong>join()</strong> 阻塞方法与get()不同的是会抛出<code>unchecked</code>异常</li>\n<li><strong>complete(String value)</strong> 线程直接完成并返回<code>value</code>值</li>\n</ul>\n<h4 id=\"异常补偿\"><a href=\"#异常补偿\" class=\"headerlink\" title=\"异常补偿\"></a>异常补偿</h4><p>在线程链式调用中如果某一步发生异常后续的所有调用都将不会执行，为了更好的处理可以引入异常补偿，根据实际的业务需求处理异常</p>\n<p>-<strong>whenComplete()</strong> 当完成调用可对有异常情况进行处理<br>-<strong>handle()</strong> 相当于whenComplete()+结果转化</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>java 8 函数编程写爽了，发现线程异步调用也可以用函数编程来写逻辑上更清晰代码更简洁明了，特地记录下学习笔记</p>\n</blockquote>\n<h2 id=\"CompletableFuture\"><a href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"></a>CompletableFuture</h2><p>CompletableFuture 属于 Future Api 功能上的拓展，它实现了<code>Future</code>接口和<code>CompletableStage</code>接口简化了异步编程的复杂性并可使用函数编程进行编码，能适应项目中各种场景需求灵活编写。<code>CompletableStage</code>提供了线程阶段性调用当现场完成某一些阶段继续进行某一些操作。</p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>CompletableFuture 的创建常用 supplyAsync() 和 runAsync() 区别 supplyAsync()用于需要返回值，其中<code>Executor</code>参数可传入线程池以避免浪费资源，默认使用<code>ForkJoinPool</code>线程池，建议传入线程池便于自行控制线程池大小等各类设置。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n *  返回值为String异步调用\n */</span>\nCompletable&lt;String&gt; hasResult = CompletableFuture.supplyAsync(() -&gt; &#123;\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;)\n\n<span class=\"hljs-comment\">/**\n *  无返回值异步调用\n */</span>\nCompletable&lt;Void&gt; noResult = CompletableFuture.runAsync(() -&gt; &#123;\n\t代码块\n&#125;)</code></pre>\n<h4 id=\"转换和运行\"><a href=\"#转换和运行\" class=\"headerlink\" title=\"转换和运行\"></a>转换和运行</h4><p>CompletableFuture.get()会阻塞线程直到线程调用完毕返回结果，如果我想将结果进行其他逻辑处理必须要等待结果完成，对于异步构建我们可以使用回调方法不必等待结果返回</p>\n<ul>\n<li><strong>thenApply()</strong>  有返回值转化，可以获取上一步 CompletableFuture 结果进行处理转化，类似于stream 中的 map() 方法</li>\n<li><strong>thenCompose()</strong> 类似于 thenApply() 用于多个 CompletableFutre 结果处理，类似于 stream 中的 flatMap() 方法</li>\n<li><strong>thenRun()</strong>    无返回值转化，不可获取上一步 CompletableFuture 结果</li>\n<li><strong>thenAccept()</strong> 无返回值转化，可以获取上一步 CompletableFuture 结果</li>\n<li><strong>thenCombine()</strong> 组合2个 独立 CompletableFuture 并发运行当2个都完成后进行回调结果转化</li>\n<li><strong>thenAcceptBoth()</strong> 类似于thenCombine(),但无返回值转化</li>\n<li><strong>allOf()</strong> 多个 CompletableFuture 并发运行无返回值，所有结果需要通过特殊处理来获取</li>\n<li><strong>anyOf()</strong> 多个 CompletableFuture 并发运行第一个完成的结果</li>\n<li><strong>applyToEither</strong> 两个 CompletableFuture 取第一个完成的结果进行处理并返回</li>\n<li><strong>acceptEither</strong> 两个 CompletableFuture 取第一个完成的结果进行处理无返回</li>\n</ul>\n<blockquote>\n<p>回调方法带有Async的方法为异步调用为独立的线程与主线程不在同一个线程中，且可传入线程池对象或使用默认的<code>ForkJoinPool</code></p>\n</blockquote>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n *  thenApply 类型转化\n */</span>\nCompletableFuture threadOne = Completable.supplyAsync(() -&gt; ｛\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> 结果;\n｝).thenApply(s-&gt;&#123;\n\t代码块(这里可以引用到s)\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;).thenAccept(s-&gt;&#123;\n\t代码块\n&#125;).thenRun(()-&gt;&#123;\n\t代码块\n&#125;)；\n\n<span class=\"hljs-comment\">/**\n *  thenCompose 用于 CompletableFuture 之间链接\n */</span>\nCompletableFuture compose = CompletableFuture.supplyAsync(() -&gt; &#123;\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;).thenCompose(s -&gt; CompletableFuture.supplyAsync(()-&gt;&#123;\n\t代码块(这里可以引用到s)\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;))\n\n\n<span class=\"hljs-comment\">/**\n *  thenCombine 两个 CompletableFuture 并发运行后结果回调\n */</span>\nCompletableFuture combineOne = CompletableFuture.supplyAsync(() -&gt; ｛\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;);\n\nCompletableFuture combineTwo = CompletableFuture.supplyAsync(() -&gt; ｛\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> 结果;\n&#125;);\n\nCompletableFuture combineThread = combineOne.thenCombine(combineTwo, (o, o2) -&gt; &#123;\n\t代码块\n\t<span class=\"hljs-keyword\">return</span> o + o2;\n&#125;);\n\n<span class=\"hljs-comment\">/**\n *  allOf 多个 CompletableFuture 全部并行处理完毕后进行处理\n */</span>\nCompletableFuture allOne = CompletableFuture.runAsync(() -&gt; &#123;\n\t代码块\n&#125;)\n\nCompletableFuture allTwo = CompletableFuture.runAsync(() -&gt; &#123;\n\t代码块\n&#125;)\n\nCompletableFuture allOf = CompletableFuture.allOf(allOne,allTwo);</code></pre>\n<h4 id=\"完成结束\"><a href=\"#完成结束\" class=\"headerlink\" title=\"完成结束\"></a>完成结束</h4><p>获取异步调用结果使用一下函数</p>\n<ul>\n<li><strong>get()</strong> 阻塞方法等待直到线程执行完毕，会抛出checked异常需要<code>catch</code>或者<code>throws</code></li>\n<li><strong>get(lont timeOut,TimeUnit unit)</strong>  带有超时时间的阻塞方法</li>\n<li><strong>getNow(T valueIfAbsent)</strong> 立刻获取结果如果没有则返回 <code>valueIfAbsent</code>值</li>\n<li><strong>join()</strong> 阻塞方法与get()不同的是会抛出<code>unchecked</code>异常</li>\n<li><strong>complete(String value)</strong> 线程直接完成并返回<code>value</code>值</li>\n</ul>\n<h4 id=\"异常补偿\"><a href=\"#异常补偿\" class=\"headerlink\" title=\"异常补偿\"></a>异常补偿</h4><p>在线程链式调用中如果某一步发生异常后续的所有调用都将不会执行，为了更好的处理可以引入异常补偿，根据实际的业务需求处理异常</p>\n<p>-<strong>whenComplete()</strong> 当完成调用可对有异常情况进行处理<br>-<strong>handle()</strong> 相当于whenComplete()+结果转化</p>\n"},{"title":"学习 CurrentHashMap","toc":false,"date":"2020-05-25T12:36:32.000Z","_content":"\n![](/images/java.jpg)\n> 平时工作多线程都用的少一面试问问CurrentHashMap 哦豁不会，场面一度陷入尴尬只知道多线程并发使用线程安全但是其中原理不知，现在学习 CurrentHashMap 的原理还有 HashMap 源码\n\n\n### HashMap\nHashMap 采用链地址法来存储数据，在查询插入数据效率特别高，根据`key`算出哈希地址得到哈希表对应数组下表，时间复杂度`O(1)`，JDK 1.7 采用数组+链表，JDK 1.8 采用 数组+链表+红黑树\n![image.png](/images/2020/05/25/72d56dc0-9e9f-11ea-81d3-796c7949b71a.png)\n#### hash 值算法\nhashcode与(hashcode除以2的16次方)进行位异或运算得到新的hash值用于计算在数组中的下标位置\n``` java\n# 对 key 进行二进制转化位异或运算出 hash 值\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n#### put 方法\nput 方法通过`hash()`方法得到对应`key`的值对应`Node`数组下标获取`Node<K,V>`，存在则进行`hash`比对链表或红黑树中的节点进行覆盖或者新增，其中当链表大于8时链表自动转化成红黑树\n``` java\n# 存放数据\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n# 存放数据方法\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    # 定义变量\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    # 判断是否未第一次存放数据，调用 resize 调整容量 返回新容量\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    # （n-1）& hash 数组长度与 hash 值进行位与运算得到数据下标中无 Node 数据则新增 Node\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    # 已有 Node 数据\n    else {\n        Node<K,V> e; K k;\n        # 如果 Node 链表第一个Node 同 key 值覆盖\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        # 如果当前 Node 结构为红黑树加入树中\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        # Node 结构为链表循环尝试插入\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                # 链表下一个节点为空 覆盖插入的新节点\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    # 绑定次数大于等于7 即链表的长度即将超过8 需要讲链表转化成红黑树提交效率\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                # 如果 Node 链表中已有同 key 跳出循环\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                # Node 覆盖用于下次循环继续 next\n                p = e;\n            }\n        }\n        // 如果 Node 结构中已包含 key  进行值覆盖\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    # 修改次数自增\n    ++modCount;\n    # 当数组长度大于阈值进行扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n#### resize 扩容\nMap的初始容量为16、负载因子为0.75f、最大容量限制为 2^30，当已有数据的长度大于阈值则进行扩容操作，每次扩容需要重新创建容量为之前2倍的Node数组进行转移，当数据量较大时反复进行扩容会消耗大量机器资源，所以应当在创建的时候根据实际情况给予合适的初始容量\n``` java\n# 调整大小\nfinal Node<K,V>[] resize() {\n    # 旧数据定义\n    Node<K,V>[] oldTab = table;\n    # 定义旧容量\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    # 旧阈值\n    int oldThr = threshold;\n    # 新容量和新阈值初始化 0 \n    int newCap, newThr = 0;\n    # 容量调整 如果旧容量大于0 \n    if (oldCap > 0) {\n        # 旧容量大于最大容量 （1<<30  2的30次方）\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            # 更新阈值为 (1<<31)-1 2的31次方-1\n            threshold = Integer.MAX_VALUE;\n            # 返回旧数据\n            return oldTab;\n        }\n        # 旧容量大于等于默认初始容量（16）且旧容量扩容两倍未超过最大容量时新阈值 x 2\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    # 旧阈值大于 0 旧阈值覆盖新容量\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    # 旧阈值小于等于0 新容量为默认初始化容量（16），新阈值为默认负责系列 0.75f * 16\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    # 新阈值为0时 重新计算阈值 当新容量小于最大容量且（新容量*负载因子）小于最大容量同时满足使用（新容量*负载因子）否则使用 Interger最大值\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    # 阈值赋值\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    # 根据新容量初始化新 Node\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];z\n    table = newTab;\n    if (oldTab != null) {\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n> 对于 hash(key)对应的数据下标采用了位与运算 hash(key)&(数组长度-1) ，等价于hash(key)%(数组长度)取模操作，得到的余数对应数组中的下标值\n\n### CurrentHashMap \n`HashMap`是线程不安全，在多线程情况下操作会造成数据不一致等各类并发问题，对于线程安全有`HashTable`但是由于使用了`synchronized`同步锁住所有数据效率很低，`CurrentHashMap`相对于`HashTable`采用分段式锁更轻量效率更高\n\n","source":"_posts/学习-CurrentHashMap.md","raw":"---\ntitle: 学习 CurrentHashMap\ntags: []\ncategories: []\ntoc: false\ndate: 2020-05-25 20:36:32\n---\n\n![](/images/java.jpg)\n> 平时工作多线程都用的少一面试问问CurrentHashMap 哦豁不会，场面一度陷入尴尬只知道多线程并发使用线程安全但是其中原理不知，现在学习 CurrentHashMap 的原理还有 HashMap 源码\n\n\n### HashMap\nHashMap 采用链地址法来存储数据，在查询插入数据效率特别高，根据`key`算出哈希地址得到哈希表对应数组下表，时间复杂度`O(1)`，JDK 1.7 采用数组+链表，JDK 1.8 采用 数组+链表+红黑树\n![image.png](/images/2020/05/25/72d56dc0-9e9f-11ea-81d3-796c7949b71a.png)\n#### hash 值算法\nhashcode与(hashcode除以2的16次方)进行位异或运算得到新的hash值用于计算在数组中的下标位置\n``` java\n# 对 key 进行二进制转化位异或运算出 hash 值\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n#### put 方法\nput 方法通过`hash()`方法得到对应`key`的值对应`Node`数组下标获取`Node<K,V>`，存在则进行`hash`比对链表或红黑树中的节点进行覆盖或者新增，其中当链表大于8时链表自动转化成红黑树\n``` java\n# 存放数据\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n# 存放数据方法\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    # 定义变量\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    # 判断是否未第一次存放数据，调用 resize 调整容量 返回新容量\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    # （n-1）& hash 数组长度与 hash 值进行位与运算得到数据下标中无 Node 数据则新增 Node\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    # 已有 Node 数据\n    else {\n        Node<K,V> e; K k;\n        # 如果 Node 链表第一个Node 同 key 值覆盖\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        # 如果当前 Node 结构为红黑树加入树中\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        # Node 结构为链表循环尝试插入\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                # 链表下一个节点为空 覆盖插入的新节点\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    # 绑定次数大于等于7 即链表的长度即将超过8 需要讲链表转化成红黑树提交效率\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                # 如果 Node 链表中已有同 key 跳出循环\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                # Node 覆盖用于下次循环继续 next\n                p = e;\n            }\n        }\n        // 如果 Node 结构中已包含 key  进行值覆盖\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    # 修改次数自增\n    ++modCount;\n    # 当数组长度大于阈值进行扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n#### resize 扩容\nMap的初始容量为16、负载因子为0.75f、最大容量限制为 2^30，当已有数据的长度大于阈值则进行扩容操作，每次扩容需要重新创建容量为之前2倍的Node数组进行转移，当数据量较大时反复进行扩容会消耗大量机器资源，所以应当在创建的时候根据实际情况给予合适的初始容量\n``` java\n# 调整大小\nfinal Node<K,V>[] resize() {\n    # 旧数据定义\n    Node<K,V>[] oldTab = table;\n    # 定义旧容量\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    # 旧阈值\n    int oldThr = threshold;\n    # 新容量和新阈值初始化 0 \n    int newCap, newThr = 0;\n    # 容量调整 如果旧容量大于0 \n    if (oldCap > 0) {\n        # 旧容量大于最大容量 （1<<30  2的30次方）\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            # 更新阈值为 (1<<31)-1 2的31次方-1\n            threshold = Integer.MAX_VALUE;\n            # 返回旧数据\n            return oldTab;\n        }\n        # 旧容量大于等于默认初始容量（16）且旧容量扩容两倍未超过最大容量时新阈值 x 2\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    # 旧阈值大于 0 旧阈值覆盖新容量\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    # 旧阈值小于等于0 新容量为默认初始化容量（16），新阈值为默认负责系列 0.75f * 16\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    # 新阈值为0时 重新计算阈值 当新容量小于最大容量且（新容量*负载因子）小于最大容量同时满足使用（新容量*负载因子）否则使用 Interger最大值\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    # 阈值赋值\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    # 根据新容量初始化新 Node\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];z\n    table = newTab;\n    if (oldTab != null) {\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n> 对于 hash(key)对应的数据下标采用了位与运算 hash(key)&(数组长度-1) ，等价于hash(key)%(数组长度)取模操作，得到的余数对应数组中的下标值\n\n### CurrentHashMap \n`HashMap`是线程不安全，在多线程情况下操作会造成数据不一致等各类并发问题，对于线程安全有`HashTable`但是由于使用了`synchronized`同步锁住所有数据效率很低，`CurrentHashMap`相对于`HashTable`采用分段式锁更轻量效率更高\n\n","slug":"学习-CurrentHashMap","published":1,"updated":"2020-08-10T01:48:44.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9ar005ajsudnurh7pz4","content":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>平时工作多线程都用的少一面试问问CurrentHashMap 哦豁不会，场面一度陷入尴尬只知道多线程并发使用线程安全但是其中原理不知，现在学习 CurrentHashMap 的原理还有 HashMap 源码</p>\n</blockquote>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>HashMap 采用链地址法来存储数据，在查询插入数据效率特别高，根据<code>key</code>算出哈希地址得到哈希表对应数组下表，时间复杂度<code>O(1)</code>，JDK 1.7 采用数组+链表，JDK 1.8 采用 数组+链表+红黑树<br><img src=\"/images/2020/05/25/72d56dc0-9e9f-11ea-81d3-796c7949b71a.png\" srcset=\"/img/loading.gif\" alt=\"image.png\"></p>\n<h4 id=\"hash-值算法\"><a href=\"#hash-值算法\" class=\"headerlink\" title=\"hash 值算法\"></a>hash 值算法</h4><p>hashcode与(hashcode除以2的16次方)进行位异或运算得到新的hash值用于计算在数组中的下标位置<br><pre><code class=\"hljs java\"># 对 key 进行二进制转化位异或运算出 hash 值\nstatic final int hash(Object key) &#123;\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;</code></pre></p>\n<h4 id=\"put-方法\"><a href=\"#put-方法\" class=\"headerlink\" title=\"put 方法\"></a>put 方法</h4><p>put 方法通过<code>hash()</code>方法得到对应<code>key</code>的值对应<code>Node</code>数组下标获取<code>Node&lt;K,V&gt;</code>，存在则进行<code>hash</code>比对链表或红黑树中的节点进行覆盖或者新增，其中当链表大于8时链表自动转化成红黑树<br><pre><code class=\"hljs java\"># 存放数据\npublic V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n\n# 存放数据方法\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    # 定义变量\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    # 判断是否未第一次存放数据，调用 resize 调整容量 返回新容量\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    # （n-1）&amp; hash 数组长度与 hash 值进行位与运算得到数据下标中无 Node 数据则新增 Node\n    if ((p = tab[i = (n - 1) &amp; hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    # 已有 Node 数据\n    else &#123;\n        Node&lt;K,V&gt; e; K k;\n        # 如果 Node 链表第一个Node 同 key 值覆盖\n        if (p.hash == hash &amp;&amp;\n            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n            e = p;\n        # 如果当前 Node 结构为红黑树加入树中\n        else if (p instanceof TreeNode)\n            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        # Node 结构为链表循环尝试插入\n        else &#123;\n            for (int binCount = 0; ; ++binCount) &#123;\n                # 链表下一个节点为空 覆盖插入的新节点\n                if ((e = p.next) == null) &#123;\n                    p.next = newNode(hash, key, value, null);\n                    # 绑定次数大于等于7 即链表的长度即将超过8 需要讲链表转化成红黑树提交效率\n                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                &#125;\n                # 如果 Node 链表中已有同 key 跳出循环\n                if (e.hash == hash &amp;&amp;\n                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    break;\n                # Node 覆盖用于下次循环继续 next\n                p = e;\n            &#125;\n        &#125;\n        // 如果 Node 结构中已包含 key  进行值覆盖\n        if (e != null) &#123; // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        &#125;\n    &#125;\n    # 修改次数自增\n    ++modCount;\n    # 当数组长度大于阈值进行扩容\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n&#125;</code></pre></p>\n<h4 id=\"resize-扩容\"><a href=\"#resize-扩容\" class=\"headerlink\" title=\"resize 扩容\"></a>resize 扩容</h4><p>Map的初始容量为16、负载因子为0.75f、最大容量限制为 2^30，当已有数据的长度大于阈值则进行扩容操作，每次扩容需要重新创建容量为之前2倍的Node数组进行转移，当数据量较大时反复进行扩容会消耗大量机器资源，所以应当在创建的时候根据实际情况给予合适的初始容量<br><pre><code class=\"hljs java\"># 调整大小\nfinal Node&lt;K,V&gt;[] resize() &#123;\n    # 旧数据定义\n    Node&lt;K,V&gt;[] oldTab = table;\n    # 定义旧容量\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    # 旧阈值\n    int oldThr = threshold;\n    # 新容量和新阈值初始化 0 \n    int newCap, newThr = 0;\n    # 容量调整 如果旧容量大于0 \n    if (oldCap &gt; 0) &#123;\n        # 旧容量大于最大容量 （1&lt;&lt;30  2的30次方）\n        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;\n            # 更新阈值为 (1&lt;&lt;31)-1 2的31次方-1\n            threshold = Integer.MAX_VALUE;\n            # 返回旧数据\n            return oldTab;\n        &#125;\n        # 旧容量大于等于默认初始容量（16）且旧容量扩容两倍未超过最大容量时新阈值 x 2\n        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr &lt;&lt; 1; // double threshold\n    &#125;\n    # 旧阈值大于 0 旧阈值覆盖新容量\n    else if (oldThr &gt; 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    # 旧阈值小于等于0 新容量为默认初始化容量（16），新阈值为默认负责系列 0.75f * 16\n    else &#123;               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n    # 新阈值为0时 重新计算阈值 当新容量小于最大容量且（新容量*负载因子）小于最大容量同时满足使用（新容量*负载因子）否则使用 Interger最大值\n    if (newThr == 0) &#123;\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    &#125;\n    # 阈值赋值\n    threshold = newThr;\n    @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;)\n    # 根据新容量初始化新 Node\n    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];z\n    table = newTab;\n    if (oldTab != null) &#123;\n        for (int j = 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V&gt; e;\n            if ((e = oldTab[j]) != null) &#123;\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash &amp; (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                else &#123; // preserve order\n                    Node&lt;K,V&gt; loHead = null, loTail = null;\n                    Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                    Node&lt;K,V&gt; next;\n                    do &#123;\n                        next = e.next;\n                        if ((e.hash &amp; oldCap) == 0) &#123;\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        &#125;\n                        else &#123;\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        &#125;\n                    &#125; while ((e = next) != null);\n                    if (loTail != null) &#123;\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    &#125;\n                    if (hiTail != null) &#123;\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;</code></pre></p>\n<blockquote>\n<p>对于 hash(key)对应的数据下标采用了位与运算 hash(key)&amp;(数组长度-1) ，等价于hash(key)%(数组长度)取模操作，得到的余数对应数组中的下标值</p>\n</blockquote>\n<h3 id=\"CurrentHashMap\"><a href=\"#CurrentHashMap\" class=\"headerlink\" title=\"CurrentHashMap\"></a>CurrentHashMap</h3><p><code>HashMap</code>是线程不安全，在多线程情况下操作会造成数据不一致等各类并发问题，对于线程安全有<code>HashTable</code>但是由于使用了<code>synchronized</code>同步锁住所有数据效率很低，<code>CurrentHashMap</code>相对于<code>HashTable</code>采用分段式锁更轻量效率更高</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java.jpg\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>平时工作多线程都用的少一面试问问CurrentHashMap 哦豁不会，场面一度陷入尴尬只知道多线程并发使用线程安全但是其中原理不知，现在学习 CurrentHashMap 的原理还有 HashMap 源码</p>\n</blockquote>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>HashMap 采用链地址法来存储数据，在查询插入数据效率特别高，根据<code>key</code>算出哈希地址得到哈希表对应数组下表，时间复杂度<code>O(1)</code>，JDK 1.7 采用数组+链表，JDK 1.8 采用 数组+链表+红黑树<br><img src=\"/images/2020/05/25/72d56dc0-9e9f-11ea-81d3-796c7949b71a.png\" srcset=\"/img/loading.gif\" alt=\"image.png\"></p>\n<h4 id=\"hash-值算法\"><a href=\"#hash-值算法\" class=\"headerlink\" title=\"hash 值算法\"></a>hash 值算法</h4><p>hashcode与(hashcode除以2的16次方)进行位异或运算得到新的hash值用于计算在数组中的下标位置<br><pre><code class=\"hljs java\"># 对 key 进行二进制转化位异或运算出 hash 值\nstatic final int hash(Object key) &#123;\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;</code></pre></p>\n<h4 id=\"put-方法\"><a href=\"#put-方法\" class=\"headerlink\" title=\"put 方法\"></a>put 方法</h4><p>put 方法通过<code>hash()</code>方法得到对应<code>key</code>的值对应<code>Node</code>数组下标获取<code>Node&lt;K,V&gt;</code>，存在则进行<code>hash</code>比对链表或红黑树中的节点进行覆盖或者新增，其中当链表大于8时链表自动转化成红黑树<br><pre><code class=\"hljs java\"># 存放数据\npublic V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n\n# 存放数据方法\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    # 定义变量\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    # 判断是否未第一次存放数据，调用 resize 调整容量 返回新容量\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    # （n-1）&amp; hash 数组长度与 hash 值进行位与运算得到数据下标中无 Node 数据则新增 Node\n    if ((p = tab[i = (n - 1) &amp; hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    # 已有 Node 数据\n    else &#123;\n        Node&lt;K,V&gt; e; K k;\n        # 如果 Node 链表第一个Node 同 key 值覆盖\n        if (p.hash == hash &amp;&amp;\n            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n            e = p;\n        # 如果当前 Node 结构为红黑树加入树中\n        else if (p instanceof TreeNode)\n            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        # Node 结构为链表循环尝试插入\n        else &#123;\n            for (int binCount = 0; ; ++binCount) &#123;\n                # 链表下一个节点为空 覆盖插入的新节点\n                if ((e = p.next) == null) &#123;\n                    p.next = newNode(hash, key, value, null);\n                    # 绑定次数大于等于7 即链表的长度即将超过8 需要讲链表转化成红黑树提交效率\n                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                &#125;\n                # 如果 Node 链表中已有同 key 跳出循环\n                if (e.hash == hash &amp;&amp;\n                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    break;\n                # Node 覆盖用于下次循环继续 next\n                p = e;\n            &#125;\n        &#125;\n        // 如果 Node 结构中已包含 key  进行值覆盖\n        if (e != null) &#123; // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        &#125;\n    &#125;\n    # 修改次数自增\n    ++modCount;\n    # 当数组长度大于阈值进行扩容\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n&#125;</code></pre></p>\n<h4 id=\"resize-扩容\"><a href=\"#resize-扩容\" class=\"headerlink\" title=\"resize 扩容\"></a>resize 扩容</h4><p>Map的初始容量为16、负载因子为0.75f、最大容量限制为 2^30，当已有数据的长度大于阈值则进行扩容操作，每次扩容需要重新创建容量为之前2倍的Node数组进行转移，当数据量较大时反复进行扩容会消耗大量机器资源，所以应当在创建的时候根据实际情况给予合适的初始容量<br><pre><code class=\"hljs java\"># 调整大小\nfinal Node&lt;K,V&gt;[] resize() &#123;\n    # 旧数据定义\n    Node&lt;K,V&gt;[] oldTab = table;\n    # 定义旧容量\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    # 旧阈值\n    int oldThr = threshold;\n    # 新容量和新阈值初始化 0 \n    int newCap, newThr = 0;\n    # 容量调整 如果旧容量大于0 \n    if (oldCap &gt; 0) &#123;\n        # 旧容量大于最大容量 （1&lt;&lt;30  2的30次方）\n        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;\n            # 更新阈值为 (1&lt;&lt;31)-1 2的31次方-1\n            threshold = Integer.MAX_VALUE;\n            # 返回旧数据\n            return oldTab;\n        &#125;\n        # 旧容量大于等于默认初始容量（16）且旧容量扩容两倍未超过最大容量时新阈值 x 2\n        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr &lt;&lt; 1; // double threshold\n    &#125;\n    # 旧阈值大于 0 旧阈值覆盖新容量\n    else if (oldThr &gt; 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    # 旧阈值小于等于0 新容量为默认初始化容量（16），新阈值为默认负责系列 0.75f * 16\n    else &#123;               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n    # 新阈值为0时 重新计算阈值 当新容量小于最大容量且（新容量*负载因子）小于最大容量同时满足使用（新容量*负载因子）否则使用 Interger最大值\n    if (newThr == 0) &#123;\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    &#125;\n    # 阈值赋值\n    threshold = newThr;\n    @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;)\n    # 根据新容量初始化新 Node\n    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];z\n    table = newTab;\n    if (oldTab != null) &#123;\n        for (int j = 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V&gt; e;\n            if ((e = oldTab[j]) != null) &#123;\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash &amp; (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                else &#123; // preserve order\n                    Node&lt;K,V&gt; loHead = null, loTail = null;\n                    Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                    Node&lt;K,V&gt; next;\n                    do &#123;\n                        next = e.next;\n                        if ((e.hash &amp; oldCap) == 0) &#123;\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        &#125;\n                        else &#123;\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        &#125;\n                    &#125; while ((e = next) != null);\n                    if (loTail != null) &#123;\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    &#125;\n                    if (hiTail != null) &#123;\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;</code></pre></p>\n<blockquote>\n<p>对于 hash(key)对应的数据下标采用了位与运算 hash(key)&amp;(数组长度-1) ，等价于hash(key)%(数组长度)取模操作，得到的余数对应数组中的下标值</p>\n</blockquote>\n<h3 id=\"CurrentHashMap\"><a href=\"#CurrentHashMap\" class=\"headerlink\" title=\"CurrentHashMap\"></a>CurrentHashMap</h3><p><code>HashMap</code>是线程不安全，在多线程情况下操作会造成数据不一致等各类并发问题，对于线程安全有<code>HashTable</code>但是由于使用了<code>synchronized</code>同步锁住所有数据效率很低，<code>CurrentHashMap</code>相对于<code>HashTable</code>采用分段式锁更轻量效率更高</p>\n"},{"title":"学习红黑树","toc":false,"date":"2019-07-25T01:55:02.000Z","_content":"\n### 二叉查找树\n二叉查找树（binary search tree）也称为有序二叉树（order binary tree）或排序二叉树（sorted binary tree）\n\n- 若任意节点的左子树不空，则左子树的所有结点的值都小于它们的根节点\n- 若任意节点的右子树不空，则右子树的所有结点的值都大于它们的根节点\n- 没有键值相等的节点（no duplicate nodes）\n\n由 $n$ 个节点构造的二叉树的高度为 $lgn$ 空间复杂度为 $O(lgn)$，当树不再平衡退化成一颗 $n$ 个节点的线性链后，空间复杂度则为 $O(n)$\n\n### 红黑树\n红黑树（red black tree）也称为平衡二叉B树（symmetric binary B-trees）通过特殊操作保持二叉查找树的平衡，插入、删除、查找的空间复杂度为 $O(lgn)$，一个 $n$ 个节点的红黑树的高度为 $2log(n+1)$，高度为 $h$ 的红黑树包含的节点至少为 $2^{bh(x)}-1$ 个\n\n- 每个节点的颜色是红色或黑色\n- 根节点的颜色始终是黑色\n- 每个红色节点的子节点必然是两个黑色\n- 每个叶子到根的所有路径上不能有两个连续的红色节点\n\n![](/images/red-black-tree.png)\n\n### 树的旋转\n红黑树在进入插入或者删除操作后可能会违背红黑树的性质，为了保证其平衡性需要通过改变节点颜色和结构使其继续保持其特性，改变树结构的操作称为树的旋转\n\n##### 左旋\n`pivot`节点进行左旋，`pivot`的右子节点成为新父节点且其左子节点成为左旋节点右子节点\n\n![左旋](/images/left-pivot.jpg)\n\n##### 右旋\n`pivot`节点进行右旋，`pivot`的左子节点成为新父节点且其右子节点成为右旋节点的左子节点\n\n![右旋](/images/right-povit.jpg)","source":"_posts/学习红黑树.md","raw":"---\ntitle: 学习红黑树\ntags:\n  - 复习\ncategories:\n  - Java\ntoc: false\ndate: 2019-07-25 09:55:02\n---\n\n### 二叉查找树\n二叉查找树（binary search tree）也称为有序二叉树（order binary tree）或排序二叉树（sorted binary tree）\n\n- 若任意节点的左子树不空，则左子树的所有结点的值都小于它们的根节点\n- 若任意节点的右子树不空，则右子树的所有结点的值都大于它们的根节点\n- 没有键值相等的节点（no duplicate nodes）\n\n由 $n$ 个节点构造的二叉树的高度为 $lgn$ 空间复杂度为 $O(lgn)$，当树不再平衡退化成一颗 $n$ 个节点的线性链后，空间复杂度则为 $O(n)$\n\n### 红黑树\n红黑树（red black tree）也称为平衡二叉B树（symmetric binary B-trees）通过特殊操作保持二叉查找树的平衡，插入、删除、查找的空间复杂度为 $O(lgn)$，一个 $n$ 个节点的红黑树的高度为 $2log(n+1)$，高度为 $h$ 的红黑树包含的节点至少为 $2^{bh(x)}-1$ 个\n\n- 每个节点的颜色是红色或黑色\n- 根节点的颜色始终是黑色\n- 每个红色节点的子节点必然是两个黑色\n- 每个叶子到根的所有路径上不能有两个连续的红色节点\n\n![](/images/red-black-tree.png)\n\n### 树的旋转\n红黑树在进入插入或者删除操作后可能会违背红黑树的性质，为了保证其平衡性需要通过改变节点颜色和结构使其继续保持其特性，改变树结构的操作称为树的旋转\n\n##### 左旋\n`pivot`节点进行左旋，`pivot`的右子节点成为新父节点且其左子节点成为左旋节点右子节点\n\n![左旋](/images/left-pivot.jpg)\n\n##### 右旋\n`pivot`节点进行右旋，`pivot`的左子节点成为新父节点且其右子节点成为右旋节点的左子节点\n\n![右旋](/images/right-povit.jpg)","slug":"学习红黑树","published":1,"updated":"2020-08-10T01:48:44.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9au005djsud39rztbco","content":"<h3 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h3><p>二叉查找树（binary search tree）也称为有序二叉树（order binary tree）或排序二叉树（sorted binary tree）</p>\n<ul>\n<li>若任意节点的左子树不空，则左子树的所有结点的值都小于它们的根节点</li>\n<li>若任意节点的右子树不空，则右子树的所有结点的值都大于它们的根节点</li>\n<li>没有键值相等的节点（no duplicate nodes）</li>\n</ul>\n<p>由 $n$ 个节点构造的二叉树的高度为 $lgn$ 空间复杂度为 $O(lgn)$，当树不再平衡退化成一颗 $n$ 个节点的线性链后，空间复杂度则为 $O(n)$</p>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><p>红黑树（red black tree）也称为平衡二叉B树（symmetric binary B-trees）通过特殊操作保持二叉查找树的平衡，插入、删除、查找的空间复杂度为 $O(lgn)$，一个 $n$ 个节点的红黑树的高度为 $2log(n+1)$，高度为 $h$ 的红黑树包含的节点至少为 $2^{bh(x)}-1$ 个</p>\n<ul>\n<li>每个节点的颜色是红色或黑色</li>\n<li>根节点的颜色始终是黑色</li>\n<li>每个红色节点的子节点必然是两个黑色</li>\n<li>每个叶子到根的所有路径上不能有两个连续的红色节点</li>\n</ul>\n<p><img src=\"/images/red-black-tree.png\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"树的旋转\"><a href=\"#树的旋转\" class=\"headerlink\" title=\"树的旋转\"></a>树的旋转</h3><p>红黑树在进入插入或者删除操作后可能会违背红黑树的性质，为了保证其平衡性需要通过改变节点颜色和结构使其继续保持其特性，改变树结构的操作称为树的旋转</p>\n<h5 id=\"左旋\"><a href=\"#左旋\" class=\"headerlink\" title=\"左旋\"></a>左旋</h5><p><code>pivot</code>节点进行左旋，<code>pivot</code>的右子节点成为新父节点且其左子节点成为左旋节点右子节点</p>\n<p><img src=\"/images/left-pivot.jpg\" srcset=\"/img/loading.gif\" alt=\"左旋\"></p>\n<h5 id=\"右旋\"><a href=\"#右旋\" class=\"headerlink\" title=\"右旋\"></a>右旋</h5><p><code>pivot</code>节点进行右旋，<code>pivot</code>的左子节点成为新父节点且其右子节点成为右旋节点的左子节点</p>\n<p><img src=\"/images/right-povit.jpg\" srcset=\"/img/loading.gif\" alt=\"右旋\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h3><p>二叉查找树（binary search tree）也称为有序二叉树（order binary tree）或排序二叉树（sorted binary tree）</p>\n<ul>\n<li>若任意节点的左子树不空，则左子树的所有结点的值都小于它们的根节点</li>\n<li>若任意节点的右子树不空，则右子树的所有结点的值都大于它们的根节点</li>\n<li>没有键值相等的节点（no duplicate nodes）</li>\n</ul>\n<p>由 $n$ 个节点构造的二叉树的高度为 $lgn$ 空间复杂度为 $O(lgn)$，当树不再平衡退化成一颗 $n$ 个节点的线性链后，空间复杂度则为 $O(n)$</p>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><p>红黑树（red black tree）也称为平衡二叉B树（symmetric binary B-trees）通过特殊操作保持二叉查找树的平衡，插入、删除、查找的空间复杂度为 $O(lgn)$，一个 $n$ 个节点的红黑树的高度为 $2log(n+1)$，高度为 $h$ 的红黑树包含的节点至少为 $2^{bh(x)}-1$ 个</p>\n<ul>\n<li>每个节点的颜色是红色或黑色</li>\n<li>根节点的颜色始终是黑色</li>\n<li>每个红色节点的子节点必然是两个黑色</li>\n<li>每个叶子到根的所有路径上不能有两个连续的红色节点</li>\n</ul>\n<p><img src=\"/images/red-black-tree.png\" srcset=\"/img/loading.gif\" alt></p>\n<h3 id=\"树的旋转\"><a href=\"#树的旋转\" class=\"headerlink\" title=\"树的旋转\"></a>树的旋转</h3><p>红黑树在进入插入或者删除操作后可能会违背红黑树的性质，为了保证其平衡性需要通过改变节点颜色和结构使其继续保持其特性，改变树结构的操作称为树的旋转</p>\n<h5 id=\"左旋\"><a href=\"#左旋\" class=\"headerlink\" title=\"左旋\"></a>左旋</h5><p><code>pivot</code>节点进行左旋，<code>pivot</code>的右子节点成为新父节点且其左子节点成为左旋节点右子节点</p>\n<p><img src=\"/images/left-pivot.jpg\" srcset=\"/img/loading.gif\" alt=\"左旋\"></p>\n<h5 id=\"右旋\"><a href=\"#右旋\" class=\"headerlink\" title=\"右旋\"></a>右旋</h5><p><code>pivot</code>节点进行右旋，<code>pivot</code>的左子节点成为新父节点且其右子节点成为右旋节点的左子节点</p>\n<p><img src=\"/images/right-povit.jpg\" srcset=\"/img/loading.gif\" alt=\"右旋\"></p>\n"},{"title":"抢卷并发代码Redis应用","toc":false,"date":"2020-09-28T03:12:10.000Z","_content":"\n### 代码实现\n最近的项目有一个抢卷业务为保证性能使用`redis`来实现保证高并发性能，首先分析下抢卷业务\n- 优惠卷的数量不能超发，保证卷的一人一张\n- 锁的粒度尽可能的小\n- 锁的维度唯一性（用户id+卷id）\n- 优惠卷的数量事先写入`Redis`防止大量访问`DB`获取卷数量，`DB`由于数据的隔离性读取的数量也可能会不同发生超发场景\n\n#### Redisson\n通过注入`RedissonClient`来实现各种锁场景\n``` xml\n<dependency>\n     <groupId>org.redisson</groupId>\n     <artifactId>redisson</artifactId>\n     <version>3.9.1</version>\n</dependency>\n```\n\n### 代码流程\n1. 尝试获取锁（用户id+卷id）唯一锁\n2. 获取成功开始进行抢卷操作否则抢卷失败\n3. 进行`DB`操作插入用户卷关联关系，插入成功进行缓存写入修改卷的数量和用户已抢卷的key防止用户多次抢卷\n\n``` java\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public boolean getCoupon(String userId, String materielId) throws Exception {\n        // 以优惠卷为维度加锁 防止超发\n        String ticketLock = new StringBuilder(RedisPrefixEnum.LIVE_TICKET.getPrefix())\n                .append(materielId).toString();\n        // 用户领卷 key\n        String tickerUser = new StringBuilder(RedisPrefixEnum.LIVE_COUPON_USER_LOCK.getPrefix())\n                .append(materielId).append(\"_\").append(userId).toString();\n\n        SysUserEntity user = sysUserService.getById(userId);\n        boolean result = redisLocker.fairLock(ticketLock, () -> {\n            Integer ticketSum = checkTicket(userId, materielId);\n            // 领卷逻辑\n            PortalMateriel portalMateriel = portalMaterielMapper.selectById(materielId);\n            PortalUserMateriel userMateriel = new PortalUserMateriel();\n            userMateriel.setId(UUIDUtils.get32UUID());\n            userMateriel.setUserId(userId); // 助力活动发起人\n            userMateriel.setMaterielId(materielId);\n            userMateriel.setTel(user.getTel());\n            userMateriel.setMaterielCode(portalMateriel.getPre() + DateUtil.current(true));\n            userMateriel.setTitle(portalMateriel.getTitle());\n            userMateriel.setParValue(portalMateriel.getParValue());\n            userMateriel.setEndDate(portalMateriel.getEndDate());\n            userMateriel.setStatus(0); // 未使用\n            userMateriel.setType(portalMateriel.getType()); // 优惠券\n            // 插入用户物件表\n            portalUserMaterielMapper.insert(userMateriel);\n            // 更新优惠卷数量缓存\n            redisService.setModel(ticketLock, ticketSum - 1);\n            // 新增领卷记录 key 防止用户多次领取\n            redisService.setModel(tickerUser, null);\n            return true;\n        }, 60);\n        return result;\n\n    }\n```\n这里采用了`Redisson`组件方便使用各种锁，用户抢卷为了保证公平所有使用 **fairLock公平锁** ，当大量用户进行抢卷操作时根据等待时长顺序依次进行抢卷逻辑，首先卷的数量需要先缓存到`redis`中防止在高并发下直接访问`DB`从而影响正常使用\n\n在查阅了资料和同事的指导下对上述代码进行重构优化，采用`Redis`的原子性操作`decr`自减方法，锁的粒度也是以人为单位，卷的数量通过原子减是否小于等于0来判断用户领卷是否成功，使用`lock`锁对用户进行加锁，防止用户多次点击抢卷或通过其他方式请求抢卷接口，特别要注意设置锁的**释放时间**防止死锁导致后续所有请求阻塞产生系统严重性能问题，有异常后finally中必写`lock.unlock()`释放锁操作\n\n\n``` java\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public boolean getCoupon(String userId, String materielId) throws Exception {\n        if (this.hasCoupon(userId, materielId)) {\n            throw new GlobalException(\"你已经领过券了\");\n        }\n        String userKey = userKey(userId, materielId).toString();\n        // 尝试获取锁 防止当前用户疯狂点击\n        RLock lock = redissonClient.getLock(userKey);\n        lock.tryLock(0L,20L, TimeUnit.SECONDS);\n        if (!lock.isLocked()) {\n            throw new GlobalException(\"请勿重复领取\");\n        }\n        try {\n            // 先尝试领卷 原子性减少卷数量 -1\n            Long sum = getCouponNum(materielId);\n            if (sum <= 0) {\n                throw new GlobalException(\"很遗憾，券已领完！\");\n            }\n            // 发生异常需要退还卷\n            PortalUserMateriel portalUserMateriel = initPortalUserMaterielByUserId(userId, materielId);\n            int saveNum  = portalUserMaterielMapper.insert(portalUserMateriel);\n            // 保存失败抛出异常执行退还操作\n            if (saveNum != 1) {\n                throw new GlobalException(\"抢卷失败\");\n            }\n\n        } catch (Exception e) {\n            log.error(userId+\"用户抢卷\"+materielId+\"失败\",e);\n            throw e;\n        } finally {\n            // 最终释放锁\n            lock.unlock();\n        }\n        // 领取成功插入领取记录\n        redisService.setModel(userKey, null);\n        return true;\n\n    }\n```\n\n如果对时效性不高可以使用队列去做抢卷的逻辑，这样可以保证大量的请求进行分发处理防止瞬间的大量请求拖垮服务器","source":"_posts/抢卷并发代码Redis应用.md","raw":"---\ntitle: 抢卷并发代码Redis应用\ntags:\n  - 技术\ncategories:\n  - 代码块\ntoc: false\ndate: 2020-09-28 11:12:10\n---\n\n### 代码实现\n最近的项目有一个抢卷业务为保证性能使用`redis`来实现保证高并发性能，首先分析下抢卷业务\n- 优惠卷的数量不能超发，保证卷的一人一张\n- 锁的粒度尽可能的小\n- 锁的维度唯一性（用户id+卷id）\n- 优惠卷的数量事先写入`Redis`防止大量访问`DB`获取卷数量，`DB`由于数据的隔离性读取的数量也可能会不同发生超发场景\n\n#### Redisson\n通过注入`RedissonClient`来实现各种锁场景\n``` xml\n<dependency>\n     <groupId>org.redisson</groupId>\n     <artifactId>redisson</artifactId>\n     <version>3.9.1</version>\n</dependency>\n```\n\n### 代码流程\n1. 尝试获取锁（用户id+卷id）唯一锁\n2. 获取成功开始进行抢卷操作否则抢卷失败\n3. 进行`DB`操作插入用户卷关联关系，插入成功进行缓存写入修改卷的数量和用户已抢卷的key防止用户多次抢卷\n\n``` java\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public boolean getCoupon(String userId, String materielId) throws Exception {\n        // 以优惠卷为维度加锁 防止超发\n        String ticketLock = new StringBuilder(RedisPrefixEnum.LIVE_TICKET.getPrefix())\n                .append(materielId).toString();\n        // 用户领卷 key\n        String tickerUser = new StringBuilder(RedisPrefixEnum.LIVE_COUPON_USER_LOCK.getPrefix())\n                .append(materielId).append(\"_\").append(userId).toString();\n\n        SysUserEntity user = sysUserService.getById(userId);\n        boolean result = redisLocker.fairLock(ticketLock, () -> {\n            Integer ticketSum = checkTicket(userId, materielId);\n            // 领卷逻辑\n            PortalMateriel portalMateriel = portalMaterielMapper.selectById(materielId);\n            PortalUserMateriel userMateriel = new PortalUserMateriel();\n            userMateriel.setId(UUIDUtils.get32UUID());\n            userMateriel.setUserId(userId); // 助力活动发起人\n            userMateriel.setMaterielId(materielId);\n            userMateriel.setTel(user.getTel());\n            userMateriel.setMaterielCode(portalMateriel.getPre() + DateUtil.current(true));\n            userMateriel.setTitle(portalMateriel.getTitle());\n            userMateriel.setParValue(portalMateriel.getParValue());\n            userMateriel.setEndDate(portalMateriel.getEndDate());\n            userMateriel.setStatus(0); // 未使用\n            userMateriel.setType(portalMateriel.getType()); // 优惠券\n            // 插入用户物件表\n            portalUserMaterielMapper.insert(userMateriel);\n            // 更新优惠卷数量缓存\n            redisService.setModel(ticketLock, ticketSum - 1);\n            // 新增领卷记录 key 防止用户多次领取\n            redisService.setModel(tickerUser, null);\n            return true;\n        }, 60);\n        return result;\n\n    }\n```\n这里采用了`Redisson`组件方便使用各种锁，用户抢卷为了保证公平所有使用 **fairLock公平锁** ，当大量用户进行抢卷操作时根据等待时长顺序依次进行抢卷逻辑，首先卷的数量需要先缓存到`redis`中防止在高并发下直接访问`DB`从而影响正常使用\n\n在查阅了资料和同事的指导下对上述代码进行重构优化，采用`Redis`的原子性操作`decr`自减方法，锁的粒度也是以人为单位，卷的数量通过原子减是否小于等于0来判断用户领卷是否成功，使用`lock`锁对用户进行加锁，防止用户多次点击抢卷或通过其他方式请求抢卷接口，特别要注意设置锁的**释放时间**防止死锁导致后续所有请求阻塞产生系统严重性能问题，有异常后finally中必写`lock.unlock()`释放锁操作\n\n\n``` java\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public boolean getCoupon(String userId, String materielId) throws Exception {\n        if (this.hasCoupon(userId, materielId)) {\n            throw new GlobalException(\"你已经领过券了\");\n        }\n        String userKey = userKey(userId, materielId).toString();\n        // 尝试获取锁 防止当前用户疯狂点击\n        RLock lock = redissonClient.getLock(userKey);\n        lock.tryLock(0L,20L, TimeUnit.SECONDS);\n        if (!lock.isLocked()) {\n            throw new GlobalException(\"请勿重复领取\");\n        }\n        try {\n            // 先尝试领卷 原子性减少卷数量 -1\n            Long sum = getCouponNum(materielId);\n            if (sum <= 0) {\n                throw new GlobalException(\"很遗憾，券已领完！\");\n            }\n            // 发生异常需要退还卷\n            PortalUserMateriel portalUserMateriel = initPortalUserMaterielByUserId(userId, materielId);\n            int saveNum  = portalUserMaterielMapper.insert(portalUserMateriel);\n            // 保存失败抛出异常执行退还操作\n            if (saveNum != 1) {\n                throw new GlobalException(\"抢卷失败\");\n            }\n\n        } catch (Exception e) {\n            log.error(userId+\"用户抢卷\"+materielId+\"失败\",e);\n            throw e;\n        } finally {\n            // 最终释放锁\n            lock.unlock();\n        }\n        // 领取成功插入领取记录\n        redisService.setModel(userKey, null);\n        return true;\n\n    }\n```\n\n如果对时效性不高可以使用队列去做抢卷的逻辑，这样可以保证大量的请求进行分发处理防止瞬间的大量请求拖垮服务器","slug":"抢卷并发代码Redis应用","published":1,"updated":"2020-11-18T07:41:21.548Z","_id":"ckhmyc9ax005gjsud5jtc5ssv","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>最近的项目有一个抢卷业务为保证性能使用<code>redis</code>来实现保证高并发性能，首先分析下抢卷业务</p>\n<ul>\n<li>优惠卷的数量不能超发，保证卷的一人一张</li>\n<li>锁的粒度尽可能的小</li>\n<li>锁的维度唯一性（用户id+卷id）</li>\n<li>优惠卷的数量事先写入<code>Redis</code>防止大量访问<code>DB</code>获取卷数量，<code>DB</code>由于数据的隔离性读取的数量也可能会不同发生超发场景</li>\n</ul>\n<h4 id=\"Redisson\"><a href=\"#Redisson\" class=\"headerlink\" title=\"Redisson\"></a>Redisson</h4><p>通过注入<code>RedissonClient</code>来实现各种锁场景<br><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.redisson<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>redisson<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre></p>\n<h3 id=\"代码流程\"><a href=\"#代码流程\" class=\"headerlink\" title=\"代码流程\"></a>代码流程</h3><ol>\n<li>尝试获取锁（用户id+卷id）唯一锁</li>\n<li>获取成功开始进行抢卷操作否则抢卷失败</li>\n<li>进行<code>DB</code>操作插入用户卷关联关系，插入成功进行缓存写入修改卷的数量和用户已抢卷的key防止用户多次抢卷</li>\n</ol>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-meta\">@Transactional</span>(rollbackFor = Exception<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">boolean</span> <span class=\"hljs-title\">getCoupon</span>(<span class=\"hljs-title\">String</span> <span class=\"hljs-title\">userId</span>, <span class=\"hljs-title\">String</span> <span class=\"hljs-title\">materielId</span>) <span class=\"hljs-title\">throws</span> <span class=\"hljs-title\">Exception</span> </span>&#123;\n    <span class=\"hljs-comment\">// 以优惠卷为维度加锁 防止超发</span>\n    String ticketLock = <span class=\"hljs-keyword\">new</span> StringBuilder(RedisPrefixEnum.LIVE_TICKET.getPrefix())\n            .append(materielId).toString();\n    <span class=\"hljs-comment\">// 用户领卷 key</span>\n    String tickerUser = <span class=\"hljs-keyword\">new</span> StringBuilder(RedisPrefixEnum.LIVE_COUPON_USER_LOCK.getPrefix())\n            .append(materielId).append(<span class=\"hljs-string\">\"_\"</span>).append(userId).toString();\n\n    SysUserEntity user = sysUserService.getById(userId);\n    <span class=\"hljs-keyword\">boolean</span> result = redisLocker.fairLock(ticketLock, () -&gt; &#123;\n        Integer ticketSum = checkTicket(userId, materielId);\n        <span class=\"hljs-comment\">// 领卷逻辑</span>\n        PortalMateriel portalMateriel = portalMaterielMapper.selectById(materielId);\n        PortalUserMateriel userMateriel = <span class=\"hljs-keyword\">new</span> PortalUserMateriel();\n        userMateriel.setId(UUIDUtils.get32UUID());\n        userMateriel.setUserId(userId); <span class=\"hljs-comment\">// 助力活动发起人</span>\n        userMateriel.setMaterielId(materielId);\n        userMateriel.setTel(user.getTel());\n        userMateriel.setMaterielCode(portalMateriel.getPre() + DateUtil.current(<span class=\"hljs-keyword\">true</span>));\n        userMateriel.setTitle(portalMateriel.getTitle());\n        userMateriel.setParValue(portalMateriel.getParValue());\n        userMateriel.setEndDate(portalMateriel.getEndDate());\n        userMateriel.setStatus(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 未使用</span>\n        userMateriel.setType(portalMateriel.getType()); <span class=\"hljs-comment\">// 优惠券</span>\n        <span class=\"hljs-comment\">// 插入用户物件表</span>\n        portalUserMaterielMapper.insert(userMateriel);\n        <span class=\"hljs-comment\">// 更新优惠卷数量缓存</span>\n        redisService.setModel(ticketLock, ticketSum - <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-comment\">// 新增领卷记录 key 防止用户多次领取</span>\n        redisService.setModel(tickerUser, <span class=\"hljs-keyword\">null</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    &#125;, <span class=\"hljs-number\">60</span>);\n    <span class=\"hljs-keyword\">return</span> result;\n\n&#125;</code></pre>\n<p>这里采用了<code>Redisson</code>组件方便使用各种锁，用户抢卷为了保证公平所有使用 <strong>fairLock公平锁</strong> ，当大量用户进行抢卷操作时根据等待时长顺序依次进行抢卷逻辑，首先卷的数量需要先缓存到<code>redis</code>中防止在高并发下直接访问<code>DB</code>从而影响正常使用</p>\n<p>在查阅了资料和同事的指导下对上述代码进行重构优化，采用<code>Redis</code>的原子性操作<code>decr</code>自减方法，锁的粒度也是以人为单位，卷的数量通过原子减是否小于等于0来判断用户领卷是否成功，使用<code>lock</code>锁对用户进行加锁，防止用户多次点击抢卷或通过其他方式请求抢卷接口，特别要注意设置锁的<strong>释放时间</strong>防止死锁导致后续所有请求阻塞产生系统严重性能问题，有异常后finally中必写<code>lock.unlock()</code>释放锁操作</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-meta\">@Transactional</span>(rollbackFor = Exception<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">boolean</span> <span class=\"hljs-title\">getCoupon</span>(<span class=\"hljs-title\">String</span> <span class=\"hljs-title\">userId</span>, <span class=\"hljs-title\">String</span> <span class=\"hljs-title\">materielId</span>) <span class=\"hljs-title\">throws</span> <span class=\"hljs-title\">Exception</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.hasCoupon(userId, materielId)) &#123;\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> GlobalException(<span class=\"hljs-string\">\"你已经领过券了\"</span>);\n    &#125;\n    String userKey = userKey(userId, materielId).toString();\n    <span class=\"hljs-comment\">// 尝试获取锁 防止当前用户疯狂点击</span>\n    RLock lock = redissonClient.getLock(userKey);\n    lock.tryLock(<span class=\"hljs-number\">0L</span>,<span class=\"hljs-number\">20L</span>, TimeUnit.SECONDS);\n    <span class=\"hljs-keyword\">if</span> (!lock.isLocked()) &#123;\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> GlobalException(<span class=\"hljs-string\">\"请勿重复领取\"</span>);\n    &#125;\n    <span class=\"hljs-keyword\">try</span> &#123;\n        <span class=\"hljs-comment\">// 先尝试领卷 原子性减少卷数量 -1</span>\n        Long sum = getCouponNum(materielId);\n        <span class=\"hljs-keyword\">if</span> (sum &lt;= <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> GlobalException(<span class=\"hljs-string\">\"很遗憾，券已领完！\"</span>);\n        &#125;\n        <span class=\"hljs-comment\">// 发生异常需要退还卷</span>\n        PortalUserMateriel portalUserMateriel = initPortalUserMaterielByUserId(userId, materielId);\n        <span class=\"hljs-keyword\">int</span> saveNum  = portalUserMaterielMapper.insert(portalUserMateriel);\n        <span class=\"hljs-comment\">// 保存失败抛出异常执行退还操作</span>\n        <span class=\"hljs-keyword\">if</span> (saveNum != <span class=\"hljs-number\">1</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> GlobalException(<span class=\"hljs-string\">\"抢卷失败\"</span>);\n        &#125;\n\n    &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n        log.error(userId+<span class=\"hljs-string\">\"用户抢卷\"</span>+materielId+<span class=\"hljs-string\">\"失败\"</span>,e);\n        <span class=\"hljs-keyword\">throw</span> e;\n    &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n        <span class=\"hljs-comment\">// 最终释放锁</span>\n        lock.unlock();\n    &#125;\n    <span class=\"hljs-comment\">// 领取成功插入领取记录</span>\n    redisService.setModel(userKey, <span class=\"hljs-keyword\">null</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n\n&#125;</code></pre>\n<p>如果对时效性不高可以使用队列去做抢卷的逻辑，这样可以保证大量的请求进行分发处理防止瞬间的大量请求拖垮服务器</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>最近的项目有一个抢卷业务为保证性能使用<code>redis</code>来实现保证高并发性能，首先分析下抢卷业务</p>\n<ul>\n<li>优惠卷的数量不能超发，保证卷的一人一张</li>\n<li>锁的粒度尽可能的小</li>\n<li>锁的维度唯一性（用户id+卷id）</li>\n<li>优惠卷的数量事先写入<code>Redis</code>防止大量访问<code>DB</code>获取卷数量，<code>DB</code>由于数据的隔离性读取的数量也可能会不同发生超发场景</li>\n</ul>\n<h4 id=\"Redisson\"><a href=\"#Redisson\" class=\"headerlink\" title=\"Redisson\"></a>Redisson</h4><p>通过注入<code>RedissonClient</code>来实现各种锁场景<br><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.redisson<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>redisson<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre></p>\n<h3 id=\"代码流程\"><a href=\"#代码流程\" class=\"headerlink\" title=\"代码流程\"></a>代码流程</h3><ol>\n<li>尝试获取锁（用户id+卷id）唯一锁</li>\n<li>获取成功开始进行抢卷操作否则抢卷失败</li>\n<li>进行<code>DB</code>操作插入用户卷关联关系，插入成功进行缓存写入修改卷的数量和用户已抢卷的key防止用户多次抢卷</li>\n</ol>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-meta\">@Transactional</span>(rollbackFor = Exception<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">boolean</span> <span class=\"hljs-title\">getCoupon</span>(<span class=\"hljs-title\">String</span> <span class=\"hljs-title\">userId</span>, <span class=\"hljs-title\">String</span> <span class=\"hljs-title\">materielId</span>) <span class=\"hljs-title\">throws</span> <span class=\"hljs-title\">Exception</span> </span>&#123;\n    <span class=\"hljs-comment\">// 以优惠卷为维度加锁 防止超发</span>\n    String ticketLock = <span class=\"hljs-keyword\">new</span> StringBuilder(RedisPrefixEnum.LIVE_TICKET.getPrefix())\n            .append(materielId).toString();\n    <span class=\"hljs-comment\">// 用户领卷 key</span>\n    String tickerUser = <span class=\"hljs-keyword\">new</span> StringBuilder(RedisPrefixEnum.LIVE_COUPON_USER_LOCK.getPrefix())\n            .append(materielId).append(<span class=\"hljs-string\">\"_\"</span>).append(userId).toString();\n\n    SysUserEntity user = sysUserService.getById(userId);\n    <span class=\"hljs-keyword\">boolean</span> result = redisLocker.fairLock(ticketLock, () -&gt; &#123;\n        Integer ticketSum = checkTicket(userId, materielId);\n        <span class=\"hljs-comment\">// 领卷逻辑</span>\n        PortalMateriel portalMateriel = portalMaterielMapper.selectById(materielId);\n        PortalUserMateriel userMateriel = <span class=\"hljs-keyword\">new</span> PortalUserMateriel();\n        userMateriel.setId(UUIDUtils.get32UUID());\n        userMateriel.setUserId(userId); <span class=\"hljs-comment\">// 助力活动发起人</span>\n        userMateriel.setMaterielId(materielId);\n        userMateriel.setTel(user.getTel());\n        userMateriel.setMaterielCode(portalMateriel.getPre() + DateUtil.current(<span class=\"hljs-keyword\">true</span>));\n        userMateriel.setTitle(portalMateriel.getTitle());\n        userMateriel.setParValue(portalMateriel.getParValue());\n        userMateriel.setEndDate(portalMateriel.getEndDate());\n        userMateriel.setStatus(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 未使用</span>\n        userMateriel.setType(portalMateriel.getType()); <span class=\"hljs-comment\">// 优惠券</span>\n        <span class=\"hljs-comment\">// 插入用户物件表</span>\n        portalUserMaterielMapper.insert(userMateriel);\n        <span class=\"hljs-comment\">// 更新优惠卷数量缓存</span>\n        redisService.setModel(ticketLock, ticketSum - <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-comment\">// 新增领卷记录 key 防止用户多次领取</span>\n        redisService.setModel(tickerUser, <span class=\"hljs-keyword\">null</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    &#125;, <span class=\"hljs-number\">60</span>);\n    <span class=\"hljs-keyword\">return</span> result;\n\n&#125;</code></pre>\n<p>这里采用了<code>Redisson</code>组件方便使用各种锁，用户抢卷为了保证公平所有使用 <strong>fairLock公平锁</strong> ，当大量用户进行抢卷操作时根据等待时长顺序依次进行抢卷逻辑，首先卷的数量需要先缓存到<code>redis</code>中防止在高并发下直接访问<code>DB</code>从而影响正常使用</p>\n<p>在查阅了资料和同事的指导下对上述代码进行重构优化，采用<code>Redis</code>的原子性操作<code>decr</code>自减方法，锁的粒度也是以人为单位，卷的数量通过原子减是否小于等于0来判断用户领卷是否成功，使用<code>lock</code>锁对用户进行加锁，防止用户多次点击抢卷或通过其他方式请求抢卷接口，特别要注意设置锁的<strong>释放时间</strong>防止死锁导致后续所有请求阻塞产生系统严重性能问题，有异常后finally中必写<code>lock.unlock()</code>释放锁操作</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-meta\">@Transactional</span>(rollbackFor = Exception<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)\n<span class=\"hljs-title\">public</span> <span class=\"hljs-title\">boolean</span> <span class=\"hljs-title\">getCoupon</span>(<span class=\"hljs-title\">String</span> <span class=\"hljs-title\">userId</span>, <span class=\"hljs-title\">String</span> <span class=\"hljs-title\">materielId</span>) <span class=\"hljs-title\">throws</span> <span class=\"hljs-title\">Exception</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.hasCoupon(userId, materielId)) &#123;\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> GlobalException(<span class=\"hljs-string\">\"你已经领过券了\"</span>);\n    &#125;\n    String userKey = userKey(userId, materielId).toString();\n    <span class=\"hljs-comment\">// 尝试获取锁 防止当前用户疯狂点击</span>\n    RLock lock = redissonClient.getLock(userKey);\n    lock.tryLock(<span class=\"hljs-number\">0L</span>,<span class=\"hljs-number\">20L</span>, TimeUnit.SECONDS);\n    <span class=\"hljs-keyword\">if</span> (!lock.isLocked()) &#123;\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> GlobalException(<span class=\"hljs-string\">\"请勿重复领取\"</span>);\n    &#125;\n    <span class=\"hljs-keyword\">try</span> &#123;\n        <span class=\"hljs-comment\">// 先尝试领卷 原子性减少卷数量 -1</span>\n        Long sum = getCouponNum(materielId);\n        <span class=\"hljs-keyword\">if</span> (sum &lt;= <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> GlobalException(<span class=\"hljs-string\">\"很遗憾，券已领完！\"</span>);\n        &#125;\n        <span class=\"hljs-comment\">// 发生异常需要退还卷</span>\n        PortalUserMateriel portalUserMateriel = initPortalUserMaterielByUserId(userId, materielId);\n        <span class=\"hljs-keyword\">int</span> saveNum  = portalUserMaterielMapper.insert(portalUserMateriel);\n        <span class=\"hljs-comment\">// 保存失败抛出异常执行退还操作</span>\n        <span class=\"hljs-keyword\">if</span> (saveNum != <span class=\"hljs-number\">1</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> GlobalException(<span class=\"hljs-string\">\"抢卷失败\"</span>);\n        &#125;\n\n    &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n        log.error(userId+<span class=\"hljs-string\">\"用户抢卷\"</span>+materielId+<span class=\"hljs-string\">\"失败\"</span>,e);\n        <span class=\"hljs-keyword\">throw</span> e;\n    &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n        <span class=\"hljs-comment\">// 最终释放锁</span>\n        lock.unlock();\n    &#125;\n    <span class=\"hljs-comment\">// 领取成功插入领取记录</span>\n    redisService.setModel(userKey, <span class=\"hljs-keyword\">null</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n\n&#125;</code></pre>\n<p>如果对时效性不高可以使用队列去做抢卷的逻辑，这样可以保证大量的请求进行分发处理防止瞬间的大量请求拖垮服务器</p>\n"},{"title":"阿里巴巴诊断器","date":"2019-04-28T01:41:02.000Z","_content":"\n![](/images/arthas.png)\n\n> Arthas 是阿里巴巴开源的一款 Java 诊断器，可查看`Jvm`运行状态、堆栈异常、Class运行加载情况反编译等\n\n### Arthas 安装\n`Artas` 建议安装使用`arthas-boot.jar`，安装地址 https://alibaba.github.io/arthas/arthas-boot.jar\n``` powershell\n# Linux 下载\nwget https://alibaba.github.io/arthas/arthas-boot.jar\n# 运行\njava -jar arthas-boot.jar\n```\n运行可以查看到所有运行的`java`进程，可以通过`Web Console`进行调试，默认地址为 http://127.0.0.1:8563/ 也可以通过`IP`访问其他机器上的`Arthas`\n![Web Console](/images/arthas-web-console.png)\n### 命令分类\n\n##### 基础命令\n- **help**——查看命令帮助信息\n- **cat**——打印文件内容，和linux里的cat命令类似\n- **pwd**——返回当前的工作目录，和linux命令类似\n- **cls**——清空当前屏幕区域\n- **session**——查看当前会话的信息\n- **reset**——重置增强类，将被`Arthas`增强过的类全部还原，`Arthas`服务端关闭时会重置所有增强过的类\n- **version**——输出当前目标 Java 进程所加载的 Arthas 版本号\n- **history**——打印命令历史\n- **quit**——退出当前`Arthas`客户端，其他`Arthas`客户端不受影响\n- **shutdown**——关闭`Arthas`服务端，所有`Arthas`客户端全部退出\n- **keymap**——`Arthas`快捷键列表及自定义快捷键\n\n##### Jvm相关\n- **dashboard**——当前系统的实时数据面板\n- **thread**——查看当前 JVM 的线程堆栈信息\n- **jvm**——查看当前 JVM 的信息\n- **sysprop**——查看和修改JVM的系统属性\n- **sysenv**——查看JVM的环境变量\n- **getstatic**——查看类的静态属性\n- **ognl**——执行`ognl`表达式\n\n---\n### 常用指令\n``` powershell\n# 查看所有线程 无参\nthread\n# 查看前3最占用CPU线程堆栈\nthread -n 3 \n# 查看线程ID为5的堆栈\nthread 5\n# 查看阻塞的线程堆栈（只支持`synchronized`关键字阻塞的线程）\nthreah -b\n# 查看某线程采样时间间隔\nthread 3 -i 3000\n# 查看Jvm属性的值 无参则是所有\nsysprpo [属性]\n# 查看Jvm环境变量 无参则是所有\nsysenv [属性]\n# 查看搜索所有加载的类 配合 * 模糊查询\nsc [通配符*]\n# 查找加载UserController的 ClassLoader\nsc -d *UserController | grep classLoaderHash\n# 查看某类的详情以及成员变量\nsc [类路径] -d -f\n# 查看某类的方法 配合 * 模糊查询  -d 显示详情\nsm [类路径] [方法名] -d\n# 反编译 默认情况下，反编译结果里会带有ClassLoader信息\n# 通过--source-only选项，可以只打印源代码。方便和mc/redefine命令结合使用\n# 使用 > 指定路径生成文件\njad [类路径] [方法名] > [生成路径]\n# 监控器 -c 周期时间 默认值120秒  返回方法调用情况 \nmonitor -c 30 [类路径] [方法名]\n# 观察类方法运行情况 分4种观察点 -b 方法调用前，-e 方法异常后，-s 方法返回后，-f 方法结束后\nwatch [类路径] [方法名] [ognl表达式]\n```\n\n##### 详细的文档可以查看 https://alibaba.github.io/arthas/index.html \n","source":"_posts/阿里巴巴诊断器.md","raw":"---\ntitle: 阿里巴巴诊断器\ndate: 2019-04-28 09:41:02\ncategories: [Java]\ntags:\n\t - Java\n---\n\n![](/images/arthas.png)\n\n> Arthas 是阿里巴巴开源的一款 Java 诊断器，可查看`Jvm`运行状态、堆栈异常、Class运行加载情况反编译等\n\n### Arthas 安装\n`Artas` 建议安装使用`arthas-boot.jar`，安装地址 https://alibaba.github.io/arthas/arthas-boot.jar\n``` powershell\n# Linux 下载\nwget https://alibaba.github.io/arthas/arthas-boot.jar\n# 运行\njava -jar arthas-boot.jar\n```\n运行可以查看到所有运行的`java`进程，可以通过`Web Console`进行调试，默认地址为 http://127.0.0.1:8563/ 也可以通过`IP`访问其他机器上的`Arthas`\n![Web Console](/images/arthas-web-console.png)\n### 命令分类\n\n##### 基础命令\n- **help**——查看命令帮助信息\n- **cat**——打印文件内容，和linux里的cat命令类似\n- **pwd**——返回当前的工作目录，和linux命令类似\n- **cls**——清空当前屏幕区域\n- **session**——查看当前会话的信息\n- **reset**——重置增强类，将被`Arthas`增强过的类全部还原，`Arthas`服务端关闭时会重置所有增强过的类\n- **version**——输出当前目标 Java 进程所加载的 Arthas 版本号\n- **history**——打印命令历史\n- **quit**——退出当前`Arthas`客户端，其他`Arthas`客户端不受影响\n- **shutdown**——关闭`Arthas`服务端，所有`Arthas`客户端全部退出\n- **keymap**——`Arthas`快捷键列表及自定义快捷键\n\n##### Jvm相关\n- **dashboard**——当前系统的实时数据面板\n- **thread**——查看当前 JVM 的线程堆栈信息\n- **jvm**——查看当前 JVM 的信息\n- **sysprop**——查看和修改JVM的系统属性\n- **sysenv**——查看JVM的环境变量\n- **getstatic**——查看类的静态属性\n- **ognl**——执行`ognl`表达式\n\n---\n### 常用指令\n``` powershell\n# 查看所有线程 无参\nthread\n# 查看前3最占用CPU线程堆栈\nthread -n 3 \n# 查看线程ID为5的堆栈\nthread 5\n# 查看阻塞的线程堆栈（只支持`synchronized`关键字阻塞的线程）\nthreah -b\n# 查看某线程采样时间间隔\nthread 3 -i 3000\n# 查看Jvm属性的值 无参则是所有\nsysprpo [属性]\n# 查看Jvm环境变量 无参则是所有\nsysenv [属性]\n# 查看搜索所有加载的类 配合 * 模糊查询\nsc [通配符*]\n# 查找加载UserController的 ClassLoader\nsc -d *UserController | grep classLoaderHash\n# 查看某类的详情以及成员变量\nsc [类路径] -d -f\n# 查看某类的方法 配合 * 模糊查询  -d 显示详情\nsm [类路径] [方法名] -d\n# 反编译 默认情况下，反编译结果里会带有ClassLoader信息\n# 通过--source-only选项，可以只打印源代码。方便和mc/redefine命令结合使用\n# 使用 > 指定路径生成文件\njad [类路径] [方法名] > [生成路径]\n# 监控器 -c 周期时间 默认值120秒  返回方法调用情况 \nmonitor -c 30 [类路径] [方法名]\n# 观察类方法运行情况 分4种观察点 -b 方法调用前，-e 方法异常后，-s 方法返回后，-f 方法结束后\nwatch [类路径] [方法名] [ognl表达式]\n```\n\n##### 详细的文档可以查看 https://alibaba.github.io/arthas/index.html \n","slug":"阿里巴巴诊断器","published":1,"updated":"2020-08-10T01:48:44.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhmyc9b0005kjsudl6tdjh4t","content":"<p><img src=\"/images/arthas.png\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>Arthas 是阿里巴巴开源的一款 Java 诊断器，可查看<code>Jvm</code>运行状态、堆栈异常、Class运行加载情况反编译等</p>\n</blockquote>\n<h3 id=\"Arthas-安装\"><a href=\"#Arthas-安装\" class=\"headerlink\" title=\"Arthas 安装\"></a>Arthas 安装</h3><p><code>Artas</code> 建议安装使用<code>arthas-boot.jar</code>，安装地址 <a href=\"https://alibaba.github.io/arthas/arthas-boot.jar\" target=\"_blank\" rel=\"noopener\">https://alibaba.github.io/arthas/arthas-boot.jar</a><br><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># Linux 下载</span>\nwget https://alibaba.github.io/arthas/arthas<span class=\"hljs-literal\">-boot</span>.jar\n<span class=\"hljs-comment\"># 运行</span>\njava <span class=\"hljs-literal\">-jar</span> arthas<span class=\"hljs-literal\">-boot</span>.jar</code></pre></p>\n<p>运行可以查看到所有运行的<code>java</code>进程，可以通过<code>Web Console</code>进行调试，默认地址为 <a href=\"http://127.0.0.1:8563/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8563/</a> 也可以通过<code>IP</code>访问其他机器上的<code>Arthas</code><br><img src=\"/images/arthas-web-console.png\" srcset=\"/img/loading.gif\" alt=\"Web Console\"></p>\n<h3 id=\"命令分类\"><a href=\"#命令分类\" class=\"headerlink\" title=\"命令分类\"></a>命令分类</h3><h5 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h5><ul>\n<li><strong>help</strong>——查看命令帮助信息</li>\n<li><strong>cat</strong>——打印文件内容，和linux里的cat命令类似</li>\n<li><strong>pwd</strong>——返回当前的工作目录，和linux命令类似</li>\n<li><strong>cls</strong>——清空当前屏幕区域</li>\n<li><strong>session</strong>——查看当前会话的信息</li>\n<li><strong>reset</strong>——重置增强类，将被<code>Arthas</code>增强过的类全部还原，<code>Arthas</code>服务端关闭时会重置所有增强过的类</li>\n<li><strong>version</strong>——输出当前目标 Java 进程所加载的 Arthas 版本号</li>\n<li><strong>history</strong>——打印命令历史</li>\n<li><strong>quit</strong>——退出当前<code>Arthas</code>客户端，其他<code>Arthas</code>客户端不受影响</li>\n<li><strong>shutdown</strong>——关闭<code>Arthas</code>服务端，所有<code>Arthas</code>客户端全部退出</li>\n<li><strong>keymap</strong>——<code>Arthas</code>快捷键列表及自定义快捷键</li>\n</ul>\n<h5 id=\"Jvm相关\"><a href=\"#Jvm相关\" class=\"headerlink\" title=\"Jvm相关\"></a>Jvm相关</h5><ul>\n<li><strong>dashboard</strong>——当前系统的实时数据面板</li>\n<li><strong>thread</strong>——查看当前 JVM 的线程堆栈信息</li>\n<li><strong>jvm</strong>——查看当前 JVM 的信息</li>\n<li><strong>sysprop</strong>——查看和修改JVM的系统属性</li>\n<li><strong>sysenv</strong>——查看JVM的环境变量</li>\n<li><strong>getstatic</strong>——查看类的静态属性</li>\n<li><strong>ognl</strong>——执行<code>ognl</code>表达式</li>\n</ul>\n<hr>\n<h3 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h3><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># 查看所有线程 无参</span>\nthread\n<span class=\"hljs-comment\"># 查看前3最占用CPU线程堆栈</span>\nthread <span class=\"hljs-literal\">-n</span> <span class=\"hljs-number\">3</span> \n<span class=\"hljs-comment\"># 查看线程ID为5的堆栈</span>\nthread <span class=\"hljs-number\">5</span>\n<span class=\"hljs-comment\"># 查看阻塞的线程堆栈（只支持`synchronized`关键字阻塞的线程）</span>\nthreah <span class=\"hljs-literal\">-b</span>\n<span class=\"hljs-comment\"># 查看某线程采样时间间隔</span>\nthread <span class=\"hljs-number\">3</span> <span class=\"hljs-literal\">-i</span> <span class=\"hljs-number\">3000</span>\n<span class=\"hljs-comment\"># 查看Jvm属性的值 无参则是所有</span>\nsysprpo [属性]\n<span class=\"hljs-comment\"># 查看Jvm环境变量 无参则是所有</span>\nsysenv [属性]\n<span class=\"hljs-comment\"># 查看搜索所有加载的类 配合 * 模糊查询</span>\nsc [通配符*]\n<span class=\"hljs-comment\"># 查找加载UserController的 ClassLoader</span>\nsc <span class=\"hljs-literal\">-d</span> *UserController | grep classLoaderHash\n<span class=\"hljs-comment\"># 查看某类的详情以及成员变量</span>\nsc [类路径] <span class=\"hljs-literal\">-d</span> <span class=\"hljs-operator\">-f</span>\n<span class=\"hljs-comment\"># 查看某类的方法 配合 * 模糊查询  -d 显示详情</span>\nsm [类路径] [方法名] <span class=\"hljs-literal\">-d</span>\n<span class=\"hljs-comment\"># 反编译 默认情况下，反编译结果里会带有ClassLoader信息</span>\n<span class=\"hljs-comment\"># 通过--source-only选项，可以只打印源代码。方便和mc/redefine命令结合使用</span>\n<span class=\"hljs-comment\"># 使用 &gt; 指定路径生成文件</span>\njad [类路径] [方法名] &gt; [生成路径]\n<span class=\"hljs-comment\"># 监控器 -c 周期时间 默认值120秒  返回方法调用情况 </span>\nmonitor <span class=\"hljs-literal\">-c</span> <span class=\"hljs-number\">30</span> [类路径] [方法名]\n<span class=\"hljs-comment\"># 观察类方法运行情况 分4种观察点 -b 方法调用前，-e 方法异常后，-s 方法返回后，-f 方法结束后</span>\nwatch [类路径] [方法名] [<span class=\"hljs-type\">ognl</span>表达式]</code></pre>\n<h5 id=\"详细的文档可以查看-https-alibaba-github-io-arthas-index-html\"><a href=\"#详细的文档可以查看-https-alibaba-github-io-arthas-index-html\" class=\"headerlink\" title=\"详细的文档可以查看 https://alibaba.github.io/arthas/index.html\"></a>详细的文档可以查看 <a href=\"https://alibaba.github.io/arthas/index.html\" target=\"_blank\" rel=\"noopener\">https://alibaba.github.io/arthas/index.html</a></h5>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/arthas.png\" srcset=\"/img/loading.gif\" alt></p>\n<blockquote>\n<p>Arthas 是阿里巴巴开源的一款 Java 诊断器，可查看<code>Jvm</code>运行状态、堆栈异常、Class运行加载情况反编译等</p>\n</blockquote>\n<h3 id=\"Arthas-安装\"><a href=\"#Arthas-安装\" class=\"headerlink\" title=\"Arthas 安装\"></a>Arthas 安装</h3><p><code>Artas</code> 建议安装使用<code>arthas-boot.jar</code>，安装地址 <a href=\"https://alibaba.github.io/arthas/arthas-boot.jar\" target=\"_blank\" rel=\"noopener\">https://alibaba.github.io/arthas/arthas-boot.jar</a><br><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># Linux 下载</span>\nwget https://alibaba.github.io/arthas/arthas<span class=\"hljs-literal\">-boot</span>.jar\n<span class=\"hljs-comment\"># 运行</span>\njava <span class=\"hljs-literal\">-jar</span> arthas<span class=\"hljs-literal\">-boot</span>.jar</code></pre></p>\n<p>运行可以查看到所有运行的<code>java</code>进程，可以通过<code>Web Console</code>进行调试，默认地址为 <a href=\"http://127.0.0.1:8563/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8563/</a> 也可以通过<code>IP</code>访问其他机器上的<code>Arthas</code><br><img src=\"/images/arthas-web-console.png\" srcset=\"/img/loading.gif\" alt=\"Web Console\"></p>\n<h3 id=\"命令分类\"><a href=\"#命令分类\" class=\"headerlink\" title=\"命令分类\"></a>命令分类</h3><h5 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h5><ul>\n<li><strong>help</strong>——查看命令帮助信息</li>\n<li><strong>cat</strong>——打印文件内容，和linux里的cat命令类似</li>\n<li><strong>pwd</strong>——返回当前的工作目录，和linux命令类似</li>\n<li><strong>cls</strong>——清空当前屏幕区域</li>\n<li><strong>session</strong>——查看当前会话的信息</li>\n<li><strong>reset</strong>——重置增强类，将被<code>Arthas</code>增强过的类全部还原，<code>Arthas</code>服务端关闭时会重置所有增强过的类</li>\n<li><strong>version</strong>——输出当前目标 Java 进程所加载的 Arthas 版本号</li>\n<li><strong>history</strong>——打印命令历史</li>\n<li><strong>quit</strong>——退出当前<code>Arthas</code>客户端，其他<code>Arthas</code>客户端不受影响</li>\n<li><strong>shutdown</strong>——关闭<code>Arthas</code>服务端，所有<code>Arthas</code>客户端全部退出</li>\n<li><strong>keymap</strong>——<code>Arthas</code>快捷键列表及自定义快捷键</li>\n</ul>\n<h5 id=\"Jvm相关\"><a href=\"#Jvm相关\" class=\"headerlink\" title=\"Jvm相关\"></a>Jvm相关</h5><ul>\n<li><strong>dashboard</strong>——当前系统的实时数据面板</li>\n<li><strong>thread</strong>——查看当前 JVM 的线程堆栈信息</li>\n<li><strong>jvm</strong>——查看当前 JVM 的信息</li>\n<li><strong>sysprop</strong>——查看和修改JVM的系统属性</li>\n<li><strong>sysenv</strong>——查看JVM的环境变量</li>\n<li><strong>getstatic</strong>——查看类的静态属性</li>\n<li><strong>ognl</strong>——执行<code>ognl</code>表达式</li>\n</ul>\n<hr>\n<h3 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h3><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># 查看所有线程 无参</span>\nthread\n<span class=\"hljs-comment\"># 查看前3最占用CPU线程堆栈</span>\nthread <span class=\"hljs-literal\">-n</span> <span class=\"hljs-number\">3</span> \n<span class=\"hljs-comment\"># 查看线程ID为5的堆栈</span>\nthread <span class=\"hljs-number\">5</span>\n<span class=\"hljs-comment\"># 查看阻塞的线程堆栈（只支持`synchronized`关键字阻塞的线程）</span>\nthreah <span class=\"hljs-literal\">-b</span>\n<span class=\"hljs-comment\"># 查看某线程采样时间间隔</span>\nthread <span class=\"hljs-number\">3</span> <span class=\"hljs-literal\">-i</span> <span class=\"hljs-number\">3000</span>\n<span class=\"hljs-comment\"># 查看Jvm属性的值 无参则是所有</span>\nsysprpo [属性]\n<span class=\"hljs-comment\"># 查看Jvm环境变量 无参则是所有</span>\nsysenv [属性]\n<span class=\"hljs-comment\"># 查看搜索所有加载的类 配合 * 模糊查询</span>\nsc [通配符*]\n<span class=\"hljs-comment\"># 查找加载UserController的 ClassLoader</span>\nsc <span class=\"hljs-literal\">-d</span> *UserController | grep classLoaderHash\n<span class=\"hljs-comment\"># 查看某类的详情以及成员变量</span>\nsc [类路径] <span class=\"hljs-literal\">-d</span> <span class=\"hljs-operator\">-f</span>\n<span class=\"hljs-comment\"># 查看某类的方法 配合 * 模糊查询  -d 显示详情</span>\nsm [类路径] [方法名] <span class=\"hljs-literal\">-d</span>\n<span class=\"hljs-comment\"># 反编译 默认情况下，反编译结果里会带有ClassLoader信息</span>\n<span class=\"hljs-comment\"># 通过--source-only选项，可以只打印源代码。方便和mc/redefine命令结合使用</span>\n<span class=\"hljs-comment\"># 使用 &gt; 指定路径生成文件</span>\njad [类路径] [方法名] &gt; [生成路径]\n<span class=\"hljs-comment\"># 监控器 -c 周期时间 默认值120秒  返回方法调用情况 </span>\nmonitor <span class=\"hljs-literal\">-c</span> <span class=\"hljs-number\">30</span> [类路径] [方法名]\n<span class=\"hljs-comment\"># 观察类方法运行情况 分4种观察点 -b 方法调用前，-e 方法异常后，-s 方法返回后，-f 方法结束后</span>\nwatch [类路径] [方法名] [<span class=\"hljs-type\">ognl</span>表达式]</code></pre>\n<h5 id=\"详细的文档可以查看-https-alibaba-github-io-arthas-index-html\"><a href=\"#详细的文档可以查看-https-alibaba-github-io-arthas-index-html\" class=\"headerlink\" title=\"详细的文档可以查看 https://alibaba.github.io/arthas/index.html\"></a>详细的文档可以查看 <a href=\"https://alibaba.github.io/arthas/index.html\" target=\"_blank\" rel=\"noopener\">https://alibaba.github.io/arthas/index.html</a></h5>"},{"title":"Spring Security 集成 Jwt","toc":false,"date":"2020-12-21T07:57:28.000Z","_content":"\n### maven集成\nSpring Security 权限安全框架\n\n\n``` xml\n<!--安全-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\n<!--jwt-->\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt</artifactId>\n    <version>0.9.1</version>\n</dependency>\n```\n\n### 安全配置\n继承`WebSecurityConfigurerAdapter`编写相关配置、`@EnableWebSecurity`开启web安全，`@EnableGlobalMethodSecurity`开启全局方法安全设置，`prePostEnabled `开启方法请求前后校验例如`@PreAuthorize(\"hasAuthority('KHZX.MXGL.CK')\")` 请求用户是否拥有权限\n\n\n``` java\n/**\n * 权限配置中心\n *\n * @author Major.Fang\n */\n@Slf4j\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class SecurityConfigurer extends WebSecurityConfigurerAdapter implements ApplicationContextAware {\n\n    @Autowired\n    private RedisUtil redisUtil;\n\n\n    /**\n     * 路径过滤白名单无需携带token\n     *\n     * @param web\n     * @throws Exception\n     */\n    @Override\n    public void configure(WebSecurity web)  {\n        web.ignoring()\n                .antMatchers(\"/swagger-ui.html\")\n                .antMatchers(\"/v2/**\")\n                .antMatchers(\"/swagger-resources/**\")\n                .antMatchers(\"/index/*\")\n                .antMatchers(\"/common/upload\")\n                .antMatchers(whiteList());\n    }\n\n\n    /**\n     * 白名单处理\n     * @return\n     */\n    private String[] whiteList(){\n        RequestMappingHandlerMapping requestMappingHandlerMapping = super.getApplicationContext().getBean(RequestMappingHandlerMapping.class);\n        Map<RequestMappingInfo, HandlerMethod> map = requestMappingHandlerMapping.getHandlerMethods();\n        Set<String> whiteList = new HashSet<>();\n        for(Map.Entry<RequestMappingInfo,HandlerMethod> entry:map.entrySet()){\n            HandlerMethod handlerMethod = entry.getValue();\n            RequestMappingInfo requestMappingInfo = entry.getKey();\n            if(handlerMethod.hasMethodAnnotation(WhiteList.class)){\n                whiteList.addAll(requestMappingInfo.getPatternsCondition().getPatterns());\n            }\n        }\n        return whiteList.toArray(new String[whiteList.size()]);\n    }\n\n    /**\n     * 请求认证配置\n     *\n     * @param httpSecurity\n     * @throws Exception\n     */\n    @Override\n    protected void configure(HttpSecurity httpSecurity) throws Exception {\n        // 除去特殊路径意外所有请求需要认证\n        httpSecurity.authorizeRequests()\n                .antMatchers(\"/index/*\").permitAll()\n                .antMatchers(\"/common/upload\").permitAll()\n                .anyRequest().authenticated();\n        // 无需开启csrf 非法跨域请求拦截\n        httpSecurity.csrf().disable();\n        // 禁用 Security 的 Session策略\n        httpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        // 访问异常处理 认证用户访问无权限资源时的异常\n        httpSecurity.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler());\n        // 添加 JWT 过滤器\n        httpSecurity.addFilterAfter(new JwtAuthenticationTokenFilter(redisUtil), UsernamePasswordAuthenticationFilter.class);\n        // 禁用缓存\n        httpSecurity.headers().cacheControl();\n\n    }\n\n    /**\n     * 认证用户没有权限访问资源\n     */\n    private class MyAccessDeniedHandler implements AccessDeniedHandler {\n\n        @Override\n        public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException {\n            HttpResponseUtil.writeError(HttpStatus.HS_FORBIDDEN, httpServletResponse);\n        }\n    }\n```\n\n#### Jwt认证过滤器\n``` java \n/**\n * JWT Token 认证过滤器\n * 1.请求头Headers 是否包含 token\n * 2.token进行校验是否合法、是否过期、签名是否校验成功\n * 3.通过token获取用户userId获取缓存中的用户信息\n * 4.上述都校验成功构建用户资源权限校验实体交予安全上下文进行权限处理\n *\n * @author Major.Fang\n */\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\n\n    private RedisUtil redisUtil;\n\n    public JwtAuthenticationTokenFilter(RedisUtil redisUtil) {\n        this.redisUtil = redisUtil;\n    }\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {\n        String token = httpServletRequest.getHeader(\"Authorization\");\n        if (StrUtil.isEmpty(token)) {\n            HttpResponseUtil.writeError(HttpStatus.HS_ILLEGAL_TOKEN, httpServletResponse);\n            return;\n        }\n        HttpStatus errorStatus = JwtUtil.verifyToken(token);\n        if (errorStatus != null) {\n            HttpResponseUtil.writeError(errorStatus, httpServletResponse);\n            return;\n        }\n        SecurityUserDetails securityUserDetails = redisUtil.getValue(RedisKeyConstant.SYS_USER_TOKEN + token, SecurityUserDetails.class);\n        if (securityUserDetails == null) {\n            HttpResponseUtil.writeError(HttpStatus.HS_ILLEGAL_TOKEN,httpServletResponse);\n            return;\n        }\n        // 构建验证所需对象参数交予安全上下文进行权限校验\n        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(\n                securityUserDetails, null, securityUserDetails.getAuthorities());\n        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(\n                httpServletRequest));\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        filterChain.doFilter(httpServletRequest, httpServletResponse);\n    }\n}\n```\n#### JwtUtil 工具类\n``` java\n/**\n * Jwt 工具\n *\n * @author Major.Fang\n */\npublic class JwtUtil {\n    /**\n     * token的密码\n     **/\n    private static String tokenPassword = \"ZK-PRODUCT\";\n\n    /**\n     * token的有效时长，小时为单位\n     **/\n    private static Long liveHours = 24L;\n\n    /**\n     * 根据用户id生成token\n     *\n     * @param userId\n     * @return\n     */\n    public static String genTokenByUserId(String userId) {\n        return Jwts.builder()\n                .setClaims(null)\n                .setId(userId)\n                .setIssuedAt(new Date())\n                .setExpiration(new Date(System.currentTimeMillis() + liveHours * 60 * 60 * 1000))\n                .signWith(SignatureAlgorithm.HS256, tokenPassword)\n                .compact();\n    }\n\n    /**\n     * 校验Token\n     *\n     * @param token\n     * @return  错误状态码\n     */\n    public static HttpStatus verifyToken(String token) {\n        try {\n            getClaims(token);\n        } catch (ExpiredJwtException e) {\n            return HttpStatus.HS_TOKEN_EXPIRED;\n        } catch (SignatureException e) {\n            return HttpStatus.HS_TOKEN_INSUFFICIENT;\n        } catch (MalformedJwtException e){\n            return HttpStatus.HS_ILLEGAL_TOKEN;\n        }\n        return null;\n    }\n\n    /**\n     * 根据Token获取userId\n     *\n     * @param token\n     * @return\n     */\n    public static String getUserIdByToken(String token) {\n        Claims claims = getClaims(token);\n        return Optional.of(claims).map(Claims::getId).orElse(null);\n    }\n\n    private static Claims getClaims(String token) {\n        return Jwts.parser().setSigningKey(tokenPassword).parseClaimsJws(token).getBody();\n    }\n}\n```","source":"_posts/Spring-Security-集成-Jwt.md","raw":"---\ntitle: Spring Security 集成 Jwt\ntags:\n  - Spring\ncategories:\n  - Java\ntoc: false\ndate: 2020-12-21 15:57:28\n---\n\n### maven集成\nSpring Security 权限安全框架\n\n\n``` xml\n<!--安全-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\n<!--jwt-->\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt</artifactId>\n    <version>0.9.1</version>\n</dependency>\n```\n\n### 安全配置\n继承`WebSecurityConfigurerAdapter`编写相关配置、`@EnableWebSecurity`开启web安全，`@EnableGlobalMethodSecurity`开启全局方法安全设置，`prePostEnabled `开启方法请求前后校验例如`@PreAuthorize(\"hasAuthority('KHZX.MXGL.CK')\")` 请求用户是否拥有权限\n\n\n``` java\n/**\n * 权限配置中心\n *\n * @author Major.Fang\n */\n@Slf4j\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class SecurityConfigurer extends WebSecurityConfigurerAdapter implements ApplicationContextAware {\n\n    @Autowired\n    private RedisUtil redisUtil;\n\n\n    /**\n     * 路径过滤白名单无需携带token\n     *\n     * @param web\n     * @throws Exception\n     */\n    @Override\n    public void configure(WebSecurity web)  {\n        web.ignoring()\n                .antMatchers(\"/swagger-ui.html\")\n                .antMatchers(\"/v2/**\")\n                .antMatchers(\"/swagger-resources/**\")\n                .antMatchers(\"/index/*\")\n                .antMatchers(\"/common/upload\")\n                .antMatchers(whiteList());\n    }\n\n\n    /**\n     * 白名单处理\n     * @return\n     */\n    private String[] whiteList(){\n        RequestMappingHandlerMapping requestMappingHandlerMapping = super.getApplicationContext().getBean(RequestMappingHandlerMapping.class);\n        Map<RequestMappingInfo, HandlerMethod> map = requestMappingHandlerMapping.getHandlerMethods();\n        Set<String> whiteList = new HashSet<>();\n        for(Map.Entry<RequestMappingInfo,HandlerMethod> entry:map.entrySet()){\n            HandlerMethod handlerMethod = entry.getValue();\n            RequestMappingInfo requestMappingInfo = entry.getKey();\n            if(handlerMethod.hasMethodAnnotation(WhiteList.class)){\n                whiteList.addAll(requestMappingInfo.getPatternsCondition().getPatterns());\n            }\n        }\n        return whiteList.toArray(new String[whiteList.size()]);\n    }\n\n    /**\n     * 请求认证配置\n     *\n     * @param httpSecurity\n     * @throws Exception\n     */\n    @Override\n    protected void configure(HttpSecurity httpSecurity) throws Exception {\n        // 除去特殊路径意外所有请求需要认证\n        httpSecurity.authorizeRequests()\n                .antMatchers(\"/index/*\").permitAll()\n                .antMatchers(\"/common/upload\").permitAll()\n                .anyRequest().authenticated();\n        // 无需开启csrf 非法跨域请求拦截\n        httpSecurity.csrf().disable();\n        // 禁用 Security 的 Session策略\n        httpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        // 访问异常处理 认证用户访问无权限资源时的异常\n        httpSecurity.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler());\n        // 添加 JWT 过滤器\n        httpSecurity.addFilterAfter(new JwtAuthenticationTokenFilter(redisUtil), UsernamePasswordAuthenticationFilter.class);\n        // 禁用缓存\n        httpSecurity.headers().cacheControl();\n\n    }\n\n    /**\n     * 认证用户没有权限访问资源\n     */\n    private class MyAccessDeniedHandler implements AccessDeniedHandler {\n\n        @Override\n        public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException {\n            HttpResponseUtil.writeError(HttpStatus.HS_FORBIDDEN, httpServletResponse);\n        }\n    }\n```\n\n#### Jwt认证过滤器\n``` java \n/**\n * JWT Token 认证过滤器\n * 1.请求头Headers 是否包含 token\n * 2.token进行校验是否合法、是否过期、签名是否校验成功\n * 3.通过token获取用户userId获取缓存中的用户信息\n * 4.上述都校验成功构建用户资源权限校验实体交予安全上下文进行权限处理\n *\n * @author Major.Fang\n */\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\n\n    private RedisUtil redisUtil;\n\n    public JwtAuthenticationTokenFilter(RedisUtil redisUtil) {\n        this.redisUtil = redisUtil;\n    }\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {\n        String token = httpServletRequest.getHeader(\"Authorization\");\n        if (StrUtil.isEmpty(token)) {\n            HttpResponseUtil.writeError(HttpStatus.HS_ILLEGAL_TOKEN, httpServletResponse);\n            return;\n        }\n        HttpStatus errorStatus = JwtUtil.verifyToken(token);\n        if (errorStatus != null) {\n            HttpResponseUtil.writeError(errorStatus, httpServletResponse);\n            return;\n        }\n        SecurityUserDetails securityUserDetails = redisUtil.getValue(RedisKeyConstant.SYS_USER_TOKEN + token, SecurityUserDetails.class);\n        if (securityUserDetails == null) {\n            HttpResponseUtil.writeError(HttpStatus.HS_ILLEGAL_TOKEN,httpServletResponse);\n            return;\n        }\n        // 构建验证所需对象参数交予安全上下文进行权限校验\n        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(\n                securityUserDetails, null, securityUserDetails.getAuthorities());\n        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(\n                httpServletRequest));\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        filterChain.doFilter(httpServletRequest, httpServletResponse);\n    }\n}\n```\n#### JwtUtil 工具类\n``` java\n/**\n * Jwt 工具\n *\n * @author Major.Fang\n */\npublic class JwtUtil {\n    /**\n     * token的密码\n     **/\n    private static String tokenPassword = \"ZK-PRODUCT\";\n\n    /**\n     * token的有效时长，小时为单位\n     **/\n    private static Long liveHours = 24L;\n\n    /**\n     * 根据用户id生成token\n     *\n     * @param userId\n     * @return\n     */\n    public static String genTokenByUserId(String userId) {\n        return Jwts.builder()\n                .setClaims(null)\n                .setId(userId)\n                .setIssuedAt(new Date())\n                .setExpiration(new Date(System.currentTimeMillis() + liveHours * 60 * 60 * 1000))\n                .signWith(SignatureAlgorithm.HS256, tokenPassword)\n                .compact();\n    }\n\n    /**\n     * 校验Token\n     *\n     * @param token\n     * @return  错误状态码\n     */\n    public static HttpStatus verifyToken(String token) {\n        try {\n            getClaims(token);\n        } catch (ExpiredJwtException e) {\n            return HttpStatus.HS_TOKEN_EXPIRED;\n        } catch (SignatureException e) {\n            return HttpStatus.HS_TOKEN_INSUFFICIENT;\n        } catch (MalformedJwtException e){\n            return HttpStatus.HS_ILLEGAL_TOKEN;\n        }\n        return null;\n    }\n\n    /**\n     * 根据Token获取userId\n     *\n     * @param token\n     * @return\n     */\n    public static String getUserIdByToken(String token) {\n        Claims claims = getClaims(token);\n        return Optional.of(claims).map(Claims::getId).orElse(null);\n    }\n\n    private static Claims getClaims(String token) {\n        return Jwts.parser().setSigningKey(tokenPassword).parseClaimsJws(token).getBody();\n    }\n}\n```","slug":"Spring-Security-集成-Jwt","published":1,"updated":"2021-03-02T01:24:27.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklrbwso10000f8uds0770ph7","content":"<h3 id=\"maven集成\"><a href=\"#maven集成\" class=\"headerlink\" title=\"maven集成\"></a>maven集成</h3><p>Spring Security 权限安全框架</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-comment\">&lt;!--安全--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--jwt--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.jsonwebtoken<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>jjwt<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.9.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n<h3 id=\"安全配置\"><a href=\"#安全配置\" class=\"headerlink\" title=\"安全配置\"></a>安全配置</h3><p>继承<code>WebSecurityConfigurerAdapter</code>编写相关配置、<code>@EnableWebSecurity</code>开启web安全，<code>@EnableGlobalMethodSecurity</code>开启全局方法安全设置，<code>prePostEnabled</code>开启方法请求前后校验例如<code>@PreAuthorize(&quot;hasAuthority(&#39;KHZX.MXGL.CK&#39;)&quot;)</code> 请求用户是否拥有权限</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n * 权限配置中心\n *\n * <span class=\"hljs-doctag\">@author</span> Major.Fang\n */</span>\n<span class=\"hljs-meta\">@Slf</span>4j\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@EnableWebSecurity</span>\n<span class=\"hljs-meta\">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class=\"hljs-keyword\">true</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SecurityConfigurer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WebSecurityConfigurerAdapter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ApplicationContextAware</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> RedisUtil redisUtil;\n\n\n    <span class=\"hljs-comment\">/**\n     * 路径过滤白名单无需携带token\n     *\n     * <span class=\"hljs-doctag\">@param</span> web\n     * <span class=\"hljs-doctag\">@throws</span> Exception\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">(WebSecurity web)</span>  </span>&#123;\n        web.ignoring()\n                .antMatchers(<span class=\"hljs-string\">\"/swagger-ui.html\"</span>)\n                .antMatchers(<span class=\"hljs-string\">\"/v2/**\"</span>)\n                .antMatchers(<span class=\"hljs-string\">\"/swagger-resources/**\"</span>)\n                .antMatchers(<span class=\"hljs-string\">\"/index/*\"</span>)\n                .antMatchers(<span class=\"hljs-string\">\"/common/upload\"</span>)\n                .antMatchers(whiteList());\n    &#125;\n\n\n    <span class=\"hljs-comment\">/**\n     * 白名单处理\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-keyword\">private</span> String[] whiteList()&#123;\n        RequestMappingHandlerMapping requestMappingHandlerMapping = <span class=\"hljs-keyword\">super</span>.getApplicationContext().getBean(RequestMappingHandlerMapping<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        Map&lt;RequestMappingInfo, HandlerMethod&gt; map = requestMappingHandlerMapping.getHandlerMethods();\n        Set&lt;String&gt; whiteList = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\n        <span class=\"hljs-keyword\">for</span>(Map.Entry&lt;RequestMappingInfo,HandlerMethod&gt; entry:map.entrySet())&#123;\n            HandlerMethod handlerMethod = entry.getValue();\n            RequestMappingInfo requestMappingInfo = entry.getKey();\n            <span class=\"hljs-keyword\">if</span>(handlerMethod.hasMethodAnnotation(WhiteList<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>&#123;\n                whiteList.addAll(requestMappingInfo.getPatternsCondition().getPatterns());\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> whiteList.toArray(<span class=\"hljs-keyword\">new</span> String[whiteList.size()]);\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 请求认证配置\n     *\n     * <span class=\"hljs-doctag\">@param</span> httpSecurity\n     * <span class=\"hljs-doctag\">@throws</span> Exception\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">(HttpSecurity httpSecurity)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n        <span class=\"hljs-comment\">// 除去特殊路径意外所有请求需要认证</span>\n        httpSecurity.authorizeRequests()\n                .antMatchers(<span class=\"hljs-string\">\"/index/*\"</span>).permitAll()\n                .antMatchers(<span class=\"hljs-string\">\"/common/upload\"</span>).permitAll()\n                .anyRequest().authenticated();\n        <span class=\"hljs-comment\">// 无需开启csrf 非法跨域请求拦截</span>\n        httpSecurity.csrf().disable();\n        <span class=\"hljs-comment\">// 禁用 Security 的 Session策略</span>\n        httpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        <span class=\"hljs-comment\">// 访问异常处理 认证用户访问无权限资源时的异常</span>\n        httpSecurity.exceptionHandling().accessDeniedHandler(<span class=\"hljs-keyword\">new</span> MyAccessDeniedHandler());\n        <span class=\"hljs-comment\">// 添加 JWT 过滤器</span>\n        httpSecurity.addFilterAfter(<span class=\"hljs-keyword\">new</span> JwtAuthenticationTokenFilter(redisUtil), UsernamePasswordAuthenticationFilter<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        <span class=\"hljs-comment\">// 禁用缓存</span>\n        httpSecurity.headers().cacheControl();\n\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 认证用户没有权限访问资源\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyAccessDeniedHandler</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">AccessDeniedHandler</span> </span>&#123;\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handle</span><span class=\"hljs-params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>&#123;\n            HttpResponseUtil.writeError(HttpStatus.HS_FORBIDDEN, httpServletResponse);\n        &#125;\n    &#125;</code></pre>\n<h4 id=\"Jwt认证过滤器\"><a href=\"#Jwt认证过滤器\" class=\"headerlink\" title=\"Jwt认证过滤器\"></a>Jwt认证过滤器</h4><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n * JWT Token 认证过滤器\n * 1.请求头Headers 是否包含 token\n * 2.token进行校验是否合法、是否过期、签名是否校验成功\n * 3.通过token获取用户userId获取缓存中的用户信息\n * 4.上述都校验成功构建用户资源权限校验实体交予安全上下文进行权限处理\n *\n * <span class=\"hljs-doctag\">@author</span> Major.Fang\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JwtAuthenticationTokenFilter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">OncePerRequestFilter</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> RedisUtil redisUtil;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">JwtAuthenticationTokenFilter</span><span class=\"hljs-params\">(RedisUtil redisUtil)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.redisUtil = redisUtil;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doFilterInternal</span><span class=\"hljs-params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException </span>&#123;\n        String token = httpServletRequest.getHeader(<span class=\"hljs-string\">\"Authorization\"</span>);\n        <span class=\"hljs-keyword\">if</span> (StrUtil.isEmpty(token)) &#123;\n            HttpResponseUtil.writeError(HttpStatus.HS_ILLEGAL_TOKEN, httpServletResponse);\n            <span class=\"hljs-keyword\">return</span>;\n        &#125;\n        HttpStatus errorStatus = JwtUtil.verifyToken(token);\n        <span class=\"hljs-keyword\">if</span> (errorStatus != <span class=\"hljs-keyword\">null</span>) &#123;\n            HttpResponseUtil.writeError(errorStatus, httpServletResponse);\n            <span class=\"hljs-keyword\">return</span>;\n        &#125;\n        SecurityUserDetails securityUserDetails = redisUtil.getValue(RedisKeyConstant.SYS_USER_TOKEN + token, SecurityUserDetails<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        <span class=\"hljs-keyword\">if</span> (securityUserDetails == <span class=\"hljs-keyword\">null</span>) &#123;\n            HttpResponseUtil.writeError(HttpStatus.HS_ILLEGAL_TOKEN,httpServletResponse);\n            <span class=\"hljs-keyword\">return</span>;\n        &#125;\n        <span class=\"hljs-comment\">// 构建验证所需对象参数交予安全上下文进行权限校验</span>\n        UsernamePasswordAuthenticationToken authentication = <span class=\"hljs-keyword\">new</span> UsernamePasswordAuthenticationToken(\n                securityUserDetails, <span class=\"hljs-keyword\">null</span>, securityUserDetails.getAuthorities());\n        authentication.setDetails(<span class=\"hljs-keyword\">new</span> WebAuthenticationDetailsSource().buildDetails(\n                httpServletRequest));\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        filterChain.doFilter(httpServletRequest, httpServletResponse);\n    &#125;\n&#125;</code></pre>\n<h4 id=\"JwtUtil-工具类\"><a href=\"#JwtUtil-工具类\" class=\"headerlink\" title=\"JwtUtil 工具类\"></a>JwtUtil 工具类</h4><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n * Jwt 工具\n *\n * <span class=\"hljs-doctag\">@author</span> Major.Fang\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JwtUtil</span> </span>&#123;\n    <span class=\"hljs-comment\">/**\n     * token的密码\n     **/</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String tokenPassword = <span class=\"hljs-string\">\"ZK-PRODUCT\"</span>;\n\n    <span class=\"hljs-comment\">/**\n     * token的有效时长，小时为单位\n     **/</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Long liveHours = <span class=\"hljs-number\">24L</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 根据用户id生成token\n     *\n     * <span class=\"hljs-doctag\">@param</span> userId\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">genTokenByUserId</span><span class=\"hljs-params\">(String userId)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> Jwts.builder()\n                .setClaims(<span class=\"hljs-keyword\">null</span>)\n                .setId(userId)\n                .setIssuedAt(<span class=\"hljs-keyword\">new</span> Date())\n                .setExpiration(<span class=\"hljs-keyword\">new</span> Date(System.currentTimeMillis() + liveHours * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>))\n                .signWith(SignatureAlgorithm.HS256, tokenPassword)\n                .compact();\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 校验Token\n     *\n     * <span class=\"hljs-doctag\">@param</span> token\n     * <span class=\"hljs-doctag\">@return</span>  错误状态码\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> HttpStatus <span class=\"hljs-title\">verifyToken</span><span class=\"hljs-params\">(String token)</span> </span>&#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            getClaims(token);\n        &#125; <span class=\"hljs-keyword\">catch</span> (ExpiredJwtException e) &#123;\n            <span class=\"hljs-keyword\">return</span> HttpStatus.HS_TOKEN_EXPIRED;\n        &#125; <span class=\"hljs-keyword\">catch</span> (SignatureException e) &#123;\n            <span class=\"hljs-keyword\">return</span> HttpStatus.HS_TOKEN_INSUFFICIENT;\n        &#125; <span class=\"hljs-keyword\">catch</span> (MalformedJwtException e)&#123;\n            <span class=\"hljs-keyword\">return</span> HttpStatus.HS_ILLEGAL_TOKEN;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 根据Token获取userId\n     *\n     * <span class=\"hljs-doctag\">@param</span> token\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">getUserIdByToken</span><span class=\"hljs-params\">(String token)</span> </span>&#123;\n        Claims claims = getClaims(token);\n        <span class=\"hljs-keyword\">return</span> Optional.of(claims).map(Claims::getId).orElse(<span class=\"hljs-keyword\">null</span>);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Claims <span class=\"hljs-title\">getClaims</span><span class=\"hljs-params\">(String token)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> Jwts.parser().setSigningKey(tokenPassword).parseClaimsJws(token).getBody();\n    &#125;\n&#125;</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"maven集成\"><a href=\"#maven集成\" class=\"headerlink\" title=\"maven集成\"></a>maven集成</h3><p>Spring Security 权限安全框架</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-comment\">&lt;!--安全--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--jwt--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.jsonwebtoken<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>jjwt<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.9.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n<h3 id=\"安全配置\"><a href=\"#安全配置\" class=\"headerlink\" title=\"安全配置\"></a>安全配置</h3><p>继承<code>WebSecurityConfigurerAdapter</code>编写相关配置、<code>@EnableWebSecurity</code>开启web安全，<code>@EnableGlobalMethodSecurity</code>开启全局方法安全设置，<code>prePostEnabled</code>开启方法请求前后校验例如<code>@PreAuthorize(&quot;hasAuthority(&#39;KHZX.MXGL.CK&#39;)&quot;)</code> 请求用户是否拥有权限</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n * 权限配置中心\n *\n * <span class=\"hljs-doctag\">@author</span> Major.Fang\n */</span>\n<span class=\"hljs-meta\">@Slf</span>4j\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@EnableWebSecurity</span>\n<span class=\"hljs-meta\">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class=\"hljs-keyword\">true</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SecurityConfigurer</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WebSecurityConfigurerAdapter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ApplicationContextAware</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> RedisUtil redisUtil;\n\n\n    <span class=\"hljs-comment\">/**\n     * 路径过滤白名单无需携带token\n     *\n     * <span class=\"hljs-doctag\">@param</span> web\n     * <span class=\"hljs-doctag\">@throws</span> Exception\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">(WebSecurity web)</span>  </span>&#123;\n        web.ignoring()\n                .antMatchers(<span class=\"hljs-string\">\"/swagger-ui.html\"</span>)\n                .antMatchers(<span class=\"hljs-string\">\"/v2/**\"</span>)\n                .antMatchers(<span class=\"hljs-string\">\"/swagger-resources/**\"</span>)\n                .antMatchers(<span class=\"hljs-string\">\"/index/*\"</span>)\n                .antMatchers(<span class=\"hljs-string\">\"/common/upload\"</span>)\n                .antMatchers(whiteList());\n    &#125;\n\n\n    <span class=\"hljs-comment\">/**\n     * 白名单处理\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-keyword\">private</span> String[] whiteList()&#123;\n        RequestMappingHandlerMapping requestMappingHandlerMapping = <span class=\"hljs-keyword\">super</span>.getApplicationContext().getBean(RequestMappingHandlerMapping<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        Map&lt;RequestMappingInfo, HandlerMethod&gt; map = requestMappingHandlerMapping.getHandlerMethods();\n        Set&lt;String&gt; whiteList = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\n        <span class=\"hljs-keyword\">for</span>(Map.Entry&lt;RequestMappingInfo,HandlerMethod&gt; entry:map.entrySet())&#123;\n            HandlerMethod handlerMethod = entry.getValue();\n            RequestMappingInfo requestMappingInfo = entry.getKey();\n            <span class=\"hljs-keyword\">if</span>(handlerMethod.hasMethodAnnotation(WhiteList<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>))</span>&#123;\n                whiteList.addAll(requestMappingInfo.getPatternsCondition().getPatterns());\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> whiteList.toArray(<span class=\"hljs-keyword\">new</span> String[whiteList.size()]);\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 请求认证配置\n     *\n     * <span class=\"hljs-doctag\">@param</span> httpSecurity\n     * <span class=\"hljs-doctag\">@throws</span> Exception\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">(HttpSecurity httpSecurity)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n        <span class=\"hljs-comment\">// 除去特殊路径意外所有请求需要认证</span>\n        httpSecurity.authorizeRequests()\n                .antMatchers(<span class=\"hljs-string\">\"/index/*\"</span>).permitAll()\n                .antMatchers(<span class=\"hljs-string\">\"/common/upload\"</span>).permitAll()\n                .anyRequest().authenticated();\n        <span class=\"hljs-comment\">// 无需开启csrf 非法跨域请求拦截</span>\n        httpSecurity.csrf().disable();\n        <span class=\"hljs-comment\">// 禁用 Security 的 Session策略</span>\n        httpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        <span class=\"hljs-comment\">// 访问异常处理 认证用户访问无权限资源时的异常</span>\n        httpSecurity.exceptionHandling().accessDeniedHandler(<span class=\"hljs-keyword\">new</span> MyAccessDeniedHandler());\n        <span class=\"hljs-comment\">// 添加 JWT 过滤器</span>\n        httpSecurity.addFilterAfter(<span class=\"hljs-keyword\">new</span> JwtAuthenticationTokenFilter(redisUtil), UsernamePasswordAuthenticationFilter<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        <span class=\"hljs-comment\">// 禁用缓存</span>\n        httpSecurity.headers().cacheControl();\n\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 认证用户没有权限访问资源\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyAccessDeniedHandler</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">AccessDeniedHandler</span> </span>&#123;\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handle</span><span class=\"hljs-params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>&#123;\n            HttpResponseUtil.writeError(HttpStatus.HS_FORBIDDEN, httpServletResponse);\n        &#125;\n    &#125;</code></pre>\n<h4 id=\"Jwt认证过滤器\"><a href=\"#Jwt认证过滤器\" class=\"headerlink\" title=\"Jwt认证过滤器\"></a>Jwt认证过滤器</h4><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n * JWT Token 认证过滤器\n * 1.请求头Headers 是否包含 token\n * 2.token进行校验是否合法、是否过期、签名是否校验成功\n * 3.通过token获取用户userId获取缓存中的用户信息\n * 4.上述都校验成功构建用户资源权限校验实体交予安全上下文进行权限处理\n *\n * <span class=\"hljs-doctag\">@author</span> Major.Fang\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JwtAuthenticationTokenFilter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">OncePerRequestFilter</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> RedisUtil redisUtil;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">JwtAuthenticationTokenFilter</span><span class=\"hljs-params\">(RedisUtil redisUtil)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.redisUtil = redisUtil;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doFilterInternal</span><span class=\"hljs-params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException </span>&#123;\n        String token = httpServletRequest.getHeader(<span class=\"hljs-string\">\"Authorization\"</span>);\n        <span class=\"hljs-keyword\">if</span> (StrUtil.isEmpty(token)) &#123;\n            HttpResponseUtil.writeError(HttpStatus.HS_ILLEGAL_TOKEN, httpServletResponse);\n            <span class=\"hljs-keyword\">return</span>;\n        &#125;\n        HttpStatus errorStatus = JwtUtil.verifyToken(token);\n        <span class=\"hljs-keyword\">if</span> (errorStatus != <span class=\"hljs-keyword\">null</span>) &#123;\n            HttpResponseUtil.writeError(errorStatus, httpServletResponse);\n            <span class=\"hljs-keyword\">return</span>;\n        &#125;\n        SecurityUserDetails securityUserDetails = redisUtil.getValue(RedisKeyConstant.SYS_USER_TOKEN + token, SecurityUserDetails<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        <span class=\"hljs-keyword\">if</span> (securityUserDetails == <span class=\"hljs-keyword\">null</span>) &#123;\n            HttpResponseUtil.writeError(HttpStatus.HS_ILLEGAL_TOKEN,httpServletResponse);\n            <span class=\"hljs-keyword\">return</span>;\n        &#125;\n        <span class=\"hljs-comment\">// 构建验证所需对象参数交予安全上下文进行权限校验</span>\n        UsernamePasswordAuthenticationToken authentication = <span class=\"hljs-keyword\">new</span> UsernamePasswordAuthenticationToken(\n                securityUserDetails, <span class=\"hljs-keyword\">null</span>, securityUserDetails.getAuthorities());\n        authentication.setDetails(<span class=\"hljs-keyword\">new</span> WebAuthenticationDetailsSource().buildDetails(\n                httpServletRequest));\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        filterChain.doFilter(httpServletRequest, httpServletResponse);\n    &#125;\n&#125;</code></pre>\n<h4 id=\"JwtUtil-工具类\"><a href=\"#JwtUtil-工具类\" class=\"headerlink\" title=\"JwtUtil 工具类\"></a>JwtUtil 工具类</h4><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**\n * Jwt 工具\n *\n * <span class=\"hljs-doctag\">@author</span> Major.Fang\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JwtUtil</span> </span>&#123;\n    <span class=\"hljs-comment\">/**\n     * token的密码\n     **/</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String tokenPassword = <span class=\"hljs-string\">\"ZK-PRODUCT\"</span>;\n\n    <span class=\"hljs-comment\">/**\n     * token的有效时长，小时为单位\n     **/</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Long liveHours = <span class=\"hljs-number\">24L</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 根据用户id生成token\n     *\n     * <span class=\"hljs-doctag\">@param</span> userId\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">genTokenByUserId</span><span class=\"hljs-params\">(String userId)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> Jwts.builder()\n                .setClaims(<span class=\"hljs-keyword\">null</span>)\n                .setId(userId)\n                .setIssuedAt(<span class=\"hljs-keyword\">new</span> Date())\n                .setExpiration(<span class=\"hljs-keyword\">new</span> Date(System.currentTimeMillis() + liveHours * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>))\n                .signWith(SignatureAlgorithm.HS256, tokenPassword)\n                .compact();\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 校验Token\n     *\n     * <span class=\"hljs-doctag\">@param</span> token\n     * <span class=\"hljs-doctag\">@return</span>  错误状态码\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> HttpStatus <span class=\"hljs-title\">verifyToken</span><span class=\"hljs-params\">(String token)</span> </span>&#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            getClaims(token);\n        &#125; <span class=\"hljs-keyword\">catch</span> (ExpiredJwtException e) &#123;\n            <span class=\"hljs-keyword\">return</span> HttpStatus.HS_TOKEN_EXPIRED;\n        &#125; <span class=\"hljs-keyword\">catch</span> (SignatureException e) &#123;\n            <span class=\"hljs-keyword\">return</span> HttpStatus.HS_TOKEN_INSUFFICIENT;\n        &#125; <span class=\"hljs-keyword\">catch</span> (MalformedJwtException e)&#123;\n            <span class=\"hljs-keyword\">return</span> HttpStatus.HS_ILLEGAL_TOKEN;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    &#125;\n\n    <span class=\"hljs-comment\">/**\n     * 根据Token获取userId\n     *\n     * <span class=\"hljs-doctag\">@param</span> token\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">getUserIdByToken</span><span class=\"hljs-params\">(String token)</span> </span>&#123;\n        Claims claims = getClaims(token);\n        <span class=\"hljs-keyword\">return</span> Optional.of(claims).map(Claims::getId).orElse(<span class=\"hljs-keyword\">null</span>);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Claims <span class=\"hljs-title\">getClaims</span><span class=\"hljs-params\">(String token)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> Jwts.parser().setSigningKey(tokenPassword).parseClaimsJws(token).getBody();\n    &#125;\n&#125;</code></pre>"},{"title":"Spring 动态注入 Bean 以及修改","toc":false,"date":"2020-11-18T06:53:09.000Z","_content":"### ImportBeanDefinitionRegistrar 类\n实现`ImportBeanDefinitionRegistrar`类进行动态注册，**必须配合@Import注解进行使用**，`Import`注解用于导入一些未被将其交给Spring容器去管理，例如`@MapperScan`注册对应的`Mapper`类就通过`@Import`导入`MapperScannerRegistrar`类实现`ImportBeanDefinitionRegistrar`接口进行自定义Bean注入\n\n``` java\n\n/**\n * @author lenovo\n */\npublic class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        BeanDefinitionBuilder definitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(TestDemo.class);\n        definitionBuilder.addPropertyValue(\"name\", \"mytest\");\n        registry.registerBeanDefinition(\"mytest\",definitionBuilder.getBeanDefinition());\n    }\n}\n```\n以上代码中`registry.registerBeanDefinition(beanName, builder.getBeanDefinition());`将`MapperScannerConfigurer` 注册至IOC中用于后续的Mapper Bean 的扫描，`BeanDefinitionBuilder`用于对Bean定义信息,Mybatis 就是通过这样的方法把扫描指定路径的Mapper接口类并创建代理类交予IOC进行管理\n\n### BeanDefinitionRegistryPostProcessor 后置处理器\n\n实现`BeanDefinitionRegistryPostProcessor`接口可以对已有`BeanDefinition`进行修改也可以根据业务需求进行动态注册自己的`Bean`、\n\n- `BeanDefinitionPostProcessor` 执行在容器加载所有`bean`完毕之后实例化之前\n- 可以配置多个`BeanDefinitionRegistryPostProcessor`在容器刷新时遍历所有的后置处理器\n\n``` java\n@Component\npublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n      BeanDefinition beanDefinition =  registry.getBeanDefinition(\"mytest\");\n        Arrays.stream(beanDefinition.getPropertyValues().getPropertyValues())\n                .forEach(propertyValue -> {\n                    propertyValue.setConvertedValue(\"change\");\n                });\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n\n    }\n}\n```\n\n> ImportBeanDefinitionRegistrar 的执行在 BeanDefinitionPostProcessor 之前且必须配合@Import进行\n","source":"_posts/Spring动态注入Bean.md","raw":"---\ntitle: Spring 动态注入 Bean 以及修改\ntags:\n  - Java\ncategories:\n- Spring\ntoc: false\ndate: 2020-11-18 14:53:09\n---\n### ImportBeanDefinitionRegistrar 类\n实现`ImportBeanDefinitionRegistrar`类进行动态注册，**必须配合@Import注解进行使用**，`Import`注解用于导入一些未被将其交给Spring容器去管理，例如`@MapperScan`注册对应的`Mapper`类就通过`@Import`导入`MapperScannerRegistrar`类实现`ImportBeanDefinitionRegistrar`接口进行自定义Bean注入\n\n``` java\n\n/**\n * @author lenovo\n */\npublic class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        BeanDefinitionBuilder definitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(TestDemo.class);\n        definitionBuilder.addPropertyValue(\"name\", \"mytest\");\n        registry.registerBeanDefinition(\"mytest\",definitionBuilder.getBeanDefinition());\n    }\n}\n```\n以上代码中`registry.registerBeanDefinition(beanName, builder.getBeanDefinition());`将`MapperScannerConfigurer` 注册至IOC中用于后续的Mapper Bean 的扫描，`BeanDefinitionBuilder`用于对Bean定义信息,Mybatis 就是通过这样的方法把扫描指定路径的Mapper接口类并创建代理类交予IOC进行管理\n\n### BeanDefinitionRegistryPostProcessor 后置处理器\n\n实现`BeanDefinitionRegistryPostProcessor`接口可以对已有`BeanDefinition`进行修改也可以根据业务需求进行动态注册自己的`Bean`、\n\n- `BeanDefinitionPostProcessor` 执行在容器加载所有`bean`完毕之后实例化之前\n- 可以配置多个`BeanDefinitionRegistryPostProcessor`在容器刷新时遍历所有的后置处理器\n\n``` java\n@Component\npublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n      BeanDefinition beanDefinition =  registry.getBeanDefinition(\"mytest\");\n        Arrays.stream(beanDefinition.getPropertyValues().getPropertyValues())\n                .forEach(propertyValue -> {\n                    propertyValue.setConvertedValue(\"change\");\n                });\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n\n    }\n}\n```\n\n> ImportBeanDefinitionRegistrar 的执行在 BeanDefinitionPostProcessor 之前且必须配合@Import进行\n","slug":"Spring动态注入Bean","published":1,"updated":"2020-11-19T01:20:23.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklrbwsp80003f8udbsiamfih","content":"<h3 id=\"ImportBeanDefinitionRegistrar-类\"><a href=\"#ImportBeanDefinitionRegistrar-类\" class=\"headerlink\" title=\"ImportBeanDefinitionRegistrar 类\"></a>ImportBeanDefinitionRegistrar 类</h3><p>实现<code>ImportBeanDefinitionRegistrar</code>类进行动态注册，<strong>必须配合@Import注解进行使用</strong>，<code>Import</code>注解用于导入一些未被将其交给Spring容器去管理，例如<code>@MapperScan</code>注册对应的<code>Mapper</code>类就通过<code>@Import</code>导入<code>MapperScannerRegistrar</code>类实现<code>ImportBeanDefinitionRegistrar</code>接口进行自定义Bean注入</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@author</span> lenovo\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyImportBeanDefinitionRegistrar</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ImportBeanDefinitionRegistrar</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerBeanDefinitions</span><span class=\"hljs-params\">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;\n        BeanDefinitionBuilder definitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(TestDemo<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        definitionBuilder.addPropertyValue(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"mytest\"</span>);\n        registry.registerBeanDefinition(<span class=\"hljs-string\">\"mytest\"</span>,definitionBuilder.getBeanDefinition());\n    &#125;\n&#125;</code></pre>\n<p>以上代码中<code>registry.registerBeanDefinition(beanName, builder.getBeanDefinition());</code>将<code>MapperScannerConfigurer</code> 注册至IOC中用于后续的Mapper Bean 的扫描，<code>BeanDefinitionBuilder</code>用于对Bean定义信息,Mybatis 就是通过这样的方法把扫描指定路径的Mapper接口类并创建代理类交予IOC进行管理</p>\n<h3 id=\"BeanDefinitionRegistryPostProcessor-后置处理器\"><a href=\"#BeanDefinitionRegistryPostProcessor-后置处理器\" class=\"headerlink\" title=\"BeanDefinitionRegistryPostProcessor 后置处理器\"></a>BeanDefinitionRegistryPostProcessor 后置处理器</h3><p>实现<code>BeanDefinitionRegistryPostProcessor</code>接口可以对已有<code>BeanDefinition</code>进行修改也可以根据业务需求进行动态注册自己的<code>Bean</code>、</p>\n<ul>\n<li><code>BeanDefinitionPostProcessor</code> 执行在容器加载所有<code>bean</code>完毕之后实例化之前</li>\n<li>可以配置多个<code>BeanDefinitionRegistryPostProcessor</code>在容器刷新时遍历所有的后置处理器</li>\n</ul>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyBeanDefinitionRegistryPostProcessor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">BeanDefinitionRegistryPostProcessor</span> </span>&#123;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postProcessBeanDefinitionRegistry</span><span class=\"hljs-params\">(BeanDefinitionRegistry registry)</span> <span class=\"hljs-keyword\">throws</span> BeansException </span>&#123;\n      BeanDefinition beanDefinition =  registry.getBeanDefinition(<span class=\"hljs-string\">\"mytest\"</span>);\n        Arrays.stream(beanDefinition.getPropertyValues().getPropertyValues())\n                .forEach(propertyValue -&gt; &#123;\n                    propertyValue.setConvertedValue(<span class=\"hljs-string\">\"change\"</span>);\n                &#125;);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postProcessBeanFactory</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class=\"hljs-keyword\">throws</span> BeansException </span>&#123;\n\n    &#125;\n&#125;</code></pre>\n<blockquote>\n<p>ImportBeanDefinitionRegistrar 的执行在 BeanDefinitionPostProcessor 之前且必须配合@Import进行</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"ImportBeanDefinitionRegistrar-类\"><a href=\"#ImportBeanDefinitionRegistrar-类\" class=\"headerlink\" title=\"ImportBeanDefinitionRegistrar 类\"></a>ImportBeanDefinitionRegistrar 类</h3><p>实现<code>ImportBeanDefinitionRegistrar</code>类进行动态注册，<strong>必须配合@Import注解进行使用</strong>，<code>Import</code>注解用于导入一些未被将其交给Spring容器去管理，例如<code>@MapperScan</code>注册对应的<code>Mapper</code>类就通过<code>@Import</code>导入<code>MapperScannerRegistrar</code>类实现<code>ImportBeanDefinitionRegistrar</code>接口进行自定义Bean注入</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@author</span> lenovo\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyImportBeanDefinitionRegistrar</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ImportBeanDefinitionRegistrar</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerBeanDefinitions</span><span class=\"hljs-params\">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;\n        BeanDefinitionBuilder definitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(TestDemo<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        definitionBuilder.addPropertyValue(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"mytest\"</span>);\n        registry.registerBeanDefinition(<span class=\"hljs-string\">\"mytest\"</span>,definitionBuilder.getBeanDefinition());\n    &#125;\n&#125;</code></pre>\n<p>以上代码中<code>registry.registerBeanDefinition(beanName, builder.getBeanDefinition());</code>将<code>MapperScannerConfigurer</code> 注册至IOC中用于后续的Mapper Bean 的扫描，<code>BeanDefinitionBuilder</code>用于对Bean定义信息,Mybatis 就是通过这样的方法把扫描指定路径的Mapper接口类并创建代理类交予IOC进行管理</p>\n<h3 id=\"BeanDefinitionRegistryPostProcessor-后置处理器\"><a href=\"#BeanDefinitionRegistryPostProcessor-后置处理器\" class=\"headerlink\" title=\"BeanDefinitionRegistryPostProcessor 后置处理器\"></a>BeanDefinitionRegistryPostProcessor 后置处理器</h3><p>实现<code>BeanDefinitionRegistryPostProcessor</code>接口可以对已有<code>BeanDefinition</code>进行修改也可以根据业务需求进行动态注册自己的<code>Bean</code>、</p>\n<ul>\n<li><code>BeanDefinitionPostProcessor</code> 执行在容器加载所有<code>bean</code>完毕之后实例化之前</li>\n<li>可以配置多个<code>BeanDefinitionRegistryPostProcessor</code>在容器刷新时遍历所有的后置处理器</li>\n</ul>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyBeanDefinitionRegistryPostProcessor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">BeanDefinitionRegistryPostProcessor</span> </span>&#123;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postProcessBeanDefinitionRegistry</span><span class=\"hljs-params\">(BeanDefinitionRegistry registry)</span> <span class=\"hljs-keyword\">throws</span> BeansException </span>&#123;\n      BeanDefinition beanDefinition =  registry.getBeanDefinition(<span class=\"hljs-string\">\"mytest\"</span>);\n        Arrays.stream(beanDefinition.getPropertyValues().getPropertyValues())\n                .forEach(propertyValue -&gt; &#123;\n                    propertyValue.setConvertedValue(<span class=\"hljs-string\">\"change\"</span>);\n                &#125;);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postProcessBeanFactory</span><span class=\"hljs-params\">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class=\"hljs-keyword\">throws</span> BeansException </span>&#123;\n\n    &#125;\n&#125;</code></pre>\n<blockquote>\n<p>ImportBeanDefinitionRegistrar 的执行在 BeanDefinitionPostProcessor 之前且必须配合@Import进行</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckhmyc9680000jsud7ptlla1q","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc96x000djsud2aek9bas"},{"post_id":"ckhmyc96e0001jsud8ov3wc58","category_id":"ckhmyc96q0007jsudxte5mb48","_id":"ckhmyc977000jjsudj8mlpyyb"},{"post_id":"ckhmyc96t000cjsudumtwo4uh","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc97b000ojsudxby7g7is"},{"post_id":"ckhmyc972000gjsud7jpnbfks","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc97d000qjsudtd3byfcw"},{"post_id":"ckhmyc96k0004jsudy8u8fkfx","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc97g000vjsud3jmpxejt"},{"post_id":"ckhmyc975000ijsudkfsdkvmf","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc97i000xjsud8iu2w6c0"},{"post_id":"ckhmyc979000mjsudvt3tw2fq","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc97l0011jsud352jppc0"},{"post_id":"ckhmyc96m0005jsudc3wbwbdx","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc97n0014jsudnuhtoxe7"},{"post_id":"ckhmyc97b000pjsudr7v6ezgl","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc97q0018jsudwrg7pxjs"},{"post_id":"ckhmyc97e000tjsudhkbimj8c","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc97s001bjsudz3aww56m"},{"post_id":"ckhmyc96o0006jsudny4ep3d1","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc97u001fjsudo4fqrpjt"},{"post_id":"ckhmyc97g000wjsudbkikj5jz","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc97w001ijsudla68aflg"},{"post_id":"ckhmyc97k0010jsudo5serpch","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc97z001mjsudgg9nvkzd"},{"post_id":"ckhmyc96r000ajsudwpxbtw4t","category_id":"ckhmyc97i000yjsud4m9vweyt","_id":"ckhmyc983001pjsud16ej8bul"},{"post_id":"ckhmyc97m0013jsudly48l4ov","category_id":"ckhmyc96q0007jsudxte5mb48","_id":"ckhmyc985001tjsudvzc8596x"},{"post_id":"ckhmyc97o0017jsudu8jua8qk","category_id":"ckhmyc96q0007jsudxte5mb48","_id":"ckhmyc988001xjsude42244m7"},{"post_id":"ckhmyc97q001ajsudlifq8xvk","category_id":"ckhmyc96q0007jsudxte5mb48","_id":"ckhmyc98a0021jsud2rmbdjaf"},{"post_id":"ckhmyc97s001djsudi7rtr2mv","category_id":"ckhmyc96q0007jsudxte5mb48","_id":"ckhmyc98c0025jsud1aqzpmpc"},{"post_id":"ckhmyc97v001hjsudugehu0px","category_id":"ckhmyc96q0007jsudxte5mb48","_id":"ckhmyc98e0029jsudv6uysd4b"},{"post_id":"ckhmyc97x001kjsudoa7dcdgq","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc98g002djsud75dt7br9"},{"post_id":"ckhmyc983001rjsudezogmvtk","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc98j002gjsud32a134m0"},{"post_id":"ckhmyc988001zjsudpy6csg3m","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc98l002kjsudv83xkkwq"},{"post_id":"ckhmyc981001ojsudbus61g0n","category_id":"ckhmyc986001ujsud9y4b300d","_id":"ckhmyc98n002ojsudg2sxxmk2"},{"post_id":"ckhmyc98c0027jsudvvtakgi1","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc98t002sjsudcykuxy37"},{"post_id":"ckhmyc986001wjsudl39w530d","category_id":"ckhmyc98b0024jsudtsra6ip9","_id":"ckhmyc98x002vjsudkdigaak5"},{"post_id":"ckhmyc98f002bjsud1egyqpn1","category_id":"ckhmyc98b0024jsudtsra6ip9","_id":"ckhmyc990002zjsudrzqqgrop"},{"post_id":"ckhmyc98b0023jsudq39jov04","category_id":"ckhmyc98b0024jsudtsra6ip9","_id":"ckhmyc9930032jsudo4f2gwnm"},{"post_id":"ckhmyc98k002jjsudhhalaprc","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc9950035jsudg616bwmx"},{"post_id":"ckhmyc98m002njsudy9smt80x","category_id":"ckhmyc98b0024jsudtsra6ip9","_id":"ckhmyc9970039jsudqw8x4r2e"},{"post_id":"ckhmyc98o002rjsudsz9ez37d","category_id":"ckhmyc98b0024jsudtsra6ip9","_id":"ckhmyc999003djsudvbkuqs1p"},{"post_id":"ckhmyc98h002fjsudkauiq8w6","category_id":"ckhmyc98m002ljsudj8vc39xu","_id":"ckhmyc99b003gjsud35vbz79j"},{"post_id":"ckhmyc98u002ujsudkxcsuezs","category_id":"ckhmyc98b0024jsudtsra6ip9","_id":"ckhmyc99d003jjsudm1q34683"},{"post_id":"ckhmyc98y002yjsud9wvxj0zf","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc99g003mjsudiydr1x0s"},{"post_id":"ckhmyc9930033jsud0nfcztbm","category_id":"ckhmyc98b0024jsudtsra6ip9","_id":"ckhmyc99j003ojsudjtu7v4vm"},{"post_id":"ckhmyc9960038jsudbyab06of","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc99n003sjsudit2bwjts"},{"post_id":"ckhmyc998003bjsudcbobovu4","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc99p003ujsud1lkam7vc"},{"post_id":"ckhmyc9910031jsudxji0aof0","category_id":"ckhmyc9960036jsud0mn41ta1","_id":"ckhmyc99s003xjsuduaa40sfd"},{"post_id":"ckhmyc99a003fjsudvhly90ra","category_id":"ckhmyc986001ujsud9y4b300d","_id":"ckhmyc99u0040jsudzmyd2ax5"},{"post_id":"ckhmyc99b003hjsudx1fn4420","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc99w0044jsud26vgdqbx"},{"post_id":"ckhmyc99d003ljsudgntd7o5t","category_id":"ckhmyc986001ujsud9y4b300d","_id":"ckhmyc99y0047jsudwafbhyzb"},{"post_id":"ckhmyc99h003njsud2to6afy6","category_id":"ckhmyc986001ujsud9y4b300d","_id":"ckhmyc9a0004bjsudechqxowg"},{"post_id":"ckhmyc99k003qjsudms2hbp3h","category_id":"ckhmyc986001ujsud9y4b300d","_id":"ckhmyc9a2004ejsudmvdfheti"},{"post_id":"ckhmyc99o003tjsuddlrr9vmy","category_id":"ckhmyc986001ujsud9y4b300d","_id":"ckhmyc9a4004ijsud4l0asmag"},{"post_id":"ckhmyc99q003wjsud8owifvdz","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc9a6004ljsudr8c5eubd"},{"post_id":"ckhmyc99s003zjsudd23ym4sm","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc9a8004pjsudxgioljyr"},{"post_id":"ckhmyc99x0046jsudprdgl95g","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc9ab004sjsudr9drw2z1"},{"post_id":"ckhmyc9a1004djsudr8dbpo0s","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc9ah004zjsud81v363m8"},{"post_id":"ckhmyc9a3004hjsud5ectkqaq","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc9al0053jsudcy76pzzu"},{"post_id":"ckhmyc9a5004kjsudb0zhmqqr","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc9ap0056jsudk1e2jb7e"},{"post_id":"ckhmyc9a7004ojsud05kbyvsr","category_id":"ckhmyc96y000ejsudfyxzr8if","_id":"ckhmyc9au005bjsud1ffioyoh"},{"post_id":"ckhmyc9ad004vjsudf5qks9k0","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc9aw005ejsudkyxef954"},{"post_id":"ckhmyc9ag004yjsuduqpbd8br","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc9az005ijsudbxzplimb"},{"post_id":"ckhmyc9an0055jsudm975x6lg","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc9b5005ljsuda9eum0v0"},{"post_id":"ckhmyc9au005djsud39rztbco","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc9b7005ojsudzcxl9rjd"},{"post_id":"ckhmyc9ai0052jsudbepocj3z","category_id":"ckhmyc9aq0057jsuduw3zw772","_id":"ckhmyc9b9005qjsuduhn2ot3m"},{"post_id":"ckhmyc9ax005gjsud5jtc5ssv","category_id":"ckhmyc9aq0057jsuduw3zw772","_id":"ckhmyc9ba005tjsudyzf60v19"},{"post_id":"ckhmyc9b0005kjsudl6tdjh4t","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"ckhmyc9bb005vjsude94031k8"},{"post_id":"cklrbwso10000f8uds0770ph7","category_id":"ckhmyc96h0002jsud6uub1okk","_id":"cklrbwsob0002f8udv7b0gmk2"},{"post_id":"cklrbwsp80003f8udbsiamfih","category_id":"ckhmyc986001ujsud9y4b300d","_id":"cklrbwsph0005f8ud1wh5sx7j"}],"PostTag":[{"post_id":"ckhmyc96m0005jsudc3wbwbdx","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc96r0009jsudsp741nq9"},{"post_id":"ckhmyc9680000jsud7ptlla1q","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc96t000bjsudku0ph19b"},{"post_id":"ckhmyc96e0001jsud8ov3wc58","tag_id":"ckhmyc96q0008jsudcip6z5ez","_id":"ckhmyc974000hjsudd3x6fqy3"},{"post_id":"ckhmyc96k0004jsudy8u8fkfx","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc97a000njsuddiu5klc7"},{"post_id":"ckhmyc96o0006jsudny4ep3d1","tag_id":"ckhmyc96q0008jsudcip6z5ez","_id":"ckhmyc97f000ujsudc5zhhe8a"},{"post_id":"ckhmyc96t000cjsudumtwo4uh","tag_id":"ckhmyc97d000rjsudpd1mego3","_id":"ckhmyc97l0012jsudbr4hoaco"},{"post_id":"ckhmyc97k0010jsudo5serpch","tag_id":"ckhmyc97j000zjsudum4kbrv0","_id":"ckhmyc97o0015jsudifq39kdr"},{"post_id":"ckhmyc972000gjsud7jpnbfks","tag_id":"ckhmyc97j000zjsudum4kbrv0","_id":"ckhmyc97q0019jsud2x15zyzk"},{"post_id":"ckhmyc97m0013jsudly48l4ov","tag_id":"ckhmyc96q0008jsudcip6z5ez","_id":"ckhmyc97s001cjsudut5763cs"},{"post_id":"ckhmyc97o0017jsudu8jua8qk","tag_id":"ckhmyc96q0008jsudcip6z5ez","_id":"ckhmyc97v001gjsudpxks7shc"},{"post_id":"ckhmyc97q001ajsudlifq8xvk","tag_id":"ckhmyc96q0008jsudcip6z5ez","_id":"ckhmyc97x001jjsudagsoapqb"},{"post_id":"ckhmyc975000ijsudkfsdkvmf","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc980001njsudhgytcml8"},{"post_id":"ckhmyc975000ijsudkfsdkvmf","tag_id":"ckhmyc97o0016jsud933hup6o","_id":"ckhmyc983001qjsudd7zejhko"},{"post_id":"ckhmyc97s001djsudi7rtr2mv","tag_id":"ckhmyc96q0008jsudcip6z5ez","_id":"ckhmyc986001vjsudj7rsqsmx"},{"post_id":"ckhmyc97v001hjsudugehu0px","tag_id":"ckhmyc96q0008jsudcip6z5ez","_id":"ckhmyc988001yjsud0gdn4wk6"},{"post_id":"ckhmyc979000mjsudvt3tw2fq","tag_id":"ckhmyc97o0016jsud933hup6o","_id":"ckhmyc98a0022jsudojqsqec0"},{"post_id":"ckhmyc981001ojsudbus61g0n","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc98c0026jsudbyfl0cc0"},{"post_id":"ckhmyc97b000pjsudr7v6ezgl","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc98e002ajsudpzx6xljl"},{"post_id":"ckhmyc97b000pjsudr7v6ezgl","tag_id":"ckhmyc97o0016jsud933hup6o","_id":"ckhmyc98h002ejsud6u0z4fmw"},{"post_id":"ckhmyc986001wjsudl39w530d","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc98j002ijsuda128zy60"},{"post_id":"ckhmyc97e000tjsudhkbimj8c","tag_id":"ckhmyc97j000zjsudum4kbrv0","_id":"ckhmyc98m002mjsud1l61h4xg"},{"post_id":"ckhmyc97g000wjsudbkikj5jz","tag_id":"ckhmyc97j000zjsudum4kbrv0","_id":"ckhmyc98o002qjsudcx95a1hj"},{"post_id":"ckhmyc98f002bjsud1egyqpn1","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc98u002tjsudrg179s6m"},{"post_id":"ckhmyc97x001kjsudoa7dcdgq","tag_id":"ckhmyc98d0028jsudcgkilsqn","_id":"ckhmyc98x002wjsud8ivw7bjv"},{"post_id":"ckhmyc983001rjsudezogmvtk","tag_id":"ckhmyc98j002hjsudtjgzk1vj","_id":"ckhmyc9910030jsudvug07f74"},{"post_id":"ckhmyc988001zjsudpy6csg3m","tag_id":"ckhmyc98o002pjsud30xlqdhx","_id":"ckhmyc9960037jsud9yuik7ck"},{"post_id":"ckhmyc988001zjsudpy6csg3m","tag_id":"ckhmyc98y002xjsudx9nds1yu","_id":"ckhmyc997003ajsudr2typ6ey"},{"post_id":"ckhmyc98b0023jsudq39jov04","tag_id":"ckhmyc98o002pjsud30xlqdhx","_id":"ckhmyc99a003ejsudcv2ly1ij"},{"post_id":"ckhmyc98c0027jsudvvtakgi1","tag_id":"ckhmyc98d0028jsudcgkilsqn","_id":"ckhmyc99d003kjsudbuq68wyi"},{"post_id":"ckhmyc98h002fjsudkauiq8w6","tag_id":"ckhmyc99c003ijsud5qcy1q32","_id":"ckhmyc99n003rjsudyei43flj"},{"post_id":"ckhmyc98k002jjsudhhalaprc","tag_id":"ckhmyc99j003pjsuds2c8rogh","_id":"ckhmyc99s003yjsudzkx2uzda"},{"post_id":"ckhmyc99q003wjsud8owifvdz","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc99u0041jsudvdo1r765"},{"post_id":"ckhmyc99q003wjsud8owifvdz","tag_id":"ckhmyc98d0028jsudcgkilsqn","_id":"ckhmyc99x0045jsud2xqlouro"},{"post_id":"ckhmyc98m002njsudy9smt80x","tag_id":"ckhmyc99q003vjsud4i0u9ugd","_id":"ckhmyc99y0048jsuds29cb9vb"},{"post_id":"ckhmyc99s003zjsudd23ym4sm","tag_id":"ckhmyc98d0028jsudcgkilsqn","_id":"ckhmyc9a0004cjsudtu760r45"},{"post_id":"ckhmyc98o002rjsudsz9ez37d","tag_id":"ckhmyc99q003vjsud4i0u9ugd","_id":"ckhmyc9a2004fjsuddssbpbta"},{"post_id":"ckhmyc98u002ujsudkxcsuezs","tag_id":"ckhmyc99q003vjsud4i0u9ugd","_id":"ckhmyc9a4004jjsuduv7zwnog"},{"post_id":"ckhmyc9a1004djsudr8dbpo0s","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc9a6004mjsudqcmu7hrk"},{"post_id":"ckhmyc9a1004djsudr8dbpo0s","tag_id":"ckhmyc98d0028jsudcgkilsqn","_id":"ckhmyc9a9004qjsudr5wymmji"},{"post_id":"ckhmyc9a3004hjsud5ectkqaq","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc9ac004tjsudcvxw6gz6"},{"post_id":"ckhmyc98y002yjsud9wvxj0zf","tag_id":"ckhmyc99q003vjsud4i0u9ugd","_id":"ckhmyc9af004xjsudscn20862"},{"post_id":"ckhmyc9a5004kjsudb0zhmqqr","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc9ah0050jsude01usnzs"},{"post_id":"ckhmyc9930033jsud0nfcztbm","tag_id":"ckhmyc99q003vjsud4i0u9ugd","_id":"ckhmyc9an0054jsudmpjdt9j6"},{"post_id":"ckhmyc9930033jsud0nfcztbm","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc9aq0058jsudoh79x2gd"},{"post_id":"ckhmyc9960038jsudbyab06of","tag_id":"ckhmyc99j003pjsuds2c8rogh","_id":"ckhmyc9au005cjsudny9iscpi"},{"post_id":"ckhmyc9ag004yjsuduqpbd8br","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc9aw005fjsud5ccqie9g"},{"post_id":"ckhmyc9ai0052jsudbepocj3z","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc9az005jjsudki6zy0zr"},{"post_id":"ckhmyc998003bjsudcbobovu4","tag_id":"ckhmyc99j003pjsuds2c8rogh","_id":"ckhmyc9b5005mjsuda1umi4xs"},{"post_id":"ckhmyc9au005djsud39rztbco","tag_id":"ckhmyc97j000zjsudum4kbrv0","_id":"ckhmyc9b8005pjsud5mxgh1nv"},{"post_id":"ckhmyc99a003fjsudvhly90ra","tag_id":"ckhmyc9ar0059jsudyqhbh1tf","_id":"ckhmyc9b9005rjsudid1vr940"},{"post_id":"ckhmyc9ax005gjsud5jtc5ssv","tag_id":"ckhmyc98d0028jsudcgkilsqn","_id":"ckhmyc9bb005ujsudf7p3hfyt"},{"post_id":"ckhmyc9b0005kjsudl6tdjh4t","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc9bc005wjsudpa98mamo"},{"post_id":"ckhmyc99b003hjsudx1fn4420","tag_id":"ckhmyc9ar0059jsudyqhbh1tf","_id":"ckhmyc9bd005yjsudhf8mesj9"},{"post_id":"ckhmyc99d003ljsudgntd7o5t","tag_id":"ckhmyc9ar0059jsudyqhbh1tf","_id":"ckhmyc9bd005zjsud3uwzcift"},{"post_id":"ckhmyc99h003njsud2to6afy6","tag_id":"ckhmyc9ar0059jsudyqhbh1tf","_id":"ckhmyc9be0061jsudw1exd964"},{"post_id":"ckhmyc99k003qjsudms2hbp3h","tag_id":"ckhmyc9ar0059jsudyqhbh1tf","_id":"ckhmyc9be0062jsudfy1vzl91"},{"post_id":"ckhmyc99o003tjsuddlrr9vmy","tag_id":"ckhmyc9ar0059jsudyqhbh1tf","_id":"ckhmyc9bg0064jsudcw2c00q2"},{"post_id":"ckhmyc99o003tjsuddlrr9vmy","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"ckhmyc9bg0065jsud44qtbrig"},{"post_id":"ckhmyc99x0046jsudprdgl95g","tag_id":"ckhmyc9be0063jsudgs4ubu3p","_id":"ckhmyc9bh0067jsudusr7vmez"},{"post_id":"ckhmyc9a7004ojsud05kbyvsr","tag_id":"ckhmyc9be0063jsudgs4ubu3p","_id":"ckhmyc9bk006bjsudxyi37jwp"},{"post_id":"ckhmyc9ad004vjsudf5qks9k0","tag_id":"ckhmyc9ar0059jsudyqhbh1tf","_id":"ckhmyc9bk006djsud2vnq6bqm"},{"post_id":"ckhmyc9an0055jsudm975x6lg","tag_id":"ckhmyc9bk006cjsud51y3q6bp","_id":"ckhmyc9bk006ejsudofbpcgjt"},{"post_id":"cklrbwso10000f8uds0770ph7","tag_id":"ckhmyc9ar0059jsudyqhbh1tf","_id":"cklrbwsoa0001f8udxuy28gm6"},{"post_id":"cklrbwsp80003f8udbsiamfih","tag_id":"ckhmyc96j0003jsuduotu36y4","_id":"cklrbwspf0004f8udqe9t0ces"}],"Tag":[{"name":"Java","_id":"ckhmyc96j0003jsuduotu36y4"},{"name":"Linux","_id":"ckhmyc96q0008jsudcip6z5ez"},{"name":"前端","_id":"ckhmyc97d000rjsudpd1mego3"},{"name":"复习","_id":"ckhmyc97j000zjsudum4kbrv0"},{"name":"Jvm","_id":"ckhmyc97o0016jsud933hup6o"},{"name":"技术","_id":"ckhmyc98d0028jsudcgkilsqn"},{"name":"Maven","_id":"ckhmyc98j002hjsudtjgzk1vj"},{"name":"数据库","_id":"ckhmyc98o002pjsud30xlqdhx"},{"name":"文档","_id":"ckhmyc98y002xjsudx9nds1yu"},{"name":"Python","_id":"ckhmyc99c003ijsud5qcy1q32"},{"name":"中间件","_id":"ckhmyc99j003pjsuds2c8rogh"},{"name":"Redis","_id":"ckhmyc99q003vjsud4i0u9ugd"},{"name":"Spring","_id":"ckhmyc9ar0059jsudyqhbh1tf"},{"name":"心得","_id":"ckhmyc9be0063jsudgs4ubu3p"},{"name":"多线程","_id":"ckhmyc9bk006cjsud51y3q6bp"}]}}