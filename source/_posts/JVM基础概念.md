---
layout: post
title: JVM 基础概念
categories: [Java]
comments: true
date: 2019-03-21 21:01:28
tags:
	- Java
	- 技术
---
![Java](/images/java.jpg)


>JVM 复习基本概念学习和记录

## 概述
对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

## JVM 运行时候数据区域
Java 虚拟机在执行 java 程序的过程中会把管理的内存划分为若干个不同的数据区域，JDK 1.8 和之前的版本有不同。
![JDK 1.8之前内存划分](/images/JVM-1.8-before.png)
![JDK 1.8版本的内存划分](/images/JVM-1.8-after.png)

- ##### 线程私有的：
  [程序计数器](#程序计数器)、[虚拟机栈](#虚拟机栈)、[本地方法栈](#本地方法栈)
- ##### 线程共享的：
 [堆](#堆)、[方法区](#方法区)、直接内存（非运行数据区的一部分） 

- ##### [直接内存](#直接内存) 

### 程序计数器
程序计数器（`Pargram Counter Register`）是一块很小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 字节码解释器工作通过改变计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖此计数器。多线程中每个线程都有一个计数器用来记录线程执行的位置，每个计数器之间相互不影响独立，独立存储，被称为“线程私有”的内存。

__程序计数器是唯一一个不会出现`OutOfMemoryError`的内存区域，它的生命周期随着线程的创建才创建，结束而结束。__

### 虚拟机栈
 Java 虚拟机栈（`Jasva Virtual Machine Stacks`）也是私有内存，它的生命周期和线程一样，描述的是 Java 方法执行的内存模型： 每个方法在执行的同时都会创建一个帧栈（`Stack Frame`）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的执行完成的过程对应着每个帧栈在虚拟栈中入栈到出栈的过程。

 __局部变量表__的主要存放了编译期可知的各种__基本数据类型__（`boolean`、`byte`、`char`、`short`、`int`、`float`、`long`、`double`）、对象引用（`reference`类型，不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）

 __虚拟机栈只会出现2种异常__
 - __StackOverFlowError__：如虚拟机不支持内存动态扩展，当线程请求栈的深度大于虚拟机的最大阈值，则会抛出`StackOverFlowError`。
 - __OutOfMemoryError__：如果虚拟机支持内存动态扩展，当线程申请内存无法再动态扩展时，会抛出`OutOfMemoryError`


### 本地方法栈
和虚拟机栈不同的：__虚拟机栈为虚拟机执行 Java 方法（`字节码`）服务，而本地方法栈为虚拟机使用`Native`方法服务。在`HotSpot`中 Java 虚拟机合二为一。__

## 堆
Java 堆（`Java Heap`）是虚拟机所管理的内存中最大的一块，Java 堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建用于存放几乎所有的对象实例和数组。

Java 堆是 垃圾回收器管理的主要区域 GC 堆（`Garbage Collector Heap`）,垃圾回收采用`分代垃圾收集算法`，可以细分为：`新生代`和`老年代`,在细致点可分为：`Eden`空间、`From Survivor`、`To Survivor`空间等。
![内存划分](/images/MemorySplit.png)
`eden`、`s0`、`s1`区属于新生代，`tentired`区属于老年区。

通常虚拟机的内存拓展是通过（`-Xms` 和 `-Xms`控制）。

### 方法区
方法区（`Method Area`）和 Java 堆一样属于共享的内存区域，用于存放已经被虚拟机啊加载的类信息、常量、静态变量、即时编译器后的代码等数据。为区分 Java 堆，方法区也叫`Non-Heap（非堆）`。

### 运行时常量池
运行时常量（`Running Constant Pool`）是方法区的一部分。`Class`文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池（`Constant Pool Table`）,用于存放编译期生成的各种`字面量`和`符号引用`，这部分内容将在类加载后进入方法区的运行时常量池中存放。
![常量池](/images/ConstantPoolTable.jpg)

### 直接内存
直接内存（`Direct Memory`）不是虚拟机运行时数据区的一部分，也不是虚拟机规范中划分的内存区域。

JDK 1.4中新加入的`NIO`(`New Input/OutPut`)类，引入基于通道(`Channel`)与缓冲区（`Buffer`）的`I/O`方式，它可以直接通过`Native`函数直接分配堆外内存，然后通过 Java 中 DirectByBuffer 对象来操作这些内存。这样避免 `Java 堆`和 `Native 堆`之间来回复制数据浪费性能。

__直接内存分配不受 Java 堆的限制，但是受限于机器的物理内存大小和逻辑器寻址空间限制。__